{"version":3,"sources":["extensions/default/Git/src/GutterManager.js"],"names":["define","require","exports","_","brackets","getModule","CommandManager","DocumentManager","EditorManager","MainViewManager","ErrorHandler","Events","EventEmitter","Git","Preferences","Strings","gitAvailable","gutterName","editorsWithGutters","openWidgets","_addDummyGutterMarkerIfNotExist","cm","line","lineInfo","gutters","gutterEnabled","getOption","slice","indexOf","gutterMarkers","existingMarker","dummy","document","createElement","className","setGutterMarker","_cursorActivity","_evt","editor","_codeMirror","getCursorPos","clearWidgets","lines","map","mark","w","lineWidget","visible","widget","clear","clearOld","io","splice","clearGutter","setOption","off","gutterClick","gitGutters","prepareGutter","unshift","on","push","prepareGutters","editors","forEach","idx","length","showGutters","_results","sortBy","openBefore","obj","$marker","$","addClass","type","html","lineIndex","gutterId","find","o","parentMark","element","$btn","text","doc","getCurrentDocument","replaceRange","content","ch","execute","refresh","attr","append","appendTo","addLineWidget","coverGutter","noHScroll","above","showIfHidden","getEditorFromPane","paneId","currentPath","getCurrentlyViewedPath","getOpenDocumentForPath","_masterEditor","processDiffResults","diff","added","removed","modified","changesets","split","str","shift","m","match","s1","s2","lineRemovedFrom","lineFrom","parseInt","lineCount","isNaN","filter","l","substring","join","isModifiedMark","firstAddedMark","i","lineTo","lineNo","pop","concat","get","currentGitRoot","compact","getPaneIdList","currentFilePath","file","fullPath","filename","diffFile","then","catch","err","contains","showError","ERROR_REFRESH_GUTTER","goToPrev","activeEditor","getActiveEditor","results","searched","currentPos","goToMark","setCursorPos","goToNext","init","event","newEditor","oldEditor","GIT_ENABLED","GIT_DISABLED","BRACKETS_CURRENT_DOCUMENT_CHANGE","alreadyOpened","GIT_COMMITED","BRACKETS_FILE_CHANGED"],"mappings":"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","sourcesContent":["// this file was composed with a big help from @MiguelCastillo extension Brackets-InteractiveLinter\n// @see https://github.com/MiguelCastillo/Brackets-InteractiveLinter\n\ndefine(function (require, exports) {\n\n    // Brackets modules\n    var _               = brackets.getModule(\"thirdparty/lodash\"),\n        CommandManager  = brackets.getModule(\"command/CommandManager\"),\n        DocumentManager = brackets.getModule(\"document/DocumentManager\"),\n        EditorManager   = brackets.getModule(\"editor/EditorManager\"),\n        MainViewManager = brackets.getModule(\"view/MainViewManager\"),\n        ErrorHandler    = require(\"src/ErrorHandler\"),\n        Events          = require(\"src/Events\"),\n        EventEmitter    = require(\"src/EventEmitter\"),\n        Git             = require(\"src/git/Git\"),\n        Preferences     = require(\"./Preferences\"),\n        Strings             = brackets.getModule(\"strings\");\n\n    var gitAvailable = false,\n        gutterName = \"brackets-git-gutter\",\n        editorsWithGutters = [],\n        openWidgets = [];\n\n    /**\n     * Checks if there's already a gutter marker on the given line;\n     * if not, inserts a blank <div> to prevent an empty gutter spot.\n     */\n    function _addDummyGutterMarkerIfNotExist(cm, line) {\n        var lineInfo = cm.lineInfo(line);\n        if (!lineInfo) {\n            return; // If line is out of range or doc is empty\n        }\n        var gutters = cm.getOption(\"gutters\").slice(0),\n            gutterEnabled = gutters.indexOf(gutterName);\n        if(gutterEnabled === -1){\n            return;\n        }\n        var gutterMarkers = lineInfo.gutterMarkers;\n        var existingMarker = gutterMarkers && gutterMarkers[gutterName];\n        if (!existingMarker) {\n            var dummy = document.createElement(\"div\");\n            dummy.className = \"CodeMirror-gitGutter-none\";\n            cm.setGutterMarker(line, gutterName, dummy);\n        }\n    }\n\n    function _cursorActivity(_evt, editor){\n        // this is to prevent a gutter gap in the active line if there is no color on this line.\n        _addDummyGutterMarkerIfNotExist(editor._codeMirror, editor.getCursorPos().line);\n    }\n\n    EditorManager.on(\"activeEditorChange\", function (event, newEditor, oldEditor) {\n        if(newEditor){\n            newEditor.off(\"cursorActivity.gitGutter\");\n            newEditor.on(\"cursorActivity.gitGutter\", _cursorActivity);\n            _cursorActivity(null, newEditor);\n        }\n        if(oldEditor){\n            oldEditor.off(\"cursorActivity.gitGutter\");\n        }\n    });\n\n    function clearWidgets() {\n        var lines = openWidgets.map(function (mark) {\n            var w = mark.lineWidget;\n            if (w.visible) {\n                w.visible = false;\n                w.widget.clear();\n            }\n            return {\n                cm: mark.cm,\n                line: mark.line\n            };\n        });\n        openWidgets = [];\n        return lines;\n    }\n\n    function clearOld(editor) {\n        var cm = editor._codeMirror;\n        if (!cm) { return; }\n\n        var gutters = cm.getOption(\"gutters\").slice(0),\n            io = gutters.indexOf(gutterName);\n\n        if (io !== -1) {\n            gutters.splice(io, 1);\n            cm.clearGutter(gutterName);\n            cm.setOption(\"gutters\", gutters);\n            cm.off(\"gutterClick\", gutterClick);\n        }\n\n        delete cm.gitGutters;\n\n        clearWidgets();\n    }\n\n    function prepareGutter(editor) {\n        // add our gutter if its not already available\n        var cm = editor._codeMirror;\n\n        var gutters = cm.getOption(\"gutters\").slice(0);\n        if (gutters.indexOf(gutterName) === -1) {\n            gutters.unshift(gutterName);\n            cm.setOption(\"gutters\", gutters);\n            cm.on(\"gutterClick\", gutterClick);\n        }\n\n        if (editorsWithGutters.indexOf(editor) === -1) {\n            editorsWithGutters.push(editor);\n        }\n    }\n\n    function prepareGutters(editors) {\n        editors.forEach(function (editor) {\n            prepareGutter(editor);\n        });\n        // clear the rest\n        var idx = editorsWithGutters.length;\n        while (idx--) {\n            if (editors.indexOf(editorsWithGutters[idx]) === -1) {\n                clearOld(editorsWithGutters[idx]);\n                editorsWithGutters.splice(idx, 1);\n            }\n        }\n    }\n\n    function showGutters(editor, _results) {\n        prepareGutter(editor);\n\n        var cm = editor._codeMirror;\n        cm.gitGutters = _.sortBy(_results, \"line\");\n\n        // get line numbers of currently opened widgets\n        var openBefore = clearWidgets();\n\n        cm.clearGutter(gutterName);\n        cm.gitGutters.forEach(function (obj) {\n            var $marker = $(\"<div>\")\n                            .addClass(gutterName + \"-\" + obj.type + \" gitline-\" + (obj.line + 1))\n                            .html(\"&nbsp;\");\n            cm.setGutterMarker(obj.line, gutterName, $marker[0]);\n        });\n        _cursorActivity(null, editor);\n        // reopen widgets that were opened before refresh\n        openBefore.forEach(function (obj) {\n            gutterClick(obj.cm, obj.line, gutterName);\n        });\n    }\n\n    function gutterClick(cm, lineIndex, gutterId) {\n        if (!cm) {\n            return;\n        }\n\n        if (gutterId !== gutterName && gutterId !== \"CodeMirror-linenumbers\") {\n            return;\n        }\n\n        var mark = _.find(cm.gitGutters, function (o) { return o.line === lineIndex; });\n        if (!mark || mark.type === \"added\") { return; }\n\n        // we need to be able to identify cm instance from any mark\n        mark.cm = cm;\n\n        if (mark.parentMark) { mark = mark.parentMark; }\n\n        if (!mark.lineWidget) {\n            mark.lineWidget = {\n                visible: false,\n                element: $(\"<div class='\" + gutterName + \"-deleted-lines'></div>\")\n            };\n            var $btn = $(\"<button/>\")\n                .addClass(\"brackets-git-gutter-copy-button\")\n                .text(\"R\")\n                .on(\"click\", function () {\n                    var doc = DocumentManager.getCurrentDocument();\n                    doc.replaceRange(mark.content + \"\\n\", {\n                        line: mark.line,\n                        ch: 0\n                    });\n                    CommandManager.execute(\"file.save\");\n                    refresh();\n                });\n            $(\"<pre/>\")\n                .attr(\"style\", \"tab-size:\" + cm.getOption(\"tabSize\"))\n                .text(mark.content || \" \")\n                .append($btn)\n                .appendTo(mark.lineWidget.element);\n        }\n\n        if (mark.lineWidget.visible !== true) {\n            mark.lineWidget.visible = true;\n            mark.lineWidget.widget = cm.addLineWidget(mark.line, mark.lineWidget.element[0], {\n                coverGutter: false,\n                noHScroll: false,\n                above: true,\n                showIfHidden: false\n            });\n            openWidgets.push(mark);\n        } else {\n            mark.lineWidget.visible = false;\n            mark.lineWidget.widget.clear();\n            var io = openWidgets.indexOf(mark);\n            if (io !== -1) {\n                openWidgets.splice(io, 1);\n            }\n        }\n    }\n\n    function getEditorFromPane(paneId) {\n        var currentPath = MainViewManager.getCurrentlyViewedPath(paneId),\n            doc = currentPath && DocumentManager.getOpenDocumentForPath(currentPath);\n        return doc && doc._masterEditor;\n    }\n\n    function processDiffResults(editor, diff) {\n        var added = [],\n            removed = [],\n            modified = [],\n            changesets = diff.split(/\\n@@/).map(function (str) { return \"@@\" + str; });\n\n        // remove part before first\n        changesets.shift();\n\n        changesets.forEach(function (str) {\n            var m = str.match(/^@@ -([,0-9]+) \\+([,0-9]+) @@/);\n            var s1 = m[1].split(\",\");\n            var s2 = m[2].split(\",\");\n\n            // removed stuff\n            var lineRemovedFrom;\n            var lineFrom = parseInt(s2[0], 10);\n            var lineCount = parseInt(s1[1], 10);\n            if (isNaN(lineCount)) { lineCount = 1; }\n            if (lineCount > 0) {\n                lineRemovedFrom = lineFrom - 1;\n                removed.push({\n                    type: \"removed\",\n                    line: lineRemovedFrom,\n                    content: str.split(\"\\n\")\n                                .filter(function (l) { return l.indexOf(\"-\") === 0; })\n                                .map(function (l) { return l.substring(1); })\n                                .join(\"\\n\")\n                });\n            }\n\n            // added stuff\n            lineFrom = parseInt(s2[0], 10);\n            lineCount = parseInt(s2[1], 10);\n            if (isNaN(lineCount)) { lineCount = 1; }\n            var isModifiedMark = false;\n            var firstAddedMark = false;\n            for (var i = lineFrom, lineTo = lineFrom + lineCount; i < lineTo; i++) {\n                var lineNo = i - 1;\n                if (lineNo === lineRemovedFrom) {\n                    // modified\n                    var o = removed.pop();\n                    o.type = \"modified\";\n                    modified.push(o);\n                    isModifiedMark = o;\n                } else {\n                    var mark = {\n                        type: isModifiedMark ? \"modified\" : \"added\",\n                        line: lineNo,\n                        parentMark: isModifiedMark || firstAddedMark || null\n                    };\n                    if (!isModifiedMark && !firstAddedMark) {\n                        firstAddedMark = mark;\n                    }\n                    // added new\n                    added.push(mark);\n                }\n            }\n        });\n\n        // fix displaying of removed lines\n        removed.forEach(function (o) {\n            o.line = o.line + 1;\n        });\n\n        showGutters(editor, [].concat(added, removed, modified));\n    }\n\n    function refresh() {\n        if (!gitAvailable) {\n            return;\n        }\n\n        if (!Preferences.get(\"useGitGutter\")) {\n            return;\n        }\n\n        var currentGitRoot = Preferences.get(\"currentGitRoot\");\n\n        // we get a list of editors, which need to be refreshed\n        var editors = _.compact(_.map(MainViewManager.getPaneIdList(), function (paneId) {\n            return getEditorFromPane(paneId);\n        }));\n\n        // we create empty gutters in all of these editors, all other editors lose their gutters\n        prepareGutters(editors);\n\n        // now we launch a diff to fill the gutters in our editors\n        editors.forEach(function (editor) {\n\n            var currentFilePath = null;\n\n            if (editor.document && editor.document.file) {\n                currentFilePath = editor.document.file.fullPath;\n            }\n\n            if (currentFilePath.indexOf(currentGitRoot) !== 0) {\n                // file is not in the current project\n                return;\n            }\n\n            var filename = currentFilePath.substring(currentGitRoot.length);\n\n            Git.diffFile(filename).then(function (diff) {\n                processDiffResults(editor, diff);\n            }).catch(function (err) {\n                // if this is launched in a non-git repository, just ignore\n                if (ErrorHandler.contains(err, \"Not a git repository\")) {\n                    return;\n                }\n                // if this file was moved or deleted before this command could be executed, ignore\n                if (ErrorHandler.contains(err, \"No such file or directory\")) {\n                    return;\n                }\n                ErrorHandler.showError(err, Strings.ERROR_REFRESH_GUTTER);\n            });\n\n        });\n    }\n\n    function goToPrev() {\n        var activeEditor = EditorManager.getActiveEditor();\n        if (!activeEditor) { return; }\n\n        var results = activeEditor._codeMirror.gitGutters || [];\n        var searched = _.filter(results, function (i) { return !i.parentMark; });\n\n        var currentPos = activeEditor.getCursorPos();\n        var i = searched.length;\n        while (i--) {\n            if (searched[i].line < currentPos.line) {\n                break;\n            }\n        }\n        if (i > -1) {\n            var goToMark = searched[i];\n            activeEditor.setCursorPos(goToMark.line, currentPos.ch);\n        }\n    }\n\n    function goToNext() {\n        var activeEditor = EditorManager.getActiveEditor();\n        if (!activeEditor) { return; }\n\n        var results = activeEditor._codeMirror.gitGutters || [];\n        var searched = _.filter(results, function (i) { return !i.parentMark; });\n\n        var currentPos = activeEditor.getCursorPos();\n        for (var i = 0, l = searched.length; i < l; i++) {\n            if (searched[i].line > currentPos.line) {\n                break;\n            }\n        }\n        if (i < searched.length) {\n            var goToMark = searched[i];\n            activeEditor.setCursorPos(goToMark.line, currentPos.ch);\n        }\n    }\n\n    // Event handlers\n    EventEmitter.on(Events.GIT_ENABLED, function () {\n        gitAvailable = true;\n        refresh();\n    });\n    EventEmitter.on(Events.GIT_DISABLED, function () {\n        gitAvailable = false;\n        // calling this with an empty array will remove gutters from all editor instances\n        prepareGutters([]);\n    });\n    EventEmitter.on(Events.BRACKETS_CURRENT_DOCUMENT_CHANGE, function (file) {\n        // file will be null when switching to an empty pane\n        if (!file) { return; }\n\n        // document change gets launched even when switching panes,\n        // so we check if the file hasn't already got the gutters\n        var alreadyOpened = _.filter(editorsWithGutters, function (editor) {\n            return editor.document.file.fullPath === file.fullPath;\n        }).length > 0;\n\n        if (!alreadyOpened) {\n            // TODO: here we could sent a particular file to be refreshed only\n            refresh();\n        }\n    });\n    EventEmitter.on(Events.GIT_COMMITED, function () {\n        refresh();\n    });\n    EventEmitter.on(Events.BRACKETS_FILE_CHANGED, function (file) {\n        var alreadyOpened = _.filter(editorsWithGutters, function (editor) {\n            return editor.document.file.fullPath === file.fullPath;\n        }).length > 0;\n\n        if (alreadyOpened) {\n            // TODO: here we could sent a particular file to be refreshed only\n            refresh();\n        }\n    });\n\n    function init() {\n        const editor = EditorManager.getActiveEditor();\n        if(!editor){\n            return;\n        }\n        editor.off(\"cursorActivity.gitGutter\");\n        editor.on(\"cursorActivity.gitGutter\", _cursorActivity);\n        _cursorActivity(null, editor);\n    }\n\n    // API\n    exports.init = init;\n    exports.goToPrev = goToPrev;\n    exports.goToNext = goToNext;\n});\n"],"file":"GutterManager.js"}