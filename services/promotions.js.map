{"version":3,"sources":["services/promotions.js"],"names":["define","require","exports","module","Metrics","semver","ProDialogs","dateNowFn","Date","now","KernalModeTrust","window","Error","LoginService","loginService","EVENT_PRO_UPGRADE_ON_INSTALL","PROMO_LOCAL_FILE","path","join","Phoenix","app","getApplicationSupportDirectory","isTestWindow","TRIAL_POLL_MS","FIRST_INSTALL_TRIAL_DAYS","SUBSEQUENT_TRIAL_DAYS","MS_PER_DAY","ERR_CORRUPTED","_writeFileAsync","filePath","data","Promise","resolve","reject","fs","writeFile","err","async","_clearTrialData","isNativeApp","removeCredential","CRED_KEY_PROMO","unlink","error","console","log","_generateSignature","proVersion","endDate","salt","getSalt","generateDataSignature","_isValidSignature","trialData","signature","expectedSignature","_getTrialData","getCredential","JSON","parse","isValid","e","fileData","VFS","readFileResolves","_setTrialData","setCredential","stringify","_calculateRemainingTrialDays","existingTrialData","trialEndDate","msRemaining","Math","max","ceil","_isNewerVersion","version1","version2","gt","_hasProSubscription","_verifyLoginStatus","entitlements","getEntitlements","plan","isSubscriber","_isTrialClosedForCurrentVersion","currentTrialData","currentVersion","AppConfig","apiVersion","remainingDays","trialVersion","isNewerVersion","trialClosedDialogShown","upgradeDialogShownVersion","getProTrialDaysRemaining","result","activateProTrial","trialDays","metricString","replaceAll","warn","countEvent","EVENT_TYPE","PRO","hasProSubscription","showProUpsellDialog","UPSELL_TYPE_PRO_TRIAL_ENDED","showProTrialStartDialog","trigger","isFirstInstall","getEffectiveEntitlements","EVENT_ENTITLEMENTS_CHANGED","_isAnyDialogsVisible","dialogsVisible","$","is","notificationsVisible","trialActivatePoller","setInterval","clearInterval","catch","logger","reportError","_test_promo_login_exports","_cleanTrialData","_cleanSaltData","SIGNATURE_SALT_KEY","_testSetPromoJSON","setDateNowFn","_setDdateNowFn","fn","TRIAL_CONSTANTS","ERROR_CONSTANTS"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU Affero General Public License as published by the Free\n * Software Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*global logger, path*/\n\n/**\n * Promotions Service\n *\n * Manages pro trial promotions for both native and browser applications.\n * Provides loginless pro trials\n *\n * - First install: 30-day trial on first usage\n * - Subsequent versions: 7-day trial (or remaining from 30-day if still valid)\n * - Older versions: No new trial, but existing 30-day trial remains valid\n */\n\ndefine(function (require, exports, module) {\n\n    require(\"./setup-login-service\"); // this adds loginService to KernalModeTrust\n    const Metrics = require(\"utils/Metrics\"),\n        semver = require(\"thirdparty/semver.browser\"),\n        ProDialogs = require(\"./pro-dialogs\");\n\n    let dateNowFn = Date.now;\n    const KernalModeTrust = window.KernalModeTrust;\n    if (!KernalModeTrust) {\n        throw new Error(\"Promotions service requires access to KernalModeTrust. Cannot boot without trust ring\");\n    }\n\n    const LoginService = KernalModeTrust.loginService;\n\n    // Constants\n    const EVENT_PRO_UPGRADE_ON_INSTALL = \"pro_upgrade_on_install\";\n    const PROMO_LOCAL_FILE = path.join(Phoenix.app.getApplicationSupportDirectory(),\n        Phoenix.isTestWindow ? \"entitlements_promo_test.json\" : \"entitlements_promo.json\");\n    const TRIAL_POLL_MS = 1000; // We assign a free trial if possible as soon as user comes in for best UX.\n    const FIRST_INSTALL_TRIAL_DAYS = 30;\n    const SUBSEQUENT_TRIAL_DAYS = 7;\n    const MS_PER_DAY = 24 * 60 * 60 * 1000;\n\n    // Error constants for _getTrialData\n    const ERR_CORRUPTED = \"corrupted\";\n\n    /**\n     * Async wrapper for fs.writeFile in browser\n     */\n    function _writeFileAsync(filePath, data) {\n        return new Promise((resolve, reject) => {\n            window.fs.writeFile(filePath, data, 'utf8', (err) => {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve();\n                }\n            });\n        });\n    }\n\n    /**\n     * Clear trial data from storage (reusable function)\n     */\n    async function _clearTrialData() {\n        try {\n            if (Phoenix.isNativeApp) {\n                await KernalModeTrust.removeCredential(KernalModeTrust.CRED_KEY_PROMO);\n            } else {\n                await new Promise((resolve) => {\n                    window.fs.unlink(PROMO_LOCAL_FILE, () => resolve()); // Always resolve, ignore errors\n                });\n            }\n        } catch (error) {\n            console.log(\"Error clearing trial data:\", error);\n        }\n    }\n\n    /**\n     * Generate SHA-256 signature for trial data integrity\n     */\n    async function _generateSignature(proVersion, endDate) {\n        const salt = await LoginService.getSalt();\n        const data = proVersion + \"|\" + endDate;\n        return KernalModeTrust.generateDataSignature(data, salt);\n    }\n\n    /**\n     * Validate trial data signature\n     */\n    async function _isValidSignature(trialData) {\n        if (!trialData.signature || !trialData.proVersion || !trialData.endDate) {\n            return false;\n        }\n\n        const expectedSignature = await _generateSignature(trialData.proVersion, trialData.endDate);\n        return trialData.signature === expectedSignature;\n    }\n\n    /**\n     * Get stored trial data with validation and corruption detection\n     * Returns: {data: {...}} for valid data, {error: ERR_CORRUPTED} for errors, or null for no data\n     */\n    async function _getTrialData() {\n        try {\n            if (Phoenix.isNativeApp) {\n                // Native app: use KernalModeTrust credential store\n                const data = await KernalModeTrust.getCredential(KernalModeTrust.CRED_KEY_PROMO);\n                if (!data) {\n                    return null; // No data exists - genuine first install\n                }\n                try {\n                    const trialData = JSON.parse(data);\n                    const isValid = await _isValidSignature(trialData);\n                    if (isValid) {\n                        return { data: trialData }; // Valid trial data\n                    }\n                    return { error: ERR_CORRUPTED }; // Data exists but signature invalid\n                } catch (e) {\n                    return { error: ERR_CORRUPTED }; // JSON parse error\n                }\n            } else {\n                // Browser app: use virtual filesystem. in future we need to always fetch from remote about trial\n                // entitlements for browser app.\n                const fileData = await Phoenix.VFS.readFileResolves(PROMO_LOCAL_FILE, 'utf8');\n\n                if (fileData.error) {\n                    return null; // No data exists - genuine first install\n                }\n\n                try {\n                    const trialData = JSON.parse(fileData.data);\n                    const isValid = await _isValidSignature(trialData);\n                    if (isValid) {\n                        return { data: trialData }; // Valid trial data\n                    }\n                    return { error: ERR_CORRUPTED }; // Data exists but signature invalid\n                } catch (e) {\n                    return { error: ERR_CORRUPTED }; // JSON parse error\n                }\n            }\n        } catch (error) {\n            console.error(\"Error getting trial data:\", error);\n            return { error: ERR_CORRUPTED }; // Treat error as corrupted/tampered data\n        }\n    }\n\n    /**\n     * Store trial data with signature\n     */\n    async function _setTrialData(trialData) {\n        trialData.signature = await _generateSignature(trialData.proVersion, trialData.endDate);\n\n        try {\n            if (Phoenix.isNativeApp) {\n                // Native app: use KernalModeTrust credential store\n                await KernalModeTrust.setCredential(KernalModeTrust.CRED_KEY_PROMO, JSON.stringify(trialData));\n            } else {\n                // Browser app: use virtual filesystem\n                await _writeFileAsync(PROMO_LOCAL_FILE, JSON.stringify(trialData));\n            }\n        } catch (error) {\n            console.error(\"Error setting trial data:\", error);\n            throw error;\n        }\n    }\n\n    /**\n     * Calculate remaining trial days from end date\n     */\n    function _calculateRemainingTrialDays(existingTrialData) {\n        const now = dateNowFn();\n        const trialEndDate = existingTrialData.endDate;\n\n        // Calculate days remaining until trial ends\n        const msRemaining = trialEndDate - now;\n        return Math.max(0, Math.ceil(msRemaining / MS_PER_DAY)); // days remaining\n    }\n\n    /**\n     * Check if version1 is newer than version2 using semver\n     */\n    function _isNewerVersion(version1, version2) {\n        try {\n            return semver.gt(version1, version2);\n        } catch (error) {\n            console.error(\"Error comparing versions:\", error, version1, version2);\n            // Assume not newer if comparison fails\n            return false;\n        }\n    }\n\n    /**\n     * Check if user has active pro subscription. this calls actual login endpoint and is not to be used frequently!.\n     * Returns true if user is logged in and has a paid subscription\n     */\n    async function _hasProSubscription() {\n        try {\n            // First verify login status to ensure login state is properly resolved\n            await LoginService._verifyLoginStatus();\n\n            // getEntitlements() returns null if not logged in\n            const entitlements = await LoginService.getEntitlements();\n            return entitlements && entitlements.plan && entitlements.plan.isSubscriber === true;\n        } catch (error) {\n            console.error(\"Error checking pro subscription:\", error);\n            return false;\n        }\n    }\n\n    function _isTrialClosedForCurrentVersion(currentTrialData) {\n        if(!currentTrialData) {\n            return false;\n        }\n        const currentVersion = window.AppConfig ? window.AppConfig.apiVersion : \"1.0.0\";\n        const remainingDays = _calculateRemainingTrialDays(currentTrialData);\n        const trialVersion = currentTrialData.proVersion;\n        const isNewerVersion = _isNewerVersion(currentVersion, trialVersion);\n        const trialClosedDialogShown = currentTrialData.upgradeDialogShownVersion === currentVersion;\n        // if isCurrentVersionTrialClosed and if remainingDays > 0, it means that user put back system time to\n        // before trial end. in this case we should not grant any trial.\n        return trialClosedDialogShown || (remainingDays <= 0 && !isNewerVersion);\n    }\n\n    /**\n     * Get remaining pro trial days\n     * Returns 0 if no trial or trial expired\n     */\n    async function getProTrialDaysRemaining() {\n        const result = await _getTrialData();\n        if (!result || result.error || _isTrialClosedForCurrentVersion(result.data)) {\n            return 0;\n        }\n\n        return _calculateRemainingTrialDays(result.data);\n    }\n\n    async function activateProTrial() {\n        const currentVersion = window.AppConfig ? window.AppConfig.apiVersion : \"1.0.0\";\n        const result = await _getTrialData();\n\n        let trialDays = FIRST_INSTALL_TRIAL_DAYS;\n        let endDate;\n        const now = dateNowFn();\n        let metricString = `${currentVersion.replaceAll(\".\", \"_\")}`; // 3.1.0 -> 3_1_0\n\n        // Handle corrupted or parse failed data - reset trial state and deny any trial grants\n        if (result && result.error) {\n            console.warn(`Trial data error detected (${result.error}) - resetting trial state without granting trial`);\n            Metrics.countEvent(Metrics.EVENT_TYPE.PRO, \"trial\", \"corrupt\");\n\n            // Check if user has pro subscription\n            const hasProSubscription = await _hasProSubscription();\n            if (hasProSubscription) {\n                console.log(\"User has pro subscription - resetting corrupted trial marker\");\n                await _setTrialData({\n                    proVersion: currentVersion,\n                    endDate: now // Expires immediately\n                });\n                return;\n            }\n\n            // For corruption, show trial ended dialog and create expired marker\n            // Do not grant any new trial as possible tampering.\n            console.warn(\"trial data corrupted\");\n            ProDialogs.showProUpsellDialog(ProDialogs.UPSELL_TYPE_PRO_TRIAL_ENDED); // Show ended dialog for security\n\n            // Create expired trial marker to prevent future trial grants\n            await _setTrialData({\n                proVersion: currentVersion,\n                endDate: now // Expires immediately\n            });\n            return;\n        }\n\n        const existingTrialData = result ? result.data : null;\n        if (existingTrialData) {\n            // Existing trial found\n            const remainingDays = _calculateRemainingTrialDays(existingTrialData);\n            const trialVersion = existingTrialData.proVersion;\n            const isNewerVersion = _isNewerVersion(currentVersion, trialVersion);\n\n            // Check if we should grant any trial\n            if (_isTrialClosedForCurrentVersion(existingTrialData)) {\n                // Check if promo ended dialog was already shown for this version\n                if (existingTrialData.upgradeDialogShownVersion !== currentVersion) {\n                    // Check if user has pro subscription before showing promo dialog\n                    const hasProSubscription = await _hasProSubscription();\n                    if (!hasProSubscription) {\n                        console.log(\"Existing trial expired, showing promo ended dialog\");\n                        ProDialogs.showProUpsellDialog(ProDialogs.UPSELL_TYPE_PRO_TRIAL_ENDED);\n                    } else {\n                        console.log(\"Existing trial expired, but user has pro subscription - skipping promo dialog\");\n                    }\n                    // Store that dialog was shown for this version\n                    await _setTrialData({\n                        ...existingTrialData,\n                        upgradeDialogShownVersion: currentVersion\n                    });\n                } else {\n                    console.log(\"Existing trial expired, upgrade dialog already shown for this version\");\n                }\n                return;\n            }\n\n            // Determine trial days and end date\n            if (isNewerVersion) {\n                if (remainingDays >= SUBSEQUENT_TRIAL_DAYS) {\n                    // Newer version but existing trial is longer - keep existing\n                    console.log(`Newer version, keeping existing trial (${remainingDays} days)`);\n                    trialDays = remainingDays;\n                    endDate = existingTrialData.endDate;\n                    metricString = `nD_${metricString}_upgrade`;\n                } else {\n                    // Newer version with shorter existing trial - give 7 days\n                    console.log(`Newer version - granting ${SUBSEQUENT_TRIAL_DAYS} days trial`);\n                    trialDays = SUBSEQUENT_TRIAL_DAYS;\n                    endDate = now + (trialDays * MS_PER_DAY);\n                    metricString = `3D_${metricString}`;\n                }\n            } else {\n                // Same/older version: keep existing trial - no changes needed\n                console.log(`Same/older version - keeping existing ${remainingDays} day trial.`);\n                return;\n            }\n        } else {\n            // First install - 30 days from now\n            endDate = now + (FIRST_INSTALL_TRIAL_DAYS * MS_PER_DAY);\n            metricString = `1Mo_${metricString}`;\n        }\n\n        const trialData = {\n            proVersion: currentVersion,\n            endDate: endDate\n        };\n\n        await _setTrialData(trialData);\n        Metrics.countEvent(Metrics.EVENT_TYPE.PRO, \"trialAct\", metricString);\n        Metrics.countEvent(Metrics.EVENT_TYPE.PRO, \"trial\", \"activated\");\n        console.log(`Pro trial activated for ${trialDays} days`);\n\n        // Check if user has pro subscription before showing upgrade dialog\n        const hasProSubscription = await _hasProSubscription();\n        if (!hasProSubscription) {\n            ProDialogs.showProTrialStartDialog(trialDays);\n        } else {\n            console.log(\"Pro trial activated, but user has pro subscription - skipping upgrade dialog\");\n        }\n        // Trigger the event for UI to handle\n        LoginService.trigger(EVENT_PRO_UPGRADE_ON_INSTALL, {\n            trialDays: trialDays,\n            isFirstInstall: !existingTrialData\n        });\n\n        // Also trigger entitlements changed event since effective entitlements have changed\n        // This allows UI components to update based on the new trial status\n        await LoginService.getEffectiveEntitlements();\n        LoginService.trigger(LoginService.EVENT_ENTITLEMENTS_CHANGED);\n    }\n\n    function _isAnyDialogsVisible() {\n        const dialogsVisible = $(`.modal.instance`).is(':visible');\n        const notificationsVisible = $(`.notification-ui-tooltip`).is(':visible');\n        return dialogsVisible || notificationsVisible;\n    }\n\n    /**\n     * Start the pro trial activation process\n     */\n    console.log(`Checking pro trial activation in ${TRIAL_POLL_MS / 1000} seconds...`);\n\n    const trialActivatePoller = setInterval(()=> {\n        if(Phoenix.isTestWindow) {\n            clearInterval(trialActivatePoller);\n            return;\n        }\n        if(_isAnyDialogsVisible()){\n            // maybe the user hasn't dismissed the new project dialog\n            return;\n        }\n        clearInterval(trialActivatePoller);\n        activateProTrial().catch(error => {\n            Metrics.countEvent(Metrics.EVENT_TYPE.PRO, \"trial\", `errActivate`);\n            logger.reportError(error, \"Error activating pro trial:\");\n        });\n    }, TRIAL_POLL_MS);\n\n    // Add to secure exports\n    LoginService.getProTrialDaysRemaining = getProTrialDaysRemaining;\n    LoginService.EVENT_PRO_UPGRADE_ON_INSTALL = EVENT_PRO_UPGRADE_ON_INSTALL;\n\n    // Test-only exports for integration testing\n    if (Phoenix.isTestWindow) {\n        window._test_promo_login_exports = {\n            LoginService: LoginService,\n            ProDialogs: ProDialogs,\n            _getTrialData: _getTrialData,\n            _setTrialData: _setTrialData,\n            _isTrialClosedForCurrentVersion: _isTrialClosedForCurrentVersion,\n            _cleanTrialData: _clearTrialData,\n            _cleanSaltData: async function() {\n                try {\n                    if (Phoenix.isNativeApp) {\n                        await KernalModeTrust.removeCredential(KernalModeTrust.SIGNATURE_SALT_KEY);\n                        console.log(\"Salt data cleanup completed\");\n                    }\n                    // in browser app we always return a static salt, so no need to clear it\n                } catch (error) {\n                    // Ignore cleanup errors\n                    console.log(\"Salt data cleanup completed (ignoring errors)\");\n                }\n            },\n            // Test-only functions for manipulating credentials directly (bypassing validation)\n            _testSetPromoJSON: async function(data) {\n                if (Phoenix.isNativeApp) {\n                    await KernalModeTrust.setCredential(KernalModeTrust.CRED_KEY_PROMO, JSON.stringify(data));\n                } else {\n                    await _writeFileAsync(PROMO_LOCAL_FILE, JSON.stringify(data));\n                }\n            },\n            activateProTrial: activateProTrial,\n            getProTrialDaysRemaining: getProTrialDaysRemaining,\n            setDateNowFn: function _setDdateNowFn(fn) {\n                dateNowFn = fn;\n            },\n            EVENT_PRO_UPGRADE_ON_INSTALL: EVENT_PRO_UPGRADE_ON_INSTALL,\n            TRIAL_CONSTANTS: {\n                FIRST_INSTALL_TRIAL_DAYS,\n                SUBSEQUENT_TRIAL_DAYS,\n                MS_PER_DAY\n            },\n            ERROR_CONSTANTS: {\n                ERR_CORRUPTED\n            }\n        };\n    }\n\n    // no public exports to prevent extension tampering\n});\n"],"file":"promotions.js"}