{"version":3,"sources":["services/login-desktop.js"],"names":["define","require","exports","module","LoginServiceDirectImport","EventDispatcher","PreferencesManager","Metrics","Dialogs","DefaultDialogs","Strings","NativeApp","ProfileMenu","Mustache","NodeConnector","otpDialogTemplate","KernalModeTrust","window","Error","LoginService","loginService","userProfile","isLoggedInUser","fetchFn","fetch","PREF_USER_PROFILE_VERSION","_EVT_PAGE_FOCUSED","focusWatcher","makeEventDispatcher","$","focus","trigger","AUTH_CONNECTOR_ID","EVENT_CONNECTED","authNodeConnector","isLoggedIn","getProfile","getAccountBaseURL","location","hostname","Phoenix","config","account_url","replace","_getAccountWebURL","isNativeApp","createNodeConnector","ERR_RETRY_LATER","ERR_INVALID","async","_resolveAPIKey","apiKey","validationCode","resolveURL","navigator","onLine","err","isTestWindow","response","status","ok","userDetails","json","console","log","e","error","_resetAccountLogin","setNotLoggedIn","removeCredential","CRED_KEY_API","stateManager","set","crypto","randomUUID","_verifyLogin","silentCheck","savedUserProfile","getCredential","JSON","parse","setLoggedIn","profileIcon","initials","color","resolveResponse","setCredential","stringify","catch","showModalDialog","DIALOG_ID_ERROR","SIGNED_OUT","SIGNED_OUT_MESSAGE","_getAutoAuthPortURL","localAutoAuthURL","PLATFORM_STRINGS","win","mac","linux","_getAppAuthSession","authPortURL","platformStr","platform","appName","encodeURIComponent","APP_NAME","appSessionID","countEvent","EVENT_TYPE","AUTH","logger","reportError","setAutoVerificationCode","TIMEOUT_MS","Promise","race","execPeer","_","reject","setTimeout","signInToAccount","SIGNED_IN_OFFLINE_TITLE","SIGNED_IN_OFFLINE_MESSAGE","appAuthSession","SIGNED_IN_FAILED_TITLE","SIGNED_IN_FAILED_MESSAGE","appSignInURL","dialogData","$template","render","dialog","showModalDialogUsingTemplate","closeTimeout","close","on","app","copyToClipboard","$validationCodeSpan","find","originalText","text","VALIDATION_CODE_COPIED","openURLInDefaultBrowser","checkLoginStatus","checking","checkAgain","isAutoSignedIn","_AutoSignedIn","one","done","off","clearTimeout","signOutAccount","input","method","headers","Content-Type","body","result","isSuccess","SIGNED_OUT_FAILED_TITLE","SIGNED_OUT_FAILED_MESSAGE","DIALOG_ID_INFO","SIGNED_OUT_MESSAGE_FRIENDLY","init","pref","definePreference","watchExternalChanges","_verifyLoginStatus","_test_login_desktop_exports","setFetchFn","_setFetchFn","fn"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU Affero General Public License as published by the Free\n * Software Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along\n * with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*global logger*/\n\ndefine(function (require, exports, module) {\n    const LoginServiceDirectImport = require(\"./login-service\"); // after this, loginService will be in KernalModeTrust\n\n    const EventDispatcher = require(\"utils/EventDispatcher\"),\n        PreferencesManager  = require(\"preferences/PreferencesManager\"),\n        Metrics = require(\"utils/Metrics\"),\n        Dialogs = require(\"widgets/Dialogs\"),\n        DefaultDialogs = require(\"widgets/DefaultDialogs\"),\n        Strings = require(\"strings\"),\n        NativeApp = require(\"utils/NativeApp\"),\n        ProfileMenu  = require(\"./profile-menu\"),\n        Mustache = require(\"thirdparty/mustache/mustache\"),\n        NodeConnector = require(\"NodeConnector\"),\n        otpDialogTemplate = require(\"text!./html/otp-dialog.html\");\n\n    const KernalModeTrust = window.KernalModeTrust;\n    if(!KernalModeTrust){\n        // integrated extensions will have access to kernal mode, but not external extensions\n        throw new Error(\"Login service should have access to KernalModeTrust. Cannot boot without trust ring\");\n    }\n    const LoginService = KernalModeTrust.loginService;\n\n    // user profile is something like \"apiKey\": \"uuid...\", validationCode: \"dfdf\", \"firstName\":\"Aa\",\"lastName\":\"bb\",\n    // \"email\":\"aaaa@sss.com\", \"customerID\":\"uuid...\",\"loginTime\":1750074393853,\n    // \"profileIcon\":{\"color\":\"#14b8a6\",\"initials\":\"AB\"}\n    let userProfile = null;\n    let isLoggedInUser = false;\n\n    // save a copy of window.fetch so that extensions wont tamper with it.\n    let fetchFn = window.fetch;\n\n    // just used as trigger to notify different windows about user profile changes\n    const PREF_USER_PROFILE_VERSION = \"userProfileVersion\";\n\n    const _EVT_PAGE_FOCUSED = \"page_focused\";\n    const focusWatcher = {};\n    EventDispatcher.makeEventDispatcher(focusWatcher);\n    $(window).focus(function () {\n        focusWatcher.trigger(_EVT_PAGE_FOCUSED);\n    });\n\n    const AUTH_CONNECTOR_ID = \"ph_auth\";\n    const EVENT_CONNECTED = \"connected\";\n    let authNodeConnector;\n    if(Phoenix.isNativeApp) {\n        authNodeConnector = NodeConnector.createNodeConnector(AUTH_CONNECTOR_ID, exports);\n    }\n\n\n    function isLoggedIn() {\n        return isLoggedInUser;\n    }\n\n    function getProfile() {\n        return userProfile;\n    }\n\n    /**\n     * Get the account base URL for API calls\n     * For desktop apps, this directly uses the configured account URL\n     */\n    function getAccountBaseURL() {\n        if (location.hostname === 'localhost' || location.hostname === '127.0.0.1') {\n            return '/proxy/accounts';\n        }\n        return Phoenix.config.account_url.replace(/\\/$/, ''); // Remove trailing slash\n    }\n\n    /**\n     * Get the account website URL for opening browser tabs\n     */\n    function _getAccountWebURL() {\n        return Phoenix.config.account_url;\n    }\n\n    const ERR_RETRY_LATER = \"retry_later\";\n    const ERR_INVALID = \"invalid\";\n\n    /**\n     * Resolves the provided API key and verification code to user profile data\n     *\n     * @param {string} apiKey - The API key to be validated.\n     * @param {string} validationCode - The verification code associated with the API key.\n     * @return {Promise<Object>} A promise resolving to an object containing the user details if successful,\n     * or an error object with the relevant error code (`ERR_RETRY_LATER` or `ERR_INVALID`) if the operation fails.\n     * never rejects.\n     */\n    async function _resolveAPIKey(apiKey, validationCode) {\n        const resolveURL = `${getAccountBaseURL()}/resolveAppSessionID?appSessionID=${apiKey}&validationCode=${validationCode}`;\n        if (!navigator.onLine) {\n            return {err: ERR_RETRY_LATER};\n        }\n        try {\n            if(Phoenix.isTestWindow && fetchFn === fetch){\n                // so we never allow tests to hit the actual login service.\n                return {err: ERR_INVALID};\n            }\n            const response = await fetchFn(resolveURL);\n            if (response.status === 400 || response.status === 404) {\n                // 404 api key not found and 400 Bad Request, eg: verification code mismatch\n                return {err: ERR_INVALID};\n            } else if (response.ok) {\n                const userDetails = await response.json();\n                userDetails.apiKey = apiKey;\n                userDetails.validationCode = validationCode;\n                return {userDetails};\n            }\n            // Other errors like 500 are retriable\n            console.log('Other error:', response.status);\n            return {err: ERR_RETRY_LATER};\n        } catch (e) {\n            console.error(e, \"Failed to call resolve API endpoint\", resolveURL);\n            return {err: ERR_RETRY_LATER};\n        }\n    }\n\n    async function _resetAccountLogin() {\n        isLoggedInUser = false;\n        ProfileMenu.setNotLoggedIn();\n        await KernalModeTrust.removeCredential(KernalModeTrust.CRED_KEY_API);\n        // bump the version so that in multi windows, the other window gets notified of the change\n        PreferencesManager.stateManager.set(PREF_USER_PROFILE_VERSION, crypto.randomUUID());\n    }\n\n    async function _verifyLogin(silentCheck = false) {\n        const savedUserProfile = await KernalModeTrust.getCredential(KernalModeTrust.CRED_KEY_API);\n        if(!savedUserProfile){\n            console.log(\"No savedUserProfile found. Not logged in\");\n            if (!silentCheck) {\n                ProfileMenu.setNotLoggedIn();\n            }\n            isLoggedInUser = false;\n            return;\n        }\n        try {\n            userProfile = JSON.parse(savedUserProfile);\n        } catch (e) {\n            console.error(e, \"Failed to parse saved user profile credentials\");// this should never happen\n            if (!silentCheck) {\n                ProfileMenu.setNotLoggedIn();\n            }\n            return; // not logged in if parse fails\n        }\n        isLoggedInUser = true;\n        // api key is present, verify if the key is valid. but just show user that we are logged in with\n        // stored credentials.\n        ProfileMenu.setLoggedIn(userProfile.profileIcon.initials, userProfile.profileIcon.color);\n        const resolveResponse = await _resolveAPIKey(userProfile.apiKey, userProfile.validationCode);\n        if(resolveResponse.userDetails) {\n            // a valid user account is in place. update the stored credentials\n            userProfile = resolveResponse.userDetails;\n            ProfileMenu.setLoggedIn(userProfile.profileIcon.initials, userProfile.profileIcon.color);\n            await KernalModeTrust.setCredential(KernalModeTrust.CRED_KEY_API, JSON.stringify(userProfile));\n            // we dont need to bump the PREF_USER_PROFILE_VERSION here as its just a cred update\n            // (maybe name) and may lead to infi loops.\n            return;\n        }\n        // some error happened.\n        if(resolveResponse.err === ERR_INVALID) { // the api key is invalid, we need to logout and tell user\n            _resetAccountLogin()\n                .catch(console.error);\n            Dialogs.showModalDialog(\n                DefaultDialogs.DIALOG_ID_ERROR,\n                Strings.SIGNED_OUT,\n                Strings.SIGNED_OUT_MESSAGE\n            );\n        }\n        // maybe some intermittent network error, ERR_RETRY_LATER is here. do nothing\n    }\n\n    function _getAutoAuthPortURL() {\n        const localAutoAuthURL = KernalModeTrust.localAutoAuthURL; // Eg: http://localhost:33577/AutoAuthDI0zAUJo\n        if(!localAutoAuthURL) {\n            return \"9797/urlDoesntExist\";\n        }\n        return localAutoAuthURL.replace(\"http://localhost:\", \"\");\n    }\n\n    const PLATFORM_STRINGS = {\n        \"win\": \"Windows\",\n        \"mac\": \"mac\",\n        \"linux\": \"Linux\"\n    };\n    // never rejects.\n    async function _getAppAuthSession() {\n        const authPortURL = _getAutoAuthPortURL();\n        const platformStr = PLATFORM_STRINGS[Phoenix.platform] || Phoenix.platform;\n        const appName = encodeURIComponent(`${Strings.APP_NAME} Desktop on ${platformStr}`);\n        const resolveURL = `${getAccountBaseURL()}/getAppAuthSession?autoAuthPort=${authPortURL}&appName=${appName}`;\n        // {\"isSuccess\":true,\"appSessionID\":\"a uuid...\",\"validationCode\":\"SWXP07\"}\n        try {\n            if(Phoenix.isTestWindow && fetchFn === fetch){\n                // so we never allow tests to hit the actual login service.\n                return null;\n            }\n            const response = await fetchFn(resolveURL);\n            if (response.ok) {\n                const {appSessionID, validationCode} = await response.json();\n                if(!appSessionID || !validationCode) {\n                    throw new Error(\"Invalid response from getAppAuthSession API endpoint\" + resolveURL);\n                }\n                return {appSessionID, validationCode};\n            }\n            return null;\n        } catch (e) {\n            console.error(e, \"Failed to call getAppAuthSession API endpoint\", resolveURL);\n            Metrics.countEvent(Metrics.EVENT_TYPE.AUTH, 'getAppAuth', Phoenix.platform);\n            logger.reportError(e, \"Failed to call getAppAuthSession API endpoint\" + resolveURL);\n            return null;\n        }\n    }\n\n    async function setAutoVerificationCode(validationCode) {\n        const TIMEOUT_MS = 1000;\n        try {\n            await Promise.race([\n                authNodeConnector.execPeer(\"setVerificationCode\", validationCode),\n                new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), TIMEOUT_MS))\n            ]);\n        } catch (e) {\n            console.error(\"failed to send auth login verification code to node\", e);\n            // we ignore this and continue for manual verification\n            Metrics.countEvent(Metrics.EVENT_TYPE.AUTH, 'autoFail', Phoenix.platform);\n        }\n    }\n\n    async function signInToAccount() {\n        if (!navigator.onLine) {\n            Dialogs.showModalDialog(\n                DefaultDialogs.DIALOG_ID_ERROR,\n                Strings.SIGNED_IN_OFFLINE_TITLE,\n                Strings.SIGNED_IN_OFFLINE_MESSAGE\n            );\n            return;\n        }\n        const appAuthSession = await _getAppAuthSession();\n        if(!appAuthSession) {\n            Dialogs.showModalDialog(\n                DefaultDialogs.DIALOG_ID_ERROR,\n                Strings.SIGNED_IN_FAILED_TITLE,\n                Strings.SIGNED_IN_FAILED_MESSAGE\n            );\n            return;\n        }\n        const {appSessionID, validationCode} = appAuthSession;\n        await setAutoVerificationCode(validationCode);\n        const appSignInURL = `${_getAccountWebURL()}authorizeApp?appSessionID=${appSessionID}`;\n\n        // Show dialog with validation code\n        const dialogData = {\n            validationCode: validationCode,\n            Strings: Strings\n        };\n\n        const $template = $(Mustache.render(otpDialogTemplate, dialogData));\n        const dialog = Dialogs.showModalDialogUsingTemplate($template);\n\n        // Set timeout to close dialog after 5 minutes, as validity is only 5 mins\n        const closeTimeout = setTimeout(() => {\n            dialog.close();\n        }, 5 * 60 * 1000);\n\n        // Handle button clicks\n        $template.on('click', '[data-button-id=\"copy\"]', function() {\n            Phoenix.app.copyToClipboard(validationCode);\n\n            // Show \"Copied\" feedback\n            const $validationCodeSpan = $template.find('.validation-code span');\n            const originalText = $validationCodeSpan.text();\n\n            // Replace validation code with \"Copied\" text\n            $validationCodeSpan.text(Strings.VALIDATION_CODE_COPIED);\n\n            // Restore original validation code after 1.5 seconds\n            setTimeout(() => {\n                $validationCodeSpan.text(originalText);\n            }, 1500);\n        });\n\n        $template.on('click', '[data-button-id=\"open\"]', function() {\n            NativeApp.openURLInDefaultBrowser(appSignInURL);\n        });\n        $template.on('click', '[data-button-id=\"cancel\"]', function() {\n            dialog.close();\n        });\n        $template.on('click', '[data-button-id=\"refresh\"]', function() {\n            checkLoginStatus();\n        });\n\n        let checking = false, checkAgain = false;\n        // never rejects\n        async function checkLoginStatus() {\n            if(checking) {\n                checkAgain = true;\n                return;\n            }\n            checking = true;\n            try {\n                const resolveResponse = await _resolveAPIKey(appSessionID, validationCode);\n                if(resolveResponse.userDetails) {\n                    // the user has validated the creds\n                    userProfile = resolveResponse.userDetails;\n                    ProfileMenu.setLoggedIn(userProfile.profileIcon.initials, userProfile.profileIcon.color);\n                    await KernalModeTrust.setCredential(KernalModeTrust.CRED_KEY_API, JSON.stringify(userProfile));\n                    // bump the version so that in multi windows, the other window gets notified of the change\n                    PreferencesManager.stateManager.set(PREF_USER_PROFILE_VERSION, crypto.randomUUID());\n                    checkAgain = false;\n                    isLoggedInUser = true;\n                    dialog.close();\n                }\n            } catch (e) {\n                console.error(\"Failed to check login status.\", e);\n            }\n            checking = false;\n            if(checkAgain) {\n                checkAgain = false;\n                setTimeout(checkLoginStatus, 100);\n            }\n        }\n        let isAutoSignedIn = false;\n        focusWatcher.on(_EVT_PAGE_FOCUSED, checkLoginStatus);\n        async function _AutoSignedIn() {\n            isAutoSignedIn = true;\n            await checkLoginStatus();\n        }\n        authNodeConnector.one(EVENT_CONNECTED, _AutoSignedIn);\n\n        // Clean up when dialog is closed\n        dialog.done(function() {\n            focusWatcher.off(_EVT_PAGE_FOCUSED, checkLoginStatus);\n            authNodeConnector.off(EVENT_CONNECTED, _AutoSignedIn);\n            clearTimeout(closeTimeout);\n            Metrics.countEvent(Metrics.EVENT_TYPE.AUTH,\n                isAutoSignedIn ? 'autoLogin' : 'manLogin'\n                , Phoenix.platform);\n            Metrics.countEvent(Metrics.EVENT_TYPE.AUTH, \"dsktpLogin\",\n                isAutoSignedIn ? 'auto' : 'man');\n        });\n        NativeApp.openURLInDefaultBrowser(appSignInURL);\n    }\n\n    async function signOutAccount() {\n        const resolveURL = `${getAccountBaseURL()}/logoutSession`;\n        try {\n            let input = {\n                appSessionID: userProfile.apiKey\n            };\n\n            if(Phoenix.isTestWindow && fetchFn === fetch){\n                // so we never allow tests to hit the actual login service.\n                return;\n            }\n            const response = await fetchFn(resolveURL, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify(input)\n            });\n\n            const result = await response.json();\n\n            if (!result.isSuccess) {\n                console.error('Error logging out', result);\n                const dialog = Dialogs.showModalDialog(\n                    DefaultDialogs.DIALOG_ID_ERROR,\n                    Strings.SIGNED_OUT_FAILED_TITLE,\n                    Strings.SIGNED_OUT_FAILED_MESSAGE\n                );\n                dialog.done(() => {\n                    NativeApp.openURLInDefaultBrowser(_getAccountWebURL() + \"#advanced\");\n                });\n                Metrics.countEvent(Metrics.EVENT_TYPE.AUTH, 'logoutFail', Phoenix.platform);\n                return;\n            }\n            await _resetAccountLogin();\n            await _verifyLogin();\n            Dialogs.showModalDialog(\n                DefaultDialogs.DIALOG_ID_INFO,\n                Strings.SIGNED_OUT,\n                Strings.SIGNED_OUT_MESSAGE_FRIENDLY\n            );\n            Metrics.countEvent(Metrics.EVENT_TYPE.AUTH, 'logoutOK', Phoenix.platform);\n        } catch (error) {\n            console.error(\"Network error. Could not log out session.\", error);\n            const dialog = Dialogs.showModalDialog(\n                DefaultDialogs.DIALOG_ID_ERROR,\n                Strings.SIGNED_OUT_FAILED_TITLE,\n                Strings.SIGNED_OUT_FAILED_MESSAGE\n            );\n            dialog.done(() => {\n                NativeApp.openURLInDefaultBrowser(_getAccountWebURL() + \"#advanced\");\n            });\n            Metrics.countEvent(Metrics.EVENT_TYPE.AUTH, 'getAppAuth', Phoenix.platform);\n            logger.reportError(error, \"Failed to call logout calling\" + resolveURL);\n        }\n    }\n\n    function init() {\n        if(!Phoenix.isNativeApp){\n            console.log(\"Desktop login service not needed for browser\");\n            return;\n        }\n        ProfileMenu.init();\n        LoginServiceDirectImport.init();\n        _verifyLogin(true).catch(console.error);// todo raise metrics - silent check on init\n        const pref = PreferencesManager.stateManager.definePreference(PREF_USER_PROFILE_VERSION, 'string', '0');\n        pref.watchExternalChanges();\n        pref.on('change', _verifyLogin);\n    }\n\n    // no sensitive apis or events should be triggered from the public exports of this module as extensions\n    // can read them. Always use KernalModeTrust.loginService for sensitive apis.\n\n    // Only set exports for native apps to avoid conflict with browser login\n    if (Phoenix.isNativeApp) {\n        // kernal exports - add to existing KernalModeTrust.loginService from login-service.js\n        // isLoggedIn API shouldn't be used outside loginService, please use Entitlements.isLoggedIn API.\n        LoginService.isLoggedIn = isLoggedIn;\n        // signInToAccount API shouldn't be used outside loginService, please use Entitlements.loginToAccount API.\n        LoginService.signInToAccount = signInToAccount;\n        LoginService.signOutAccount = signOutAccount;\n        LoginService.getProfile = getProfile;\n        LoginService._verifyLoginStatus = () => _verifyLogin(false);\n        LoginService.getAccountBaseURL = getAccountBaseURL;\n        init();\n    }\n\n    // Test-only exports for integration testing\n    if (Phoenix.isTestWindow) {\n        window._test_login_desktop_exports = {\n            setFetchFn: function _setFetchFn(fn) {\n                fetchFn = fn;\n            }\n        };\n    }\n\n    // public exports\n    exports.isLoggedIn = isLoggedIn;\n\n});\n"],"file":"login-desktop.js"}