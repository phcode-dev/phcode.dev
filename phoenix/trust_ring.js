function generateRandomKeyAndIV(){const keyBytes=new Uint8Array(32);crypto.getRandomValues(keyBytes);const ivBytes=new Uint8Array(12);crypto.getRandomValues(ivBytes);const key=Array.from(keyBytes).map(byte=>byte.toString(16).padStart(2,"0")).join(""),iv=Array.from(ivBytes).map(byte=>byte.toString(16).padStart(2,"0")).join("");return{key:key,iv:iv}}async function AESDecryptString(val,key,iv){const encryptedData=new Uint8Array(val.length/2);for(let i=0;i<val.length;i+=2)encryptedData[i/2]=parseInt(val.substr(i,2),16);const keyBytes=new Uint8Array(key.length/2);for(let i=0;i<key.length;i+=2)keyBytes[i/2]=parseInt(key.substr(i,2),16);const ivBytes=new Uint8Array(iv.length/2);for(let i=0;i<iv.length;i+=2)ivBytes[i/2]=parseInt(iv.substr(i,2),16);const cryptoKey=await crypto.subtle.importKey("raw",keyBytes,{name:"AES-GCM"},!1,["decrypt"]),decryptedBuffer=await crypto.subtle.decrypt({name:"AES-GCM",iv:ivBytes},cryptoKey,encryptedData);return new TextDecoder("utf-8").decode(decryptedBuffer)}const TEMP_KV_TRUST_FOR_TESTSUITE="TEMP_KV_TRUST_FOR_TESTSUITE";function _selectKeys(){if(Phoenix.isTestWindow){const kvj=window.top.sessionStorage.getItem(TEMP_KV_TRUST_FOR_TESTSUITE);if(!kvj){const kv=generateRandomKeyAndIV();return window.top.sessionStorage.setItem(TEMP_KV_TRUST_FOR_TESTSUITE,JSON.stringify(kv)),kv}try{return JSON.parse(kvj)}catch(e){console.error("Error parsing test suite trust keyring, defaulting to random which may not work!",e)}}return generateRandomKeyAndIV()}const CRED_KEY_API=Phoenix.isTestWindow?"API_KEY_TEST":"API_KEY",CRED_KEY_PROMO=Phoenix.isTestWindow?"PROMO_GRANT_KEY_TEST":"PROMO_GRANT_KEY",SIGNATURE_SALT_KEY=Phoenix.isTestWindow?"SIGNATURE_SALT_KEY_TEST":"SIGNATURE_SALT_KEY",VERSION_PORTER_KEY=Phoenix.isTestWindow?"VERSION_PORTER_TEST":"VERSION_PORTER",{key:key,iv:iv}=_selectKeys();async function setCredential(credKey,secret){if(!window.__TAURI__)throw new Error("Phoenix API key can only be set in tauri shell!");if(!credKey)throw new Error("credKey is required to set credential!");return window.__TAURI__.tauri.invoke("store_credential",{scopeName:credKey,secretVal:secret})}async function getCredential(credKey){if(!window.__TAURI__)throw new Error("Phoenix API key can only be get in tauri shell!");if(!credKey)throw new Error("credKey is required to get credential!");const encryptedKey=await window.__TAURI__.tauri.invoke("get_credential",{scopeName:credKey});return encryptedKey?AESDecryptString(encryptedKey,key,iv):null}async function removeCredential(credKey){if(!window.__TAURI__)throw new Error("Phoenix API key can only be set in tauri shell!");if(!credKey)throw new Error("credKey is required to remove credential!");return window.__TAURI__.tauri.invoke("delete_credential",{scopeName:credKey})}let _dismatled=!1;async function dismantleKeyring(){if(_dismatled)throw new Error("Keyring can only be dismantled once!");if(_dismatled=!0,key&&iv){if(window.__TAURI__)return window.__TAURI__.tauri.invoke("remove_trust_window_aes_key",{key:key,iv:iv})}else console.error("Invalid kernal keys supplied to shutdown. Ignoring kernal trust reset at shutdown.")}export async function initTrustRing(){window.__TAURI__&&(await window.__TAURI__.tauri.invoke("trust_window_aes_key",{key:key,iv:iv}),_portCredentials())}async function reinstallCreds(){if(!window.__TAURI__)throw new Error("reinstallCreds can only be called in tauri shell!");const apiKey=await getCredential(CRED_KEY_API),promoKey=await getCredential(CRED_KEY_PROMO),saltKey=await getCredential(SIGNATURE_SALT_KEY);apiKey&&await removeCredential(CRED_KEY_API),promoKey&&await removeCredential(CRED_KEY_PROMO),saltKey&&await removeCredential(SIGNATURE_SALT_KEY),apiKey&&await setCredential(CRED_KEY_API,apiKey),promoKey&&await setCredential(CRED_KEY_PROMO,promoKey),saltKey&&await setCredential(SIGNATURE_SALT_KEY,saltKey);const currentVersion=Phoenix.metadata.version;await setCredential(VERSION_PORTER_KEY,currentVersion)}async function _portCredentials(){if(Phoenix.isNativeApp&&"win"!==Phoenix.platform&&"linux"!==Phoenix.platform)try{const storedVersion=await getCredential(VERSION_PORTER_KEY),currentVersion=Phoenix.metadata.version;!storedVersion&&currentVersion?await setCredential(VERSION_PORTER_KEY,currentVersion):storedVersion&&currentVersion&&storedVersion!==currentVersion&&(console.log(`Version changed from ${storedVersion} to ${currentVersion}, reinstalling credentials`),await setCredential(VERSION_PORTER_KEY,currentVersion),await reinstallCreds())}catch(error){console.error("Error during version-based credential check:",error)}}async function generateDataSignature(dataString,salt){const signatureData=salt?dataString+"|"+salt:dataString,encoder=new TextEncoder,dataBuffer=encoder.encode(signatureData),hashBuffer=await crypto.subtle.digest("SHA-256",dataBuffer),hashArray=Array.from(new Uint8Array(hashBuffer));return hashArray.map(b=>b.toString(16).padStart(2,"0")).join("")}async function validateDataSignature(data,signature,salt){if(!signature)return!1;const expectedSignature=await generateDataSignature(data,salt);return signature===expectedSignature}window.KernalModeTrust={CRED_KEY_API:CRED_KEY_API,CRED_KEY_PROMO:CRED_KEY_PROMO,SIGNATURE_SALT_KEY:SIGNATURE_SALT_KEY,aesKeys:{key:key,iv:iv},setCredential:setCredential,getCredential:getCredential,removeCredential:removeCredential,AESDecryptString:AESDecryptString,generateRandomKeyAndIV:generateRandomKeyAndIV,dismantleKeyring:dismantleKeyring,generateDataSignature:generateDataSignature,validateDataSignature:validateDataSignature,reinstallCreds:reinstallCreds},Phoenix.isSpecRunnerWindow&&(window.specRunnerTestKernalModeTrust=window.KernalModeTrust);
//# sourceMappingURL=trust_ring.js.map
