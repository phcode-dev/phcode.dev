{"version":3,"sources":["phoenix/trust_ring.js"],"names":["generateRandomKeyAndIV","keyBytes","Uint8Array","crypto","getRandomValues","ivBytes","key","Array","from","map","byte","toString","padStart","join","iv","async","AESDecryptString","val","encryptedData","length","i","parseInt","substr","cryptoKey","subtle","importKey","name","decryptedBuffer","decrypt","TextDecoder","decode","TEMP_KV_TRUST_FOR_TESTSUITE","_selectKeys","Phoenix","isTestWindow","kvj","window","top","sessionStorage","getItem","kv","setItem","JSON","stringify","parse","e","console","error","CRED_KEY_API","CRED_KEY_PROMO","SIGNATURE_SALT_KEY","VERSION_PORTER_KEY","setCredential","credKey","secret","__TAURI__","Error","tauri","invoke","scopeName","secretVal","getCredential","encryptedKey","removeCredential","_dismatled","dismantleKeyring","initTrustRing","_portCredentials","reinstallCreds","apiKey","promoKey","saltKey","currentVersion","metadata","version","isNativeApp","platform","storedVersion","log","generateDataSignature","dataString","salt","signatureData","encoder","TextEncoder","dataBuffer","encode","hashBuffer","digest","hashArray","b","validateDataSignature","data","signature","expectedSignature","KernalModeTrust","aesKeys","isSpecRunnerWindow","specRunnerTestKernalModeTrust"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU Affero General Public License as published by the Free\n * Software Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along\n * with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/**\n * KernalModeTrust is a security mechanism in Phoenix that provides a trust base for core components before any\n * extensions are loaded. It establishes a secure communication channel between core modules and the Tauri shell,\n * preventing unauthorized access to sensitive information by extensions or other potentially malicious code.\n *\n * ## Purpose\n *\n * The primary purposes of KernalModeTrust are:\n *\n * 1. **Secure Boot Process**: Ensures that the application can only boot with a properly initialized trust ring.\n * 2. **Secure Communication**: Enables core modules to communicate securely without worrying about interception by\n *    extensions.\n * 3. **API Key Management**: Provides secure storage and retrieval of Phoenix API keys.\n * 4. **Security Boundary**: Creates a clear security boundary between trusted core components and potentially untrusted\n *    extensions.\n *\n * ## Implementation Details\n *\n * ### Trust Ring Initialization\n *\n * The trust ring is initialized at boot time before any extensions are loaded:\n *\n * 1. Random AES-256 keys and initialization vectors (IV) are generated using the Web Crypto API.\n * 2. These cryptographic materials are stored in the `window.KernalModeTrust` object.\n * 3. The trust relationship is established with the Tauri backend via the `initTrustRing()` function.\n *\n * The trust ring has several important security characteristics:\n *\n * 1. **Memory-Only Storage**: The random AES key-based trust ring is only kept in memory and never persisted to disk.\n * 2. **One-Time Use**: The trust ring is designed for one-time use and is discarded after serving its purpose.\n * 3. **Session Lifetime**: It is maintained in memory only until the end of the Phoenix session.\n * 4. **Tauri Communication**: The trust keys are communicated to the Tauri shell at boot time.\n * 5. **API Response Encryption**: Once an AES key is trusted by the Tauri shell, all sensitive API responses will be\n *   encrypted with this key. This means extensions can still call sensitive APIs but will receive only encrypted\n *   garbage responses without access to the trust key.\n *\n * ### Security Model\n *\n * KernalModeTrust implements a strict security model:\n *\n * 1. **Boot-time Only Access**: The trust ring is only available to code that loads before any extensions.\n * 2. **One-time Trust**: For a given Tauri window, the trust ring can only be set once.\n * 3. **Deliberate Removal**: Before extensions are loaded, `window.KernalModeTrust` is deleted to prevent extensions\n *    from accessing it.\n * 4. **Dismantling Before Restart**: The trust ring must be dismantled before restarting the application. This is a\n *    critical security requirement. If not dismantled, the old trust keys will still be in place when the page reloads,\n *    but the application will lose access to them (as they were only stored in memory). As a result, the Tauri shell\n *    will not trust any sensitive API calls from the reloaded page, as these calls will rely on the old keys that the\n *    new page instance cannot access. This security measure intentionally prevents any page reload from maintaining\n *    trust without explicitly dismantling the old trust ring first, ensuring that malicious code cannot bypass\n *    security by simply reloading the window.\n *\n * ### Cryptographic Implementation\n *\n * KernalModeTrust uses strong cryptography:\n *\n * 1. **AES-256 Encryption**: Uses AES-256 in GCM mode for secure encryption/decryption.\n * 2. **Random Key Generation**: Cryptographically secure random number generation for keys and IVs.\n * 3. **Secure Key Storage**: Keys are stored securely in the Tauri backend(which is stored in OS keychain).\n *\n * ## Security Considerations\n *\n * 1. **Extension Isolation**: Extensions should never have access to KernalModeTrust to prevent potential security\n *    breaches.\n *\n * 2. **One-time Trust**: The trust ring can only be set once per Tauri window, preventing malicious code from replacing\n *    it.\n *\n * 3. **Complete Dismantling**: When dismantling the keyring, it's recommended to reload the page immediately to prevent\n *    any potential exploitation of the system.\n *\n * 4. **Test Environment Handling**: Special handling exists for test environments to ensure tests can run properly\n *    without compromising security.\n *\n * ## Conclusion\n *\n * KernalModeTrust is a critical security component in Phoenix that establishes a trust boundary between core components\n * and extensions. By providing secure communication channels and API key management, it helps maintain the overall\n * security posture of the application.\n * */\n\n// Generate random AES-256 key and GCM nonce/IV\nfunction generateRandomKeyAndIV() {\n    // Generate 32 random bytes for AES-256 key\n    const keyBytes = new Uint8Array(32);\n    crypto.getRandomValues(keyBytes);\n\n    // Generate 12 random bytes for AES-GCM nonce/IV\n    const ivBytes = new Uint8Array(12);\n    crypto.getRandomValues(ivBytes);\n\n    // Convert to hex strings\n    const key = Array.from(keyBytes)\n        .map(byte => byte.toString(16).padStart(2, '0'))\n        .join('');\n\n    const iv = Array.from(ivBytes)\n        .map(byte => byte.toString(16).padStart(2, '0'))\n        .join('');\n\n    return { key, iv };\n}\n\nasync function AESDecryptString(val, key, iv) {\n    // Convert hex strings to ArrayBuffers\n    const encryptedData = new Uint8Array(val.length / 2);\n    for (let i = 0; i < val.length; i += 2) {\n        encryptedData[i / 2] = parseInt(val.substr(i, 2), 16);\n    }\n\n    const keyBytes = new Uint8Array(key.length / 2);\n    for (let i = 0; i < key.length; i += 2) {\n        keyBytes[i / 2] = parseInt(key.substr(i, 2), 16);\n    }\n\n    const ivBytes = new Uint8Array(iv.length / 2);\n    for (let i = 0; i < iv.length; i += 2) {\n        ivBytes[i / 2] = parseInt(iv.substr(i, 2), 16);\n    }\n\n    // Import the AES key\n    const cryptoKey = await crypto.subtle.importKey(\n        'raw',\n        keyBytes,\n        { name: 'AES-GCM' },\n        false,\n        ['decrypt']\n    );\n\n    // Decrypt the data\n    const decryptedBuffer = await crypto.subtle.decrypt(\n        {\n            name: 'AES-GCM',\n            iv: ivBytes\n        },\n        cryptoKey,\n        encryptedData\n    );\n\n    // Convert back to string\n    return new TextDecoder('utf-8').decode(decryptedBuffer);\n}\n\nconst TEMP_KV_TRUST_FOR_TESTSUITE = \"TEMP_KV_TRUST_FOR_TESTSUITE\";\nfunction _selectKeys() {\n    if (Phoenix.isTestWindow) {\n        // this could be an iframe in a spec runner window or the spec runner window itself.\n        const kvj = window.top.sessionStorage.getItem(TEMP_KV_TRUST_FOR_TESTSUITE);\n        if(!kvj) {\n            const kv = generateRandomKeyAndIV();\n            window.top.sessionStorage.setItem(TEMP_KV_TRUST_FOR_TESTSUITE, JSON.stringify(kv));\n            return kv;\n        }\n        try{\n            return JSON.parse(kvj);\n        } catch (e) {\n            console.error(\"Error parsing test suite trust keyring, defaulting to random which may not work!\", e);\n        }\n    }\n    return generateRandomKeyAndIV();\n}\n\nconst CRED_KEY_API = Phoenix.isTestWindow ? \"API_KEY_TEST\" : \"API_KEY\";\nconst CRED_KEY_PROMO = Phoenix.isTestWindow ? \"PROMO_GRANT_KEY_TEST\" : \"PROMO_GRANT_KEY\";\nconst SIGNATURE_SALT_KEY = Phoenix.isTestWindow ? \"SIGNATURE_SALT_KEY_TEST\" : \"SIGNATURE_SALT_KEY\";\nconst VERSION_PORTER_KEY = Phoenix.isTestWindow ? \"VERSION_PORTER_TEST\" : \"VERSION_PORTER\";\nconst { key, iv } = _selectKeys();\n\nasync function setCredential(credKey, secret) {\n    if(!window.__TAURI__){\n        throw new Error(\"Phoenix API key can only be set in tauri shell!\");\n    }\n    if(!credKey){\n        throw new Error(\"credKey is required to set credential!\");\n    }\n    return window.__TAURI__.tauri.invoke(\"store_credential\", {scopeName: credKey, secretVal: secret});\n}\n\nasync function getCredential(credKey) {\n    if(!window.__TAURI__){\n        throw new Error(\"Phoenix API key can only be get in tauri shell!\");\n    }\n    if(!credKey){\n        throw new Error(\"credKey is required to get credential!\");\n    }\n    const encryptedKey = await window.__TAURI__.tauri.invoke(\"get_credential\", {scopeName: credKey});\n    if(!encryptedKey){\n        return null;\n    }\n    return AESDecryptString(encryptedKey, key, iv);\n}\n\nasync function removeCredential(credKey) {\n    if(!window.__TAURI__){\n        throw new Error(\"Phoenix API key can only be set in tauri shell!\");\n    }\n    if(!credKey){\n        throw new Error(\"credKey is required to remove credential!\");\n    }\n    return window.__TAURI__.tauri.invoke(\"delete_credential\", {scopeName: credKey});\n}\n\nlet _dismatled = false;\nasync function dismantleKeyring() {\n    if(_dismatled){\n        throw new Error(\"Keyring can only be dismantled once!\");\n        // and once dismantled, the next line should be reload page. this is a strict security posture requirement to\n        // prevent extensions from stealing sensitive info from system key ring as once the trust in invalidated,\n        // the tauri get_system key ring cred apis will work for anyone who does the first call.\n    }\n    _dismatled = true;\n    if(!key || !iv){\n        console.error(\"Invalid kernal keys supplied to shutdown. Ignoring kernal trust reset at shutdown.\");\n        return;\n    }\n    if(!window.__TAURI__){\n        return;\n    }\n    return window.__TAURI__.tauri.invoke(\"remove_trust_window_aes_key\", {key, iv});\n}\n\nexport async function initTrustRing() {\n    if(!window.__TAURI__){\n        return;\n    }\n    // this will only work once in a window unless dismantleKeyring is called. So this is safe as\n    // a public export as essentially this is a fn that only works in the boot and shutdown phase.\n    await window.__TAURI__.tauri.invoke(\"trust_window_aes_key\", {key, iv});\n\n    _portCredentials();\n}\nasync function reinstallCreds() {\n    if(!window.__TAURI__){\n        throw new Error(\"reinstallCreds can only be called in tauri shell!\");\n    }\n    // Read current credential values\n    const apiKey = await getCredential(CRED_KEY_API);\n    const promoKey = await getCredential(CRED_KEY_PROMO);\n    const saltKey = await getCredential(SIGNATURE_SALT_KEY);\n\n    // Remove credentials from keychain\n    if(apiKey) {\n        await removeCredential(CRED_KEY_API);\n    }\n    if(promoKey) {\n        await removeCredential(CRED_KEY_PROMO);\n    }\n    if(saltKey) {\n        await removeCredential(SIGNATURE_SALT_KEY);\n    }\n\n    // Re-set credentials to refresh keychain access\n    if(apiKey) {\n        await setCredential(CRED_KEY_API, apiKey);\n    }\n    if(promoKey) {\n        await setCredential(CRED_KEY_PROMO, promoKey);\n    }\n    if(saltKey) {\n        await setCredential(SIGNATURE_SALT_KEY, saltKey);\n    }\n\n    const currentVersion = Phoenix.metadata.version;\n    await setCredential(VERSION_PORTER_KEY, currentVersion);\n}\n\n/**\n * Handles keychain credential portability across app versions on macOS.\n * not a problem in windows/linux.\n *\n * On macOS, the system keychain ties stored credentials to the app’s code signature.\n * If the signature changes (for example: running a debug build, unsigned dev build,\n * or re-signed binary), macOS will repeatedly prompt the user for their password\n * every time credentials are accessed. This does not usually happen in official\n * signed release builds, but it can be disruptive during development.\n *\n * To reduce this annoyance, we track the app version in the keychain. If the\n * stored version and the current version don’t match, we reinstall credentials\n * under the new signature so that future keychain access works without constant\n * prompts.\n */\nasync function _portCredentials() {\n    if(!Phoenix.isNativeApp || Phoenix.platform === \"win\" || Phoenix.platform === \"linux\") {\n        return;\n    }\n    try {\n        const storedVersion = await getCredential(VERSION_PORTER_KEY);\n        const currentVersion = Phoenix.metadata.version;\n\n        if (!storedVersion && currentVersion) {\n            // First boot or version key doesn't exist, set it\n            await setCredential(VERSION_PORTER_KEY, currentVersion);\n        } else if (storedVersion && currentVersion && storedVersion !== currentVersion) {\n            // Version changed, reinstall credentials\n            console.log(`Version changed from ${storedVersion} to ${currentVersion}, reinstalling credentials`);\n            // Update stored version first to prevent races with multi phoenix windows\n            await setCredential(VERSION_PORTER_KEY, currentVersion);\n            await reinstallCreds();\n        }\n    } catch (error) {\n        console.error(\"Error during version-based credential check:\", error);\n    }\n}\n\n/**\n * Generates an SHA-256 hash signature of the provided data string combined with a salt.\n *\n * @param {string} dataString - The input data string that needs to be signed.\n * @param {string} [salt] - A Optional salt value to combine with the data string for additional uniqueness.\n * @return {Promise<string>} A promise that resolves to the generated SHA-256 hash signature as a hexadecimal string.\n */\nasync function generateDataSignature(dataString, salt) {\n    const signatureData = salt ? dataString + \"|\" + salt : dataString;\n    const encoder = new TextEncoder();\n    const dataBuffer = encoder.encode(signatureData);\n    const hashBuffer = await crypto.subtle.digest('SHA-256', dataBuffer);\n    const hashArray = Array.from(new Uint8Array(hashBuffer));\n    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\n}\n\n/**\n * Validates the provided data signature by comparing it to an expected signature.\n *\n * @param {string} data - The data to validate the signature against.\n * @param {string} signature - The actual signature to be validated.\n * @param {string} salt - The salt used in generating the expected signature.\n * @return {Promise<boolean>} A promise resolving to true if the signature is valid, otherwise false.\n */\nasync function validateDataSignature(data, signature, salt) {\n    if (!signature) {\n        return false;\n    }\n    const expectedSignature = await generateDataSignature(data, salt);\n    return signature === expectedSignature;\n}\n\n// this key is set at boot time as a trust base for all the core components before any extensions are loaded.\n// just before extensions are loaded, this key is blanked. This can be used by core modules to talk with other\n// core modules securely without worrying about interception by extensions.\n// KernalModeTrust should only be available within all code that loads before the first default/any extension.\nwindow.KernalModeTrust = {\n    CRED_KEY_API,\n    CRED_KEY_PROMO,\n    SIGNATURE_SALT_KEY,\n    aesKeys: { key, iv },\n    setCredential,\n    getCredential,\n    removeCredential,\n    AESDecryptString,\n    generateRandomKeyAndIV,\n    dismantleKeyring,\n    generateDataSignature,\n    validateDataSignature,\n    reinstallCreds\n};\nif(Phoenix.isSpecRunnerWindow){\n    window.specRunnerTestKernalModeTrust = window.KernalModeTrust;\n}\n// key is 64 hex characters, iv is 24 hex characters\n"],"file":"trust_ring.js"}