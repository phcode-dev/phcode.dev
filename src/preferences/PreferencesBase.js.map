{"version":3,"sources":["preferences/PreferencesBase.js"],"names":["define","require","exports","module","FileUtils","FileSystem","FileSystemError","EventDispatcher","_","Async","globmatch","PREFERENCE_CHANGE","SCOPEORDER_CHANGE","MemoryStorage","data","this","ParsingError","message","name","FileStorage","path","createIfMissing","recreateIfInvalid","_lineEndings","getPlatformLineEndings","Scope","storage","on","load","bind","_dirty","_layers","_layerMap","_exclusions","_findMatchingGlob","pathData","filename","globs","Object","keys","globCounter","length","glob","ProjectLayer","projectPath","LanguageLayer","PathLayer","prefFilePath","setPrefFilePath","Preference","properties","extend","_addEventDispatcherImpl","proto","temp","makeEventDispatcher","_on_internal","_off_internal","off","trigger","PrefixedPreferencesSystem","base","prefix","_listenerInstalled","PreferencesSystem","contextBuilder","_knownPrefs","_scopes","default","_defaults","scopeOrder","_shadowScopeOrder","id","scope","promise","$","Deferred","resolve","_pendingScopes","_saveInProgress","_nextSaveDeferred","_pathScopeDefinitions","_pathScopeFilenames","_pathScopes","_changeEventQueue","notifyPrefChange","pref","e","ids","forEach","prototype","result","save","newData","fileChanged","filePath","Error","self","prefFile","getFileForPath","read","err","text","NOT_READABLE","UNSUPPORTED_ENCODING","appshell","fs","unlink","console","log","reject","sniffLineEndings","test","JSON","parse","toString","stringify","translateLineEndings","write","setPath","newPath","then","oldKeys","getKeys","union","fail","error","set","value","context","location","getPreferenceLocation","layer","undefined","key","wasSet","layerID","_performSet","isEqual","cloneDeep","get","layerCounter","layers","indexOf","keySets","difference","push","apply","addLayer","contextChanged","oldContext","newContext","changes","each","changesInLayer","section","map","values","setProjectPath","language","isEmpty","relativeFilename","getRelativeFilename","getDirectoryPath","newGlob","oldGlob","definePreference","type","initial","options","getPreference","_getContext","doNotSave","_installListener","onlyWithPrefix","startsWith","withoutPrefix","substr","prefixedIds","filter","event","preferenceID","handler","hasOwnProperty","description","validator","excludeFromHints","valueType","getAllPreferences","_pushToScopeOrder","before","defaultScopeOrder","index","findIndex","splice","_tryAddToScopeOrder","shadowEntry","shadowScopeOrder","i","entry","state","always","action","_triggerChange","_addToScopeOrder","addBefore","isPending","queue","unshift","pull","pending","addToScopeOrder","removeFromScopeOrder","addScope","removeScope","shadowIndex","_getScopeOrder","scopeCounter","scopeName","forceDefault","valid","stored","that","deferred","doInParallel","signalContextChanged","changedInScope","pauseChangeEvents","resumeChangeEvents","getPrefixedSystem"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*global appshell */\n/*unittests: Preferences Base */\n\n/**\n * Infrastructure for the preferences system.\n *\n * At the top, the level at which most people will interact, is the `PreferencesSystem` object.\n * The most common operation is `get(id)`, which simply retrieves the value of a given preference.\n *\n * The PreferencesSystem has a collection of Scopes, which it traverses in a specified order.\n * Each Scope holds one level of settings.\n *\n * PreferencesManager.js sets up a singleton PreferencesSystem that has the following Scopes:\n *\n * * default (the default values for any settings that are explicitly registered)\n * * user (the user's customized settings â€“ the equivalent of Brackets' old\n *   localStorage-based system. This is the settings file that lives in AppData)\n * * Additional scopes for each .brackets.json file going upward in the file tree from the\n *   current file\n *\n * For example, if spaceUnits has a value set in a .brackets.json file near the open file,\n * then a call to get(\"spaceUnits\") would return the value from that file. File values come\n * first, user values next, default values last. If the setting is not known\n * at all, undefined is returned.\n *\n * Each Scope has an associated Storage object that knows how to load and\n * save the preferences value for that Scope. There are two implementations:\n * MemoryStorage and FileStorage.\n *\n * The final concept used is that of Layers, which can be added to Scopes. Generally, a Layer looks\n * for a collection of preferences that are nested in some fashion in the Scope's\n * data. Under certain circumstances (decided upon by the Layer object),\n * those nested preferences will take precedence over the main preferences in the Scope.\n */\ndefine(function (require, exports, module) {\n\n\n    var FileUtils       = require(\"file/FileUtils\"),\n        FileSystem      = require(\"filesystem/FileSystem\"),\n        FileSystemError = require(\"filesystem/FileSystemError\"),\n        EventDispatcher = require(\"utils/EventDispatcher\"),\n        _               = require(\"thirdparty/lodash\"),\n        Async           = require(\"utils/Async\"),\n        globmatch       = require(\"thirdparty/globmatch\");\n\n    // CONSTANTS\n    var PREFERENCE_CHANGE = \"change\",\n        SCOPEORDER_CHANGE = \"scopeOrderChange\";\n\n    /*\n     * Storages manage the loading and saving of preference data.\n     */\n\n    /**\n     * MemoryStorage, as the name implies, stores the preferences in memory.\n     * This is suitable for single session data or testing.\n     *\n     * @constructor\n     * @param {?Object} data Initial data for the storage.\n     */\n    function MemoryStorage(data) {\n        this.data = data || {};\n    }\n\n    MemoryStorage.prototype = {\n\n        /**\n         * *Synchronously* returns the data stored in this storage.\n         * The original object (not a clone) is returned.\n         *\n         * @return {Promise} promise that is already resolved\n         */\n        load: function () {\n            var result = new $.Deferred();\n            result.resolve(this.data);\n            return result.promise();\n        },\n\n        /**\n         * *Synchronously* saves the data to this storage. This saves\n         * the `newData` object reference without cloning it.\n         *\n         * @param {Object} newData The data to store.\n         * @return {Promise} promise that is already resolved\n         */\n        save: function (newData) {\n            var result = new $.Deferred();\n            this.data = newData;\n            result.resolve();\n            return result.promise();\n        },\n\n        /**\n         * MemoryStorage is not stored in a file, so fileChanged is ignored.\n         *\n         * @param {string} filePath File that has changed\n         */\n        fileChanged: function (filePath) {\n        }\n    };\n\n    // MemoryStorage never actually dispatches change events, but Storage interface requires implementing on()/off()\n    EventDispatcher.makeEventDispatcher(MemoryStorage.prototype);\n\n\n    /**\n     * Error type for problems parsing preference files.\n     *\n     * @constructor\n     * @param {string} message Error message\n     */\n    function ParsingError(message) {\n        this.name = \"ParsingError\";\n        this.message = message || \"\";\n    }\n\n    ParsingError.prototype = new Error();\n\n\n    /**\n     * Loads/saves preferences from a JSON file on disk.\n     *\n     * @constructor\n     * @param {string}  path        Path to the preferences file\n     * @param {boolean} createIfMissing True if the file should be created if it doesn't exist.\n     *                              If this is not true, an exception will be thrown if the\n     *                              file does not exist.\n     * @param {boolean} recreateIfInvalid True if the file needs to be recreated if it is invalid.\n     *                              Invalid- Either unreadable or unparseable.\n     *                              The invalid copy will be sent to trash in case the user wants to refer to it.\n     */\n    function FileStorage(path, createIfMissing, recreateIfInvalid) {\n        this.path = path;\n        this.createIfMissing = createIfMissing;\n        this.recreateIfInvalid = recreateIfInvalid;\n        this._lineEndings = FileUtils.getPlatformLineEndings();\n    }\n\n    FileStorage.prototype = {\n\n        /**\n         * Loads the preferences from disk. Can throw an exception if the file is not\n         * readable or parseable.\n         *\n         * @return {Promise} Resolved with the data once it has been parsed.\n         */\n        load: function () {\n            var result = new $.Deferred();\n            var path = this.path;\n            var createIfMissing = this.createIfMissing;\n            var recreateIfInvalid = this.recreateIfInvalid;\n            var self = this;\n\n            if (path) {\n                var prefFile = FileSystem.getFileForPath(path);\n                prefFile.read({}, function (err, text) {\n                    if (err) {\n                        if (createIfMissing) {\n                            // Unreadable file is also unwritable -- delete so get recreated\n                            if (recreateIfInvalid && (err === FileSystemError.NOT_READABLE || err === FileSystemError.UNSUPPORTED_ENCODING)) {\n                                appshell.fs.unlink(path, function (err) {\n                                    if (err) {\n                                        console.log(\"Cannot move unreadable preferences file \" + path + \" to trash!!\");\n                                    } else {\n                                        console.log(\"Brackets has recreated the unreadable preferences file \" + path + \". You may refer to the deleted file in trash in case you need it!!\");\n                                    }\n                                }.bind(this));\n                            }\n                            result.resolve({});\n                        } else {\n                            result.reject(new Error(\"Unable to load preferences at \" + path + \" \" + err));\n                        }\n                        return;\n                    }\n\n                    self._lineEndings = FileUtils.sniffLineEndings(text);\n\n                    // If the file is empty, turn it into an empty object\n                    if (/^\\s*$/.test(text)) {\n                        result.resolve({});\n                    } else {\n                        try {\n                            result.resolve(JSON.parse(text));\n                        } catch (e) {\n                            if (recreateIfInvalid) {\n                                // JSON parsing error -- recreate the preferences file\n                                appshell.fs.unlink(path, function (err) {\n                                    if (err) {\n                                        console.log(\"Cannot move unparseable preferences file \" + path + \" to trash!!\");\n                                    } else {\n                                        console.log(\"Brackets has recreated the Invalid JSON preferences file \" + path + \". You may refer to the deleted file in trash in case you need it!!\");\n                                    }\n                                }.bind(this));\n                                result.resolve({});\n                            } else {\n                                result.reject(new ParsingError(\"Invalid JSON settings at \" + path + \"(\" + e.toString() + \")\"));\n                            }\n                        }\n                    }\n                });\n            } else {\n                result.resolve({});\n            }\n\n            return result.promise();\n        },\n\n        /**\n         * Saves the new data to disk.\n         *\n         * @param {Object} newData data to save\n         * @return {Promise} Promise resolved (with no arguments) once the data has been saved\n         */\n        save: function (newData) {\n            var result = new $.Deferred();\n            var path = this.path;\n            var prefFile = FileSystem.getFileForPath(path);\n\n            if (path) {\n                try {\n                    var text = JSON.stringify(newData, null, 4);\n\n                    // maintain the original line endings\n                    text = FileUtils.translateLineEndings(text, this._lineEndings);\n                    prefFile.write(text, {}, function (err) {\n                        if (err) {\n                            result.reject(\"Unable to save prefs at \" + path + \" \" + err);\n                        } else {\n                            result.resolve();\n                        }\n                    });\n                } catch (e) {\n                    result.reject(\"Unable to convert prefs to JSON\" + e.toString());\n                }\n            } else {\n                result.resolve();\n            }\n            return result.promise();\n        },\n\n        /**\n         * Changes the path to the preferences file.\n         * This sends a \"changed\" event to listeners, regardless of whether\n         * the path has changed.\n         *\n         * @param {string} newPath location of this settings file\n         */\n        setPath: function (newPath) {\n            this.path = newPath;\n            this.trigger(\"changed\");\n        },\n\n        /**\n         * If the filename matches this Storage's path, a changed message is triggered.\n         *\n         * @param {string} filePath File that has changed\n         */\n        fileChanged: function (filePath) {\n            if (filePath === this.path) {\n                this.trigger(\"changed\");\n            }\n        }\n    };\n\n    EventDispatcher.makeEventDispatcher(FileStorage.prototype);\n\n\n    /**\n     * A `Scope` is a data container that is tied to a `Storage`.\n     *\n     * Additionally, `Scope`s support \"layers\" which are additional levels of preferences\n     * that are stored within a single preferences file.\n     *\n     * @constructor\n     * @param {Storage} storage Storage object from which prefs are loaded/saved\n     */\n    function Scope(storage) {\n        this.storage = storage;\n        storage.on(\"changed\", this.load.bind(this));\n        this.data = {};\n        this._dirty = false;\n        this._layers = [];\n        this._layerMap = {};\n        this._exclusions = [];\n    }\n\n    _.extend(Scope.prototype, {\n        /**\n         * Loads the prefs for this `Scope` from the `Storage`.\n         *\n         * @return {Promise} Promise that is resolved once loading is complete\n         */\n        load: function () {\n            var result = new $.Deferred();\n            this.storage.load()\n                .then(function (data) {\n                    var oldKeys = this.getKeys();\n                    this.data = data;\n                    result.resolve();\n                    this.trigger(PREFERENCE_CHANGE, {\n                        ids: _.union(this.getKeys(), oldKeys)\n                    });\n                }.bind(this))\n                .fail(function (error) {\n                    result.reject(error);\n                });\n            return result.promise();\n        },\n\n        /**\n         * Saves the prefs for this `Scope`.\n         *\n         * @return {Promise} promise resolved once the data is saved.\n         */\n        save: function () {\n            var self = this;\n            if (this._dirty) {\n                self._dirty = false;\n                return this.storage.save(this.data);\n            }\n            return (new $.Deferred()).resolve().promise();\n\n        },\n\n        /**\n         * Sets the value for `id`. The value is set at the location given, or at the current\n         * location for the preference if no location is specified. If an invalid location is\n         * given, nothing will be set and no exception is thrown.\n         *\n         * @param {string} id Key to set\n         * @param {*} value Value for this key\n         * @param {Object=} context Optional additional information about the request (typically used for layers)\n         * @param {{layer: ?string, layerID: ?Object}=} location Optional location in which to set the value.\n         *                                                      If the object is empty, the value will be\n         *                                                      set at the Scope's base level.\n         * @return {boolean} true if the value was set\n         */\n        set: function (id, value, context, location) {\n            if (!location) {\n                location = this.getPreferenceLocation(id, context);\n            }\n            if (location && location.layer) {\n                var layer = this._layerMap[location.layer];\n                if (layer) {\n                    if (this.data[layer.key] === undefined) {\n                        this.data[layer.key] = {};\n                    }\n\n                    var wasSet = layer.set(this.data[layer.key], id, value, context, location.layerID);\n                    this._dirty = this._dirty || wasSet;\n                    return wasSet;\n                }\n                return false;\n\n            }\n            return this._performSet(id, value);\n\n        },\n\n        /**\n         * @private\n         *\n         * Performs the set operation on this Scope's data, deleting the given ID if\n         * the new value is undefined. The dirty flag will be set as well.\n         *\n         * @param {string} id key to set or delete\n         * @param {*} value value for this key (undefined to delete)\n         * @return {boolean} true if the value was set.\n         */\n        _performSet: function (id, value) {\n            if (!_.isEqual(this.data[id], value)) {\n                this._dirty = true;\n                if (value === undefined) {\n                    delete this.data[id];\n                } else {\n                    this.data[id] = _.cloneDeep(value);\n                }\n                return true;\n            }\n            return false;\n        },\n\n        /**\n         * Get the value for id, given the context. The context is provided to layers\n         * which may override the value from the main data of the Scope. Note that\n         * layers will often exclude values from consideration.\n         *\n         * @param {string} id Preference to retrieve\n         * @param {?Object} context Optional additional information about the request\n         * @return {*} Current value of the Preference\n         */\n        get: function (id, context) {\n            var layerCounter,\n                layers = this._layers,\n                layer,\n                data = this.data,\n                result;\n\n            context = context || {};\n\n            for (layerCounter = 0; layerCounter < layers.length; layerCounter++) {\n                layer = layers[layerCounter];\n                result = layer.get(data[layer.key], id, context);\n                if (result !== undefined) {\n                    return result;\n                }\n            }\n\n            if (this._exclusions.indexOf(id) === -1) {\n                return data[id];\n            }\n        },\n\n        /**\n         * Get the location in this Scope (if any) where the given preference is set.\n         *\n         * @param {string} id Name of the preference for which the value should be retrieved\n         * @param {Object=} context Optional context object to change the preference lookup\n         * @return {{layer: ?string, layerID: ?object}|undefined} Object describing where the preferences came from.\n         *                                              An empty object means that it was defined in the Scope's\n         *                                              base data. Undefined means the pref is not\n         *                                              defined in this Scope.\n         */\n        getPreferenceLocation: function (id, context) {\n            var layerCounter,\n                layers = this._layers,\n                layer,\n                data = this.data,\n                result;\n\n            context = context || {};\n\n            for (layerCounter = 0; layerCounter < layers.length; layerCounter++) {\n                layer = layers[layerCounter];\n                result = layer.getPreferenceLocation(data[layer.key], id, context);\n                if (result !== undefined) {\n                    return {\n                        layer: layer.key,\n                        layerID: result\n                    };\n                }\n            }\n\n            if (this._exclusions.indexOf(id) === -1 && data[id] !== undefined) {\n                // The value is defined in this Scope, which means we need to return an\n                // empty object as a signal to the PreferencesSystem that this pref\n                // is defined in this Scope (in the base data)\n                return {};\n            }\n\n            // return undefined when this Scope does not have the requested pref\n            return undefined;\n        },\n\n        /**\n         * Get the preference IDs that are set in this Scope. All layers are added\n         * in. If context is not provided, the set of all keys in the Scope including\n         * all keys in each layer will be returned.\n         *\n         * @param {?Object} context Optional additional information for looking up the keys\n         * @return {Array.<string>} Set of preferences set by this Scope\n         */\n        getKeys: function (context) {\n            context = context || {};\n\n            var layerCounter,\n                layers = this._layers,\n                layer,\n                data = this.data;\n\n            var keySets = [_.difference(_.keys(data), this._exclusions)];\n            for (layerCounter = 0; layerCounter < layers.length; layerCounter++) {\n                layer = layers[layerCounter];\n                keySets.push(layer.getKeys(data[layer.key], context));\n            }\n\n            return _.union.apply(null, keySets);\n        },\n\n        /**\n         * Adds a Layer to this Scope. The Layer object should define a `key`, which\n         * represents the subset of the preference data that the Layer works with.\n         * Layers should also define `get` and `getKeys` operations that are like their\n         * counterparts in Scope but take \"data\" as the first argument.\n         *\n         * Listeners are notified of potential changes in preferences with the addition of\n         * this layer.\n         *\n         * @param {Layer} layer Layer object to add to this Scope\n         */\n        addLayer: function (layer) {\n            this._layers.push(layer);\n            this._layerMap[layer.key] = layer;\n            this._exclusions.push(layer.key);\n            this.trigger(PREFERENCE_CHANGE, {\n                ids: layer.getKeys(this.data[layer.key], {})\n            });\n        },\n\n        /**\n         * Tells the Scope that the given file has been changed so that the\n         * Storage can be reloaded if needed.\n         *\n         * @param {string} filePath File that has changed\n         */\n        fileChanged: function (filePath) {\n            this.storage.fileChanged(filePath);\n        },\n\n        /**\n         * Determines if there are likely to be any changes based on the change\n         * of context.\n         *\n         * @param {{path: string, language: string}} oldContext Old context\n         * @param {{path: string, language: string}} newContext New context\n         * @return {Array.<string>} List of changed IDs\n         */\n        contextChanged: function (oldContext, newContext) {\n            var changes = [],\n                data    = this.data;\n\n            _.each(this._layers, function (layer) {\n                if (data[layer.key] && oldContext[layer.key] !== newContext[layer.key]) {\n                    var changesInLayer = layer.contextChanged(data[layer.key],\n                                                              oldContext,\n                                                              newContext);\n                    if (changesInLayer) {\n                        changes.push(changesInLayer);\n                    }\n                }\n            });\n            return _.union.apply(null, changes);\n        }\n    });\n\n    EventDispatcher.makeEventDispatcher(Scope.prototype);\n\n\n    // Utility functions for the PathLayer\n\n    /**\n     * @private\n     *\n     * Look for a matching file glob among the collection of paths.\n     *\n     * @param {Object} pathData The keys are globs and the values are the preferences for that glob\n     * @param {string} filename relative filename to match against the globs\n     * @return {?string} glob pattern that matched, if any\n     */\n    function _findMatchingGlob(pathData, filename) {\n        var globs = Object.keys(pathData),\n            globCounter;\n\n        if (!filename) {\n            return;\n        }\n\n        for (globCounter = 0; globCounter < globs.length; globCounter++) {\n            var glob = globs[globCounter];\n\n            if (globmatch(filename, glob)) {\n                return glob;\n            }\n        }\n    }\n\n    /**\n     * Create a default project layer object that has a single property \"key\"\n     * with \"project\" as its value.\n     *\n     * @constructor\n     */\n    function ProjectLayer() {\n        this.projectPath = null;\n    }\n\n    ProjectLayer.prototype = {\n        key: \"project\",\n\n        /**\n         * Retrieve the current value based on the current project path\n         * in the layer.\n         *\n         * @param {Object} data the preference data from the Scope\n         * @param {string} id preference ID to look up\n         */\n        get: function (data, id) {\n            if (!data || !this.projectPath) {\n                return;\n            }\n\n            if (data[this.projectPath] && (data[this.projectPath][id] !== undefined)) {\n                return data[this.projectPath][id];\n            }\n            return;\n        },\n\n        /**\n         * Gets the location in which the given pref was set, if it was set within\n         * this project layer for the current project path.\n         *\n         * @param {Object} data the preference data from the Scope\n         * @param {string} id preference ID to look up\n         * @return {string} the Layer ID, in this case the current project path.\n         */\n        getPreferenceLocation: function (data, id) {\n            if (!data || !this.projectPath) {\n                return;\n            }\n\n            if (data[this.projectPath] && (data[this.projectPath][id] !== undefined)) {\n                return this.projectPath;\n            }\n\n            return;\n        },\n\n        /**\n         * Sets the preference value in the given data structure for the layerID provided. If no\n         * layerID is provided, then the current project path is used. If a layerID is provided\n         * and it does not exist, it will be created.\n         *\n         * This function returns whether or not a value was set.\n         *\n         * @param {Object} data the preference data from the Scope\n         * @param {string} id preference ID to look up\n         * @param {Object} value new value to assign to the preference\n         * @param {Object} context Object with scope and layer key-value pairs (not yet used in project layer)\n         * @param {string=} layerID Optional: project path to be used for setting value\n         * @return {boolean} true if the value was set\n         */\n        set: function (data, id, value, context, layerID) {\n            if (!layerID) {\n                layerID = this.getPreferenceLocation(data, id);\n            }\n\n            if (!layerID) {\n                return false;\n            }\n\n            var section = data[layerID];\n            if (!section) {\n                data[layerID] = section = {};\n            }\n            if (!_.isEqual(section[id], value)) {\n                if (value === undefined) {\n                    delete section[id];\n                } else {\n                    section[id] = _.cloneDeep(value);\n                }\n                return true;\n            }\n            return false;\n        },\n\n        /**\n         * Retrieves the keys provided by this layer object.\n         *\n         * @param {Object} data the preference data from the Scope\n         */\n        getKeys: function (data) {\n            if (!data) {\n                return;\n            }\n\n            return _.union.apply(null, _.map(_.values(data), _.keys));\n        },\n\n        /**\n         * Set the project path to be used as the layer ID of this layer object.\n         *\n         * @param {string} projectPath Path of the project root\n         */\n        setProjectPath: function (projectPath) {\n            this.projectPath = projectPath;\n        }\n    };\n\n\n    /**\n     * @constructor\n     *\n     * Create a language layer object. Language Layer is completely stateless, it\n     * only knows how look up and process prefs set in the language layer. Desired\n     * language id should be specified in the \"language\" field of the context.\n     */\n    function LanguageLayer() {\n    }\n\n    LanguageLayer.prototype = {\n        key: \"language\",\n\n        /**\n         * Retrieve the current value based on the specified context. If the context\n         * does contain language field, undefined is returned.\n         *\n         * @param {Object} data the preference data from the Scope\n         * @param {string} id preference ID to look up\n         * @param {{language: string}} context Context to operate with\n         * @return {*|undefined} property value\n         */\n        get: function (data, id, context) {\n            if (!data || !context.language) {\n                return;\n            }\n\n            if (data[context.language] && (data[context.language][id] !== undefined)) {\n                return data[context.language][id];\n            }\n            return;\n        },\n\n        /**\n         * Gets the location in which the given pref was set, if it was set within\n         * this language layer for the current language.\n         *\n         * @param {Object} data the preference data from the Scope\n         * @param {string} id preference ID to look up\n         * @param {{language: string}} context Context to operate with\n         * @return {string|undefined} the Layer ID, in this case the current language\n         */\n        getPreferenceLocation: function (data, id, context) {\n            if (!data || !context.language) {\n                return;\n            }\n\n            if (data[context.language] && (data[context.language][id] !== undefined)) {\n                return context.language;\n            }\n\n            return;\n        },\n        /**\n         * Retrieves the keys provided by this layer object. If the context is\n         * empty, it will return all the keys provided in all the layerIDs\n         * (languages).\n         *\n         * @param {Object} data the preference data from the Scope\n         * @param {{language: string}} context Context to operate with\n         * @return {Array<{string}>|undefined} An array of pref ids\n         */\n        getKeys: function (data, context) {\n            if (!data) {\n                return;\n            }\n\n            // do not upset other layers if context for the this one is not specified\n            if (!_.isEmpty(context)) {\n                if (data[context.language]) {\n                    return _.keys(data[context.language]);\n                }\n                return [];\n\n            }\n            return _.union.apply(null, _.map(_.values(data), _.keys));\n\n        },\n\n        /**\n         * Sets the preference value in the given data structure for the layerID\n         * provided. If no layerID is provided, then it will be determined using\n         * getPreferenceLocation. If a layerID is located, but it does not\n         * exist, it will be created.\n         *\n         * This function returns whether or not a value was set.\n         *\n         * @param {Object} data The preference data from the Scope\n         * @param {string} id Preference ID to look up\n         * @param {Object} value New value to assign to the preference\n         * @param {{language: string}} context Context to operate with\n         * @param {string=} layerID Language to be used for setting value\n         * @return {boolean} True if the value was set\n         */\n        set: function (data, id, value, context, layerID) {\n            if (!layerID) {\n                layerID = this.getPreferenceLocation(data, id, context);\n            }\n\n            if (!layerID) {\n                return false;\n            }\n\n            var section = data[layerID];\n            if (!section) {\n                data[layerID] = section = {};\n            }\n            if (!_.isEqual(section[id], value)) {\n                if (value === undefined) {\n                    delete section[id];\n                    if (_.isEmpty(section)) {\n                        delete data[layerID];\n                    }\n                } else {\n                    section[id] = _.cloneDeep(value);\n                }\n                return true;\n            }\n            return false;\n        },\n\n        /**\n         * Determines if there are preference IDs that could change as a result\n         * of the context change. This implementation considers only changes in\n         * language.\n         *\n         * @param {Object} data Data in the Scope\n         * @param {{language: string}} oldContext Old context\n         * @param {{language: string}} newContext New context\n         * @return {Array.<string>|undefined} list of preference IDs that could have changed\n         */\n        contextChanged: function (data, oldContext, newContext) {\n            // this function is called only if the language has changed\n            if (newContext.language === undefined) {\n                return _.keys(data[oldContext.language]);\n            }\n            if (oldContext.language === undefined) {\n                return _.keys(data[newContext.language]);\n            }\n\n            return _.union(_.keys(data[newContext.language]), _.keys(data[oldContext.language]));\n        }\n    };\n\n    /**\n     * Provides layered preferences based on file globs, generally following the model provided\n     * by [EditorConfig](http://editorconfig.org/). In usage, it looks something like this\n     * (switching to single line comments because the glob interferes with the multiline comment):\n     */\n//    \"path\": {\n//        \"src/thirdparty/CodeMirror/**/*.js\": {\n//            \"spaceUnits\": 2,\n//            \"linting.enabled\": false\n//        }\n//    }\n\n    /**\n     * There can be multiple paths and they are each checked in turn. The first that matches the\n     * currently edited file wins.\n     *\n     * @constructor\n     * @param {string} prefFilePath path to the preference file\n     */\n    function PathLayer(prefFilePath) {\n        this.setPrefFilePath(prefFilePath);\n    }\n\n    PathLayer.prototype = {\n        key: \"path\",\n\n        /**\n         * Retrieve the current value based on the filename in the context\n         * object, comparing globs relative to the prefFilePath that this\n         * PathLayer was set up with.\n         *\n         * @param {Object} data the preference data from the Scope\n         * @param {string} id preference ID to look up\n         * @param {Object} context Object with filename that will be compared to the globs\n         */\n        get: function (data, id, context) {\n            var glob = this.getPreferenceLocation(data, id, context);\n\n            if (!glob) {\n                return;\n            }\n\n            return data[glob][id];\n        },\n\n        /**\n         * Gets the location in which the given pref was set, if it was set within\n         * this path layer for the current path.\n         *\n         * @param {Object} data the preference data from the Scope\n         * @param {string} id preference ID to look up\n         * @param {Object} context Object with filename that will be compared to the globs\n         * @return {string} the Layer ID, in this case the glob that matched\n         */\n        getPreferenceLocation: function (data, id, context) {\n            if (!data) {\n                return;\n            }\n\n            var relativeFilename = FileUtils.getRelativeFilename(this.prefFilePath, context[this.key]);\n            if (!relativeFilename) {\n                return;\n            }\n\n            return _findMatchingGlob(data, relativeFilename);\n        },\n\n        /**\n         * Sets the preference value in the given data structure for the layerID provided. If no\n         * layerID is provided, then the current layer is used. If a layerID is provided and it\n         * does not exist, it will be created.\n         *\n         * This function returns whether or not a value was set.\n         *\n         * @param {Object} data the preference data from the Scope\n         * @param {string} id preference ID to look up\n         * @param {Object} value new value to assign to the preference\n         * @param {Object} context Object with filename that will be compared to the globs\n         * @param {string=} layerID Optional: glob pattern for a specific section to set the value in\n         * @return {boolean} true if the value was set\n         */\n        set: function (data, id, value, context, layerID) {\n            if (!layerID) {\n                layerID = this.getPreferenceLocation(data, id, context);\n            }\n\n            if (!layerID) {\n                return false;\n            }\n\n            var section = data[layerID];\n            if (!section) {\n                data[layerID] = section = {};\n            }\n            if (!_.isEqual(section[id], value)) {\n                if (value === undefined) {\n                    delete section[id];\n                } else {\n                    section[id] = _.cloneDeep(value);\n                }\n                return true;\n            }\n            return false;\n        },\n\n        /**\n         * Retrieves the keys provided by this layer object. If context with a filename is provided,\n         * only the keys for the matching file glob are given. Otherwise, all keys for all globs\n         * are provided.\n         *\n         * @param {Object} data the preference data from the Scope\n         * @param {?Object} context Additional context data (filename in particular is important)\n         */\n        getKeys: function (data, context) {\n            if (!data) {\n                return;\n            }\n\n            var relativeFilename = FileUtils.getRelativeFilename(this.prefFilePath, context[this.key]);\n\n            if (relativeFilename) {\n                var glob = _findMatchingGlob(data, relativeFilename);\n                if (glob) {\n                    return _.keys(data[glob]);\n                }\n                return [];\n\n            }\n            return _.union.apply(null, _.map(_.values(data), _.keys));\n        },\n\n        /**\n         * Changes the preference file path.\n         *\n         * @param {string} prefFilePath New path to the preferences file\n         */\n        setPrefFilePath: function (prefFilePath) {\n            if (!prefFilePath) {\n                this.prefFilePath = \"/\";\n            } else {\n                this.prefFilePath = FileUtils.getDirectoryPath(prefFilePath);\n            }\n        },\n\n        /**\n         * Determines if there are preference IDs that could change as a result of\n         * a change in the context. This implementation considers only the path portion\n         * of the context and looks up matching globes if any.\n         *\n         * @param {Object} data Data in the Scope\n         * @param {{path: string}} oldContext Old context\n         * @param {{path: string}} newContext New context\n         * @return {Array.<string>} list of preference IDs that could have changed\n         */\n        contextChanged: function (data, oldContext, newContext) {\n            var newGlob = _findMatchingGlob(data,\n                              FileUtils.getRelativeFilename(this.prefFilePath, newContext[this.key])),\n                oldGlob = _findMatchingGlob(data,\n                              FileUtils.getRelativeFilename(this.prefFilePath, oldContext[this.key]));\n\n            if (newGlob === oldGlob) {\n                return;\n            }\n            if (newGlob === undefined) {\n                return _.keys(data[oldGlob]);\n            }\n            if (oldGlob === undefined) {\n                return _.keys(data[newGlob]);\n            }\n\n            return _.union(_.keys(data[oldGlob]), _.keys(data[newGlob]));\n        }\n    };\n\n\n    /**\n     * Represents a single, known Preference.\n     *\n     * @constructor\n     * @param {Object} properties Information about the Preference that is stored on this object\n     */\n    function Preference(properties) {\n        _.extend(this, properties);\n    }\n\n    EventDispatcher.makeEventDispatcher(Preference.prototype);\n\n\n    /**\n     * Utility for PreferencesSystem & PrefixedPreferencesSystem -- attach EventDispatcher's on()/off()\n     * implementation as private _on_internal()/_off_internal() methods, so the custom on()/off() APIs\n     * these classes use can leverage EventDispatcher code internally. Also attach the regular public trigger().\n     */\n    function _addEventDispatcherImpl(proto) {\n        var temp = {};\n        EventDispatcher.makeEventDispatcher(temp);\n        proto._on_internal  = temp.on;\n        proto._off_internal = temp.off;\n        proto.trigger       = temp.trigger;\n    }\n\n    /**\n     * Provides a subset of the PreferencesSystem functionality with preference\n     * access always occurring with the given prefix.\n     *\n     * @constructor\n     * @param {PreferencesSystem} base The real PreferencesSystem that is backing this one\n     * @param {string} prefix Prefix that is used for preferences lookup. Any separator characters should already be added.\n     */\n    function PrefixedPreferencesSystem(base, prefix) {\n        this.base = base;\n        this.prefix = prefix;\n        this._listenerInstalled = false;\n    }\n\n    PrefixedPreferencesSystem.prototype = {\n        /**\n         * Defines a new (prefixed) preference.\n         *\n         * @param {string} id unprefixed identifier of the preference. Generally a dotted name.\n         * @param {string} type Data type for the preference (generally, string, boolean, number)\n         * @param {Object} initial Default value for the preference\n         * @param {?{name: string=, description: string=, validator: function=, excludeFromHints: boolean=, keys: object=, values: array=, valueType: string=}} options\n         *      Additional options for the pref.\n         *      - `options.name`               Name of the preference that can be used in the UI.\n         *      - `options.description`        A description of the preference.\n         *      - `options.validator`          A function to validate the value of a preference.\n         *      - `options.excludeFromHints`   True if you want to exclude a preference from code hints.\n         *      - `options.keys`               An object that will hold the child preferences in case the preference type is `object`\n         *      - `options.values`             An array of possible values of a preference. It will show up in code hints.\n         *      - `options.valueType`          In case the preference type is `array`, `valueType` should hold data type of its elements.\n         * @return {Object} The preference object.\n         */\n        definePreference: function (id, type, initial, options) {\n            return this.base.definePreference(this.prefix + id, type, initial, options);\n        },\n\n        /**\n         * Get the prefixed preference object\n         *\n         * @param {string} id ID of the pref to retrieve.\n         */\n        getPreference: function (id) {\n            return this.base.getPreference(this.prefix + id);\n        },\n\n        /**\n         * Gets the prefixed preference\n         *\n         * @param {string} id Name of the preference for which the value should be retrieved\n         * @param {Object=} context Optional context object to change the preference lookup\n         */\n        get: function (id, context) {\n            context = context || {};\n            return this.base.get(this.prefix + id, this.base._getContext(context));\n        },\n\n        /**\n         * Gets the location in which the value of a prefixed preference has been set.\n         *\n         * @param {string} id Name of the preference for which the value should be retrieved\n         * @param {Object=} context Optional context object to change the preference lookup\n         * @return {{scope: string, layer: ?string, layerID: ?object}} Object describing where the preferences came from\n         */\n        getPreferenceLocation: function (id, context) {\n            return this.base.getPreferenceLocation(this.prefix + id, context);\n        },\n\n        /**\n         * Sets the prefixed preference\n         *\n         * @param {string} id Identifier of the preference to set\n         * @param {Object} value New value for the preference\n         * @param {{location: ?Object, context: ?Object}=} options Specific location in which to set the value or the context to use when setting the value\n         * @param {boolean=} doNotSave True if the preference change should not be saved automatically.\n         * @return {valid:  {boolean}, true if no validator specified or if value is valid\n         *          stored: {boolean}} true if a value was stored\n         */\n        set: function (id, value, options, doNotSave) {\n            return this.base.set(this.prefix + id, value, options, doNotSave);\n        },\n\n        /**\n         * @private\n         *\n         * Listens for events on the base PreferencesSystem to filter down to the\n         * events that consumers of this PreferencesSystem would be interested in.\n         */\n        _installListener: function () {\n            if (this._listenerInstalled) {\n                return;\n            }\n            var self = this,\n                prefix = this.prefix;\n\n            var onlyWithPrefix = function (id) {\n                if (_.startsWith(id, prefix)) {\n                    return true;\n                }\n                return false;\n            };\n\n            var withoutPrefix = function (id) {\n                return id.substr(prefix.length);\n            };\n\n            this.base.on(PREFERENCE_CHANGE, function (e, data) {\n                var prefixedIds = data.ids.filter(onlyWithPrefix);\n\n                if (prefixedIds.length > 0) {\n                    self.trigger(PREFERENCE_CHANGE, {\n                        ids: prefixedIds.map(withoutPrefix)\n                    });\n                }\n            });\n\n            this._listenerInstalled = true;\n        },\n\n        /**\n         * Sets up a listener for events for this PrefixedPreferencesSystem. Only prefixed events\n         * will notify. Optionally, you can set up a listener for a specific preference.\n         *\n         * @param {string} event Name of the event to listen for\n         * @param {string|Function} preferenceID Name of a specific preference or the handler function\n         * @param {?Function} handler Handler for the event\n         */\n        on: function (event, preferenceID, handler) {\n            if (typeof preferenceID === \"function\") {\n                handler = preferenceID;\n                preferenceID = null;\n            }\n\n            if (preferenceID) {\n                var pref = this.getPreference(preferenceID);\n                pref.on(event, handler);\n            } else {\n                this._installListener();\n                this._on_internal(event, handler);\n            }\n        },\n\n        /**\n         * Turns off the event handlers for a given event, optionally for a specific preference\n         * or a specific handler function.\n         *\n         * @param {string} event Name of the event for which to turn off listening\n         * @param {string|Function} preferenceID Name of a specific preference or the handler function\n         * @param {?Function} handler Specific handler which should stop being notified\n         */\n        off: function (event, preferenceID, handler) {\n            if (typeof preferenceID === \"function\") {\n                handler = preferenceID;\n                preferenceID = null;\n            }\n\n            if (preferenceID) {\n                var pref = this.getPreference(preferenceID);\n                pref.off(event, handler);\n            } else {\n                this._off_internal(event, handler);\n            }\n        },\n\n        /**\n         * Saves the preferences. If a save is already in progress, a Promise is returned for\n         * that save operation.\n         *\n         * @return {Promise} Resolved when the preferences are done saving.\n         */\n        save: function () {\n            return this.base.save();\n        }\n    };\n\n    _addEventDispatcherImpl(PrefixedPreferencesSystem.prototype);\n\n\n    /**\n     * PreferencesSystem ties everything together to provide a simple interface for\n     * managing the whole prefs system.\n     *\n     * It keeps track of multiple Scope levels and also manages path-based Scopes.\n     *\n     * It also provides the ability to register preferences, which gives a fine-grained\n     * means for listening for changes and will ultimately allow for automatic UI generation.\n     *\n     * The contextBuilder is used to construct get/set contexts based on the needs of individual\n     * context systems. It can be passed in at construction time or set later.\n     *\n     * @constructor\n     * @param {function=} contextNormalizer function that is passed the context used for get or set to adjust for specific PreferencesSystem behavior\n     */\n    function PreferencesSystem(contextBuilder) {\n        this.contextBuilder = contextBuilder;\n\n        this._knownPrefs = {};\n        this._scopes = {\n            \"default\": new Scope(new MemoryStorage())\n        };\n\n        this._scopes[\"default\"].load();\n\n        this._defaults = {\n            scopeOrder: [\"default\"],\n            _shadowScopeOrder: [{\n                id: \"default\",\n                scope: this._scopes[\"default\"],\n                promise: (new $.Deferred()).resolve().promise()\n            }]\n        };\n\n        this._pendingScopes = {};\n\n        this._saveInProgress = false;\n        this._nextSaveDeferred = null;\n\n        // The objects that define the different kinds of path-based Scope handlers.\n        // Examples could include the handler for .brackets.json files or an .editorconfig\n        // handler.\n        this._pathScopeDefinitions = {};\n\n        // Names of the files that contain path scopes\n        this._pathScopeFilenames = [];\n\n        // Keeps track of cached path scope objects.\n        this._pathScopes = {};\n\n        // Keeps track of change events that need to be sent when change events are resumed\n        this._changeEventQueue = null;\n\n        var notifyPrefChange = function (id) {\n            var pref = this._knownPrefs[id];\n            if (pref) {\n                pref.trigger(PREFERENCE_CHANGE);\n            }\n        }.bind(this);\n\n        // When we signal a general change message on this manager, we also signal a change\n        // on the individual preference object.\n        this.on(PREFERENCE_CHANGE, function (e, data) {\n            data.ids.forEach(notifyPrefChange);\n        }.bind(this));\n    }\n\n    _.extend(PreferencesSystem.prototype, {\n\n        /**\n         * Defines a new preference.\n         *\n         * @param {string} id identifier of the preference. Generally a dotted name.\n         * @param {string} type Data type for the preference (generally, string, boolean, number)\n         * @param {Object} initial Default value for the preference\n         * @param {?{name: string=, description: string=, validator: function=, excludeFromHints: boolean=, keys: object=, values: array=, valueType: string=}} options\n         *      Additional options for the pref.\n         *      - `options.name`               Name of the preference that can be used in the UI.\n         *      - `options.description`        A description of the preference.\n         *      - `options.validator`          A function to validate the value of a preference.\n         *      - `options.excludeFromHints`   True if you want to exclude a preference from code hints.\n         *      - `options.keys`               An object that will hold the child preferences in case the preference type is `object`\n         *      - `options.values`             An array of possible values of a preference. It will show up in code hints.\n         *      - `options.valueType`          In case the preference type is `array`, `valueType` should hold data type of its elements.\n         * @return {Object} The preference object.\n         */\n        definePreference: function (id, type, initial, options) {\n            options = options || {};\n            if (this._knownPrefs.hasOwnProperty(id)) {\n                throw new Error(\"Preference \" + id + \" was redefined\");\n            }\n            var pref = this._knownPrefs[id] = new Preference({\n                type: type,\n                initial: initial,\n                name: options.name,\n                description: options.description,\n                validator: options.validator,\n                excludeFromHints: options.excludeFromHints,\n                keys: options.keys,\n                values: options.values,\n                valueType: options.valueType\n            });\n            this.set(id, initial, {\n                location: {\n                    scope: \"default\"\n                }\n            });\n            return pref;\n        },\n\n        /**\n         * Get the preference object for the given ID.\n         *\n         * @param {string} id ID of the pref to retrieve.\n         */\n        getPreference: function (id) {\n            return this._knownPrefs[id];\n        },\n\n        /**\n         * Returns a clone of all preferences defined.\n         *\n         * @return {Object}\n         */\n        getAllPreferences: function () {\n            return _.cloneDeep(this._knownPrefs);\n        },\n\n        /**\n         * @private\n         *\n         * Adds the scope before the scope specified by before argument.  This\n         * function must never be called directly. Use addScope to add scopes to\n         * PreferencesSystem, including from within its implementation.\n         *\n         * @param {string} id Id of the scope to add\n         * @param {string} before Id of the scope to add it before\n         */\n        _pushToScopeOrder: function (id, before) {\n            var defaultScopeOrder = this._defaults.scopeOrder,\n                index = _.findIndex(defaultScopeOrder, function (id) {\n                    return id === before;\n                });\n            if (index > -1) {\n                defaultScopeOrder.splice(index, 0, id);\n            } else {\n                // error\n                throw new Error(\"Internal error: scope \" + before + \" should be in the scope order\");\n            }\n\n        },\n\n        /**\n         * @private\n         *\n         * Tries to add scope to the scopeOrder once it's resolved. It looks up\n         * context's _shadowScopeOrder to find an appropriate context to add it\n         * before.\n         *\n         * @param {Object} shadowEntry Shadow entry of the resolved scope\n         */\n        _tryAddToScopeOrder: function (shadowEntry) {\n            var shadowScopeOrder = this._defaults._shadowScopeOrder,\n                index = _.findIndex(shadowScopeOrder, function (entry) {\n                    return entry === shadowEntry;\n                }),\n                i = index + 1;\n\n            // Find an appropriate scope of lower priority to add it before\n            while (i < shadowScopeOrder.length) {\n                if (shadowScopeOrder[i].promise.state() === \"pending\" ||\n                        shadowScopeOrder[i].promise.state() === \"resolved\") {\n                    break;\n                }\n                i++;\n            }\n            switch (shadowScopeOrder[i].promise.state()) {\n            case \"pending\":\n                // cannot decide now, lookup once pending promise is settled\n                shadowScopeOrder[i].promise.always(function () {\n                    this._tryAddToScopeOrder(shadowEntry);\n                }.bind(this));\n                break;\n            case \"resolved\":\n                this._pushToScopeOrder(shadowEntry.id, shadowScopeOrder[i].id);\n                this.trigger(SCOPEORDER_CHANGE, {\n                    id: shadowEntry.id,\n                    action: \"added\"\n                });\n                this._triggerChange({\n                    ids: shadowEntry.scope.getKeys()\n                });\n                break;\n            default:\n                throw new Error(\"Internal error: no scope found to add before. \\\"default\\\" is missing?..\");\n            }\n\n        },\n\n        /**\n         * @private\n         *\n         * Schedules the new Scope to be added the scope order in the specified\n         * location once the promise is resolved. Context's _shadowScopeOrder is\n         * used to keep track of the order in which the scope should appear. If\n         * the scope which should precede this scope fails to load, then\n         * _shadowScopeOrder will be searched for the next appropriate context\n         * (the first one which is pending or loaded that is before the failed\n         * scope). There's always the lowest-priority \"default\" scope which is\n         * loaded and added, it guarantees that a successfully loaded scope will\n         * always be added.\n         *\n         * Adding a Scope \"before\" another Scope means that the new Scope's\n         * preferences will take priority over the \"before\" Scope's preferences.\n         *\n         * @param {string} id Name of the new Scope\n         * @param {Scope} scope The scope object to add\n         * @param {$.Promise} promise Scope's load promise\n         * @param {?string} addBefore Name of the Scope before which this new one is added\n         */\n        _addToScopeOrder: function (id, scope, promise, addBefore) {\n            var shadowScopeOrder = this._defaults._shadowScopeOrder,\n                shadowEntry,\n                index,\n                isPending = false,\n                self = this;\n\n            scope.on(PREFERENCE_CHANGE + \".prefsys\", function (e, data) {\n                self._triggerChange(data);\n            }.bind(this));\n\n            index = _.findIndex(shadowScopeOrder, function (entry) {\n                return entry.id === id;\n            });\n\n            if (index > -1) {\n                shadowEntry = shadowScopeOrder[index];\n            } else {\n                /* new scope is being added. */\n                shadowEntry = {\n                    id: id,\n                    promise: promise,\n                    scope: scope\n                };\n                if (!addBefore) {\n                    shadowScopeOrder.unshift(shadowEntry);\n                } else {\n                    index = _.findIndex(shadowScopeOrder, function (entry) {\n                        return entry.id === addBefore;\n                    });\n                    if (index > -1) {\n                        shadowScopeOrder.splice(index, 0, shadowEntry);\n                    } else {\n                        var queue = this._pendingScopes[addBefore];\n                        if (!queue) {\n                            queue = [];\n                            this._pendingScopes[addBefore] = queue;\n                        }\n                        queue.unshift(shadowEntry);\n                        isPending = true;\n                    }\n                }\n            }\n\n            if (!isPending) {\n                promise\n                    .then(function () {\n                        this._scopes[id] = scope;\n                        this._tryAddToScopeOrder(shadowEntry);\n                    }.bind(this))\n                    .fail(function (err) {\n                        // clean up all what's been done up to this point\n                        _.pull(shadowScopeOrder, shadowEntry);\n                    }.bind(this));\n                if (this._pendingScopes[id]) {\n                    var pending = this._pendingScopes[id];\n                    delete this._pendingScopes[id];\n                    pending.forEach(function (entry) {\n                        this._addToScopeOrder(entry.id, entry.scope, entry.promise, id);\n                    }.bind(this));\n                }\n            }\n        },\n\n        /**\n         * Adds scope to the scope order by its id. The scope should be previously added to the preference system.\n         *\n         * @param {string} id the scope id\n         * @param {string} before the id of the scope to add before\n         *\n         */\n        addToScopeOrder: function (id, addBefore) {\n            var shadowScopeOrder = this._defaults._shadowScopeOrder,\n                index = _.findIndex(shadowScopeOrder, function (entry) {\n                    return entry.id === id;\n                }),\n                entry;\n            if (index > -1) {\n                entry = shadowScopeOrder[index];\n                this._addToScopeOrder(entry.id, entry.scope, entry.promise, addBefore);\n            }\n        },\n\n        /**\n         * Removes a scope from the default scope order.\n         *\n         * @param {string} id Name of the Scope to remove from the default scope order.\n         */\n        removeFromScopeOrder: function (id) {\n            var scope = this._scopes[id];\n            if (scope) {\n                _.pull(this._defaults.scopeOrder, id);\n                scope.off(\".prefsys\");\n                this.trigger(SCOPEORDER_CHANGE, {\n                    id: id,\n                    action: \"removed\"\n                });\n                this._triggerChange({\n                    ids: scope.getKeys()\n                });\n            }\n        },\n\n        /**\n         * @private\n         *\n         * Normalizes the context to be one of:\n         *\n         * 1. a context object that was passed in\n         * 2. the default context\n         *\n         * @param {Object} context Context that was passed in\n         * @return {{scopeOrder: string, filename: ?string}} context object\n         */\n        _getContext: function (context) {\n            if (context) {\n                if (this.contextBuilder) {\n                    context = this.contextBuilder(context);\n                }\n                if (!context.scopeOrder) {\n                    context.scopeOrder = this._defaults.scopeOrder;\n                }\n                return context;\n            }\n            return { scopeOrder: this._defaults.scopeOrder };\n        },\n\n        /**\n         * Adds a new Scope. New Scopes are added at the highest precedence, unless the \"before\" option\n         * is given. The new Scope is automatically loaded.\n         *\n         * @param {string} id Name of the Scope\n         * @param {Scope|Storage} scope the Scope object itself. Optionally, can be given a Storage directly for convenience.\n         * @param {{before: string}} options optional behavior when adding (e.g. setting which scope this comes before)\n         * @return {Promise} Promise that is resolved when the Scope is loaded. It is resolved\n         *                   with id and scope.\n         */\n        addScope: function (id, scope, options) {\n            var promise;\n            options = options || {};\n\n            if (this._scopes[id]) {\n                throw new Error(\"Attempt to redefine preferences scope: \" + id);\n            }\n\n            // Check to see if scope is a Storage that needs to be wrapped\n            if (!scope.get) {\n                scope = new Scope(scope);\n            }\n\n            promise = scope.load();\n\n            this._addToScopeOrder(id, scope, promise, options.before);\n\n            promise\n                .fail(function (err) {\n                    // With preferences, it is valid for there to be no file.\n                    // It is not valid to have an unparseable file.\n                    if (err instanceof ParsingError) {\n                        console.error(err);\n                    }\n                });\n\n            return promise;\n        },\n\n        /**\n         * Removes a Scope from this PreferencesSystem. Returns without doing anything\n         * if the Scope does not exist. Notifies listeners of preferences that may have\n         * changed.\n         *\n         * @param {string} id Name of the Scope to remove\n         */\n        removeScope: function (id) {\n            var scope = this._scopes[id],\n                shadowIndex;\n            if (!scope) {\n                return;\n            }\n\n            this.removeFromScopeOrder(id);\n            shadowIndex = _.findIndex(this._defaults._shadowScopeOrder, function (entry) {\n                return entry.id === id;\n            });\n            this._defaults._shadowScopeOrder.splice(shadowIndex, 1);\n            delete this._scopes[id];\n        },\n\n        /**\n         * @private\n         *\n         * Retrieves the appropriate scopeOrder based on the given context.\n         * If the context contains a scopeOrder, that will be used. If not,\n         * the default scopeOrder is used.\n         *\n         * @param {{scopeOrder: ?Array.<string>} context\n         * @return {Array.<string>} list of scopes in the correct order for traversal\n         */\n        _getScopeOrder: function (context) {\n            return context.scopeOrder || this._defaults.scopeOrder;\n        },\n\n        /**\n         * Get the current value of a preference. The optional context provides a way to\n         * change scope ordering or the reference filename for path-based scopes.\n         *\n         * @param {string} id Name of the preference for which the value should be retrieved\n         * @param {Object|string=} context Optional context object or name of context to change the preference lookup\n         */\n        get: function (id, context) {\n            var scopeCounter;\n\n            context = this._getContext(context);\n\n            var scopeOrder = this._getScopeOrder(context);\n\n            for (scopeCounter = 0; scopeCounter < scopeOrder.length; scopeCounter++) {\n                var scope = this._scopes[scopeOrder[scopeCounter]];\n                if (scope) {\n                    var result = scope.get(id, context);\n                    if (result !== undefined) {\n                        var pref      = this.getPreference(id),\n                            validator = pref && pref.validator;\n                        if (!validator || validator(result)) {\n                            if (pref && pref.type === \"object\") {\n                                result = _.extend({}, pref.initial, result);\n                            }\n                            return _.cloneDeep(result);\n                        }\n                    }\n                }\n            }\n        },\n\n        /**\n         * Gets the location in which the value of a preference has been set.\n         *\n         * @param {string} id Name of the preference for which the value should be retrieved\n         * @param {Object=} context Optional context object to change the preference lookup\n         * @return {{scope: string, layer: ?string, layerID: ?object}} Object describing where the preferences came from\n         */\n        getPreferenceLocation: function (id, context) {\n            var scopeCounter,\n                scopeName;\n\n            context = this._getContext(context);\n\n            var scopeOrder = this._getScopeOrder(context);\n\n            for (scopeCounter = 0; scopeCounter < scopeOrder.length; scopeCounter++) {\n                scopeName = scopeOrder[scopeCounter];\n                var scope = this._scopes[scopeName];\n                if (scope) {\n                    var result = scope.getPreferenceLocation(id, context);\n                    if (result !== undefined) {\n                        result.scope = scopeName;\n                        return result;\n                    }\n                }\n            }\n        },\n\n        /**\n         * Sets a preference and notifies listeners that there may\n         * have been a change. By default, the preference is set in the same location in which\n         * it was defined except for the \"default\" scope. If the current value of the preference\n         * comes from the \"default\" scope, the new value will be set at the level just above\n         * default.\n         *\n         * @param {string} id Identifier of the preference to set\n         * @param {Object} value New value for the preference\n         * @param {{location: ?Object, context: ?Object}=} options Specific location in which to set the value or the context to use when setting the value\n         * @param {boolean=} doNotSave True if the preference change should not be saved automatically.\n         * @return {valid:  {boolean}, true if no validator specified or if value is valid\n         *          stored: {boolean}} true if a value was stored\n         */\n        set: function (id, value, options, doNotSave) {\n            options = options || {};\n            var context = this._getContext(options.context),\n\n                // The case where the \"default\" scope was chosen specifically is special.\n                // Usually \"default\" would come up only when a preference did not have any\n                // user-set value, in which case we'd want to set the value in a different scope.\n                forceDefault = options.location && options.location.scope === \"default\" ? true : false,\n                location = options.location || this.getPreferenceLocation(id, context);\n\n            if (!location || (location.scope === \"default\" && !forceDefault)) {\n                var scopeOrder = this._getScopeOrder(context);\n\n                // The default scope for setting a preference is the lowest priority\n                // scope after \"default\".\n                if (scopeOrder.length > 1) {\n                    location = {\n                        scope: scopeOrder[scopeOrder.length - 2]\n                    };\n                } else {\n                    return { valid: true, stored: false };\n                }\n            }\n\n            var scope = this._scopes[location.scope];\n            if (!scope) {\n                return { valid: true, stored: false };\n            }\n\n            var pref      = this.getPreference(id),\n                validator = pref && pref.validator;\n            if (validator && !validator(value)) {\n                return { valid: false, stored: false };\n            }\n\n            var wasSet = scope.set(id, value, context, location);\n            if (wasSet) {\n                if (!doNotSave) {\n                    this.save();\n                }\n                this._triggerChange({\n                    ids: [id]\n                });\n            }\n            return { valid: true, stored: wasSet };\n        },\n\n        /**\n         * Saves the preferences. If a save is already in progress, a Promise is returned for\n         * that save operation.\n         *\n         * @return {Promise} Resolved when the preferences are done saving.\n         */\n        save: function () {\n            let that = this;\n            if (that._saveInProgress) {\n                if (!that._nextSaveDeferred) {\n                    that._nextSaveDeferred = new $.Deferred();\n                }\n                return that._nextSaveDeferred.promise();\n            }\n\n            var deferred = that._nextSaveDeferred || (new $.Deferred());\n            this._saveInProgress = true;\n            this._nextSaveDeferred = null;\n\n            Async.doInParallel(_.values(that._scopes), function (scope) {\n                if (scope) {\n                    return scope.save();\n                }\n                return (new $.Deferred()).resolve().promise();\n\n            }).then(function () {\n                that._saveInProgress = false;\n                if (that._nextSaveDeferred) {\n                    that.save();\n                }\n                deferred.resolve();\n            }).fail(function (err) {\n                that._saveInProgress = false;\n                deferred.reject(err);\n            });\n\n            return deferred.promise();\n        },\n\n        /**\n         * Signals the context change to all the scopes within the preferences\n         * layer.  PreferencesManager is in charge of computing the context and\n         * signaling the changes to PreferencesSystem.\n         *\n         * @param {{path: string, language: string}} oldContext Old context\n         * @param {{path: string, language: string}} newContext New context\n         */\n        signalContextChanged: function (oldContext, newContext) {\n            var changes = [];\n\n            _.each(this._scopes, function (scope) {\n                var changedInScope = scope.contextChanged(oldContext, newContext);\n                if (changedInScope) {\n                    changes.push(changedInScope);\n                }\n            });\n\n            changes = _.union.apply(null, changes);\n            if (changes.length > 0) {\n                this._triggerChange({\n                    ids: changes\n                });\n            }\n        },\n\n        /**\n         * Sets up a listener for events. Optionally, you can set up a listener for a\n         * specific preference.\n         *\n         * @param {string} event Name of the event to listen for\n         * @param {string|Function} preferenceID Name of a specific preference or the handler function\n         * @param {?Function} handler Handler for the event\n         */\n        on: function (event, preferenceID, handler) {\n            if (typeof preferenceID === \"function\") {\n                handler = preferenceID;\n                preferenceID = null;\n            }\n\n            if (preferenceID) {\n                var pref = this.getPreference(preferenceID);\n                pref.on(event, handler);\n            } else {\n                this._on_internal(event, handler);\n            }\n        },\n\n        /**\n         * Turns off the event handlers for a given event, optionally for a specific preference\n         * or a specific handler function.\n         *\n         * @param {string} event Name of the event for which to turn off listening\n         * @param {string|Function} preferenceID Name of a specific preference or the handler function\n         * @param {?Function} handler Specific handler which should stop being notified\n         */\n        off: function (event, preferenceID, handler) {\n            if (typeof preferenceID === \"function\") {\n                handler = preferenceID;\n                preferenceID = null;\n            }\n\n            if (preferenceID) {\n                var pref = this.getPreference(preferenceID);\n                pref.off(event, handler);\n            } else {\n                this._off_internal(event, handler);\n            }\n        },\n\n        /**\n         * @private\n         *\n         * Sends a change event to listeners. If change events have been paused (see\n         * pauseChangeEvents) then the IDs are queued up.\n         *\n         * @param {{ids: Array.<string>}} data Message to send\n         */\n        _triggerChange: function (data) {\n            if (this._changeEventQueue) {\n                this._changeEventQueue = _.union(this._changeEventQueue, data.ids);\n            } else {\n                this.trigger(PREFERENCE_CHANGE, data);\n            }\n        },\n\n        /**\n         * Turns off sending of change events, queueing them up for sending once sending is resumed.\n         * The events are compacted so that each preference that will be notified is only\n         * notified once. (For example, if `spaceUnits` is changed 5 times, only one change\n         * event will be sent upon resuming events.)\n         */\n        pauseChangeEvents: function () {\n            if (!this._changeEventQueue) {\n                this._changeEventQueue = [];\n            }\n        },\n\n        /**\n         * Turns sending of events back on, sending any events that were queued while the\n         * events were paused.\n         */\n        resumeChangeEvents: function () {\n            if (this._changeEventQueue) {\n                this.trigger(PREFERENCE_CHANGE, {\n                    ids: this._changeEventQueue\n                });\n                this._changeEventQueue = null;\n            }\n        },\n\n        /**\n         * Tells the PreferencesSystem that the given file has been changed so that any\n         * related Scopes can be reloaded.\n         *\n         * @param {string} filePath File that has changed\n         */\n        fileChanged: function (filePath) {\n            _.forEach(this._scopes, function (scope) {\n                scope.fileChanged(filePath);\n            });\n        },\n\n        /**\n         * Retrieves a PreferencesSystem in which all preference access is prefixed.\n         * This helps provide namespacing so that different preferences consumers do\n         * not interfere with one another.\n         *\n         * The prefix provided has a `.` character appended when preference lookups are\n         * done.\n         */\n        getPrefixedSystem: function (prefix) {\n            return new PrefixedPreferencesSystem(this, prefix + \".\");\n        }\n\n    });\n\n    _addEventDispatcherImpl(PreferencesSystem.prototype);\n\n\n    // Public interface\n    exports.PreferencesSystem   = PreferencesSystem;\n    exports.Scope               = Scope;\n    exports.MemoryStorage       = MemoryStorage;\n    exports.PathLayer           = PathLayer;\n    exports.ProjectLayer        = ProjectLayer;\n    exports.LanguageLayer       = LanguageLayer;\n    exports.FileStorage         = FileStorage;\n});\n"],"file":"PreferencesBase.js"}