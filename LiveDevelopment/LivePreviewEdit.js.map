{"version":3,"sources":["LiveDevelopment/LivePreviewEdit.js"],"names":["define","require","exports","module","HTMLInstrumentation","LiveDevMultiBrowser","CodeMirror","ProjectManager","FileSystem","PathUtils","ProDialogs","KernalModeTrust","window","Error","_syncTextContentChanges","oldContent","newContent","parser","DOMParser","oldDoc","parseFromString","newDoc","oldRoot","body","newRoot","cleanClonedElement","clonedElement","nodeType","Node","ELEMENT_NODE","attrs","forEach","attr","removeAttribute","querySelectorAll","map","a","join","el","syncText","oldNode","newNode","TEXT_NODE","oldChildren","Array","from","childNodes","newChildren","maxLen","Math","max","length","i","oldChild","newChild","cloned","cloneNode","appendChild","removeChild","tagName","nodeValue","replaceChild","oldEls","children","newEls","min","innerHTML","_getEditorAndValidate","tagId","currLiveDoc","getCurrentLiveDoc","editor","undefined","_getElementRange","startRange","getPositionFromTagId","endRange","findMatchingTag","_codeMirror","startPos","endPos","close","to","open","_editTextInSource","message","range","text","getTextBetween","isEditSuccessful","finalText","replaceRange","document","batchOperation","setTimeout","undo","_duplicateElementInSourceByTagId","indent","line","ch","trim","insertPos","_deleteElementInSourceByTagId","getLine","prevLineText","chPrevLine","_cleanupAfterRemoval","lineToCheck","lineCount","currentLineText","lineStart","lineEnd","_insertElementWithIndentation","insertAfterMode","targetIndent","sourceText","insertLine","currentLine","_targetInsideSource","source","target","_moveElementInSource","sourceId","targetId","insertAfter","insertInside","sourceRange","targetRange","sourceRangeObj","targetRangeObj","indentLength","search","repeat","sourceBeforeTarget","matchingTagInfo","indentInfo","_detectIndent","childIndent","updatedSourceRange","updatedSourceRangeObj","originalSourceRange","updatedTargetRange","updatedTargetRangeObj","handleUndoRedoOperation","undoOrRedo","redo","_getRequiredDataForAI","fileName","file","name","filePath","fullPath","AIData","prompt","model","selectedModel","async","_editWithAI","aiEntitlement","EntitlementsManager","getAIEntitlement","activated","console","log","showAIUpsellDialog","getUniqueFilename","basePath","filename","extnName","counter","uniqueFilename","checkAndIncrement","getFileForPath","Promise","resolve","exists","err","then","_updateImageSrcAttribute","newSrcValue","elementText","doc","imgElement","querySelector","setAttribute","updatedElementText","outerHTML","_updateImageAndDismissRibbon","targetPath","htmlFilePath","relativePath","makePathRelative","protocol","evaluate","_handleUseThisImageLocalFiles","projectRoot","imageData","uint8Array","Uint8Array","fs","writeFile","Filer","Buffer","encoding","BYTE_ARRAY_ENCODING","error","_handleUseThisImageRemote","imageUrl","fetch","response","ok","status","arrayBuffer","catch","_handleUseThisImage","getProjectRoot","phoenixAssetsPath","phoenixAssetsDir","getDirectoryForPath","_downloadImageToPhoenixAssets","create","isLocalFile","handleLivePreviewEditOperation","move","useImage","element","delete","duplicate","livePreviewTextEdit","AISend","undoLivePreviewOperation","redoLivePreviewOperation"],"mappings":"AA0BAA,OAAO,SAAUC,QAASC,QAASC,QAC/B,MAAMC,oBAAsBH,QAAQ,iEAC9BI,oBAAsBJ,QAAQ,uCAC9BK,WAAaL,QAAQ,wCACrBM,eAAiBN,QAAQ,0BACzBO,WAAaP,QAAQ,yBACrBQ,UAAYR,QAAQ,oCACpBS,WAAaT,QAAQ,wBAErBU,gBAAkBC,OAAOD,gBAC/B,IAAIA,gBAEA,MAAM,IAAIE,MAAM,4FA8BpB,SAASC,wBAAwBC,WAAYC,YACzC,MAAMC,OAAS,IAAIC,UACbC,OAASF,OAAOG,gBAAgBL,WAAY,aAC5CM,OAASJ,OAAOG,gBAAgBJ,WAAY,aAE5CM,QAAUH,OAAOI,KACjBC,QAAUH,OAAOE,KAGvB,SAASE,mBAAmBC,eACxB,GAAIA,cAAcC,WAAaC,KAAKC,aAAc,CAE9C,MAAMC,MAAQ,CAAC,mBAAoB,qBAGnCA,MAAMC,QAAQC,MAAQN,cAAcO,gBAAgBD,OAGpDN,cAAcQ,iBAAiBJ,MAAMK,IAAIC,OAASA,MAAMC,KAAK,MACxDN,QAAQO,IAAMR,MAAMC,QAAQC,MAAQM,GAAGL,gBAAgBD,QAEhE,OAAON,cAGX,SAASa,SAASC,QAASC,SACvB,GAAKD,SAAYC,QAKjB,GAAID,QAAQb,WAAaC,KAAKc,WAAaD,QAAQd,WAAaC,KAAKc,WAQrE,GAAIF,QAAQb,WAAaC,KAAKC,cAAgBY,QAAQd,WAAaC,KAAKC,aAAc,CAClF,MAAMc,YAAcC,MAAMC,KAAKL,QAAQM,YACjCC,YAAcH,MAAMC,KAAKJ,QAAQK,YAEjCE,OAASC,KAAKC,IAAIP,YAAYQ,OAAQJ,YAAYI,QAExD,IAAK,IAAIC,EAAI,EAAGA,EAAIJ,OAAQI,IAAK,CAC7B,MAAMC,SAAWV,YAAYS,GACvBE,SAAWP,YAAYK,GAE7B,IAAKC,UAAYC,SAAU,CAEvB,MAAMC,OAASD,SAASE,WAAU,GAClChB,QAAQiB,YAAYhC,mBAAmB8B,cACpC,GAAIF,WAAaC,SAEpBd,QAAQkB,YAAYL,eACjB,GACHA,SAAS1B,WAAa2B,SAAS3B,UAC/B0B,SAAS1B,WAAaC,KAAKC,cAC3BwB,SAASM,UAAYL,SAASK,QAG9BpB,SAASc,SAAUC,eAChB,GACHD,SAAS1B,WAAaC,KAAKc,WAC3BY,SAAS3B,WAAaC,KAAKc,UAEvBW,SAASO,YAAcN,SAASM,YAChCP,SAASO,UAAYN,SAASM,eAE/B,CAEH,MAAML,OAASD,SAASE,WAAU,GAClChB,QAAQqB,aAAapC,mBAAmB8B,QAASF,kBAzCrDb,QAAQoB,YAAcnB,QAAQmB,YAC9BpB,QAAQoB,UAAYnB,QAAQmB,WA8CxC,MAAME,OAASlB,MAAMC,KAAKvB,QAAQyC,UAC5BC,OAASpB,MAAMC,KAAKrB,QAAQuC,UAElC,IAAK,IAAIX,EAAI,EAAGA,EAAIH,KAAKgB,IAAIH,OAAOX,OAAQa,OAAOb,QAASC,IACxDb,SAASuB,OAAOV,GAAIY,OAAOZ,IAG/B,OAAO9B,QAAQ4C,UAOnB,SAASC,sBAAsBC,OAC3B,MAAMC,YAAchE,oBAAoBiE,oBACxC,OAAKD,aAAgBA,YAAYE,cAInBC,IAAVJ,OAAwBA,OAGrBC,YAAYE,OANR,KAgBf,SAASE,iBAAiBF,OAAQH,OAK9B,MAAMM,WAAatE,oBAAoBuE,qBAAqBJ,OAAQH,OACpE,IAAIM,WACA,OAAO,KAGX,MAAME,SAAWtE,WAAWuE,gBAAgBN,OAAOO,YAAaJ,WAAW7B,MAC3E,IAAK+B,SACD,OAAO,KAGX,MAAMG,SAAWL,WAAW7B,KAEtBmC,OAASJ,SAASK,MAAQL,SAASK,MAAMC,GAAKN,SAASO,KAAKD,GAElE,MAAO,CAAEH,SAAAA,SAAUC,OAAAA,QAcvB,SAASI,kBAAkBC,SACvB,MAAMd,OAASJ,sBAAsBkB,QAAQjB,OAC7C,IAAKG,OACD,OAGJ,MAAMe,MAAQb,iBAAiBF,OAAQc,QAAQjB,OAC/C,IAAKkB,MACD,OAGJ,MAAMP,SAAEA,SAAQC,OAAEA,QAAWM,MAEvBC,KAAOhB,OAAOiB,eAAeT,SAAUC,QAM7C,GAAIK,QAAQI,iBAOL,CAOH,MAAMC,UAAY5E,wBAAwByE,KAAMF,QAAQrE,YACxDuD,OAAOoB,aAAaD,UAAWX,SAAUC,aAdzCT,OAAOqB,SAASC,eAAe,WAC3BtB,OAAOoB,aAAaJ,KAAMR,SAAUC,QACpCc,WAAW,KACPvB,OAAOwB,QACR,KAkBf,SAASC,iCAAiC5B,OAEtC,MAAMG,OAASJ,sBAAsBC,OACrC,IAAKG,OACD,OAGJ,MAAMe,MAAQb,iBAAiBF,OAAQH,OACvC,IAAKkB,MACD,OAGJ,MAAMP,SAAEA,SAAQC,OAAEA,QAAWM,MAGvBC,KAAOhB,OAAOiB,eAAeT,SAAUC,QAEvCiB,OAAS1B,OAAOiB,eAAe,CAAEU,KAAMnB,SAASmB,KAAMC,GAAI,GAAKpB,UAErER,OAAOqB,SAASC,eAAe,WAE3B,GAAsB,KAAlBI,OAAOG,OAAe,CAMtB,MAAMC,UAAY,CACdH,KAAMnB,SAASmB,MAAQlB,OAAOkB,KAAOnB,SAASmB,KAAO,GACrDC,GAAI,GAGR5B,OAAOoB,aAAa,KAAMX,QAC1BT,OAAOoB,aAAaM,OAASV,KAAMc,gBAGnC9B,OAAOoB,aAAaJ,KAAMR,YAStC,SAASuB,8BAA8BlC,OAEnC,MAAMG,OAASJ,sBAAsBC,OACrC,IAAKG,OACD,OAGJ,MAAMe,MAAQb,iBAAiBF,OAAQH,OACvC,IAAKkB,MACD,OAGJ,MAAMP,SAAEA,SAAQC,OAAEA,QAAWM,MAE7Bf,OAAOqB,SAASC,eAAe,WAI3B,GAHAtB,OAAOoB,aAAa,GAAIZ,SAAUC,QAGb,IAAlBD,SAASmB,OAAgB3B,OAAOgC,QAAQxB,SAASmB,MAAME,OAAS,CAC/D,MAAMI,aAAejC,OAAOgC,QAAQxB,SAASmB,KAAO,GAC9CO,WAAaD,aAAeA,aAAarD,OAAS,EACxDoB,OAAOoB,aAAa,GAAI,CAACO,KAAMnB,SAASmB,KAAO,EAAGC,GAAIM,YAAa1B,aAU/E,SAAS2B,qBAAqBnC,OAAQe,OAClC,MAAMqB,YAAcrB,MAAMzC,KAAKqD,KAG/B,GAAIS,YAAcpC,OAAOqC,YAAa,CAClC,MAAMC,gBAAkBtC,OAAOgC,QAAQI,aACvC,GAAIE,iBAA8C,KAA3BA,gBAAgBT,OAAe,CAElD,MAAMU,UAAY,CAAEZ,KAAMS,YAAaR,GAAI,GACrCY,QAAU,CAAEb,KAAMS,YAAc,EAAGR,GAAI,GAC7C5B,OAAOoB,aAAa,GAAImB,UAAWC,UAK3C,GAAIJ,YAAc,EAAG,CACjB,MAAMH,aAAejC,OAAOgC,QAAQI,YAAc,GAClD,GAAIH,cAAwC,KAAxBA,aAAaJ,OAAe,CAC5C,MAAMU,UAAY,CAAEZ,KAAMS,YAAc,EAAGR,GAAI,GACzCY,QAAU,CAAEb,KAAMS,YAAaR,GAAI,GACzC5B,OAAOoB,aAAa,GAAImB,UAAWC,WAc/C,SAASC,8BAA8BzC,OAAQ8B,UAAWY,gBAAiBC,aAAcC,YACrF,GAAIF,gBAEA1C,OAAOoB,aAAa,KAAOuB,aAAeC,WAAYd,eACnD,CAEH,MAAMe,WAAaf,UAAUH,KACvBY,UAAY,CAAEZ,KAAMkB,WAAYjB,GAAI,GAGpCkB,YAAc9C,OAAOgC,QAAQa,YAE/BC,aAAsC,KAAvBA,YAAYjB,OAE3B7B,OAAOoB,aAAauB,aAAeC,WAAYL,UAAW,CAAEZ,KAAMkB,WAAYjB,GAAIkB,YAAYlE,SAG9FoB,OAAOoB,aAAauB,aAAeC,WAAa,KAAML,YAalE,SAASQ,oBAAoBC,OAAQC,QACjC,OACKD,OAAO1E,KAAKqD,KAAOsB,OAAO3E,KAAKqD,MAC/BqB,OAAO1E,KAAKqD,OAASsB,OAAO3E,KAAKqD,MAAQqB,OAAO1E,KAAKsD,IAAMqB,OAAO3E,KAAKsD,MACvEoB,OAAOrC,GAAGgB,KAAOsB,OAAOtC,GAAGgB,MAC3BqB,OAAOrC,GAAGgB,OAASsB,OAAOtC,GAAGgB,MAAQqB,OAAOrC,GAAGiB,IAAMqB,OAAOtC,GAAGiB,IAgBxE,SAASsB,qBAAqBC,SAAUC,SAAUC,YAAaC,cAAe,GAE1E,MAAMtD,OAASJ,sBAAsBuD,UACrC,IAAKnD,SAAWoD,SACZ,OAGJ,MAAMG,YAAcrD,iBAAiBF,OAAQmD,UAC7C,IAAKI,YACD,OAGJ,MAAMC,YAActD,iBAAiBF,OAAQoD,UAC7C,IAAKI,YACD,OAIJ,MAAMC,eAAiB,CACnBnF,KAAMiF,YAAY/C,SAClBG,GAAI4C,YAAY9C,QAGdiD,eAAiB,CACnBpF,KAAMkF,YAAYhD,SAClBG,GAAI6C,YAAY/C,QAKpB,GAAIsC,oBAAoBU,eAAgBC,gBACpC,OAGJ,MAAMd,WAAa5C,OAAOiB,eAAewC,eAAenF,KAAMmF,eAAe9C,IAC7E,IAAIgC,aAAe3C,OAAOiB,eAAe,CAAEU,KAAM+B,eAAepF,KAAKqD,KAAMC,GAAI,GAAK8B,eAAepF,MACnG,GAAGqE,cAAwC,KAAxBA,aAAad,OAAe,CAC3C,IAAI8B,aAAehB,aAAaiB,OAAO,OACjB,IAAlBD,eACAA,aAAehB,aAAa/D,QAEhC+D,aAAe,IAAIkB,OAAOF,cAQ9B,MAAMG,mBACFL,eAAenF,KAAKqD,KAAO+B,eAAepF,KAAKqD,MAC9C8B,eAAenF,KAAKqD,OAAS+B,eAAepF,KAAKqD,MAAQ8B,eAAenF,KAAKsD,GAAK8B,eAAepF,KAAKsD,GAG3G5B,OAAOqB,SAASC,eAAe,WAC3B,GAAIwC,mBAAoB,CAEpB,GAAIR,aAAc,CACd,MAAMS,gBAAkBhI,WAAWuE,gBAAgBN,OAAOO,YAAamD,eAAepF,MACtF,GAAIyF,iBAAmBA,gBAAgBnD,KAAM,CACzC,MAAMkB,UAAY,CACdH,KAAMoC,gBAAgBnD,KAAKD,GAAGgB,KAC9BC,GAAImC,gBAAgBnD,KAAKD,GAAGiB,IAG1BoC,WAAahE,OAAOiE,gBACpBC,YAAcvB,aAAeqB,WAAWtC,OAC9Ce,8BAA8BzC,OAAQ8B,WAAW,EAAMoC,YAAatB,kBAErE,GAAIS,YAAa,CACpB,MAAMvB,UAAY,CACdH,KAAM+B,eAAe/C,GAAGgB,KACxBC,GAAI8B,eAAe/C,GAAGiB,IAE1Ba,8BAA8BzC,OAAQ8B,WAAW,EAAMa,aAAcC,iBAGrEH,8BAA8BzC,OAAQ0D,eAAepF,MAAM,EAAOqE,aAAcC,YAIpF,MAAMuB,mBAAqBjE,iBAAiBF,OAAQmD,UACpD,GAAIgB,mBAAoB,CACpB,MAAMC,sBAAwB,CAC1B9F,KAAM6F,mBAAmB3D,SACzBG,GAAIwD,mBAAmB1D,QAE3BT,OAAOoB,aAAa,GAAIgD,sBAAsB9F,KAAM8F,sBAAsBzD,IAC1EwB,qBAAqBnC,OAAQoE,4BAE9B,CAGH,MAAMC,oBAAsB,IAAKZ,gBAGjCzD,OAAOoB,aAAa,GAAIqC,eAAenF,KAAMmF,eAAe9C,IAC5DwB,qBAAqBnC,OAAQqE,qBAG7B,MAAMC,mBAAqBpE,iBAAiBF,OAAQoD,UACpD,IAAKkB,mBACD,OAGJ,MAAMC,sBAAwB,CAC1BjG,KAAMgG,mBAAmB9D,SACzBG,GAAI2D,mBAAmB7D,QAG3B,GAAI6C,aAAc,CACd,MAAMS,gBAAkBhI,WAAWuE,gBAAgBN,OAAOO,YAAagE,sBAAsBjG,MAC7F,GAAIyF,iBAAmBA,gBAAgBnD,KAAM,CACzC,MAAMkB,UAAY,CACdH,KAAMoC,gBAAgBnD,KAAKD,GAAGgB,KAC9BC,GAAImC,gBAAgBnD,KAAKD,GAAGiB,IAG1BoC,WAAahE,OAAOiE,gBACpBC,YAAcvB,aAAeqB,WAAWtC,OAC9Ce,8BAA8BzC,OAAQ8B,WAAW,EAAMoC,YAAatB,kBAErE,GAAIS,YAAa,CACpB,MAAMvB,UAAY,CACdH,KAAM4C,sBAAsB5D,GAAGgB,KAC/BC,GAAI2C,sBAAsB5D,GAAGiB,IAEjCa,8BAA8BzC,OAAQ8B,WAAW,EAAMa,aAAcC,iBAGrEH,8BAA8BzC,OAAQuE,sBAAsBjG,MAAM,EAAOqE,aAAcC,eAUvG,SAAS4B,wBAAwBC,YAC7B,MAAMzE,OAASJ,wBACVI,SAIc,SAAfyE,WACAzE,OAAOwB,OACe,SAAfiD,YACPzE,OAAO0E,QAIf,SAASC,sBAAsB7D,SAE3B,MAAMd,OAASJ,sBAAsBkB,QAAQjB,OAC7C,IAAKG,OACD,OAGJ,MAAMe,MAAQb,iBAAiBF,OAAQc,QAAQjB,OAC/C,IAAKkB,MACD,OAGJ,MAAMP,SAAEA,SAAQC,OAAEA,QAAWM,MAEvBC,KAAOhB,OAAOiB,eAAeT,SAAUC,QACvCmE,SAAW5E,OAAOqB,SAASwD,KAAKC,KAChCC,SAAW/E,OAAOqB,SAASwD,KAAKG,SAEhCC,OAAS,CACXjF,OAAQA,OACR4E,SAAUA,SACVG,SAAUA,SACVlF,MAAOiB,QAAQjB,MACfkB,MAAO,CAACP,SAAAA,SAAUC,OAAAA,QAClBO,KAAMA,KACNkE,OAAQpE,QAAQoE,OAChBC,MAAOrE,QAAQsE,eAGnB,OAAOH,OAGXI,eAAeC,YAAYxE,SACvB,MAAMmE,OAASN,sBAAsB7D,SAC/ByE,oBAAsBnJ,gBAAgBoJ,oBAAoBC,mBAC3DF,cAAcG,UAOnBC,QAAQC,IAAIX,QAJR9I,WAAW0J,mBAAmBN,eActC,SAASO,kBAAkBC,SAAUC,SAAUC,UAC3C,IAAIC,QAAU,EACVC,eAAiBH,SAAWC,SAEhC,SAASG,oBACL,MAAMrB,SAAWgB,SAAWI,eACtBtB,KAAO5I,WAAWoK,eAAetB,UAEvC,OAAO,IAAIuB,QAASC,UAChB1B,KAAK2B,OAAO,CAACC,IAAKD,UACVA,QAEAL,kBAAoBH,cADpBE,UAC0CD,WAC1CG,oBAAoBM,KAAKH,UAEzBA,QAAQJ,oBAMxB,OAAOC,oBAQX,SAASO,yBAAyB9G,MAAO+G,aACrC,MAAM5G,OAASJ,sBAAsBC,OACrC,IAAKG,OACD,OAGJ,MAAMe,MAAQb,iBAAiBF,OAAQH,OACvC,IAAKkB,MACD,OAGJ,MAAMP,SAAEA,SAAQC,OAAEA,QAAWM,MACvB8F,YAAc7G,OAAOiB,eAAeT,SAAUC,QAG9C/D,OAAS,IAAIC,UACbmK,IAAMpK,OAAOG,gBAAgBgK,YAAa,aAC1CE,WAAaD,IAAIE,cAAc,OAErC,GAAID,WAAY,CACZA,WAAWE,aAAa,MAAOL,aAC/B,MAAMM,mBAAqBH,WAAWI,UAEtCnH,OAAOqB,SAASC,eAAe,WAC3BtB,OAAOoB,aAAa8F,mBAAoB1G,SAAUC,WAY9D,SAAS2G,6BAA6BvH,MAAOwH,WAAYrB,UACrD,MAAMhG,OAASJ,sBAAsBC,OACrC,GAAIG,OAAQ,CACR,MAAMsH,aAAetH,OAAOqB,SAASwD,KAAKG,SACpCuC,aAAerL,UAAUsL,iBAAiBH,WAAYC,cAC5DX,yBAAyB9G,MAAO0H,mBAEhCZ,yBAAyB9G,MAAOmG,UAIpC,MAAMlG,YAAchE,oBAAoBiE,oBACpCD,aAAeA,YAAY2H,UAAY3H,YAAY2H,SAASC,UAC5D5H,YAAY2H,SAASC,SAAS,mCAUtC,SAASC,8BAA8B7G,QAASkF,SAAU4B,aACtD,MAAM/H,MAAEA,MAAKgI,UAAEA,WAAc/G,QAEvBgH,WAAa,IAAIC,WAAWF,WAC5BR,WAAaO,YAAY5C,SAAWgB,SAE1C3J,OAAO2L,GAAGC,UAAUZ,WAAYhL,OAAO6L,MAAMC,OAAO7J,KAAKwJ,YACrD,CAAEM,SAAU/L,OAAO2L,GAAGK,qBAAwB5B,MACtCA,IACAd,QAAQ2C,MAAM,wBAAyB7B,KAEvCW,6BAA6BvH,MAAOwH,WAAYrB,YAWhE,SAASuC,0BAA0BzH,QAASkF,SAAU4B,aAClD,MAAMY,SAAEA,SAAQ3I,MAAEA,OAAUiB,QAE5B2H,MAAMD,UACD9B,KAAKgC,WACF,IAAKA,SAASC,GACV,MAAM,IAAIrM,6BAA6BoM,SAASE,UAEpD,OAAOF,SAASG,gBAEnBnC,KAAKmC,cACF,MAAMf,WAAa,IAAIC,WAAWc,aAC5BxB,WAAaO,YAAY5C,SAAWgB,SAE1C3J,OAAO2L,GAAGC,UAAUZ,WAAYhL,OAAO6L,MAAMC,OAAO7J,KAAKwJ,YACrD,CAAEM,SAAU/L,OAAO2L,GAAGK,qBAAwB5B,MACtCA,IACAd,QAAQ2C,MAAM,wBAAyB7B,KAEvCW,6BAA6BvH,MAAOwH,WAAYrB,cAI/D8C,MAAMR,QACH3C,QAAQ2C,MAAM,yBAA0BA,SAWpD,SAASS,oBAAoBjI,SACzB,MAAMkF,SAAWlF,QAAQkF,SACnBC,SAAWnF,QAAQmF,UAAY,MAE/B2B,YAAc5L,eAAegN,iBACnC,IAAKpB,YAAe,OAGpB,MAAMqB,kBAAoBrB,YAAY5C,SAAW,uBAC3CkE,iBAAmBjN,WAAWkN,oBAAoBF,mBAIxDC,iBAAiB1C,OAAO,CAACC,IAAKD,UACtBC,MAECD,OASD4C,8BAA8BtI,QAASkF,SAAUC,SAAUiD,kBAR3DA,iBAAiBG,OAAQ5C,MACjBA,IACAd,QAAQ2C,MAAM,gDAAiD7B,KAGnE2C,8BAA8BtI,QAASkF,SAAUC,SAAUiD,uBAW3E,SAASE,8BAA8BtI,QAASkF,SAAUC,SAAUiD,kBAChEpD,kBAAkBoD,iBAAiBlE,SAAUgB,SAAUC,UAAUS,KAAMP,iBAE/DrF,QAAQwI,aAAexI,QAAQ+G,UAC/BF,8BAA8B7G,QAASqF,eAAgB+C,kBAEvDX,0BAA0BzH,QAASqF,eAAgB+C,oBAExDJ,MAAMR,QACL3C,QAAQ2C,MAAM,qDAAsDA,SA2B5E,SAASiB,+BAA+BzI,SAEhCA,QAAQ0I,MAAQ1I,QAAQqC,UAAYrC,QAAQsC,SAC5CF,qBAAqBpC,QAAQqC,SAAUrC,QAAQsC,SAAUtC,QAAQuC,YAAavC,QAAQwC,cAKtFxC,QAAQ2I,UAAY3I,QAAQ0H,UAAY1H,QAAQkF,SAChD+C,oBAAoBjI,SAInBA,QAAQ4I,SAAY5I,QAAQjB,MAS7BiB,QAAQ6I,OACR5H,8BAA8BjB,QAAQjB,OAC/BiB,QAAQ8I,UACfnI,iCAAiCX,QAAQjB,OAClCiB,QAAQ+I,oBACfhJ,kBAAkBC,SACXA,QAAQgJ,QACfxE,YAAYxE,UAdRA,QAAQiJ,0BAA4BjJ,QAAQkJ,4BAC5ClJ,QAAQiJ,yBAA2BvF,wBAAwB,QAAUA,wBAAwB,SAiBzG7I,QAAQ4N,+BAAiCA","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*\n * This file handles all the editor side source code handling after user performed some live preview edit operation\n * when any operation is performed in the browser context (handled inside remoteFunctions.js) it sends a message through\n * MessageBroker, now this file then makes the change in the source code\n */\ndefine(function (require, exports, module) {\n    const HTMLInstrumentation = require(\"LiveDevelopment/MultiBrowserImpl/language/HTMLInstrumentation\");\n    const LiveDevMultiBrowser = require(\"LiveDevelopment/LiveDevMultiBrowser\");\n    const CodeMirror = require(\"thirdparty/CodeMirror/lib/codemirror\");\n    const ProjectManager = require(\"project/ProjectManager\");\n    const FileSystem = require(\"filesystem/FileSystem\");\n    const PathUtils = require(\"thirdparty/path-utils/path-utils\");\n    const ProDialogs = require(\"services/pro-dialogs\");\n\n    const KernalModeTrust = window.KernalModeTrust;\n    if(!KernalModeTrust){\n        // integrated extensions will have access to kernal mode, but not external extensions\n        throw new Error(\"LivePreviewEdit.js should have access to KernalModeTrust. Cannot boot without trust ring\");\n    }\n\n    /**\n     * This function syncs text content changes between the original source code\n     * and the live preview DOM after a text edit in the browser\n     *\n     * @private\n     * @param {String} oldContent - the original source code from the editor\n     * @param {String} newContent - the outerHTML after editing in live preview\n     * @returns {String} - the updated content that should replace the original editor code\n     *\n     * NOTE: We don’t touch tag names or attributes —\n     * we only care about text changes or things like newlines, <br>, or formatting like <b>, <i>, etc.\n     *\n     * Here's the basic idea:\n     * - Parse both old and new HTML strings into DOM trees\n     * - Then walk both DOMs side by side and sync changes\n     *\n     * What we handle:\n     * - if both are text nodes → update the text if changed\n     * - if both are elements with same tag → go deeper and sync their children\n     * - if one is text and one is an element → replace (like when user adds/removes <br> or adds bold/italic)\n     * - if a node got added or removed → do that in the old DOM\n     *\n     * We don’t recreate or touch existing elements unless absolutely needed,\n     * so all original user-written attributes and tag structure stay exactly the same.\n     *\n     * This avoids the browser trying to “fix” broken HTML (which we don’t want)\n     */\n    function _syncTextContentChanges(oldContent, newContent) {\n        const parser = new DOMParser();\n        const oldDoc = parser.parseFromString(oldContent, \"text/html\");\n        const newDoc = parser.parseFromString(newContent, \"text/html\");\n\n        const oldRoot = oldDoc.body;\n        const newRoot = newDoc.body;\n\n        // this function is to remove the phoenix internal attributes from leaking into the user's source code\n        function cleanClonedElement(clonedElement) {\n            if (clonedElement.nodeType === Node.ELEMENT_NODE) {\n                // this are phoenix's internal attributes\n                const attrs = [\"data-brackets-id\", \"data-ld-highlight\"];\n\n                // remove from the cloned element\n                attrs.forEach(attr => clonedElement.removeAttribute(attr));\n\n                // also remove from its childrens\n                clonedElement.querySelectorAll(attrs.map(a => `[${a}]`).join(\",\"))\n                    .forEach(el => attrs.forEach(attr => el.removeAttribute(attr)));\n            }\n            return clonedElement;\n        }\n\n        function syncText(oldNode, newNode) {\n            if (!oldNode || !newNode) {\n                return;\n            }\n\n            // when both are text nodes, we just need to replace the old text with the new one\n            if (oldNode.nodeType === Node.TEXT_NODE && newNode.nodeType === Node.TEXT_NODE) {\n                if (oldNode.nodeValue !== newNode.nodeValue) {\n                    oldNode.nodeValue = newNode.nodeValue;\n                }\n                return;\n            }\n\n            // when both are elements\n            if (oldNode.nodeType === Node.ELEMENT_NODE && newNode.nodeType === Node.ELEMENT_NODE) {\n                const oldChildren = Array.from(oldNode.childNodes);\n                const newChildren = Array.from(newNode.childNodes);\n\n                const maxLen = Math.max(oldChildren.length, newChildren.length);\n\n                for (let i = 0; i < maxLen; i++) {\n                    const oldChild = oldChildren[i];\n                    const newChild = newChildren[i];\n\n                    if (!oldChild && newChild) {\n                        // if new child added → clone and insert\n                        const cloned = newChild.cloneNode(true);\n                        oldNode.appendChild(cleanClonedElement(cloned));\n                    } else if (oldChild && !newChild) {\n                        // if child removed → delete\n                        oldNode.removeChild(oldChild);\n                    } else if (\n                        oldChild.nodeType === newChild.nodeType &&\n                        oldChild.nodeType === Node.ELEMENT_NODE &&\n                        oldChild.tagName === newChild.tagName\n                    ) {\n                        // same element tag → sync recursively\n                        syncText(oldChild, newChild);\n                    } else if (\n                        oldChild.nodeType === Node.TEXT_NODE &&\n                        newChild.nodeType === Node.TEXT_NODE\n                    ) {\n                        if (oldChild.nodeValue !== newChild.nodeValue) {\n                            oldChild.nodeValue = newChild.nodeValue;\n                        }\n                    } else {\n                        // different node types or tags → replace\n                        const cloned = newChild.cloneNode(true);\n                        oldNode.replaceChild(cleanClonedElement(cloned), oldChild);\n                    }\n                }\n            }\n        }\n\n        const oldEls = Array.from(oldRoot.children);\n        const newEls = Array.from(newRoot.children);\n\n        for (let i = 0; i < Math.min(oldEls.length, newEls.length); i++) {\n            syncText(oldEls[i], newEls[i]);\n        }\n\n        return oldRoot.innerHTML;\n    }\n\n    /**\n     * helper function to get editor and validate basic requirements\n     * @param {Number} tagId - the data-brackets-id of the element\n     */\n    function _getEditorAndValidate(tagId) {\n        const currLiveDoc = LiveDevMultiBrowser.getCurrentLiveDoc();\n        if (!currLiveDoc || !currLiveDoc.editor) {\n            return null;\n        }\n        // for undo/redo operations, tagId might not be needed, so we only check it if provided\n        if (tagId !== undefined && !tagId) {\n            return null;\n        }\n        return currLiveDoc.editor;\n    }\n\n    /**\n     * helper function to get element range from tagId\n     *\n     * @param {Object} editor - the editor instance\n     * @param {Number} tagId - the data-brackets-id of the element\n     * @returns {Object|null} - object with startPos and endPos, or null if not found\n     */\n    function _getElementRange(editor, tagId) {\n        // get the start range from the getPositionFromTagId function\n        // and we get the end range from the findMatchingTag function\n        // NOTE: we cannot get the end range from getPositionFromTagId\n        // because on non-beautified code getPositionFromTagId may not provide correct end position\n        const startRange = HTMLInstrumentation.getPositionFromTagId(editor, tagId);\n        if(!startRange) {\n            return null;\n        }\n\n        const endRange = CodeMirror.findMatchingTag(editor._codeMirror, startRange.from);\n        if (!endRange) {\n            return null;\n        }\n\n        const startPos = startRange.from;\n        // for empty tags endRange.close might not exist, for ex: img tag\n        const endPos = endRange.close ? endRange.close.to : endRange.open.to;\n\n        return { startPos, endPos };\n    }\n\n    /**\n     * this function handles the text edit in the source code when user updates the text in the live preview\n     *\n     * @param {Object} message - the message object\n     *   - livePreviewEditEnabled: true\n     *   - livePreviewTextEdit: true\n     *   - element: element\n     *   - newContent: element.outerHTML (the edited content from live preview)\n     *   - tagId: Number (data-brackets-id of the edited element)\n     *   - isEditSuccessful: boolean (false when user pressed Escape to cancel, otherwise true always)\n     */\n    function _editTextInSource(message) {\n        const editor = _getEditorAndValidate(message.tagId);\n        if (!editor) {\n            return;\n        }\n\n        const range = _getElementRange(editor, message.tagId);\n        if (!range) {\n            return;\n        }\n\n        const { startPos, endPos } = range;\n\n        const text = editor.getTextBetween(startPos, endPos);\n\n        // if the edit was cancelled (mainly by pressing Escape key)\n        // we just replace the same text with itself\n        // this is a quick trick because as the code is changed for that element in the file,\n        // the live preview for that element gets refreshed and the changes are discarded in the live preview\n        if(!message.isEditSuccessful) {\n            editor.document.batchOperation(function () {\n                editor.replaceRange(text, startPos, endPos);\n                setTimeout(() => {\n                    editor.undo(); // undo the replaceRange so dirty icon won't appear and no net change in undo history\n                }, 0);\n            });\n        } else {\n\n            // if the edit operation was successful, we call a helper function that\n            // is responsible to provide the actual content that needs to be written in the editor\n            //\n            // text: the actual current source code in the editor\n            // message.newContent: the new content in the live preview after the edit operation\n            const finalText = _syncTextContentChanges(text, message.newContent);\n            editor.replaceRange(finalText, startPos, endPos);\n        }\n    }\n\n    /**\n     * This function is responsible to duplicate an element from the source code\n     * @param {Number} tagId - the data-brackets-id of the DOM element\n     */\n    function _duplicateElementInSourceByTagId(tagId) {\n        // this is to get the currently live document that is being served in the live preview\n        const editor = _getEditorAndValidate(tagId);\n        if (!editor) {\n            return;\n        }\n\n        const range = _getElementRange(editor, tagId);\n        if (!range) {\n            return;\n        }\n\n        const { startPos, endPos } = range;\n\n        // this is the actual source code for the element that we need to duplicate\n        const text = editor.getTextBetween(startPos, endPos);\n        // this is the indentation on the line\n        const indent = editor.getTextBetween({ line: startPos.line, ch: 0 }, startPos);\n\n        editor.document.batchOperation(function () {\n            // make sure there is only indentation and no text before it\n            if (indent.trim() === \"\") {\n                // this is the position where we need to insert\n                // we're giving the char as 0 because since we insert a new line using '\\n'\n                // that's why writing any char value will not work, as the line is emptys\n                // and codemirror doesn't allow to insert at a column (ch) greater than the length of the line\n                // So, the logic is to just append the indent before the text at this insertPos\n                const insertPos = {\n                    line: startPos.line + (endPos.line - startPos.line + 1),\n                    ch: 0\n                };\n\n                editor.replaceRange(\"\\n\", endPos);\n                editor.replaceRange(indent + text, insertPos);\n            } else {\n                // if there is some text, we just add the duplicated text right next to it\n                editor.replaceRange(text, startPos);\n            }\n        });\n    }\n\n    /**\n     * This function is responsible to delete an element from the source code\n     * @param {Number} tagId - the data-brackets-id of the DOM element\n     */\n    function _deleteElementInSourceByTagId(tagId) {\n        // this is to get the currently live document that is being served in the live preview\n        const editor = _getEditorAndValidate(tagId);\n        if (!editor) {\n            return;\n        }\n\n        const range = _getElementRange(editor, tagId);\n        if (!range) {\n            return;\n        }\n\n        const { startPos, endPos } = range;\n\n        editor.document.batchOperation(function () {\n            editor.replaceRange(\"\", startPos, endPos);\n\n            // since we remove content from the source, we want to clear the extra line\n            if(startPos.line !== 0 && !(editor.getLine(startPos.line).trim())) {\n                const prevLineText = editor.getLine(startPos.line - 1);\n                const chPrevLine = prevLineText ? prevLineText.length : 0;\n                editor.replaceRange(\"\", {line: startPos.line - 1, ch: chPrevLine}, startPos);\n            }\n        });\n    }\n\n    /**\n     * this function is to clean up the empty lines after an element is removed\n     * @param {Object} editor - the editor instance\n     * @param {Object} range - the range where element was removed\n     */\n    function _cleanupAfterRemoval(editor, range) {\n        const lineToCheck = range.from.line;\n\n        // check if the line where element was removed is now empty\n        if (lineToCheck < editor.lineCount()) {\n            const currentLineText = editor.getLine(lineToCheck);\n            if (currentLineText && currentLineText.trim() === \"\") {\n                // remove the empty line\n                const lineStart = { line: lineToCheck, ch: 0 };\n                const lineEnd = { line: lineToCheck + 1, ch: 0 };\n                editor.replaceRange(\"\", lineStart, lineEnd);\n            }\n        }\n\n        // also we need to check the previous line if it became empty\n        if (lineToCheck > 0) {\n            const prevLineText = editor.getLine(lineToCheck - 1);\n            if (prevLineText && prevLineText.trim() === \"\") {\n                const lineStart = { line: lineToCheck - 1, ch: 0 };\n                const lineEnd = { line: lineToCheck, ch: 0 };\n                editor.replaceRange(\"\", lineStart, lineEnd);\n            }\n        }\n    }\n\n    /**\n     * this function is to make sure that we insert elements with proper indentation\n     *\n     * @param {Object} editor - the editor instance\n     * @param {Object} insertPos - position where to insert\n     * @param {Boolean} insertAfterMode - whether to insert after the position\n     * @param {String} targetIndent - the indentation to use\n     * @param {String} sourceText - the text to insert\n     */\n    function _insertElementWithIndentation(editor, insertPos, insertAfterMode, targetIndent, sourceText) {\n        if (insertAfterMode) {\n            // Insert after the target element\n            editor.replaceRange(\"\\n\" + targetIndent + sourceText, insertPos);\n        } else {\n            // Insert before the target element\n            const insertLine = insertPos.line;\n            const lineStart = { line: insertLine, ch: 0 };\n\n            // Get current line content to preserve any existing indentation structure\n            const currentLine = editor.getLine(insertLine);\n\n            if (currentLine && currentLine.trim() === \"\") {\n                // the line is empty, replace it entirely\n                editor.replaceRange(targetIndent + sourceText, lineStart, { line: insertLine, ch: currentLine.length });\n            } else {\n                // the line has content, insert before it\n                editor.replaceRange(targetIndent + sourceText + \"\\n\", lineStart);\n            }\n        }\n    }\n\n    /**\n     * This function is to make sure that the target element doesn't lie completely within the source element\n     * because if that is the case then it means that the drag-drop was not performed correctly\n     *\n     * @param {Object} source - start/end pos of the source element\n     * @param {Object} target - start/end pos of the target element\n     * @returns {Boolean} true if target is fully inside source, false otherwise\n     */\n    function _targetInsideSource(source, target) {\n        if (\n            (source.from.line < target.from.line ||\n            (source.from.line === target.from.line && source.from.ch <= target.from.ch)) &&\n            (source.to.line > target.to.line ||\n            (source.to.line === target.to.line && source.to.ch >= target.to.ch))\n        ) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * This function is responsible for moving an element from one position to another in the source code\n     * it is called when there is drag-drop in the live preview\n     * @param {Number} sourceId - the data-brackets-id of the element being moved\n     * @param {Number} targetId - the data-brackets-id of the target element where to move\n     * @param {Boolean} insertAfter - whether to insert the source element after the target element\n     * @param {Boolean} insertInside - whether to insert the source element as a child of the target element\n     */\n    function _moveElementInSource(sourceId, targetId, insertAfter, insertInside = false) {\n        // this is to get the currently live document that is being served in the live preview\n        const editor = _getEditorAndValidate(sourceId);\n        if (!editor || !targetId) {\n            return;\n        }\n\n        const sourceRange = _getElementRange(editor, sourceId);\n        if (!sourceRange) {\n            return;\n        }\n\n        const targetRange = _getElementRange(editor, targetId);\n        if (!targetRange) {\n            return;\n        }\n\n        // convert to the format expected by the rest of the function\n        const sourceRangeObj = {\n            from: sourceRange.startPos,\n            to: sourceRange.endPos\n        };\n\n        const targetRangeObj = {\n            from: targetRange.startPos,\n            to: targetRange.endPos\n        };\n\n        // make sure that the target is not within the source\n        // this would otherwise remove both source and target, breaking the document\n        if (_targetInsideSource(sourceRangeObj, targetRangeObj)) {\n            return;\n        }\n\n        const sourceText = editor.getTextBetween(sourceRangeObj.from, sourceRangeObj.to);\n        let targetIndent = editor.getTextBetween({ line: targetRangeObj.from.line, ch: 0 }, targetRangeObj.from);\n        if(targetIndent && targetIndent.trim() !== \"\") { // because indentation should hold no text\n            let indentLength = targetIndent.search(/\\S/);\n            if (indentLength === -1) {\n                indentLength = targetIndent.length;\n            }\n            targetIndent = ' '.repeat(indentLength);\n        }\n\n        // Check if source is before target to determine order of operations\n        // check if the source is before target or after the target\n        // we need this because\n        // If source is before target → we need to insert first, then remove\n        // If target is before source → remove first, then insert\n        const sourceBeforeTarget =\n            sourceRangeObj.from.line < targetRangeObj.from.line ||\n            (sourceRangeObj.from.line === targetRangeObj.from.line && sourceRangeObj.from.ch < targetRangeObj.from.ch);\n\n        // creating a batch operation so that undo in live preview works fine\n        editor.document.batchOperation(function () {\n            if (sourceBeforeTarget) {\n                // this handles the case when source is before target: insert first, then remove\n                if (insertInside) {\n                    const matchingTagInfo = CodeMirror.findMatchingTag(editor._codeMirror, targetRangeObj.from);\n                    if (matchingTagInfo && matchingTagInfo.open) {\n                        const insertPos = {\n                            line: matchingTagInfo.open.to.line,\n                            ch: matchingTagInfo.open.to.ch\n                        };\n\n                        const indentInfo = editor._detectIndent();\n                        const childIndent = targetIndent + indentInfo.indent;\n                        _insertElementWithIndentation(editor, insertPos, true, childIndent, sourceText);\n                    }\n                } else if (insertAfter) {\n                    const insertPos = {\n                        line: targetRangeObj.to.line,\n                        ch: targetRangeObj.to.ch\n                    };\n                    _insertElementWithIndentation(editor, insertPos, true, targetIndent, sourceText);\n                } else {\n                    // insert before target\n                    _insertElementWithIndentation(editor, targetRangeObj.from, false, targetIndent, sourceText);\n                }\n\n                // Now remove the source element (NOTE: the positions have shifted)\n                const updatedSourceRange = _getElementRange(editor, sourceId);\n                if (updatedSourceRange) {\n                    const updatedSourceRangeObj = {\n                        from: updatedSourceRange.startPos,\n                        to: updatedSourceRange.endPos\n                    };\n                    editor.replaceRange(\"\", updatedSourceRangeObj.from, updatedSourceRangeObj.to);\n                    _cleanupAfterRemoval(editor, updatedSourceRangeObj);\n                }\n            } else {\n                // This handles the case when target is before source: remove first, then insert\n                // Store source range before removal\n                const originalSourceRange = { ...sourceRangeObj };\n\n                // Remove the source element first\n                editor.replaceRange(\"\", sourceRangeObj.from, sourceRangeObj.to);\n                _cleanupAfterRemoval(editor, originalSourceRange);\n\n                // Recalculate target range after source removal as the positions have shifted\n                const updatedTargetRange = _getElementRange(editor, targetId);\n                if (!updatedTargetRange) {\n                    return;\n                }\n\n                const updatedTargetRangeObj = {\n                    from: updatedTargetRange.startPos,\n                    to: updatedTargetRange.endPos\n                };\n\n                if (insertInside) {\n                    const matchingTagInfo = CodeMirror.findMatchingTag(editor._codeMirror, updatedTargetRangeObj.from);\n                    if (matchingTagInfo && matchingTagInfo.open) {\n                        const insertPos = {\n                            line: matchingTagInfo.open.to.line,\n                            ch: matchingTagInfo.open.to.ch\n                        };\n\n                        const indentInfo = editor._detectIndent();\n                        const childIndent = targetIndent + indentInfo.indent;\n                        _insertElementWithIndentation(editor, insertPos, true, childIndent, sourceText);\n                    }\n                } else if (insertAfter) {\n                    const insertPos = {\n                        line: updatedTargetRangeObj.to.line,\n                        ch: updatedTargetRangeObj.to.ch\n                    };\n                    _insertElementWithIndentation(editor, insertPos, true, targetIndent, sourceText);\n                } else {\n                    // Insert before target\n                    _insertElementWithIndentation(editor, updatedTargetRangeObj.from, false, targetIndent, sourceText);\n                }\n            }\n        });\n    }\n\n    /**\n     * This function is to handle the undo redo operation in the live preview\n     * @param {String} undoOrRedo - \"undo\" when to undo, and \"redo\" for redo\n     */\n    function handleUndoRedoOperation(undoOrRedo) {\n        const editor = _getEditorAndValidate(); // no tagId needed for undo/redo\n        if (!editor) {\n            return;\n        }\n\n        if (undoOrRedo === \"undo\") {\n            editor.undo();\n        } else if (undoOrRedo === \"redo\") {\n            editor.redo();\n        }\n    }\n\n    function _getRequiredDataForAI(message) {\n        // this is to get the currently live document that is being served in the live preview\n        const editor = _getEditorAndValidate(message.tagId);\n        if (!editor) {\n            return;\n        }\n\n        const range = _getElementRange(editor, message.tagId);\n        if (!range) {\n            return;\n        }\n\n        const { startPos, endPos } = range;\n        // this is the actual source code for the element that we need to duplicate\n        const text = editor.getTextBetween(startPos, endPos);\n        const fileName = editor.document.file.name;\n        const filePath = editor.document.file.fullPath;\n\n        const AIData = {\n            editor: editor, // the editor instance that is being served in the live preview\n            fileName: fileName,\n            filePath: filePath, // the complete absolute path\n            tagId: message.tagId, // the data-brackets-id of the element which was selected for AI edit\n            range: {startPos, endPos}, // the start and end position text in the source code for that element\n            text: text, // the actual source code in between the start and the end pos\n            prompt: message.prompt, // the prompt that user typed\n            model: message.selectedModel // the selected model (fast, slow or moderate)\n        };\n\n        return AIData;\n    }\n\n    async function _editWithAI(message) {\n        const AIData = _getRequiredDataForAI(message);\n        const aiEntitlement = await KernalModeTrust.EntitlementsManager.getAIEntitlement();\n        if (!aiEntitlement.activated) {\n            // Ai is not activated for user(not logged in/no ai plan/disabled by system admin)\n            // the showAIUpsellDialog will show an appropriate message for each case.\n            ProDialogs.showAIUpsellDialog(aiEntitlement);\n            return;\n        }\n        // todo @abose ai wire in\n        console.log(AIData);\n    }\n\n    /**\n     * this is a helper function to make sure that when saving a new image, there's no existing file with the same name\n     * @param {String} basePath - this is the base path where the image will be saved\n     * @param {String} filename - the name of the image file\n     * @param {String} extnName - the name of the image extension. (defaults to \"jpg\")\n     * @returns {String} - the new file name\n     */\n    function getUniqueFilename(basePath, filename, extnName) {\n        let counter = 0;\n        let uniqueFilename = filename + extnName;\n\n        function checkAndIncrement() {\n            const filePath = basePath + uniqueFilename;\n            const file = FileSystem.getFileForPath(filePath);\n\n            return new Promise((resolve) => {\n                file.exists((err, exists) => {\n                    if (exists) {\n                        counter++;\n                        uniqueFilename = `${filename}-${counter}${extnName}`;\n                        checkAndIncrement().then(resolve);\n                    } else {\n                        resolve(uniqueFilename);\n                    }\n                });\n            });\n        }\n\n        return checkAndIncrement();\n    }\n\n    /**\n     * This function updates the src attribute of an image element in the source code\n     * @param {Number} tagId - the data-brackets-id of the image element\n     * @param {String} newSrcValue - the new src value to set\n     */\n    function _updateImageSrcAttribute(tagId, newSrcValue) {\n        const editor = _getEditorAndValidate(tagId);\n        if (!editor) {\n            return;\n        }\n\n        const range = _getElementRange(editor, tagId);\n        if (!range) {\n            return;\n        }\n\n        const { startPos, endPos } = range;\n        const elementText = editor.getTextBetween(startPos, endPos);\n\n        // parse it using DOM parser so that we can update the src attribute\n        const parser = new DOMParser();\n        const doc = parser.parseFromString(elementText, \"text/html\");\n        const imgElement = doc.querySelector('img');\n\n        if (imgElement) {\n            imgElement.setAttribute('src', newSrcValue);\n            const updatedElementText = imgElement.outerHTML;\n\n            editor.document.batchOperation(function () {\n                editor.replaceRange(updatedElementText, startPos, endPos);\n            });\n        }\n    }\n\n    /**\n     * Helper function to update image src attribute and dismiss ribbon gallery\n     *\n     * @param {Number} tagId - the data-brackets-id of the image element\n     * @param {String} targetPath - the full path where the image was saved\n     * @param {String} filename - the filename of the saved image\n     */\n    function _updateImageAndDismissRibbon(tagId, targetPath, filename) {\n        const editor = _getEditorAndValidate(tagId);\n        if (editor) {\n            const htmlFilePath = editor.document.file.fullPath;\n            const relativePath = PathUtils.makePathRelative(targetPath, htmlFilePath);\n            _updateImageSrcAttribute(tagId, relativePath);\n        } else {\n            _updateImageSrcAttribute(tagId, filename);\n        }\n\n        // dismiss the image ribbon gallery\n        const currLiveDoc = LiveDevMultiBrowser.getCurrentLiveDoc();\n        if (currLiveDoc && currLiveDoc.protocol && currLiveDoc.protocol.evaluate) {\n            currLiveDoc.protocol.evaluate(\"_LD.dismissImageRibbonGallery()\");\n        }\n    }\n\n    /**\n     * helper function to handle 'upload from computer'\n     * @param {Object} message - the message object\n     * @param {String} filename - the file name with which we need to save the image\n     * @param {Directory} projectRoot - the project root in which the image is to be saved\n     */\n    function _handleUseThisImageLocalFiles(message, filename, projectRoot) {\n        const { tagId, imageData } = message;\n\n        const uint8Array = new Uint8Array(imageData);\n        const targetPath = projectRoot.fullPath + filename;\n\n        window.fs.writeFile(targetPath, window.Filer.Buffer.from(uint8Array),\n            { encoding: window.fs.BYTE_ARRAY_ENCODING }, (err) => {\n                if (err) {\n                    console.error('Failed to save image:', err);\n                } else {\n                    _updateImageAndDismissRibbon(tagId, targetPath, filename);\n                }\n            });\n    }\n\n    /**\n     * helper function to handle 'use this image' button click on remote images\n     * @param {Object} message - the message object\n     * @param {String} filename - the file name with which we need to save the image\n     * @param {Directory} projectRoot - the project root in which the image is to be saved\n     */\n    function _handleUseThisImageRemote(message, filename, projectRoot) {\n        const { imageUrl, tagId } = message;\n\n        fetch(imageUrl)\n            .then(response => {\n                if (!response.ok) {\n                    throw new Error(`HTTP error! status: ${response.status}`);\n                }\n                return response.arrayBuffer();\n            })\n            .then(arrayBuffer => {\n                const uint8Array = new Uint8Array(arrayBuffer);\n                const targetPath = projectRoot.fullPath + filename;\n\n                window.fs.writeFile(targetPath, window.Filer.Buffer.from(uint8Array),\n                    { encoding: window.fs.BYTE_ARRAY_ENCODING }, (err) => {\n                        if (err) {\n                            console.error('Failed to save image:', err);\n                        } else {\n                            _updateImageAndDismissRibbon(tagId, targetPath, filename);\n                        }\n                    });\n            })\n            .catch(error => {\n                console.error('Failed to fetch image:', error);\n            });\n    }\n\n    /**\n     * This function is called when 'use this image' button is clicked in the image ribbon gallery\n     * or user loads an image file from the computer\n     * this is responsible to download the image in the appropriate place\n     * and also change the src attribute of the element (by calling appropriate helper functions)\n     * @param {Object} message - the message object which stores all the required data for this operation\n     */\n    function _handleUseThisImage(message) {\n        const filename = message.filename;\n        const extnName = message.extnName || \"jpg\";\n\n        const projectRoot = ProjectManager.getProjectRoot();\n        if (!projectRoot) { return; }\n\n        // phoenix-assets folder, all the images will be stored inside this\n        const phoenixAssetsPath = projectRoot.fullPath + \"phoenix-code-assets/\";\n        const phoenixAssetsDir = FileSystem.getDirectoryForPath(phoenixAssetsPath);\n\n        // check if the phoenix-assets dir exists\n        // if present, download the image inside it, if not create the dir and then download the image inside it\n        phoenixAssetsDir.exists((err, exists) => {\n            if (err) { return; }\n\n            if (!exists) {\n                phoenixAssetsDir.create((err) => {\n                    if (err) {\n                        console.error('Error creating phoenix-code-assets directory:', err);\n                        return;\n                    }\n                    _downloadImageToPhoenixAssets(message, filename, extnName, phoenixAssetsDir);\n                });\n            } else {\n                _downloadImageToPhoenixAssets(message, filename, extnName, phoenixAssetsDir);\n            }\n        });\n    }\n\n    /**\n     * Helper function to download image to phoenix-assets folder\n     */\n    function _downloadImageToPhoenixAssets(message, filename, extnName, phoenixAssetsDir) {\n        getUniqueFilename(phoenixAssetsDir.fullPath, filename, extnName).then((uniqueFilename) => {\n            // check if the image is loaded from computer or from remote\n            if (message.isLocalFile && message.imageData) {\n                _handleUseThisImageLocalFiles(message, uniqueFilename, phoenixAssetsDir);\n            } else {\n                _handleUseThisImageRemote(message, uniqueFilename, phoenixAssetsDir);\n            }\n        }).catch(error => {\n            console.error('Something went wrong when trying to use this image', error);\n        });\n    }\n\n    /**\n     * This is the main function that is exported.\n     * it will be called by LiveDevProtocol when it receives a message from RemoteFunctions.js\n     * or LiveDevProtocolRemote.js (for undo) using MessageBroker\n     * Refer to: `handleOptionClick` function in the RemoteFunctions.js and `_receive` function in LiveDevProtocol.js\n     *\n     * @param {Object} message - this is the object that is passed by RemoteFunctions.js using MessageBroker\n     * this object will be in the format\n     * {\n                livePreviewEditEnabled: true,\n                tagId: tagId,\n                delete || duplicate || livePreviewTextEdit || AISend: true\n                undoLivePreviewOperation: true (this property is available only for undo operation)\n\n                prompt: prompt (only for AI)\n\n                sourceId: sourceId, (these are for move (drag & drop))\n                targetId: targetId,\n                insertAfter: boolean, (whether to insert after the target element)\n                move: true\n        }\n    * these are the main properties that are passed through the message\n     */\n    function handleLivePreviewEditOperation(message) {\n        // handle move(drag & drop)\n        if (message.move && message.sourceId && message.targetId) {\n            _moveElementInSource(message.sourceId, message.targetId, message.insertAfter, message.insertInside);\n            return;\n        }\n\n        // use this image\n        if (message.useImage && message.imageUrl && message.filename) {\n            _handleUseThisImage(message);\n            return;\n        }\n\n        if (!message.element || !message.tagId) {\n            // check for undo\n            if (message.undoLivePreviewOperation || message.redoLivePreviewOperation) {\n                message.undoLivePreviewOperation ? handleUndoRedoOperation(\"undo\") : handleUndoRedoOperation(\"redo\");\n            }\n            return;\n        }\n\n        // just call the required functions\n        if (message.delete) {\n            _deleteElementInSourceByTagId(message.tagId);\n        } else if (message.duplicate) {\n            _duplicateElementInSourceByTagId(message.tagId);\n        } else if (message.livePreviewTextEdit) {\n            _editTextInSource(message);\n        } else if (message.AISend) {\n            _editWithAI(message);\n        }\n    }\n\n    exports.handleLivePreviewEditOperation = handleLivePreviewEditOperation;\n});\n"],"file":"LivePreviewEdit.js"}