{"version":3,"sources":["extensionsIntegrated/CustomSnippets/snippetCursorManager.js"],"names":["define","require","exports","module","KeyEvent","EditorManager","TAB_STOP_REGEX","activeSnippetSession","SnippetSession","editor","tabStops","startLine","endLine","this","currentTabNumber","length","number","isActive","parseTemplateText","templateText","match","lastIndex","exec","tabNumber","parseInt","push","sort","a","b","text","findTabStops","document","line","lineText","getLine","start","ch","index","end","shouldContinueSession","session","getLineIndentation","position","addIndentationToSnippet","baseIndent","lines","split","result","isFirstLine","i","trim","insertSnippetWithTabStops","startPos","endPos","parsed","indentedText","replaceRange","navigateToTabStop","finalPos","setCursorPos","endSnippetSession","tabStop","find","t","setSelection","focus","navigateToNextTabStop","currentNumber","nextTabStop","navigateToPreviousTabStop","prevTabStop","maxNumber","reverse","forEach","isInSnippetSession","isCursorInSnippetLines","cursorPos","handleKeyEvent","jqEvent","event","getCursorPos","keyCode","DOM_VK_TAB","shiftKey","preventDefault","DOM_VK_ESCAPE","DOM_VK_DELETE","DOM_VK_BACK_SPACE","setTimeout","handleCursorActivity","getSelections","registerHandlers","editorHolder","$","registerCursorActivityForEditor","on","addEventListener","getActiveEditor","current","previous","currentEditor","off"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\ndefine(function (require, exports, module) {\n    const KeyEvent = require(\"utils/KeyEvent\");\n    const EditorManager = require(\"editor/EditorManager\");\n\n    // tab stops regex to handle ${1}, ${2}.... etc.\n    const TAB_STOP_REGEX = /\\$\\{(\\d+)\\}/g;\n\n    // this is to check whether an active snippet session is on or off\n    let activeSnippetSession = null;\n\n    /**\n     * this represents an active snippet session with tab stops\n     */\n    function SnippetSession(editor, tabStops, startLine, endLine) {\n        this.editor = editor;\n        this.tabStops = tabStops; // this is an array of {number, line} sorted by number\n        this.currentTabNumber = tabStops.length > 0 ? tabStops[0].number : 1;\n        this.startLine = startLine;\n        this.endLine = endLine;\n        this.isActive = true;\n    }\n\n    /**\n     * this function is responsible to parse the template text and extract all the tab stops\n     *\n     * @param {string} templateText - the template text with tab stops\n     * @returns {Object} - Object containing the text and tab stop information\n     */\n    function parseTemplateText(templateText) {\n        const tabStops = [];\n        let match;\n\n        // reset regex\n        TAB_STOP_REGEX.lastIndex = 0;\n\n        // find all the tab stops\n        while ((match = TAB_STOP_REGEX.exec(templateText)) !== null) {\n            const tabNumber = parseInt(match[1], 10);\n            tabStops.push({\n                number: tabNumber\n            });\n        }\n\n        // sort the tab stops by number. note: 0 should come at last\n        tabStops.sort((a, b) => {\n            if (a.number === 0) {\n                return 1;\n            }\n            if (b.number === 0) {\n                return -1;\n            }\n            return a.number - b.number;\n        });\n\n        return {\n            text: templateText,\n            tabStops: tabStops\n        };\n    }\n\n    /**\n     * Find tab stops in the snippet lines and return their positions\n     * this is called after snippet insertion to find actual positions in the editor\n     *\n     * @param {Editor} editor - editor instance\n     * @param {number} startLine - Start line of snippet\n     * @param {number} endLine - End line of snippet\n     * @returns {Array} - array of {number, line, start, end} sorted by number\n     */\n    function findTabStops(editor, startLine, endLine) {\n        const tabStops = [];\n        const document = editor.document;\n\n        for (let line = startLine; line <= endLine; line++) {\n            const lineText = document.getLine(line);\n            let match;\n\n            TAB_STOP_REGEX.lastIndex = 0;\n            while ((match = TAB_STOP_REGEX.exec(lineText)) !== null) {\n                const tabNumber = parseInt(match[1], 10);\n                tabStops.push({\n                    number: tabNumber,\n                    line: line,\n                    start: { line: line, ch: match.index },\n                    end: { line: line, ch: match.index + match[0].length }\n                });\n            }\n        }\n\n        tabStops.sort((a, b) => {\n            if (a.number === 0) {\n                return 1;\n            }\n            if (b.number === 0) {\n                return -1;\n            }\n            return a.number - b.number;\n        });\n\n        return tabStops;\n    }\n\n    /**\n     * responsible to check if session should continue (tab stops still exist in template area)\n     * we need this because users can delete tab stops while typing\n     *\n     * @returns {boolean}\n     */\n    function shouldContinueSession() {\n        if (!activeSnippetSession || !activeSnippetSession.isActive) {\n            return false;\n        }\n\n        const session = activeSnippetSession;\n        const tabStops = findTabStops(session.editor, session.startLine, session.endLine);\n\n        // update the session with current tab stops\n        session.tabStops = tabStops;\n\n        return tabStops.length > 0;\n    }\n\n    /**\n     * this function is responsible to calculate the indentation level for the current line\n     *\n     * @param {Editor} editor - the editor instance\n     * @param {Object} position - position object with line number\n     * @returns {String} - the indentation string\n     */\n    function getLineIndentation(editor, position) {\n        const line = editor.document.getLine(position.line);\n        const match = line.match(/^\\s*/);\n        return match ? match[0] : '';\n    }\n\n    /**\n     * this function is to add proper indentation to multiline snippet text\n     *\n     * @param {String} templateText - the template text with multiple lines\n     * @param {String} baseIndent - the base indentation string from the current cursor position\n     * @returns {String} - properly indented text\n     */\n    function addIndentationToSnippet(templateText, baseIndent) {\n        const lines = templateText.split(/(\\r\\n|\\n)/g);\n\n        let result = '';\n        let isFirstLine = true;\n\n        for (let i = 0; i < lines.length; i++) {\n            const line = lines[i];\n\n            if (line === '\\n' || line === '\\r\\n') {\n                result += line;\n                continue;\n            }\n\n            if (line.trim() === '') {\n                result += line;\n                continue;\n            }\n\n            // we don't want to indent the first line as it inherits the current indent\n            if (isFirstLine) {\n                result += line;\n                isFirstLine = false;\n            } else {\n                // add base indent plus the existing indent in the template text\n                result += baseIndent + line;\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Insert snippet with tab stops and start navigation session\n     * this is the main function that handles snippet insertion with cursor positioning\n     *\n     * @param {Editor} editor - editor instance\n     * @param {string} templateText - Template text with tab stops\n     * @param {Object} startPos - Start position for insertion\n     * @param {Object} endPos - End position for insertion\n     */\n    function insertSnippetWithTabStops(editor, templateText, startPos, endPos) {\n        const parsed = parseTemplateText(templateText);\n\n        // Get the current line's indentation to apply to all subsequent lines\n        const baseIndent = getLineIndentation(editor, startPos);\n\n        // Apply proper indentation to the snippet text for multi-line snippets\n        const indentedText = addIndentationToSnippet(parsed.text, baseIndent);\n\n        editor.document.replaceRange(indentedText, startPos, endPos);\n\n        // calculate snippet bounds\n        const lines = indentedText.split(\"\\n\");\n        const startLine = startPos.line;\n        const endLine = startPos.line + lines.length - 1;\n\n        // find tab stops in the inserted snippet\n        const tabStops = findTabStops(editor, startLine, endLine);\n\n        if (tabStops.length > 0) {\n            activeSnippetSession = new SnippetSession(editor, tabStops, startLine, endLine);\n\n            // move to first tab stop. this is the default behaviour\n            navigateToTabStop(activeSnippetSession.currentTabNumber);\n        } else {\n            // when no tab stops, we just place cursor at end\n            const finalPos = {\n                line: endLine,\n                ch: lines.length === 1 ? startPos.ch + lines[0].length : lines[lines.length - 1].length\n            };\n            editor.setCursorPos(finalPos);\n        }\n    }\n\n    /**\n     * Navigate to a specific tab stop by number\n     * @param {number} tabNumber - Tab stop number to navigate to\n     */\n    function navigateToTabStop(tabNumber) {\n        if (!shouldContinueSession()) {\n            endSnippetSession();\n            return;\n        }\n\n        const session = activeSnippetSession;\n\n        // find the tab stop with the specified number\n        const tabStop = session.tabStops.find((t) => t.number === tabNumber);\n\n        if (tabStop) {\n            session.currentTabNumber = tabNumber;\n\n            // select the entire tab stop placeholder\n            session.editor.setSelection(tabStop.start, tabStop.end);\n            session.editor.focus();\n        } else {\n            endSnippetSession();\n        }\n    }\n\n    /**\n     * Navigate to the next tab stop\n     * this handles the logic for finding the next available tab stop in sequence\n     */\n    function navigateToNextTabStop() {\n        if (!shouldContinueSession()) {\n            endSnippetSession();\n            return false;\n        }\n\n        const session = activeSnippetSession;\n        const currentNumber = session.currentTabNumber;\n\n        let nextTabStop = null;\n\n        // If we're currently at ${0}, there's no next tab stop so we need to end the session\n        if (currentNumber === 0) {\n            endSnippetSession();\n            return false;\n        }\n\n        // at first, look for the next numbered tab stop (greater than current)\n        for (let i = 0; i < session.tabStops.length; i++) {\n            if (session.tabStops[i].number > currentNumber && session.tabStops[i].number !== 0) {\n                nextTabStop = session.tabStops[i];\n                break;\n            }\n        }\n\n        // If no numbered tab stop found, look for ${0} as the final stop\n        if (!nextTabStop) {\n            nextTabStop = session.tabStops.find((t) => t.number === 0);\n        }\n\n        if (nextTabStop) {\n            navigateToTabStop(nextTabStop.number);\n            return true;\n        }\n        endSnippetSession();\n        return false;\n    }\n\n    /**\n     * Navigate to the previous tab stop\n     * this handles shift+tab navigation to go backwards\n     */\n    function navigateToPreviousTabStop() {\n        if (!shouldContinueSession()) {\n            endSnippetSession();\n            return false;\n        }\n\n        const session = activeSnippetSession;\n        const currentNumber = session.currentTabNumber;\n\n        // Find the previous tab stop number in the sorted array\n        let prevTabStop = null;\n\n        // If we're currently at ${0}, find the highest numbered tab stop\n        if (currentNumber === 0) {\n            let maxNumber = -1;\n            for (let i = 0; i < session.tabStops.length; i++) {\n                if (session.tabStops[i].number !== 0 && session.tabStops[i].number > maxNumber) {\n                    maxNumber = session.tabStops[i].number;\n                    prevTabStop = session.tabStops[i];\n                }\n            }\n        } else {\n            // Find the previous numbered tab stop (less than current, but not 0)\n            for (let i = session.tabStops.length - 1; i >= 0; i--) {\n                if (session.tabStops[i].number < currentNumber && session.tabStops[i].number !== 0) {\n                    prevTabStop = session.tabStops[i];\n                    break;\n                }\n            }\n        }\n\n        if (prevTabStop) {\n            navigateToTabStop(prevTabStop.number);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * End the current snippet session\n     * this cleans up all remaining tab stop placeholders and resets the session\n     */\n    function endSnippetSession() {\n        if (activeSnippetSession) {\n            const session = activeSnippetSession;\n\n            // Remove any remaining tab stop placeholders\n            const tabStops = findTabStops(session.editor, session.startLine, session.endLine);\n            tabStops.reverse().forEach((tabStop) => {\n                session.editor.document.replaceRange(\"\", tabStop.start, tabStop.end);\n            });\n\n            activeSnippetSession.isActive = false;\n            activeSnippetSession = null;\n        }\n    }\n\n    /**\n     * Check if we're currently in a snippet session\n     * @returns {boolean}\n     */\n    function isInSnippetSession() {\n        return activeSnippetSession && activeSnippetSession.isActive;\n    }\n\n    /**\n     * Check if cursor is within snippet lines\n     * we need this to end the session if user moves cursor outside the snippet area\n     *\n     * @param {Object} cursorPos - Current cursor position\n     * @returns {boolean}\n     */\n    function isCursorInSnippetLines(cursorPos) {\n        if (!activeSnippetSession) {\n            return false;\n        }\n\n        return cursorPos.line >= activeSnippetSession.startLine && cursorPos.line <= activeSnippetSession.endLine;\n    }\n\n    /**\n     * Handle key events for tab navigation\n     * this is where all the tab/shift+tab/escape key handling happens\n     *\n     * @param {Event} jqEvent - jQuery event\n     * @param {Editor} editor - Editor instance\n     * @param {KeyboardEvent} event - Keyboard event\n     */\n    function handleKeyEvent(jqEvent, editor, event) {\n        if (!isInSnippetSession() || activeSnippetSession.editor !== editor) {\n            return false;\n        }\n\n        // make sure that the cursor is still within snippet lines\n        const cursorPos = editor.getCursorPos();\n        if (!isCursorInSnippetLines(cursorPos)) {\n            endSnippetSession();\n            return false;\n        }\n\n        // Tab key handling\n        if (event.keyCode === KeyEvent.DOM_VK_TAB) {\n            if (event.shiftKey) {\n                // Shift+Tab: go to previous tab stop\n                if (navigateToPreviousTabStop()) {\n                    event.preventDefault();\n                    return true;\n                }\n            } else {\n                // Tab: go to next tab stop\n                if (navigateToNextTabStop()) {\n                    event.preventDefault();\n                    return true;\n                }\n            }\n        }\n\n        // 'Esc' key to end snippet session\n        if (event.keyCode === KeyEvent.DOM_VK_ESCAPE) {\n            endSnippetSession();\n            event.preventDefault();\n            return true;\n        }\n\n        // handle Delete/Backspace - check if session should continue\n        // we need this because users might delete the template text from the editor\n        if (event.keyCode === KeyEvent.DOM_VK_DELETE || event.keyCode === KeyEvent.DOM_VK_BACK_SPACE) {\n            // just to let the delete/backspace complete\n            setTimeout(() => {\n                if (!shouldContinueSession()) {\n                    endSnippetSession();\n                }\n            }, 10);\n        }\n\n        return false;\n    }\n\n    /**\n     * Handle cursor position changes\n     * this ends the session if user moves cursor outside snippet bounds or creates multiple selections\n     * @param {Event} event - Cursor activity event\n     * @param {Editor} editor - Editor instance\n     */\n    function handleCursorActivity(event, editor) {\n        if (!isInSnippetSession() || activeSnippetSession.editor !== editor) {\n            return;\n        }\n\n        // end session if user creates multiple selections\n        if (editor.getSelections().length > 1) {\n            endSnippetSession();\n            return;\n        }\n\n        const cursorPos = editor.getCursorPos();\n        if (!isCursorInSnippetLines(cursorPos)) {\n            endSnippetSession();\n        }\n    }\n\n    /**\n     * This function is responsible to register all the required handers\n     * we need this to set up all the event listeners for cursor navigation\n     */\n    function registerHandlers() {\n        // register the event handler for snippet cursor navigation\n        const editorHolder = $(\"#editor-holder\")[0];\n        if (editorHolder) {\n            editorHolder.addEventListener(\n                \"keydown\",\n                function (event) {\n                    const editor = EditorManager.getActiveEditor();\n                    if (editor) {\n                        handleKeyEvent(null, editor, event);\n                    }\n                },\n                true\n            );\n        }\n\n        // Listen for editor changes to end snippet sessions\n        EditorManager.on(\"activeEditorChange\", function (event, current, previous) {\n            if (isInSnippetSession()) {\n                endSnippetSession();\n            }\n        });\n\n        // Register cursor activity handler for current and future editors\n        function registerCursorActivityForEditor(editor) {\n            if (editor) {\n                editor.on(\"cursorActivity\", handleCursorActivity);\n            }\n        }\n\n        // Register for current editor\n        const currentEditor = EditorManager.getActiveEditor();\n        if (currentEditor) {\n            registerCursorActivityForEditor(currentEditor);\n        }\n\n        // Register for editor changes\n        EditorManager.on(\"activeEditorChange\", function (event, current, previous) {\n            if (previous) {\n                previous.off(\"cursorActivity\", handleCursorActivity);\n            }\n            if (current) {\n                registerCursorActivityForEditor(current);\n            }\n            if (isInSnippetSession()) {\n                endSnippetSession();\n            }\n        });\n    }\n\n    exports.parseTemplateText = parseTemplateText;\n    exports.insertSnippetWithTabStops = insertSnippetWithTabStops;\n    exports.isInSnippetSession = isInSnippetSession;\n    exports.handleKeyEvent = handleKeyEvent;\n    exports.handleCursorActivity = handleCursorActivity;\n    exports.endSnippetSession = endSnippetSession;\n    exports.registerHandlers = registerHandlers;\n});\n"],"file":"snippetCursorManager.js"}