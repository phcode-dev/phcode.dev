{"version":3,"sources":["extensionsIntegrated/CustomSnippets/helper.js"],"names":["define","require","exports","module","StringMatch","Global","UIHelper","Strings","ALLOWED_NAVIGATION_KEYS","snippetsByLanguage","Map","snippetsByAbbreviation","allSnippetsOptimized","preprocessSnippet","snippet","optimizedSnippet","abbreviationLower","abbreviation","toLowerCase","fileExtension","supportedLangSet","Set","supportsAllLanguages","extensions","split","map","ext","trim","filter","rebuildOptimizedStructures","clear","length","SnippetHintsList","forEach","push","set","has","get","add","mapLanguageToExtension","languageId","languageMap","javascript","css","html","php","python","java","c","cpp","csharp","typescript","json","xml","sql","sass","scss","less","stylus","coffeescript","markdown","yaml","ruby","go","rust","swift","kotlin","dart","vue","jsx","tsx","processFileExtensionInput","extension","includes","replace","result","startsWith","join","endsWith","slice","getSnippetData","$","val","description","templateText","processedFileExtension","toggleSaveButtonDisability","$abbrInput","$templateInput","$saveBtn","hasAbbr","hasTemplate","prop","getCurrentLanguageContext","editor","language","getLanguageForPosition","getId","getCurrentFileExtension","filePath","document","file","fullPath","undefined","substring","lastIndexOf","isSnippetSupportedInLanguageContext","languageContext","effectiveExtension","supportedExtensions","some","isSnippetSupportedInFile","hasExactMatchingSnippet","query","queryLower","getMatchingSnippets","candidateSnippets","universalSnippets","languageSnippets","size","matchingSnippets","Array","from","sort","a","b","aExact","bExact","localeCompare","createHintItem","abbr","$hint","addClass","attr","matchResult","stringMatch","preferPrefixMatches","stringRanges","item","matched","append","text","$icon","CUSTOM_SNIPPETS_HINT_LABEL","fullDescription","displayDescription","$desc","clearAllInputFields","populateEditForm","snippetData","getEditSnippetData","toggleEditSaveButtonDisability","clearEditInputFields","updateSnippetsCount","count","$countSpan","sanitizeFileExtensionInput","value","handleFileExtensionInput","$input","sanitizedValue","handleFileExtensionKeypress","e","input","char","String","fromCharCode","which","allowed","preventDefault","test","handleFileExtensionPaste","clipboardData","originalEvent","getData","sanitized","start","selectionStart","end","selectionEnd","currentValue","newPos","setSelectionRange","handleTextareaTabKey","textarea","keyCode","trigger","validateAbbrInput","abbrBox","ctrlKey","metaKey","altKey","key","match","isEditForm","id","inputId","wrapperId","errorId","showError","CUSTOM_SNIPPETS_ABBR_LENGTH_ERROR","CUSTOM_SNIPPETS_SPACE_ERROR","validateDescInput","descBox","CUSTOM_SNIPPETS_DESC_LENGTH_ERROR","handleAbbrPaste","wasTruncated","hadSpaces","beforeCursor","afterCursor","finalValue","availableSpace","handleDescPaste","categorizeFileExtensionForMetrics"],"mappings":"AAoBAA,OAAO,SAAUC,QAASC,QAASC,QAC/B,MAAMC,YAAcH,QAAQ,qBACtBI,OAASJ,QAAQ,YACjBK,SAAWL,QAAQ,cACnBM,QAAUN,QAAQ,WAGlBO,wBAA0B,CAC5B,YACA,SACA,MACA,SACA,QACA,YACA,aACA,UACA,YACA,OACA,MACA,SACA,WACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,MACA,MACA,OAIJ,IAAIC,mBAAqB,IAAIC,IACzBC,uBAAyB,IAAID,IAC7BE,qBAAuB,GAO3B,SAASC,kBAAkBC,SACvB,MAAMC,iBAAmB,IAAKD,SAM9B,GAHAC,iBAAiBC,kBAAoBF,QAAQG,aAAaC,cAGd,QAAxCJ,QAAQK,cAAcD,cACtBH,iBAAiBK,iBAAmB,IAAIC,IAAI,CAAC,QAC7CN,iBAAiBO,sBAAuB,MACrC,CACH,MAAMC,WAAaT,QAAQK,cACtBD,cACAM,MAAM,KACNC,IAAIC,KAAOA,IAAIC,QACfC,OAAOF,KAAOA,KACnBX,iBAAiBK,iBAAmB,IAAIC,IAAIE,YAC5CR,iBAAiBO,sBAAuB,EAG5C,OAAOP,iBAQX,SAASc,6BAELpB,mBAAmBqB,QACnBnB,uBAAuBmB,QACvBlB,qBAAqBmB,OAAS,EAG9B1B,OAAO2B,iBAAiBC,QAAQnB,UAC5B,MAAMC,iBAAmBF,kBAAkBC,SAC3CF,qBAAqBsB,KAAKnB,kBAG1BJ,uBAAuBwB,IAAIpB,iBAAiBC,kBAAmBD,kBAG3DA,iBAAiBO,sBAEZb,mBAAmB2B,IAAI,QACxB3B,mBAAmB0B,IAAI,MAAO,IAAId,KAEtCZ,mBAAmB4B,IAAI,OAAOC,IAAIvB,mBAGlCA,iBAAiBK,iBAAiBa,QAAQP,MACjCjB,mBAAmB2B,IAAIV,MACxBjB,mBAAmB0B,IAAIT,IAAK,IAAIL,KAEpCZ,mBAAmB4B,IAAIX,KAAKY,IAAIvB,sBAahD,SAASwB,uBAAuBC,YAC5B,MAAMC,YAAc,CAChBC,WAAY,MACZC,IAAK,OACLC,KAAM,QACNC,IAAK,OACLC,OAAQ,MACRC,KAAM,QACNC,EAAG,KACHC,IAAK,OACLC,OAAQ,MACRC,WAAY,MACZC,KAAM,QACNC,IAAK,OACLC,IAAK,OACLC,KAAM,QACNC,KAAM,QACNC,KAAM,QACNC,OAAQ,QACRC,aAAc,UACdC,SAAU,MACVC,KAAM,OACNC,KAAM,MACNC,GAAI,MACJC,KAAM,MACNC,MAAO,SACPC,OAAQ,MACRC,KAAM,QACNC,IAAK,OACLC,IAAK,OACLC,IAAK,QAGT,OAAO7B,YAAYD,aAAeA,WAkBtC,SAAS+B,0BAA0BC,WAC/B,IAAKA,WAA2B,QAAdA,UACd,OAAOA,UAIPA,UAAUC,SAAS,OACnBD,UAAYA,UAAUE,QAAQ,OAAQ,MAG1C,IAAIC,OAAS,GAiCb,OAFAA,QAFAA,QAxBIA,OADAH,UAAUC,SAAS,KACVD,UACJhD,MAAM,KACNC,IAAKC,KAGU,OAFZA,IAAMA,IAAIC,SAEiB,KAARD,IACR,GAGJA,IAAIkD,WAAW,KAAOlD,IAAM,IAAMA,KAE5CE,OAAQF,KAAgB,KAARA,KAChBmD,KAAK,MAGQ,MAAdL,UACS,GAGAA,UAAUI,WAAW,KAAOJ,UAAY,IAAMA,WAK/CE,QAAQ,UAAW,KAAKA,QAAQ,QAAS,IAAIA,QAAQ,QAAS,IAAI/C,QAElEmD,SAAS,KAAOH,OAAOI,MAAM,GAAI,GAAKJ,OAW1D,SAASK,iBAEL,MAAM/D,aAAegE,EAAE,aAAaC,MAAMvD,OACpCwD,YAAcF,EAAE,aAAaC,MAAMvD,OACnCyD,aAAeH,EAAE,sBAAsBC,MAAMvD,OAC7CR,cAAgB8D,EAAE,kBAAkBC,MAAMvD,OAG1C0D,uBAAyBd,0BAA0BpD,eAEzD,MAAO,CACHF,aAAcA,aACdkE,YAAaA,aAAe,GAC5BC,aAAcA,aACdjE,cAAekE,wBAA0B,OAUjD,SAASC,6BAGL,MAAMC,WAAaN,EAAE,aACfO,eAAiBP,EAAE,sBAEnBQ,SAAWR,EAAE,4BAGbS,QAAUH,WAAWL,MAAMvD,OAAOI,OAAS,EAC3C4D,YAAcH,eAAeN,MAAMvD,OAAOI,OAAS,EACzD0D,SAASG,KAAK,aAAcF,SAAWC,cAU3C,SAASE,0BAA0BC,QAC/B,MAAMC,SAAWD,OAAOE,yBAClBxD,WAAauD,SAAWA,SAASE,QAAU,KACjD,OAAOzD,WAQX,SAAS0D,wBAAwBJ,QAC7B,MAAMK,SAAWL,QAAUA,OAAOM,UAAYN,OAAOM,SAASC,KAAOP,OAAOM,SAASC,KAAKC,cAAWC,EACrG,OAAIJ,SACOA,SAASK,UAAUL,SAASM,YAAY,MAAMvF,cAElD,KAYX,SAASwF,oCAAoC5F,QAAS6F,gBAAiBb,QAEnE,IACqC,IAAjChF,QAAQQ,sBACPR,QAAQK,eAAyD,QAAxCL,QAAQK,cAAcD,cAEhD,OAAO,EAIX,GAAIyF,gBAAiB,CACjB,MAAMC,mBAAqBrE,uBAAuBoE,iBAGlD,GAAIC,mBAAmBhC,WAAW,KAAM,CAEpC,GAAI9D,QAAQM,iBACR,OAAON,QAAQM,iBAAiBgB,IAAIwE,oBAGxC,MAAMC,oBAAsB/F,QAAQK,cAC/BD,cACAM,MAAM,KACNC,IAAKC,KAAQA,IAAIC,QACtB,OAAOkF,oBAAoBC,KAAMpF,KAAQA,MAAQkF,qBAKzD,GAAId,OAAQ,CACR,MAAM3E,cAAgB+E,wBAAwBJ,QAC9C,OAAOiB,yBAAyBjG,QAASK,eAG7C,OAAO,EASX,SAAS4F,yBAAyBjG,QAASK,eACvC,GAA4C,QAAxCL,QAAQK,cAAcD,cACtB,OAAO,EAGX,GAAIC,cAAe,CACf,MAAM0F,oBAAsB/F,QAAQK,cAC/BD,cACAM,MAAM,KACNC,IAAKC,KAAQA,IAAIC,QACtB,OAAOkF,oBAAoBC,KAAMpF,KAAQA,MAAQP,eAGrD,OAAO,EASX,SAAS6F,wBAAwBC,MAAOnB,QACpC,MAAMoB,WAAaD,MAAM/F,cACnByF,gBAAkBd,0BAA0BC,QAE5ChF,QAAUH,uBAAuB0B,IAAI6E,YAC3C,QAAIpG,SACO4F,oCAAoC5F,QAAS6F,gBAAiBb,QAY7E,SAASqB,oBAAoBF,MAAOnB,QAChC,MAAMoB,WAAaD,MAAM/F,cACnByF,gBAAkBd,0BAA0BC,QAGlD,IAAIsB,kBAAoB,IAAI/F,IAG5B,MAAMgG,kBAAoB5G,mBAAmB4B,IAAI,OAMjD,GALIgF,mBACAA,kBAAkBpF,QAAQnB,SAAWsG,kBAAkB9E,IAAIxB,UAI3D6F,gBAAiB,CACjB,MAAMC,mBAAqBrE,uBAAuBoE,iBAClD,GAAIC,mBAAmBhC,WAAW,KAAM,CACpC,MAAM0C,iBAAmB7G,mBAAmB4B,IAAIuE,oBAC5CU,kBACAA,iBAAiBrF,QAAQnB,SAAWsG,kBAAkB9E,IAAIxB,WAMvC,IAA3BsG,kBAAkBG,OAClBH,kBAAoB,IAAI/F,IAAIT,uBAIhC,MAAM4G,iBAAmBC,MAAMC,KAAKN,mBAAmBxF,OAAQd,SACpDA,QAAQE,kBAAkB4D,WAAWsC,aAIhD,OAAOM,iBAAiBG,KAAK,CAACC,EAAGC,KAE7B,MAAMC,OAASF,EAAE5G,oBAAsBkG,WACjCa,OAASF,EAAE7G,oBAAsBkG,WAGvC,OAAIY,SAAWC,QACH,EAERA,SAAWD,OACJ,EAGJF,EAAE5G,kBAAkBgH,cAAcH,EAAE7G,qBAcnD,SAASiH,eAAeC,KAAMjB,MAAO9B,aACjC,IAAIgD,MAAQlD,EAAE,UACTmD,SAAS,0DACTC,KAAK,WAAYH,MACjBG,KAAK,wBAAwB,GAQlC,GALIlD,aAAsC,KAAvBA,YAAYxD,QAC3BwG,MAAME,KAAK,QAASlD,YAAYxD,QAIhCsF,OAASA,MAAMlF,OAAS,EAAG,CAE3B,MAAMuG,YAAclI,YAAYmI,YAAYL,KAAMjB,MAAO,CAAEuB,qBAAqB,IAC5EF,aAAeA,YAAYG,aAC3BH,YAAYG,aAAaxG,QAAQ,SAAUyG,MACnCA,KAAKC,QACLR,MAAMS,OAAO3D,EAAE,UAAU4D,KAAKH,KAAKG,MAAMT,SAAS,iBAElDD,MAAMS,OAAOF,KAAKG,QAI1BV,MAAMU,KAAKX,WAGfC,MAAMU,KAAKX,MAIf,IAAIY,MAAQ7D,gFAAgF1E,QAAQwI,kCAGpG,GAFAZ,MAAMS,OAAOE,OAET3D,aAAsC,KAAvBA,YAAYxD,OAAe,CAC1C,MAAMqH,gBAAkB7D,YAAYxD,OAE9BsH,mBACFD,gBAAgBjH,OAAS,GAAKiH,gBAAgBxC,UAAU,EAAG,IAAM,MAAQwC,gBAEvEE,MAAQjE,uCAAuCgE,6BACrDd,MAAMS,OAAOM,OAGjB,OAAOf,MAOX,SAASgB,sBACLlE,EAAE,aAAaC,IAAI,IACnBD,EAAE,aAAaC,IAAI,IACnBD,EAAE,sBAAsBC,IAAI,IAC5BD,EAAE,kBAAkBC,IAAI,IAO5B,SAASkE,iBAAiBC,aACtBpE,EAAE,kBAAkBC,IAAImE,YAAYpI,cACpCgE,EAAE,kBAAkBC,IAAImE,YAAYlE,aAAe,IACnDF,EAAE,2BAA2BC,IAAImE,YAAYjE,cAC7CH,EAAE,uBAAuBC,IAAkC,QAA9BmE,YAAYlI,cAA0B,GAAKkI,YAAYlI,eAOxF,SAASmI,qBAEL,MAAMrI,aAAegE,EAAE,kBAAkBC,MAAMvD,OACzCwD,YAAcF,EAAE,kBAAkBC,MAAMvD,OACxCyD,aAAeH,EAAE,2BAA2BC,MAAMvD,OAClDR,cAAgB8D,EAAE,uBAAuBC,MAAMvD,OAG/C0D,uBAAyBd,0BAA0BpD,eAEzD,MAAO,CACHF,aAAcA,aACdkE,YAAaA,aAAe,GAC5BC,aAAcA,aACdjE,cAAekE,wBAA0B,OAOjD,SAASkE,iCAEL,MAAMhE,WAAaN,EAAE,kBACfO,eAAiBP,EAAE,2BAEnBQ,SAAWR,EAAE,0BAGbS,QAAUH,WAAWL,MAAMvD,OAAOI,OAAS,EAC3C4D,YAAcH,eAAeN,MAAMvD,OAAOI,OAAS,EACzD0D,SAASG,KAAK,aAAcF,SAAWC,cAM3C,SAAS6D,uBACLvE,EAAE,kBAAkBC,IAAI,IACxBD,EAAE,kBAAkBC,IAAI,IACxBD,EAAE,2BAA2BC,IAAI,IACjCD,EAAE,uBAAuBC,IAAI,IAOjC,SAASuE,sBACL,MAAMC,MAAQrJ,OAAO2B,iBAAiBD,OAChC4H,WAAa1E,EAAE,mBACjByE,MAAQ,EACRC,WAAWd,SAASa,UAEpBC,WAAWd,KAAK,IAUxB,SAASe,2BAA2BC,OAIhC,OADAA,OADAA,OADAA,MAAQA,MAAMnF,QAAQ,iBAAkB,KAC1BA,QAAQ,UAAW,MACnBA,QAAQ,WAAY,MAStC,SAASoF,yBAAyBC,QAC9B,IAAIF,MACJ,MAAMG,eAAiBJ,2BADXG,OAAO7E,OAEnB6E,OAAO7E,IAAI8E,gBAGe,uBAAtBD,OAAO1B,KAAK,MACZkB,iCAEAjE,6BAWR,SAAS2E,4BAA4BC,EAAGC,OACpC,MAAMC,KAAOC,OAAOC,aAAaJ,EAAEK,OAC7BC,QAAU,iBAGhB,MAAa,MAATJ,MAA0C,MAA1BD,MAAMN,MAAM9E,OAAO,IACnCmF,EAAEO,kBACK,KAGND,QAAQE,KAAKN,QACdF,EAAEO,kBACK,GAYf,SAASE,yBAAyBT,EAAGH,QACjCG,EAAEO,iBAEF,MAAMG,eAAiBV,EAAEW,eAAiBX,GAAGU,cAAcE,QAAQ,QACnE,IAAIC,UAAYnB,2BAA2BgB,eAG3C,MAAMT,MAAQJ,OAAO,GACfiB,MAAQb,MAAMc,eACdC,IAAMf,MAAMgB,aACZC,aAAejB,MAAMN,MAE3BM,MAAMN,MAAQuB,aAAa5E,UAAU,EAAGwE,OAASD,UAAYK,aAAa5E,UAAU0E,KAGpF,MAAMG,OAASL,MAAQD,UAAUhJ,OACjCoI,MAAMmB,kBAAkBD,OAAQA,QAGN,uBAAtBtB,OAAO1B,KAAK,MACZkB,iCAEAjE,6BAUR,SAASiG,qBAAqBrB,EAAGsB,UAE7B,GAAkB,IAAdtB,EAAEuB,SAA6B,IAAZvB,EAAEK,MAAa,CAClCL,EAAEO,iBAEF,MAAMO,MAAQQ,SAASP,eACjBC,IAAMM,SAASL,aACftB,MAAQ2B,SAAS3B,MAGvB2B,SAAS3B,MAAQA,MAAMrD,UAAU,EAAGwE,OAAS,KAAOnB,MAAMrD,UAAU0E,KACpEM,SAASP,eAAiBO,SAASL,aAAeH,MAAQ,EAC1D/F,EAAEuG,UAAUE,QAAQ,UAI5B,SAASC,kBAAkBzB,EAAG0B,SAE1B,KAAI1B,EAAE2B,SAAW3B,EAAE4B,SAAW5B,EAAE6B,QAK5BvL,wBAAwBiE,SAASyF,EAAE8B,MAKvC,GAAc,MAAV9B,EAAE8B,KAcN,GACIJ,QAAQ/B,MAAM9H,QAAU,IACP,IAAjBmI,EAAE8B,IAAIjK,QACNmI,EAAE8B,IAAIC,MAAM,kDACd,CACE/B,EAAEO,iBAGF,MAAMyB,WAA4B,kBAAfN,QAAQO,GACrBC,QAAUF,WAAa,gBAAkB,WACzCG,UAAYH,WAAa,wBAA0B,mBACnDI,QAAUJ,WAAa,iCAAmC,4BAEhE5L,SAASiM,UAAUH,QAASC,UAAW9L,QAAQiM,kCAAmCF,cA3BtF,CACIpC,EAAEO,iBAGF,MAAMyB,WAA4B,kBAAfN,QAAQO,GACrBC,QAAUF,WAAa,gBAAkB,WACzCG,UAAYH,WAAa,wBAA0B,mBACnDI,QAAUJ,WAAa,gCAAkC,2BAE/D5L,SAASiM,UAAUH,QAASC,UAAW9L,QAAQkM,4BAA6BH,UAsBpF,SAASI,kBAAkBxC,EAAGyC,SAE1B,KAAIzC,EAAE2B,SAAW3B,EAAE4B,SAAW5B,EAAE6B,UAK5BvL,wBAAwBiE,SAASyF,EAAE8B,MAMnCW,QAAQ9C,MAAM9H,QAAU,IACP,IAAjBmI,EAAE8B,IAAIjK,QACNmI,EAAE8B,IAAIC,MAAM,oDACd,CACE/B,EAAEO,iBAGF,MAAMyB,WAA4B,kBAAfS,QAAQR,GACrBC,QAAUF,WAAa,gBAAkB,WACzCG,UAAYH,WAAa,wBAA0B,mBACnDI,QAAUJ,WAAa,gCAAkC,2BAE/D5L,SAASiM,UAAUH,QAASC,UAAW9L,QAAQqM,kCAAmCN,UAS1F,SAASO,gBAAgB3C,EAAGH,QACxBG,EAAEO,iBAEF,MAAMG,eAAiBV,EAAEW,eAAiBX,GAAGU,cAAcE,QAAQ,QAGnE,IAAIC,UAAYH,cAAclG,QAAQ,MAAO,IACzCoI,cAAe,EACfC,UAAYnC,gBAAkBG,UAE9BA,UAAUhJ,OAAS,KACnBgJ,UAAYA,UAAUvE,UAAU,EAAG,IACnCsG,cAAe,GAInB,MAAM3C,MAAQJ,OAAO,GACfiB,MAAQb,MAAMc,eACdC,IAAMf,MAAMgB,aACZC,aAAejB,MAAMN,MAGrBmD,aAAe5B,aAAa5E,UAAU,EAAGwE,OACzCiC,YAAc7B,aAAa5E,UAAU0E,KACrCgC,WAAaF,aAAejC,UAAYkC,YAE9C,GAAIC,WAAWnL,OAAS,GAAI,CAExB,MAAMoL,eAAiB,IAAMH,aAAajL,OAASkL,YAAYlL,QAC3DoL,eAAiB,GACjBpC,UAAYA,UAAUvE,UAAU,EAAG2G,gBACnCL,cAAe,IAEf/B,UAAY,GACZ+B,cAAe,GAKvB3C,MAAMN,MAAQmD,aAAejC,UAAYkC,YAGzC,MAAM5B,OAASL,MAAQD,UAAUhJ,OAIjC,GAHAoI,MAAMmB,kBAAkBD,OAAQA,QAG5ByB,cAAgBC,UAAW,CAC3B,MAAMb,WAAmC,kBAAtBnC,OAAO1B,KAAK,MACzB+D,QAAUF,WAAa,gBAAkB,WACzCG,UAAYH,WAAa,wBAA0B,mBAGzD,GAAIY,aAAc,CACd,MAAMR,QAAUJ,WAAa,uCAAyC,kCACtE5L,SAASiM,UAAUH,QAASC,UAAW9L,QAAQiM,kCAAmCF,cAC/E,GAAIS,UAAW,CAClB,MAAMT,QAAUJ,WAAa,sCAAwC,iCACrE5L,SAASiM,UAAUH,QAASC,UAAW9L,QAAQkM,4BAA6BH,UAK1D,kBAAtBvC,OAAO1B,KAAK,MACZkB,iCAEAjE,6BASR,SAAS8H,gBAAgBlD,EAAGH,QACxBG,EAAEO,iBAEF,MAAMG,eAAiBV,EAAEW,eAAiBX,GAAGU,cAAcE,QAAQ,QAGnE,IAAIC,UAAYH,cACZkC,cAAe,EAEf/B,UAAUhJ,OAAS,KACnBgJ,UAAYA,UAAUvE,UAAU,EAAG,IACnCsG,cAAe,GAInB,MAAM3C,MAAQJ,OAAO,GACfiB,MAAQb,MAAMc,eACdC,IAAMf,MAAMgB,aACZC,aAAejB,MAAMN,MAGrBmD,aAAe5B,aAAa5E,UAAU,EAAGwE,OACzCiC,YAAc7B,aAAa5E,UAAU0E,KACrCgC,WAAaF,aAAejC,UAAYkC,YAE9C,GAAIC,WAAWnL,OAAS,GAAI,CAExB,MAAMoL,eAAiB,IAAMH,aAAajL,OAASkL,YAAYlL,QAC3DoL,eAAiB,GACjBpC,UAAYA,UAAUvE,UAAU,EAAG2G,gBACnCL,cAAe,IAEf/B,UAAY,GACZ+B,cAAe,GAKvB3C,MAAMN,MAAQmD,aAAejC,UAAYkC,YAGzC,MAAM5B,OAASL,MAAQD,UAAUhJ,OAIjC,GAHAoI,MAAMmB,kBAAkBD,OAAQA,QAG5ByB,aAAc,CACd,MAAMZ,WAAmC,kBAAtBnC,OAAO1B,KAAK,MACzB+D,QAAUF,WAAa,gBAAkB,WACzCG,UAAYH,WAAa,wBAA0B,mBACnDI,QAAUJ,WAAa,sCAAwC,iCAErE5L,SAASiM,UAAUH,QAASC,UAAW9L,QAAQqM,kCAAmCN,SAI5D,kBAAtBvC,OAAO1B,KAAK,MACZkB,iCAEAjE,6BASR,SAAS+H,kCAAkClM,eACvC,OAAKA,eAAmC,QAAlBA,cAKf,OAJI,MAOfjB,QAAQoF,2BAA6BA,2BACrCpF,QAAQ+H,eAAiBA,eACzB/H,QAAQiJ,oBAAsBA,oBAC9BjJ,QAAQ8E,eAAiBA,eACzB9E,QAAQ2F,0BAA4BA,0BACpC3F,QAAQgG,wBAA0BA,wBAClChG,QAAQqC,uBAAyBA,uBACjCrC,QAAQ2B,2BAA6BA,2BACrC3B,QAAQwG,oCAAsCA,oCAC9CxG,QAAQ6G,yBAA2BA,yBACnC7G,QAAQ8G,wBAA0BA,wBAClC9G,QAAQiH,oBAAsBA,oBAC9BjH,QAAQuJ,oBAAsBA,oBAC9BvJ,QAAQ0J,2BAA6BA,2BACrC1J,QAAQ4J,yBAA2BA,yBACnC5J,QAAQ+J,4BAA8BA,4BACtC/J,QAAQyK,yBAA2BA,yBACnCzK,QAAQkJ,iBAAmBA,iBAC3BlJ,QAAQoJ,mBAAqBA,mBAC7BpJ,QAAQqJ,+BAAiCA,+BACzCrJ,QAAQmN,kCAAoCA,kCAC5CnN,QAAQsJ,qBAAuBA,qBAC/BtJ,QAAQqL,qBAAuBA,qBAC/BrL,QAAQyL,kBAAoBA,kBAC5BzL,QAAQwM,kBAAoBA,kBAC5BxM,QAAQ2M,gBAAkBA,gBAC1B3M,QAAQkN,gBAAkBA","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\ndefine(function (require, exports, module) {\n    const StringMatch = require(\"utils/StringMatch\");\n    const Global = require(\"./global\");\n    const UIHelper = require(\"./UIHelper\");\n    const Strings = require(\"strings\");\n\n    // list of all the navigation and function keys that are allowed inside the input fields\n    const ALLOWED_NAVIGATION_KEYS = [\n        \"Backspace\",\n        \"Delete\",\n        \"Tab\",\n        \"Escape\",\n        \"Enter\",\n        \"ArrowLeft\",\n        \"ArrowRight\",\n        \"ArrowUp\",\n        \"ArrowDown\",\n        \"Home\",\n        \"End\",\n        \"PageUp\",\n        \"PageDown\",\n        \"F1\",\n        \"F2\",\n        \"F3\",\n        \"F4\",\n        \"F5\",\n        \"F6\",\n        \"F7\",\n        \"F8\",\n        \"F9\",\n        \"F10\",\n        \"F11\",\n        \"F12\"\n    ];\n\n    // Optimized data structures for fast snippet lookups\n    let snippetsByLanguage = new Map();\n    let snippetsByAbbreviation = new Map();\n    let allSnippetsOptimized = [];\n\n    /**\n     * Preprocesses a snippet to add optimized lookup properties\n     * @param {Object} snippet - The original snippet object\n     * @returns {Object} - The snippet with added optimization properties\n     */\n    function preprocessSnippet(snippet) {\n        const optimizedSnippet = { ...snippet };\n\n        // pre-compute lowercase abbreviation for faster matching\n        optimizedSnippet.abbreviationLower = snippet.abbreviation.toLowerCase();\n\n        // parse and create a Set of supported extensions for O(1) lookup\n        if (snippet.fileExtension.toLowerCase() === \"all\") {\n            optimizedSnippet.supportedLangSet = new Set([\"all\"]);\n            optimizedSnippet.supportsAllLanguages = true;\n        } else {\n            const extensions = snippet.fileExtension\n                .toLowerCase()\n                .split(\",\")\n                .map(ext => ext.trim())\n                .filter(ext => ext);\n            optimizedSnippet.supportedLangSet = new Set(extensions);\n            optimizedSnippet.supportsAllLanguages = false;\n        }\n\n        return optimizedSnippet;\n    }\n\n    /**\n     * Rebuilds optimized data structures from the current snippet list\n     * we call this function whenever snippets are loaded, added, modified, or deleted\n     * i.e. whenever the snippetList is updated\n     */\n    function rebuildOptimizedStructures() {\n        // clear existing structures\n        snippetsByLanguage.clear();\n        snippetsByAbbreviation.clear();\n        allSnippetsOptimized.length = 0;\n\n        // Process each snippet\n        Global.SnippetHintsList.forEach(snippet => {\n            const optimizedSnippet = preprocessSnippet(snippet);\n            allSnippetsOptimized.push(optimizedSnippet);\n\n            // Index by abbreviation (lowercase) for exact matches\n            snippetsByAbbreviation.set(optimizedSnippet.abbreviationLower, optimizedSnippet);\n\n            // Index by supported languages/extensions\n            if (optimizedSnippet.supportsAllLanguages) {\n                // Add to a special \"all\" key for universal snippets\n                if (!snippetsByLanguage.has(\"all\")) {\n                    snippetsByLanguage.set(\"all\", new Set());\n                }\n                snippetsByLanguage.get(\"all\").add(optimizedSnippet);\n            } else {\n                // Add to each supported extension\n                optimizedSnippet.supportedLangSet.forEach(ext => {\n                    if (!snippetsByLanguage.has(ext)) {\n                        snippetsByLanguage.set(ext, new Set());\n                    }\n                    snippetsByLanguage.get(ext).add(optimizedSnippet);\n                });\n            }\n        });\n    }\n\n    /**\n     * map the language IDs to their file extensions for snippet matching\n     * this is needed because we expect the user to enter file extensions and not the file type inside the input field\n     *\n     * @param {string} languageId - The language ID from Phoenix\n     * @returns {string} - The equivalent file extension for snippet matching\n     */\n    function mapLanguageToExtension(languageId) {\n        const languageMap = {\n            javascript: \".js\",\n            css: \".css\",\n            html: \".html\",\n            php: \".php\",\n            python: \".py\",\n            java: \".java\",\n            c: \".c\",\n            cpp: \".cpp\",\n            csharp: \".cs\",\n            typescript: \".ts\",\n            json: \".json\",\n            xml: \".xml\",\n            sql: \".sql\",\n            sass: \".sass\",\n            scss: \".scss\",\n            less: \".less\",\n            stylus: \".styl\",\n            coffeescript: \".coffee\",\n            markdown: \".md\",\n            yaml: \".yml\",\n            ruby: \".rb\",\n            go: \".go\",\n            rust: \".rs\",\n            swift: \".swift\",\n            kotlin: \".kt\",\n            dart: \".dart\",\n            vue: \".vue\",\n            jsx: \".jsx\",\n            tsx: \".tsx\"\n        };\n\n        return languageMap[languageId] || languageId;\n    }\n\n    /**\n     * This function is to make sure file extensions are properly formatted with leading dots\n     * because user may provide values in not very consistent manner, we need to handle all those cases\n     * For ex: what we expect: `.js, .html, .css`\n     * what user may provide: `js, html, css` or: `js html css` etc\n     *\n     * This function processes file extensions in various formats and ensures they:\n     * - Have a leading dot (if not empty or \"all\")\n     * - Are properly separated with commas and spaces\n     * - Don't contain empty or standalone dots\n     * - No consecutive commas\n     *\n     * @param {string} extension - The file extension(s) to process\n     * @returns {string} - The properly formatted file extension(s)\n     */\n    function processFileExtensionInput(extension) {\n        if (!extension || extension === \"all\") {\n            return extension;\n        }\n\n        // Step 1: normalize the input by converting spaces to commas if no commas exist\n        if (extension.includes(\" \")) {\n            extension = extension.replace(/\\s+/g, \",\");\n        }\n\n        let result = \"\";\n\n        // Step 2: process comma-separated extensions FIRST (before dot-separated)\n        // this prevents issues with inputs like \".js,.html,.\" or \".js,,.html\"\n        if (extension.includes(\",\")) {\n            result = extension\n                .split(\",\")\n                .map((ext) => {\n                    ext = ext.trim();\n                    // skip all the standalone dots or empty entries\n                    if (ext === \".\" || ext === \"\") {\n                        return \"\";\n                    }\n                    // Add leading dot if missing\n                    return ext.startsWith(\".\") ? ext : \".\" + ext;\n                })\n                .filter((ext) => ext !== \"\") // Remove empty entries\n                .join(\", \");\n        } else {\n            // Step 3: Handle single extension\n            if (extension === \".\") {\n                result = \"\"; // remove standalone dot\n            } else {\n                // Add leading dot if missing\n                result = extension.startsWith(\".\") ? extension : \".\" + extension;\n            }\n        }\n\n        // this is just the final safeguard to remove any consecutive commas and clean up spacing\n        result = result.replace(/,\\s*,+/g, \",\").replace(/,\\s*$/, \"\").replace(/^\\s*,/, \"\").trim();\n        // remove trailing dots (like .css. -> .css)\n        result = result.endsWith('.') ? result.slice(0, -1) : result;\n\n        return result;\n    }\n\n    /**\n     * This function is responsible to get the snippet data from all the required input fields\n     * it is called when the save button is clicked\n     * @private\n     * @returns {object} - a snippet object\n     */\n    function getSnippetData() {\n        // get the values from all the input fields\n        const abbreviation = $(\"#abbr-box\").val().trim();\n        const description = $(\"#desc-box\").val().trim();\n        const templateText = $(\"#template-text-box\").val().trim();\n        const fileExtension = $(\"#file-extn-box\").val().trim();\n\n        // process the file extension so that we can get the value in the required format\n        const processedFileExtension = processFileExtensionInput(fileExtension);\n\n        return {\n            abbreviation: abbreviation,\n            description: description || \"\", // allow empty description\n            templateText: templateText,\n            fileExtension: processedFileExtension || \"all\" // default to \"all\" if empty\n        };\n    }\n\n    /**\n     * This function is responsible to enable/disable the save button\n     * when all the required input fields are not filled up as required then we need to disable the save button\n     * otherwise we enable it\n     * this is called inside the '_registerHandlers' function in the main.js file\n     */\n    function toggleSaveButtonDisability() {\n        // abbreviation and template text are required fields\n        // they both should have some value only then save button will be enabled\n        const $abbrInput = $(\"#abbr-box\");\n        const $templateInput = $(\"#template-text-box\");\n\n        const $saveBtn = $(\"#save-custom-snippet-btn\");\n\n        // make sure that the required fields has some value\n        const hasAbbr = $abbrInput.val().trim().length > 0;\n        const hasTemplate = $templateInput.val().trim().length > 0;\n        $saveBtn.prop(\"disabled\", !(hasAbbr && hasTemplate));\n    }\n\n    /**\n     * this function is responsible to get the current language context,\n     * from the editor at cursor position\n     *\n     * @param {Editor} editor - The editor instance\n     * @returns {string|null} - The language ID or null if not available\n     */\n    function getCurrentLanguageContext(editor) {\n        const language = editor.getLanguageForPosition();\n        const languageId = language ? language.getId() : null;\n        return languageId;\n    }\n\n    /**\n     * Gets the current file extension from the editor\n     * @param {Editor} editor - The editor instance\n     * @returns {string|null} - The file extension or null if not available\n     */\n    function getCurrentFileExtension(editor) {\n        const filePath = editor && editor.document && editor.document.file ? editor.document.file.fullPath : undefined;\n        if (filePath) {\n            return filePath.substring(filePath.lastIndexOf(\".\")).toLowerCase();\n        }\n        return null;\n    }\n\n    /**\n     * Checks if a snippet is supported in the given language context\n     * Falls back to file extension matching if language mapping isn't available\n     *\n     * @param {Object} snippet - The snippet object (optimized or regular)\n     * @param {string|null} languageContext - The current language context\n     * @param {Editor} editor - The editor instance for fallback\n     * @returns {boolean} - True if the snippet is supported\n     */\n    function isSnippetSupportedInLanguageContext(snippet, languageContext, editor) {\n        // Check for \"all\" languages support (both optimized and non-optimized)\n        if (\n            snippet.supportsAllLanguages === true ||\n            (snippet.fileExtension && snippet.fileExtension.toLowerCase() === \"all\")\n        ) {\n            return true;\n        }\n\n        // Try language context matching if available\n        if (languageContext) {\n            const effectiveExtension = mapLanguageToExtension(languageContext);\n\n            // if we have a proper mapping (starts with .), use language context matching\n            if (effectiveExtension.startsWith(\".\")) {\n                // Use optimized path if available\n                if (snippet.supportedLangSet) {\n                    return snippet.supportedLangSet.has(effectiveExtension);\n                }\n                // Fallback for non-optimized snippets\n                const supportedExtensions = snippet.fileExtension\n                    .toLowerCase()\n                    .split(\",\")\n                    .map((ext) => ext.trim());\n                return supportedExtensions.some((ext) => ext === effectiveExtension);\n            }\n        }\n\n        // final fallback for file extension matching if language context matching failed\n        if (editor) {\n            const fileExtension = getCurrentFileExtension(editor);\n            return isSnippetSupportedInFile(snippet, fileExtension);\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks if a snippet is supported in the given file extension\n     * @param {Object} snippet - The snippet object\n     * @param {string|null} fileExtension - The current file extension\n     * @returns {boolean} - True if the snippet is supported\n     */\n    function isSnippetSupportedInFile(snippet, fileExtension) {\n        if (snippet.fileExtension.toLowerCase() === \"all\") {\n            return true;\n        }\n\n        if (fileExtension) {\n            const supportedExtensions = snippet.fileExtension\n                .toLowerCase()\n                .split(\",\")\n                .map((ext) => ext.trim());\n            return supportedExtensions.some((ext) => ext === fileExtension);\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks if there's at least one exact match for the query\n     * @param {string} query - The search query\n     * @param {Editor} editor - The editor instance\n     * @returns {boolean} - True if there's an exact match\n     */\n    function hasExactMatchingSnippet(query, editor) {\n        const queryLower = query.toLowerCase();\n        const languageContext = getCurrentLanguageContext(editor);\n\n        const snippet = snippetsByAbbreviation.get(queryLower);\n        if (snippet) {\n            return isSnippetSupportedInLanguageContext(snippet, languageContext, editor);\n        }\n\n        return false;\n    }\n\n    /**\n     * Gets all snippets that match the query (prefix matches)\n     * @param {string} query - The search query\n     * @param {Editor} editor - The editor instance\n     * @returns {Array} - an array of matching snippets, sorted with exact matches first\n     */\n    function getMatchingSnippets(query, editor) {\n        const queryLower = query.toLowerCase();\n        const languageContext = getCurrentLanguageContext(editor);\n\n        // Get the candidate snippets for the current language/extension\n        let candidateSnippets = new Set();\n\n        // Add universal snippets (support \"all\" languages)\n        const universalSnippets = snippetsByLanguage.get(\"all\");\n        if (universalSnippets) {\n            universalSnippets.forEach(snippet => candidateSnippets.add(snippet));\n        }\n\n        // Add language-specific snippets\n        if (languageContext) {\n            const effectiveExtension = mapLanguageToExtension(languageContext);\n            if (effectiveExtension.startsWith(\".\")) {\n                const languageSnippets = snippetsByLanguage.get(effectiveExtension);\n                if (languageSnippets) {\n                    languageSnippets.forEach(snippet => candidateSnippets.add(snippet));\n                }\n            }\n        }\n\n        // Fallback: if we can't determine language, check all snippets\n        if (candidateSnippets.size === 0) {\n            candidateSnippets = new Set(allSnippetsOptimized);\n        }\n\n        // Filter candidates by prefix match using pre-computed lowercase abbreviations\n        const matchingSnippets = Array.from(candidateSnippets).filter((snippet) => {\n            return snippet.abbreviationLower.startsWith(queryLower);\n        });\n\n        // sort snippets so that the exact matches will appear over the partial matches\n        return matchingSnippets.sort((a, b) => {\n            // check if either is an exact match\n            const aExact = a.abbreviationLower === queryLower;\n            const bExact = b.abbreviationLower === queryLower;\n\n            // because exact matches appear first\n            if (aExact && !bExact) {\n                return -1;\n            }\n            if (bExact && !aExact) {\n                return 1;\n            }\n\n            return a.abbreviationLower.localeCompare(b.abbreviationLower);\n        });\n    }\n\n    /**\n     * this function is responsible to create a hint item\n     * this is needed because along with the abbr in the code hint, we also want to show an icon saying 'Snippet',\n     * to give users an idea that this hint is coming from snippets\n     * this function is called inside the 'getHints' method in the codeHints.js file\n     * @param   {String} abbr - the abbreviation text that is to be displayed in the code hint\n     * @param   {String} query - the query string typed by the user for highlighting matching characters\n     * @param   {String} description - the description of the snippet to be displayed\n     * @returns {JQuery} - the jquery item that has the abbr text and the Snippet icon\n     */\n    function createHintItem(abbr, query, description) {\n        var $hint = $(\"<span>\")\n            .addClass(\"brackets-css-hints brackets-hints custom-snippets-hint\")\n            .attr(\"data-val\", abbr)\n            .attr(\"data-isCustomSnippet\", true);\n\n        // add the tooltip for the description shown when the hint is hovered\n        if (description && description.trim() !== \"\") {\n            $hint.attr(\"title\", description.trim());\n        }\n\n        // create highlighting for matching characters like other hint providers\n        if (query && query.length > 0) {\n            // use the StringMatch to get proper highlighting ranges\n            const matchResult = StringMatch.stringMatch(abbr, query, { preferPrefixMatches: true });\n            if (matchResult && matchResult.stringRanges) {\n                matchResult.stringRanges.forEach(function (item) {\n                    if (item.matched) {\n                        $hint.append($(\"<span>\").text(item.text).addClass(\"matched-hint\"));\n                    } else {\n                        $hint.append(item.text);\n                    }\n                });\n            } else {\n                $hint.text(abbr);\n            }\n        } else {\n            $hint.text(abbr);\n        }\n\n        // the codehints related style is written in brackets_patterns_override.less file\n        let $icon = $(`<a href=\"#\" class=\"custom-snippet-code-hint\" style=\"text-decoration: none\">${Strings.CUSTOM_SNIPPETS_HINT_LABEL}</a>`);\n        $hint.append($icon);\n\n        if (description && description.trim() !== \"\") {\n            const fullDescription = description.trim();\n            // truncate description if longer than 80 characters\n            const displayDescription =\n                fullDescription.length > 80 ? fullDescription.substring(0, 80) + \"...\" : fullDescription;\n\n            const $desc = $(`<span class=\"snippet-description\">${displayDescription}</span>`);\n            $hint.append($desc);\n        }\n\n        return $hint;\n    }\n\n    /**\n     * This function is responsible to clear all the input fields.\n     * when the save button is clicked we get the data from the input fields and then clear all of them\n     */\n    function clearAllInputFields() {\n        $(\"#abbr-box\").val(\"\");\n        $(\"#desc-box\").val(\"\");\n        $(\"#template-text-box\").val(\"\");\n        $(\"#file-extn-box\").val(\"\");\n    }\n\n    /**\n     * This function populates the edit form with snippet data\n     * @param {Object} snippetData - The snippet object to edit\n     */\n    function populateEditForm(snippetData) {\n        $(\"#edit-abbr-box\").val(snippetData.abbreviation);\n        $(\"#edit-desc-box\").val(snippetData.description || \"\");\n        $(\"#edit-template-text-box\").val(snippetData.templateText);\n        $(\"#edit-file-extn-box\").val(snippetData.fileExtension === \"all\" ? \"\" : snippetData.fileExtension);\n    }\n\n    /**\n     * This function is responsible to get the snippet data from all the edit form input fields\n     * @returns {object} - a snippet object\n     */\n    function getEditSnippetData() {\n        // get the values from all the edit input fields\n        const abbreviation = $(\"#edit-abbr-box\").val().trim();\n        const description = $(\"#edit-desc-box\").val().trim();\n        const templateText = $(\"#edit-template-text-box\").val().trim();\n        const fileExtension = $(\"#edit-file-extn-box\").val().trim();\n\n        // process the file extension so that we can get the value in the required format\n        const processedFileExtension = processFileExtensionInput(fileExtension);\n\n        return {\n            abbreviation: abbreviation,\n            description: description || \"\", // allow empty description\n            templateText: templateText,\n            fileExtension: processedFileExtension || \"all\" // default to \"all\" if empty\n        };\n    }\n\n    /**\n     * This function is responsible to enable/disable the save button in edit mode\n     */\n    function toggleEditSaveButtonDisability() {\n        // abbreviation and template text are required fields\n        const $abbrInput = $(\"#edit-abbr-box\");\n        const $templateInput = $(\"#edit-template-text-box\");\n\n        const $saveBtn = $(\"#save-edit-snippet-btn\");\n\n        // make sure that the required fields has some value\n        const hasAbbr = $abbrInput.val().trim().length > 0;\n        const hasTemplate = $templateInput.val().trim().length > 0;\n        $saveBtn.prop(\"disabled\", !(hasAbbr && hasTemplate));\n    }\n\n    /**\n     * This function clears all the edit form input fields\n     */\n    function clearEditInputFields() {\n        $(\"#edit-abbr-box\").val(\"\");\n        $(\"#edit-desc-box\").val(\"\");\n        $(\"#edit-template-text-box\").val(\"\");\n        $(\"#edit-file-extn-box\").val(\"\");\n    }\n\n    /**\n     * Updates the snippets count which is displayed in the toolbar at the left side\n     * @private\n     */\n    function updateSnippetsCount() {\n        const count = Global.SnippetHintsList.length;\n        const $countSpan = $(\"#snippets-count\");\n        if (count > 0) {\n            $countSpan.text(`(${count})`);\n        } else {\n            $countSpan.text(\"\");\n        }\n    }\n\n    /**\n     * validates and sanitizes file extension input\n     *\n     * @param {string} value - The input value to sanitize\n     * @returns {string} - The sanitized value\n     */\n    function sanitizeFileExtensionInput(value) {\n        value = value.replace(/[^a-zA-Z,.\\s]/g, \"\"); // we only allow a-z, A-Z, comma, dot, space\n        value = value.replace(/\\.{2,}/g, \".\"); // don't allow 2 consecutive dots\n        value = value.replace(/(\\.)\\1+/g, \"$1\"); // prevent two dots next to each other\n        return value;\n    }\n\n    /**\n     * handles file extension input event with validation\n     *\n     * @param {jQuery} $input - The input element\n     */\n    function handleFileExtensionInput($input) {\n        let value = $input.val();\n        const sanitizedValue = sanitizeFileExtensionInput(value);\n        $input.val(sanitizedValue);\n\n        // determine which save button to toggle based on input field\n        if ($input.attr(\"id\") === \"edit-file-extn-box\") {\n            toggleEditSaveButtonDisability();\n        } else {\n            toggleSaveButtonDisability();\n        }\n    }\n\n    /**\n     * Handles file extension keypress event validation\n     *\n     * @param {Event} e - The keypress event\n     * @param {HTMLElement} input - The input element\n     * @returns {boolean} - Whether to allow the keypress\n     */\n    function handleFileExtensionKeypress(e, input) {\n        const char = String.fromCharCode(e.which);\n        const allowed = /^[a-zA-Z,.\\s]$/;\n\n        // prevent two consecutive dots\n        if (char === \".\" && input.value.slice(-1) === \".\") {\n            e.preventDefault();\n            return false;\n        }\n\n        if (!allowed.test(char)) {\n            e.preventDefault();\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Handles file extension paste event with validation\n     *\n     * @param {Event} e - The paste event\n     * @param {jQuery} $input - The input element\n     */\n    function handleFileExtensionPaste(e, $input) {\n        e.preventDefault();\n\n        const clipboardData = (e.originalEvent || e).clipboardData.getData(\"text\");\n        let sanitized = sanitizeFileExtensionInput(clipboardData);\n\n        // insert sanitized value at current cursor position\n        const input = $input[0];\n        const start = input.selectionStart;\n        const end = input.selectionEnd;\n        const currentValue = input.value;\n\n        input.value = currentValue.substring(0, start) + sanitized + currentValue.substring(end);\n\n        // move the cursor to the end of the inserted text\n        const newPos = start + sanitized.length;\n        input.setSelectionRange(newPos, newPos);\n\n        // determine which save button to toggle based on input field\n        if ($input.attr(\"id\") === \"edit-file-extn-box\") {\n            toggleEditSaveButtonDisability();\n        } else {\n            toggleSaveButtonDisability();\n        }\n    }\n\n    /**\n     * this function is responsible to handle tab key press in textarea to insert tab character instead of moving focus\n     *\n     * @param {Event} e - The keydown event\n     * @param {HTMLElement} textarea - The textarea element\n     */\n    function handleTextareaTabKey(e, textarea) {\n        // check if the key that is pressed is a tab key\n        if (e.keyCode === 9 || e.which === 9) {\n            e.preventDefault(); // to prevent focus change\n\n            const start = textarea.selectionStart;\n            const end = textarea.selectionEnd;\n            const value = textarea.value;\n\n            // to insert the tab character\n            textarea.value = value.substring(0, start) + \"\\t\" + value.substring(end);\n            textarea.selectionStart = textarea.selectionEnd = start + 1;\n            $(textarea).trigger(\"input\");\n        }\n    }\n\n    function validateAbbrInput(e, abbrBox) {\n        // Allow keyboard shortcuts and navigation keys\n        if (e.ctrlKey || e.metaKey || e.altKey) {\n            return;\n        }\n\n        // Allow navigation and function keys\n        if (ALLOWED_NAVIGATION_KEYS.includes(e.key)) {\n            return;\n        }\n\n        // Prevent space character\n        if (e.key === \" \") {\n            e.preventDefault();\n\n            // Determine if this is the edit form or new form\n            const isEditForm = abbrBox.id === \"edit-abbr-box\";\n            const inputId = isEditForm ? \"edit-abbr-box\" : \"abbr-box\";\n            const wrapperId = isEditForm ? \"edit-abbr-box-wrapper\" : \"abbr-box-wrapper\";\n            const errorId = isEditForm ? \"edit-abbreviation-space-error\" : \"abbreviation-space-error\";\n\n            UIHelper.showError(inputId, wrapperId, Strings.CUSTOM_SNIPPETS_SPACE_ERROR, errorId);\n            return;\n        }\n\n        // Check for character limit (30 characters) - only for printable characters\n        if (\n            abbrBox.value.length >= 30 &&\n            e.key.length === 1 &&\n            e.key.match(/[a-zA-Z0-9!@#$%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>\\/?]/)\n        ) {\n            e.preventDefault();\n\n            // Determine if this is the edit form or new form\n            const isEditForm = abbrBox.id === \"edit-abbr-box\";\n            const inputId = isEditForm ? \"edit-abbr-box\" : \"abbr-box\";\n            const wrapperId = isEditForm ? \"edit-abbr-box-wrapper\" : \"abbr-box-wrapper\";\n            const errorId = isEditForm ? \"edit-abbreviation-length-error\" : \"abbreviation-length-error\";\n\n            UIHelper.showError(inputId, wrapperId, Strings.CUSTOM_SNIPPETS_ABBR_LENGTH_ERROR, errorId);\n        }\n    }\n\n    function validateDescInput(e, descBox) {\n        // Allow keyboard shortcuts and navigation keys\n        if (e.ctrlKey || e.metaKey || e.altKey) {\n            return;\n        }\n\n        // Allow navigation and function keys\n        if (ALLOWED_NAVIGATION_KEYS.includes(e.key)) {\n            return;\n        }\n\n        // Check for character limit (80 characters) - only for printable characters (spaces allowed)\n        if (\n            descBox.value.length >= 80 &&\n            e.key.length === 1 &&\n            e.key.match(/[a-zA-Z0-9!@#$%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>\\/?\\ ]/)\n        ) {\n            e.preventDefault();\n\n            // Determine if this is the edit form or new form\n            const isEditForm = descBox.id === \"edit-desc-box\";\n            const inputId = isEditForm ? \"edit-desc-box\" : \"desc-box\";\n            const wrapperId = isEditForm ? \"edit-desc-box-wrapper\" : \"desc-box-wrapper\";\n            const errorId = isEditForm ? \"edit-description-length-error\" : \"description-length-error\";\n\n            UIHelper.showError(inputId, wrapperId, Strings.CUSTOM_SNIPPETS_DESC_LENGTH_ERROR, errorId);\n        }\n    }\n\n    /**\n     * Handles abbreviation paste event with validation\n     * @param {Event} e - The paste event\n     * @param {jQuery} $input - The input element\n     */\n    function handleAbbrPaste(e, $input) {\n        e.preventDefault();\n\n        const clipboardData = (e.originalEvent || e).clipboardData.getData(\"text\");\n\n        // Remove spaces and limit to 30 characters\n        let sanitized = clipboardData.replace(/\\s/g, \"\"); // Remove all spaces\n        let wasTruncated = false;\n        let hadSpaces = clipboardData !== sanitized;\n\n        if (sanitized.length > 30) {\n            sanitized = sanitized.substring(0, 30);\n            wasTruncated = true;\n        }\n\n        // Insert sanitized value at current cursor position\n        const input = $input[0];\n        const start = input.selectionStart;\n        const end = input.selectionEnd;\n        const currentValue = input.value;\n\n        // Check if the final result would exceed 30 characters\n        const beforeCursor = currentValue.substring(0, start);\n        const afterCursor = currentValue.substring(end);\n        const finalValue = beforeCursor + sanitized + afterCursor;\n\n        if (finalValue.length > 30) {\n            // Trim the sanitized content to fit within the limit\n            const availableSpace = 30 - (beforeCursor.length + afterCursor.length);\n            if (availableSpace > 0) {\n                sanitized = sanitized.substring(0, availableSpace);\n                wasTruncated = true;\n            } else {\n                sanitized = \"\"; // No space available\n                wasTruncated = true;\n            }\n        }\n\n        // Insert the final sanitized value\n        input.value = beforeCursor + sanitized + afterCursor;\n\n        // Move the cursor to the end of the inserted text\n        const newPos = start + sanitized.length;\n        input.setSelectionRange(newPos, newPos);\n\n        // Show appropriate error message\n        if (wasTruncated || hadSpaces) {\n            const isEditForm = $input.attr(\"id\") === \"edit-abbr-box\";\n            const inputId = isEditForm ? \"edit-abbr-box\" : \"abbr-box\";\n            const wrapperId = isEditForm ? \"edit-abbr-box-wrapper\" : \"abbr-box-wrapper\";\n\n            // Prioritize length error over space error if both occurred\n            if (wasTruncated) {\n                const errorId = isEditForm ? \"edit-abbreviation-paste-length-error\" : \"abbreviation-paste-length-error\";\n                UIHelper.showError(inputId, wrapperId, Strings.CUSTOM_SNIPPETS_ABBR_LENGTH_ERROR, errorId);\n            } else if (hadSpaces) {\n                const errorId = isEditForm ? \"edit-abbreviation-paste-space-error\" : \"abbreviation-paste-space-error\";\n                UIHelper.showError(inputId, wrapperId, Strings.CUSTOM_SNIPPETS_SPACE_ERROR, errorId);\n            }\n        }\n\n        // Determine which save button to toggle based on input field\n        if ($input.attr(\"id\") === \"edit-abbr-box\") {\n            toggleEditSaveButtonDisability();\n        } else {\n            toggleSaveButtonDisability();\n        }\n    }\n\n    /**\n     * Handles description paste event with validation\n     * @param {Event} e - The paste event\n     * @param {jQuery} $input - The input element\n     */\n    function handleDescPaste(e, $input) {\n        e.preventDefault();\n\n        const clipboardData = (e.originalEvent || e).clipboardData.getData(\"text\");\n\n        // Keep spaces but limit to 80 characters\n        let sanitized = clipboardData;\n        let wasTruncated = false;\n\n        if (sanitized.length > 80) {\n            sanitized = sanitized.substring(0, 80);\n            wasTruncated = true;\n        }\n\n        // Insert sanitized value at current cursor position\n        const input = $input[0];\n        const start = input.selectionStart;\n        const end = input.selectionEnd;\n        const currentValue = input.value;\n\n        // Check if the final result would exceed 80 characters\n        const beforeCursor = currentValue.substring(0, start);\n        const afterCursor = currentValue.substring(end);\n        const finalValue = beforeCursor + sanitized + afterCursor;\n\n        if (finalValue.length > 80) {\n            // Trim the sanitized content to fit within the limit\n            const availableSpace = 80 - (beforeCursor.length + afterCursor.length);\n            if (availableSpace > 0) {\n                sanitized = sanitized.substring(0, availableSpace);\n                wasTruncated = true;\n            } else {\n                sanitized = \"\"; // No space available\n                wasTruncated = true;\n            }\n        }\n\n        // Insert the final sanitized value\n        input.value = beforeCursor + sanitized + afterCursor;\n\n        // Move the cursor to the end of the inserted text\n        const newPos = start + sanitized.length;\n        input.setSelectionRange(newPos, newPos);\n\n        // Show error message if content was truncated\n        if (wasTruncated) {\n            const isEditForm = $input.attr(\"id\") === \"edit-desc-box\";\n            const inputId = isEditForm ? \"edit-desc-box\" : \"desc-box\";\n            const wrapperId = isEditForm ? \"edit-desc-box-wrapper\" : \"desc-box-wrapper\";\n            const errorId = isEditForm ? \"edit-description-paste-length-error\" : \"description-paste-length-error\";\n\n            UIHelper.showError(inputId, wrapperId, Strings.CUSTOM_SNIPPETS_DESC_LENGTH_ERROR, errorId);\n        }\n\n        // Determine which save button to toggle based on input field\n        if ($input.attr(\"id\") === \"edit-desc-box\") {\n            toggleEditSaveButtonDisability();\n        } else {\n            toggleSaveButtonDisability();\n        }\n    }\n\n    /**\n     * Categorize file extension for metrics tracking\n     * @param {string} fileExtension - The file extension from snippet\n     * @returns {string} - \"all\" if snippet is enabled for all files, otherwise \"file\"\n     */\n    function categorizeFileExtensionForMetrics(fileExtension) {\n        if (!fileExtension || fileExtension === \"all\") {\n            return \"all\";\n        }\n\n        // if not enabled for \"all\", we just return \"file\"\n        return \"file\";\n    }\n\n    exports.toggleSaveButtonDisability = toggleSaveButtonDisability;\n    exports.createHintItem = createHintItem;\n    exports.clearAllInputFields = clearAllInputFields;\n    exports.getSnippetData = getSnippetData;\n    exports.getCurrentLanguageContext = getCurrentLanguageContext;\n    exports.getCurrentFileExtension = getCurrentFileExtension;\n    exports.mapLanguageToExtension = mapLanguageToExtension;\n    exports.rebuildOptimizedStructures = rebuildOptimizedStructures;\n    exports.isSnippetSupportedInLanguageContext = isSnippetSupportedInLanguageContext;\n    exports.isSnippetSupportedInFile = isSnippetSupportedInFile;\n    exports.hasExactMatchingSnippet = hasExactMatchingSnippet;\n    exports.getMatchingSnippets = getMatchingSnippets;\n    exports.updateSnippetsCount = updateSnippetsCount;\n    exports.sanitizeFileExtensionInput = sanitizeFileExtensionInput;\n    exports.handleFileExtensionInput = handleFileExtensionInput;\n    exports.handleFileExtensionKeypress = handleFileExtensionKeypress;\n    exports.handleFileExtensionPaste = handleFileExtensionPaste;\n    exports.populateEditForm = populateEditForm;\n    exports.getEditSnippetData = getEditSnippetData;\n    exports.toggleEditSaveButtonDisability = toggleEditSaveButtonDisability;\n    exports.categorizeFileExtensionForMetrics = categorizeFileExtensionForMetrics;\n    exports.clearEditInputFields = clearEditInputFields;\n    exports.handleTextareaTabKey = handleTextareaTabKey;\n    exports.validateAbbrInput = validateAbbrInput;\n    exports.validateDescInput = validateDescInput;\n    exports.handleAbbrPaste = handleAbbrPaste;\n    exports.handleDescPaste = handleDescPaste;\n});\n"],"file":"helper.js"}