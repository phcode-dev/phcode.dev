{"version":3,"sources":["virtual-server-main.js"],"names":["importScripts","_debugSWCacheLogs","CACHE_FILE_NAME","CACHE_FS_PATH","workbox","setConfig","debug","Config","Route","routing","cacheFirst","strategies","CacheFirst","StaleWhileRevalidate","ExpirationPlugin","expiration","CacheExpiration","DAYS_30_IN_SEC","CACHE_REFRESH_SCHEDULE_TIME","CACHE_NAME_EVERYTHING","CACHE_NAME_CORE_SCRIPTS","CACHE_NAME_EXTERNAL","ExpirationManager","everything","maxAgeSeconds","coreScripts","external","_debugCacheLog","args","console","log","_removeParams","url","indexOf","substring","location","href","baseURL","lastIndexOf","endsWith","CACHE_MANIFEST_URL","virtualServerBaseURL","route","wwwRegex","RegExp","_isVirtualServing","startsWith","_shouldVirtualServe","request","_clearCache","caches","open","then","cache","keys","forEach","index","array","delete","_updateTTL","cacheName","urls","length","updateTimestamp","_getCurrentCacheManifest","Promise","resolve","fs","readFile","err","data","JSON","parse","_putCurrentCacheManifest","manifestObject","writeFile","stringify","error","_getNewCacheManifest","fetch","response","json","catch","_fixCache","currentCacheManifest","newCacheManifest","currentCacheKeys","Object","newCacheKeys","reject","async","changedContentURLs","deletePromises","_index","_array","relativeURL","push","all","addAll","registerRoute","path","pathname","match","decodeURI","formatter","searchParams","get","JSONFormatter","HtmlFormatter","download","Serve","serve","Response","redirect","refreshInProgress","_refreshCache","event","ports","postMessage","e","_isCacheableExternalUrl","EXTERNAL_URLS","start","addEventListener","eventType","type","self","skipWaiting","DONT_CACHE_BASE_URLS","origin","_isNotCacheableUrl","CORE_SCRIPTS_URLS","_isCoreScript","coreScript","_belongsToEverythingCache","split","destination","disAllowedExtensions","test","allCachedRoutes","method","plugins","purgeOnQuotaError","freshnessPreferredRoutes","externalCachedRoutes","core","clientsClaim"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * modified by core.ai, based on work by David Humphrey <david.humphrey@senecacolleage.ca> (@humphd)\n *\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU Affero General Public License as published by the Free\n * Software Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along\n * with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/* global workbox, importScripts, Serve, JSONFormatter, HtmlFormatter, Config*/\nimportScripts('phoenix/virtualfs.js');\nimportScripts('phoenix/virtualServer/mime-types.js');\nimportScripts('phoenix/virtualServer/config.js');\nimportScripts('phoenix/virtualServer/content-type.js');\nimportScripts('phoenix/virtualServer/webserver.js');\nimportScripts('phoenix/virtualServer/json-formatter.js');\nimportScripts('phoenix/virtualServer/html-formatter.js');\nimportScripts('https://storage.googleapis.com/workbox-cdn/releases/6.4.1/workbox-sw.js');\n\nconst _debugSWCacheLogs = false; // change debug to true to see more logs\nconst CACHE_FILE_NAME = \"cacheManifest.json\";\nconst CACHE_FS_PATH = `/${CACHE_FILE_NAME}`;\n\nworkbox.setConfig({debug: _debugSWCacheLogs && Config.debug});\n\nconst Route = workbox.routing.Route;\n// other strategies include CacheFirst, NetworkFirst Etc..\nconst cacheFirst = workbox.strategies.CacheFirst;\nconst StaleWhileRevalidate = workbox.strategies.StaleWhileRevalidate;\nconst ExpirationPlugin = workbox.expiration.ExpirationPlugin;\nconst CacheExpiration = workbox.expiration.CacheExpiration;\nconst DAYS_30_IN_SEC = 60 * 60 * 24 * 30;\nconst CACHE_REFRESH_SCHEDULE_TIME = 10 * 1000;\nconst CACHE_NAME_EVERYTHING = \"everything\";\nconst CACHE_NAME_CORE_SCRIPTS = \"coreScripts\";\nconst CACHE_NAME_EXTERNAL = \"external\";\nconst ExpirationManager ={\n    \"everything\": new CacheExpiration(CACHE_NAME_EVERYTHING, {\n            maxAgeSeconds: DAYS_30_IN_SEC\n        }),\n    \"coreScripts\": new CacheExpiration(CACHE_NAME_CORE_SCRIPTS, {\n            maxAgeSeconds: DAYS_30_IN_SEC\n        }),\n    \"external\": new CacheExpiration(CACHE_NAME_EXTERNAL, {\n        maxAgeSeconds: DAYS_30_IN_SEC\n    })\n};\n\nfunction _debugCacheLog(...args) {\n    if(_debugSWCacheLogs){\n        console.log(...args);\n    }\n}\n\nfunction _removeParams(url) {\n    if(url.indexOf( \"?\")>-1){\n        url = url.substring( 0, url.indexOf( \"?\")); // remove query string params\n    }\n    if(location.href.indexOf( \"#\")>-1){\n        url = url.substring( 0, url.indexOf( \"#\")); // remove hrefs in page\n    }\n    return url;\n}\n\n// service worker controlling route base url. This will be something like https://phcode.dev/ or http://localhost:8000/\nlet baseURL = location.href;\nbaseURL = _removeParams(location.href);\nif(location.href.indexOf( \"/\")>-1){\n    // http://phcode.dev/index.html -> http://phcode.dev\n    baseURL = baseURL.substring( 0, baseURL.lastIndexOf( \"/\"));\n}\nif(!baseURL.endsWith('/')){\n    baseURL = baseURL + '/';\n}\nconsole.log(\"Service worker: base URL is: \", baseURL);\n\nconst CACHE_MANIFEST_URL = `${baseURL}${CACHE_FILE_NAME}`;\nconsole.log(\"Service worker: cache manifest URL is: \", CACHE_MANIFEST_URL);\n\n// this is the base url where our file system virtual server lives. http://phcode.dev/phoenix/vfs in phoenix or\n// http://localhost:8000/phoenix/vfs in dev builds\nconst virtualServerBaseURL = `${baseURL}${Config.route}`;\nconsole.log(\"Service worker: Virtual server base URL is: \", virtualServerBaseURL);\n\n// Route with trailing slash (i.e., /path/into/filesystem)\nconst wwwRegex = new RegExp(`${Config.route}(/.*)`);\n// Route minus the trailing slash\n\nfunction _isVirtualServing(url) {\n    return url.startsWith(virtualServerBaseURL);\n}\n\nfunction _shouldVirtualServe(request) {\n    return _isVirtualServing(request.url.href);\n}\n\nworkbox.routing.registerRoute(\n    _shouldVirtualServe,\n    ({url}) => {\n        // Pull the filesystem path off the url\n        let path = url.pathname.match(wwwRegex)[1];\n        // Deal with encoding in the filename (e.g., spaces as %20)\n        path = decodeURI(path);\n\n        // Allow passing `?json` on URL to get back JSON vs. raw response\n        const formatter =\n            url.searchParams.get('json') !== null\n                ? JSONFormatter\n                : HtmlFormatter;\n\n        const download = false;\n        // commented Allow passing `?download` or `dl` to have the file downloaded vs. displayed\n        // url.searchParams.get('download') !== null ||\n        // url.searchParams.get('dl') !== null;\n\n        return Serve.serve(path, formatter, download);\n    },\n    'GET'\n);\n\n// Redirect if missing the / on our expected route\nworkbox.routing.registerRoute(\n    _shouldVirtualServe,\n    ({url}) => {\n        url.pathname = `${Config.route}/`;\n        return Promise.resolve(Response.redirect(url, 302));\n    },\n    'GET'\n);\n\n// cache and offline access route\nfunction _clearCache() {\n    caches.open(CACHE_NAME_EVERYTHING).then((cache) => {\n        cache.keys().then((keys) => {\n            keys.forEach((request, index, array) => {\n                cache.delete(request);\n            });\n        });\n    });\n}\n\nfunction _updateTTL(cacheName, urls) {\n    // this is needed for workbox to purge cache by ttl. purge behaviour is not part of w3c spec, but done by workbox.\n    // cache.addall browser api will not update expiry ttls that workbox lib needs. So we add it here.\n    console.log(`Service worker: Updating expiry for ${urls.length} urls in cache: ${cacheName}`);\n    for(let url of urls){\n        ExpirationManager[cacheName].updateTimestamp(url);\n    }\n}\n\nfunction _getCurrentCacheManifest() {\n    return new Promise((resolve)=>{\n        fs.readFile(CACHE_FS_PATH, \"utf8\", function (err, data) {\n            if (err) {\n                resolve(null);\n            } else {\n                resolve(JSON.parse(data));\n            }\n        });\n    });\n}\nfunction _putCurrentCacheManifest(manifestObject) {\n    return new Promise((resolve)=>{\n        fs.writeFile(CACHE_FS_PATH, JSON.stringify(manifestObject, null, 2), \"UTF8\", function (err) {\n            if (err) {\n                console.error(\"Service worker: Failed while writing cache manifest\", err);\n            }\n            resolve(null);\n        });\n    });\n}\nfunction _getNewCacheManifest() {\n    return new Promise((resolve) => {\n        fetch(CACHE_MANIFEST_URL)\n            .then((response) => response.json())\n            .then((data) => resolve(data))\n            .catch(err =>{\n                console.error(\"Service worker: could not fetch cache manifest for app updates\", err);\n                resolve(null);\n            });\n    });\n}\n\nfunction _fixCache(currentCacheManifest, newCacheManifest) {\n    const currentCacheKeys = Object.keys(currentCacheManifest);\n    const newCacheKeys = Object.keys(newCacheManifest);\n    console.log(`Service worker: Fixing Stale Cache Entries in ${CACHE_NAME_EVERYTHING}. num cache entries in manifest:\n    current: ${currentCacheKeys.length} new: ${newCacheKeys.length}`);\n    return new Promise((resolve, reject) => {\n        caches.open(CACHE_NAME_EVERYTHING).then((cache) => {\n            cache.keys().then(async (keys) => {\n                console.log(\"Service worker: Number of cached entries in everything cache: \", keys.length);\n                let changedContentURLs = [], deletePromises = [];\n                keys.forEach((request, _index, _array) => {\n                    let relativeURL = _removeParams(request.url);\n                    relativeURL = relativeURL.substring(baseURL.length, relativeURL.length);\n                    if(!newCacheManifest[relativeURL]){\n                        _debugCacheLog(\"Service worker: entry renewed as deleted\", relativeURL);\n                        deletePromises.push(cache.delete(request));\n                        return;\n                    }\n                    if(currentCacheManifest[relativeURL] !== newCacheManifest[relativeURL]){\n                        _debugCacheLog(\"Service worker: entry renewed as changed\", relativeURL);\n                        deletePromises.push(cache.delete(request));\n                        changedContentURLs.push(request.url);\n                    }\n                });\n                console.log(`Service worker: deleting ${deletePromises.length} stale cache entries in ${CACHE_NAME_EVERYTHING}`);\n                await Promise.all(deletePromises);\n                console.log(`Service worker: updating cache for ${changedContentURLs.length} in ${CACHE_NAME_EVERYTHING}`);\n                cache.addAll(changedContentURLs).then(()=>{\n                    console.log(`Service worker: cache refresh complete for ${changedContentURLs.length} URLS in ${CACHE_NAME_EVERYTHING}`);\n                    _updateTTL(CACHE_NAME_EVERYTHING, changedContentURLs);\n                    resolve();\n                }).catch(err=>{\n                    console.error(`Service worker: cache refresh failed for ${changedContentURLs.length} URLS in ${CACHE_NAME_EVERYTHING}`, err);\n                    reject();\n                });\n            });\n        }).catch(reject);\n    });\n}\n\nlet refreshInProgress = false;\nasync function _refreshCache(event) {\n    if(refreshInProgress){\n        console.log(\"Another cache refresh is in progress, ignoring.\");\n        return;\n    }\n    refreshInProgress = true;\n    try{\n        console.log(\"Service worker: Refreshing browser cache for app updates.\");\n        const currentCacheManifest = await _getCurrentCacheManifest();\n        const newCacheManifest = await _getNewCacheManifest();\n        if(!newCacheManifest){\n            console.log(\"Service worker: could not fetch new cache manifest. Cache refresh will not be done.\");\n            refreshInProgress = false;\n            return;\n        }\n        if(!currentCacheManifest && newCacheManifest){\n            console.log(`Service worker: Fresh install, writing cache manifest with ${Object.keys(newCacheManifest).length} entries`);\n            await _putCurrentCacheManifest(newCacheManifest);\n            refreshInProgress = false;\n            return;\n        }\n        await _fixCache(currentCacheManifest, newCacheManifest);\n        await _putCurrentCacheManifest(newCacheManifest);\n        event.ports[0].postMessage(\"cache refresh completed\");\n    } catch (e) {\n        console.error(\"Service worker: error while refreshing cache\", e);\n    }\n    refreshInProgress = false;\n}\n\naddEventListener('message', (event) => {\n    // NB: Do not expect anything to persist in the service worker variables, the service worker may be reset at\n    // any time by the browser if it is not in use, and only load it when required. This means that if there is a\n    // long inactivity in the page, even if the tab is opened, the service worker will be unloaded by chrome. Then will\n    // be re-enabled when needed. Hens some of our stored variables transferred from browser tabs was being erased\n    // leading to live preview failures before. Use indexDB persistent storage only inside worker is you want to keep\n    // track of data transferred from the main browser tabs, never hold it in variables here!\n    let eventType = event.data && event.data.type;\n    switch (eventType) {\n        case 'SKIP_WAITING': self.skipWaiting(); break;\n        case 'GET_SW_BASE_URL': event.ports[0].postMessage(baseURL); break;\n        case 'CLEAR_CACHE': _clearCache(); break;\n        case 'REFRESH_CACHE': _refreshCache(event); break;\n        default: console.error(\"Service worker cannot process, received unknown message: \", event);\n    }\n});\n\nfunction _isCacheableExternalUrl(url) {\n    let EXTERNAL_URLS = [\n        'https://storage.googleapis.com/workbox-cdn/'\n    ];\n    for(let start of EXTERNAL_URLS){\n        if(url.startsWith(start)){\n            return true;\n        }\n    }\n    return false;\n}\n\n// queue cache update\n\nconst DONT_CACHE_BASE_URLS = [\n    `${location.origin}/src/`, `${location.origin}/test/`, `${location.origin}/dist/`, // https://phcode.dev/src or other\n    // https://phcode.dev/subfolder/src/ or other when phoenix is loaded from https://phcode.dev/subfolder/index.html\n    `${baseURL}src/`, `${baseURL}test/`, `${baseURL}dist/`, `${baseURL}cacheManifest.json`];\nfunction _isNotCacheableUrl(url) {\n    for(let start of DONT_CACHE_BASE_URLS){\n        if(url.startsWith(start)){\n            return true;\n        }\n    }\n    return false;\n}\n\n// we always try to load main worker scripts and index html from core scripts cache which uses stale while revalidate\n// to get aggressive updates.\nconst CORE_SCRIPTS_URLS = [`${location.origin}/index.html`, `${location.origin}/`, // https://phcode.dev/src or other\n    `${location.origin}/virtual-server-main.js`, `${location.origin}/phoenix/virtual-server-loader.js`,\n    // https://phcode.dev/subfolder/src/ or other when phoenix is loaded from https://phcode.dev/subfolder/index.html\n    `${baseURL}index.html`, `${baseURL}`,\n    `${baseURL}virtual-server-main.js`, `${baseURL}phoenix/virtual-server-loader.js`];\nfunction _isCoreScript(url) {\n    for(let coreScript of CORE_SCRIPTS_URLS){\n        if(url === coreScript){\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction _belongsToEverythingCache(request) {\n    // now do url checks, Remove # ,http://localhost:9000/dist/styles/images/sprites.svg#leftArrowDisabled.\n    // we cache entries with query string parameters in static pages with base url starting with phoenix base\n    let href = request.url.split(\"#\")[0];\n    if(request.destination === 'video' || request.destination === 'audio'){\n        _debugCacheLog(\"Not Caching audio/video URL: \", request);\n        return false;\n    }\n    if(_isNotCacheableUrl(href)){\n        _debugCacheLog(\"Not Caching un cacheable URL in everything cache: \", request);\n        return false;\n    }\n    if(_isCoreScript(href)){\n        _debugCacheLog(\"Not Caching core scripts in everything cache: \", request);\n        return false;\n    }\n    if(_isCacheableExternalUrl(href)){\n        _debugCacheLog(\"Not Caching external url in everything cache: \", request);\n        return false;\n    }\n    let disAllowedExtensions =  /.zip$|.map$/i;\n    if(href.startsWith(baseURL) && !disAllowedExtensions.test(href)) {\n        return true;\n    }\n    _debugCacheLog(\"Not Caching URL: \", request);\n    return false;\n}\n\n// handle all document\nconst allCachedRoutes = new Route(({ request }) => {\n    return (request.method === 'GET'\n        && _belongsToEverythingCache(request) && !_isVirtualServing(request.url));\n}, new cacheFirst({\n    cacheName: CACHE_NAME_EVERYTHING,\n    plugins: [\n        new ExpirationPlugin({\n            maxAgeSeconds: DAYS_30_IN_SEC,\n            purgeOnQuotaError: true\n        })\n    ]\n}));\n\n// core scripts route\nconst freshnessPreferredRoutes = new Route(({ request }) => {\n    return request.method === 'GET' && _isCoreScript(request.url) && !_isVirtualServing(request.url);\n}, new StaleWhileRevalidate({\n    cacheName: CACHE_NAME_CORE_SCRIPTS,\n    plugins: [\n        new ExpirationPlugin({\n            maxAgeSeconds: DAYS_30_IN_SEC,\n            purgeOnQuotaError: true\n        })\n    ]\n}));\n\n// scripts with a different origin like third party libs\nconst externalCachedRoutes = new Route(({ request }) => {\n    return request.method === 'GET' && _isCacheableExternalUrl(request.url) && !_isVirtualServing(request.url);\n}, new StaleWhileRevalidate({\n    cacheName: CACHE_NAME_EXTERNAL,\n    plugins: [\n        new ExpirationPlugin({\n            maxAgeSeconds: DAYS_30_IN_SEC,\n            purgeOnQuotaError: true\n        })\n    ]\n}));\n\nworkbox.routing.registerRoute(allCachedRoutes);\nworkbox.routing.registerRoute(freshnessPreferredRoutes);\nworkbox.routing.registerRoute(externalCachedRoutes);\n\nworkbox.core.clientsClaim();\n"],"file":"virtual-server-main.js"}