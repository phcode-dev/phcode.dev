{"version":3,"sources":["thirdparty/tern/lib/tern.js"],"names":["root","mod","exports","module","require","define","amd","tern","signal","acorn","walk","this","infer","plugins","Object","create","registerPlugin","name","init","defaultOptions","debug","async","getFile","_f","c","normalizeFilename","defs","fetchTimeout","dependencyBudget","reuseInstances","stripCRs","ecmaVersion","projectDir","parent","queryTypes","completions","takesFile","run","findCompletions","properties","findProperties","type","findTypeAt","documentation","findDocs","definition","findDef","refs","fullFile","findRefs","rename","buildRename","files","listFiles","File","scope","text","ast","lineOffsets","parseFile","srv","file","options","directSourceFile","allowReturnOutsideFunction","allowImportExportEverywhere","allowHashBang","signalReturnFirst","parse","defineQueryType","desc","prototype","asLineChar","pos","astral","Server","updateText","replace","hasAstral","test","withContext","cx","doRequest","doc","query","hasOwnProperty","length","uses","i","delFile","ensureFile","timeBudget","timeout","queryType","analyzeAll","err","resolveFile","resetGuessing","result","withTimeout","e","console","error","stack","analyzeFile","topScope","analyze","known","findFile","needsPurge","push","clearScopes","parentDepth","excluded","fileMap","startAsyncAction","finishAsyncAction","fetchAll","done","returned","forEach","waitOnFetch","off","clearTimeout","on","setTimeout","pending","fetchError","purge","toAnalyze","sort","a","b","j","chargeOnBudget","startTime","Date","TimedOut","firstLine","str","end","indexOf","slice","findMatchingPosition","line","near","Math","max","closest","found","abs","scopeDepth","s","prev","ternError","msg","Error","localFiles","isRef","match","realFile","backing","offset","resolvePos","offsetLines","ch","foundPos","lastIndexOf","inObject","atFunction","m","objNode","findNodeAround","node","objType","prop","cut","white","scopeStart","scopeAt","scopeEnd","tieTogether","newInner","fnType","getProp","addType","inner","fOld","fNew","min","args","propagate","self","retval","astSize","size","simple","Expression","depth","budgetName","bName","budgets","isPosition","val","invalidDoc","start","Array","isArray","o","plugin","handlers","asyncError","loadPlugin","reset","mixin","addFile","splice","Context","request","inv","data","flush","addDefs","toFront","unshift","deleteDefs","arguments","loadFirst","passes","norm","offsetSkipLines","forwardCharacters","chars","lastIndex","exec","index","findLineStart","offsets","curLine","storePos","floor","tolerant","lineStart","charDistanceBetween","diff","eol","outputPos","lineCharPositions","out","clean","obj","maybeSet","compareCompletions","aUp","bUp","isStringAround","value","pointInProp","point","curProp","key","jsKeywords","split","jsKeywordsES6","concat","addCompletion","aval","typeInfo","types","docs","urls","origins","wrapAsObjs","depths","rec","getType","guess","didGuess","toString","parseDoc","url","origin","fromPlugin","wordStart","wordEnd","isIdentifierChar","charCodeAt","expandWordForward","word","ignoreObj","hookname","isKey","gather","addInfo","objLit","omitObjectPrototype","protos","filter","caseInsensitive","toLowerCase","props","exprAt","findExpressionAround","memberExpr","exprNode","inLiteral","regex","object","parentNode","property","state","objProp","typeFromContext","expressionType","charAt","pathStart","path","def","parsePath","getObjType","completingProperty","forAllPropertiesOf","guessProperties","p","d","forAllLocalsAt","includeKeywords","kw","isKeyword","isProperty","isObjectKey","prefix","inBody","body","findExpr","findQueryExpr","wide","variable","expr","findExpressionAt","span","findClosestExpression","around","findExprAround","findExprOrThrow","ensureObj","tp","Obj","findExprType","typeHandlers","hasHandler","fromCx","hasProp","fromLocal","findTypeAtExpr","exprName","exprType","preferFunction","getFunctionType","computed","typeResult","storeTypeDocs","docFormat","parabreak","sentenceEnd","ctor","boring","proto","hasCtor","Function","getSpan","originNode","id","storeSpan","target","Number","spanFile","sourceFile","cxStart","contextOffset","context","findRefsToVariable","isRename","storeRef","scopeHere","ancestors","exists","isShorthand","onlySourceFile","cur","findRefsToProperty","propertyOf","findPropRefs","k","newName","map","f","changes","use","version"],"mappings":"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","sourcesContent":["// The Tern server object\n\n// A server is a stateful object that manages the analysis for a\n// project, and defines an interface for querying the code in the\n// project.\n\n(function(root, mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    return mod(exports, require(\"./infer\"), require(\"./signal\"),\n               require(\"acorn\"), require(\"acorn-walk\"));\n  if (typeof define == \"function\" && define.amd) // AMD\n    return define([\"exports\", \"./infer\", \"./signal\", \"acorn/dist/acorn\", \"acorn-walk/dist/walk\"], mod);\n  mod(root.tern || (root.tern = {}), tern, tern.signal, acorn, acorn.walk); // Plain browser env\n})(this, function(exports, infer, signal, acorn, walk) {\n  \"use strict\";\n\n  var plugins = Object.create(null);\n  exports.registerPlugin = function(name, init) { plugins[name] = init; };\n\n  var defaultOptions = exports.defaultOptions = {\n    debug: false,\n    async: false,\n    getFile: function(_f, c) { if (this.async) c(null, null); },\n    normalizeFilename: function(name) { return name },\n    defs: [],\n    plugins: {},\n    fetchTimeout: 1000,\n    dependencyBudget: 20000,\n    reuseInstances: true,\n    stripCRs: false,\n    ecmaVersion: 9,\n    projectDir: \"/\",\n    parent: null\n  };\n\n  var queryTypes = {\n    completions: {\n      takesFile: true,\n      run: findCompletions\n    },\n    properties: {\n      run: findProperties\n    },\n    type: {\n      takesFile: true,\n      run: findTypeAt\n    },\n    documentation: {\n      takesFile: true,\n      run: findDocs\n    },\n    definition: {\n      takesFile: true,\n      run: findDef\n    },\n    refs: {\n      takesFile: true,\n      fullFile: true,\n      run: findRefs\n    },\n    rename: {\n      takesFile: true,\n      fullFile: true,\n      run: buildRename\n    },\n    files: {\n      run: listFiles\n    }\n  };\n\n  exports.defineQueryType = function(name, desc) { queryTypes[name] = desc; };\n\n  function File(name, parent) {\n    this.name = name;\n    this.parent = parent;\n    this.scope = this.text = this.ast = this.lineOffsets = null;\n  }\n  File.prototype.asLineChar = function(pos) { return asLineChar(this, pos); };\n\n  function parseFile(srv, file) {\n    var options = {\n      directSourceFile: file,\n      allowReturnOutsideFunction: true,\n      allowImportExportEverywhere: true,\n      ecmaVersion: srv.options.ecmaVersion,\n      allowHashBang: true\n    };\n    var text = srv.signalReturnFirst(\"preParse\", file.text, options) || file.text;\n    var ast = infer.parse(text, options);\n    srv.signal(\"postParse\", ast, text);\n    return ast;\n  }\n\n  var astral = /[\\uD800-\\uDBFF]/g;\n\n  function updateText(file, text, srv) {\n    file.text = srv.options.stripCRs ? text.replace(/\\r\\n/g, \"\\n\") : text;\n    file.hasAstral = astral.test(file.text);\n    infer.withContext(srv.cx, function() {\n      file.ast = parseFile(srv, file);\n    });\n    file.lineOffsets = null;\n  }\n\n  var Server = exports.Server = function(options) {\n    this.cx = null;\n    this.options = options || {};\n    for (var o in defaultOptions) if (!options.hasOwnProperty(o))\n      options[o] = defaultOptions[o];\n\n    this.projectDir = options.projectDir.replace(/\\\\/g, \"/\");\n    if (!/\\/$/.test(this.projectDir)) this.projectDir += \"/\";\n\n    this.parent = options.parent;\n    this.handlers = Object.create(null);\n    this.files = [];\n    this.fileMap = Object.create(null);\n    this.needsPurge = [];\n    this.budgets = Object.create(null);\n    this.uses = 0;\n    this.pending = 0;\n    this.asyncError = null;\n    this.mod = {};\n\n    this.defs = options.defs.slice(0);\n    this.plugins = Object.create(null);\n    for (var plugin in options.plugins) if (options.plugins.hasOwnProperty(plugin))\n      this.loadPlugin(plugin, options.plugins[plugin]);\n\n    this.reset();\n  };\n  Server.prototype = signal.mixin({\n    addFile: function(name, /*optional*/ text, parent) {\n      // Don't crash when sloppy plugins pass non-existent parent ids\n      if (parent && !(parent in this.fileMap)) parent = null;\n      if (!(name in this.fileMap))\n        name = this.normalizeFilename(name);\n      ensureFile(this, name, parent, text);\n    },\n    delFile: function(name) {\n      var file = this.findFile(name);\n      if (file) {\n        this.needsPurge.push(file.name);\n        for (var i = 0; i < this.files.length; i++) {\n          if (this.files[i] == file) this.files.splice(i--, 1);\n          else if (this.files[i].parent == name) this.files[i].parent = null;\n        }\n        delete this.fileMap[file.name];\n      }\n    },\n    reset: function() {\n      this.signal(\"reset\");\n      this.cx = new infer.Context(this.defs, this);\n      this.uses = 0;\n      this.budgets = Object.create(null);\n      for (var i = 0; i < this.files.length; ++i) {\n        var file = this.files[i];\n        if (file.scope) {\n          infer.clearScopes(file.ast);\n          file.scope = null;\n        }\n      }\n      this.signal(\"postReset\");\n    },\n\n    request: function(doc, c) {\n      var inv = invalidDoc(doc);\n      if (inv) return c(inv);\n\n      var self = this;\n      doRequest(this, doc, function(err, data) {\n        c(err, data);\n        if (self.uses > 40) {\n          self.reset();\n          analyzeAll(self, null, function(){});\n        }\n      });\n    },\n\n    findFile: function(name) {\n      return this.fileMap[this.normalizeFilename(name)];\n    },\n\n    flush: function(c) {\n      var cx = this.cx;\n      analyzeAll(this, null, function(err) {\n        if (err) return c(err);\n        infer.withContext(cx, c);\n      });\n    },\n\n    startAsyncAction: function() {\n      ++this.pending;\n    },\n    finishAsyncAction: function(err) {\n      if (err) this.asyncError = err;\n      if (--this.pending === 0) this.signal(\"everythingFetched\");\n    },\n\n    addDefs: function(defs, toFront) {\n      if (toFront) this.defs.unshift(defs);\n      else this.defs.push(defs);\n\n      if (this.cx) this.reset();\n    },\n\n    deleteDefs: function(name) {\n      for (var i = 0; i < this.defs.length; i++) if (this.defs[i][\"!name\"] == name) {\n        this.defs.splice(i, 1);\n        if (this.cx) this.reset();\n        return;\n      }\n    },\n\n    loadPlugin: function(name, options) {\n      if (arguments.length == 1) options = this.options.plugins[name] || true;\n      if (name in this.plugins || !(name in plugins) || !options) return;\n      this.plugins[name] = true;\n      var init = plugins[name](this, options);\n\n      // This is for backwards-compatibilty. Don't rely on it -- use addDef and on directly\n      if (!init) return;\n      if (init.defs) this.addDefs(init.defs, init.loadFirst);\n      if (init.passes) for (var type in init.passes) if (init.passes.hasOwnProperty(type))\n        this.on(type, init.passes[type]);\n    },\n\n    normalizeFilename: function(name) {\n      var norm = this.options.normalizeFilename(name).replace(/\\\\/g, \"/\");\n      if (norm.indexOf(this.projectDir) == 0) norm = norm.slice(this.projectDir.length);\n      return norm;\n    }\n  });\n\n  function doRequest(srv, doc, c) {\n    if (doc.query && !queryTypes.hasOwnProperty(doc.query.type))\n      return c(\"No query type '\" + doc.query.type + \"' defined\");\n\n    var query = doc.query;\n    // Respond as soon as possible when this just uploads files\n    if (!query) c(null, {});\n\n    var files = doc.files || [];\n    if (files.length) ++srv.uses;\n    for (var i = 0; i < files.length; ++i) {\n      var file = files[i];\n      file.name = srv.normalizeFilename(file.name);\n      if (file.type == \"delete\")\n        srv.delFile(file.name);\n      else\n        ensureFile(srv, file.name, null, file.type == \"full\" ? file.text : null);\n    }\n\n    var timeBudget = typeof doc.timeout == \"number\" ? [doc.timeout] : null;\n    if (!query) {\n      analyzeAll(srv, timeBudget, function(){});\n      return;\n    }\n\n    var queryType = queryTypes[query.type];\n    if (queryType.takesFile) {\n      if (typeof query.file != \"string\") return c(\".query.file must be a string\");\n      if (!/^#/.test(query.file)) ensureFile(srv, query.file, null);\n    }\n\n    analyzeAll(srv, timeBudget, function(err) {\n      if (err) return c(err);\n      var file = queryType.takesFile && resolveFile(srv, files, query.file);\n      if (queryType.fullFile && file.type == \"part\")\n        return c(\"Can't run a \" + query.type + \" query on a file fragment\");\n\n      infer.resetGuessing();\n      infer.withContext(srv.cx, function() {\n        var result, run = function() { result = queryType.run(srv, query, file); };\n        try {\n          if (timeBudget) infer.withTimeout(timeBudget[0], run);\n          else run();\n        } catch (e) {\n          if (srv.options.debug && e.name != \"TernError\") console.error(e.stack);\n          return c(e);\n        }\n        c(null, result);\n      });\n    });\n  }\n\n  function analyzeFile(srv, file) {\n    infer.withContext(srv.cx, function() {\n      file.scope = srv.cx.topScope;\n      srv.signal(\"beforeLoad\", file);\n      infer.analyze(file.ast, file.name, file.scope);\n      srv.signal(\"afterLoad\", file);\n    });\n    return file;\n  }\n\n  function ensureFile(srv, name, parent, text) {\n    var known = srv.findFile(name);\n    if (known) {\n      if (text != null) {\n        if (known.scope) {\n          srv.needsPurge.push(name);\n          infer.clearScopes(known.ast);\n          known.scope = null;\n        }\n        updateText(known, text, srv);\n      }\n      if (parentDepth(srv, known.parent) > parentDepth(srv, parent)) {\n        known.parent = parent;\n        if (known.excluded) known.excluded = null;\n      }\n      return;\n    }\n\n    var file = new File(name, parent);\n    srv.files.push(file);\n    srv.fileMap[name] = file;\n    if (text != null) {\n      updateText(file, text, srv);\n    } else if (srv.options.async) {\n      srv.startAsyncAction();\n      srv.options.getFile(name, function(err, text) {\n        updateText(file, text || \"\", srv);\n        srv.finishAsyncAction(err);\n      });\n    } else {\n      updateText(file, srv.options.getFile(name) || \"\", srv);\n    }\n  }\n\n  function fetchAll(srv, c) {\n    var done = true, returned = false;\n    srv.files.forEach(function(file) {\n      if (file.text != null) return;\n      if (srv.options.async) {\n        done = false;\n        srv.options.getFile(file.name, function(err, text) {\n          if (err && !returned) { returned = true; return c(err); }\n          updateText(file, text || \"\", srv);\n          fetchAll(srv, c);\n        });\n      } else {\n        try {\n          updateText(file, srv.options.getFile(file.name) || \"\", srv);\n        } catch (e) { return c(e); }\n      }\n    });\n    if (done) c();\n  }\n\n  function waitOnFetch(srv, timeBudget, c) {\n    var done = function() {\n      srv.off(\"everythingFetched\", done);\n      clearTimeout(timeout);\n      analyzeAll(srv, timeBudget, c);\n    };\n    srv.on(\"everythingFetched\", done);\n    var timeout = setTimeout(done, srv.options.fetchTimeout);\n  }\n\n  function analyzeAll(srv, timeBudget, c) {\n    if (srv.pending) return waitOnFetch(srv, timeBudget, c);\n\n    var e = srv.fetchError;\n    if (e) { srv.fetchError = null; return c(e); }\n\n    if (srv.needsPurge.length > 0) infer.withContext(srv.cx, function() {\n      infer.purge(srv.needsPurge);\n      srv.needsPurge.length = 0;\n    });\n\n    var done = true;\n    // The second inner loop might add new files. The outer loop keeps\n    // repeating both inner loops until all files have been looked at.\n    for (var i = 0; i < srv.files.length;) {\n      var toAnalyze = [];\n      for (; i < srv.files.length; ++i) {\n        var file = srv.files[i];\n        if (file.text == null) done = false;\n        else if (file.scope == null && !file.excluded) toAnalyze.push(file);\n      }\n      toAnalyze.sort(function(a, b) {\n        return parentDepth(srv, a.parent) - parentDepth(srv, b.parent);\n      });\n      for (var j = 0; j < toAnalyze.length; j++) {\n        var file = toAnalyze[j];\n        if (file.parent && !chargeOnBudget(srv, file)) {\n          file.excluded = true;\n        } else if (timeBudget) {\n          var startTime = +new Date;\n          try {\n            infer.withTimeout(timeBudget[0], function() { analyzeFile(srv, file); });\n          } catch(e) {\n            if (e instanceof infer.TimedOut) return c(e);\n            else throw e;\n          }\n          timeBudget[0] -= +new Date - startTime;\n        } else {\n          analyzeFile(srv, file);\n        }\n      }\n    }\n    if (done) c();\n    else waitOnFetch(srv, timeBudget, c);\n  }\n\n  function firstLine(str) {\n    var end = str.indexOf(\"\\n\");\n    if (end < 0) return str;\n    return str.slice(0, end);\n  }\n\n  function findMatchingPosition(line, file, near) {\n    var pos = Math.max(0, near - 500), closest = null;\n    if (!/^\\s*$/.test(line)) for (;;) {\n      var found = file.indexOf(line, pos);\n      if (found < 0 || found > near + 500) break;\n      if (closest == null || Math.abs(closest - near) > Math.abs(found - near))\n        closest = found;\n      pos = found + line.length;\n    }\n    return closest;\n  }\n\n  function scopeDepth(s) {\n    for (var i = 0; s; ++i, s = s.prev) {}\n    return i;\n  }\n\n  function ternError(msg) {\n    var err = new Error(msg);\n    err.name = \"TernError\";\n    return err;\n  }\n\n  function resolveFile(srv, localFiles, name) {\n    var isRef = name.match(/^#(\\d+)$/);\n    if (!isRef) return srv.findFile(name);\n\n    var file = localFiles[isRef[1]];\n    if (!file || file.type == \"delete\") throw ternError(\"Reference to unknown file \" + name);\n    if (file.type == \"full\") return srv.fileMap[file.name];\n\n    // This is a partial file\n\n    var realFile = file.backing = srv.fileMap[file.name];\n    var offset = resolvePos(realFile, file.offsetLines == null ? file.offset : {line: file.offsetLines, ch: 0}, true);\n    var line = firstLine(file.text);\n    var foundPos = findMatchingPosition(line, realFile.text, offset);\n    var pos = foundPos == null ? Math.max(0, realFile.text.lastIndexOf(\"\\n\", offset)) : foundPos;\n    var inObject, atFunction;\n\n    infer.withContext(srv.cx, function() {\n      infer.purge(file.name, pos, pos + file.text.length);\n\n      var text = file.text, m;\n      if (m = text.match(/(?:\"([^\"]*)\"|([\\w$]+))\\s*:\\s*function\\b/)) {\n        var objNode = walk.findNodeAround(file.backing.ast, pos, \"ObjectExpression\");\n        if (objNode && objNode.node.objType)\n          inObject = {type: objNode.node.objType, prop: m[2] || m[1]};\n      }\n      if (foundPos && (m = line.match(/^(.*?)\\bfunction\\b/))) {\n        var cut = m[1].length, white = \"\";\n        for (var i = 0; i < cut; ++i) white += \" \";\n        file.text = white + text.slice(cut);\n        atFunction = true;\n      }\n\n      var scopeStart = infer.scopeAt(realFile.ast, pos, realFile.scope);\n      var scopeEnd = infer.scopeAt(realFile.ast, pos + text.length, realFile.scope);\n      var scope = file.scope = scopeDepth(scopeStart) < scopeDepth(scopeEnd) ? scopeEnd : scopeStart;\n      file.ast = parseFile(srv, file);\n      infer.analyze(file.ast, file.name, scope);\n\n      // This is a kludge to tie together the function types (if any)\n      // outside and inside of the fragment, so that arguments and\n      // return values have some information known about them.\n      tieTogether: {\n        if (inObject || atFunction) {\n          var newInner = infer.scopeAt(file.ast, line.length, scopeStart);\n          if (!newInner.fnType) break tieTogether;\n          if (inObject) {\n            var prop = inObject.type.getProp(inObject.prop);\n            prop.addType(newInner.fnType);\n          } else if (atFunction) {\n            var inner = infer.scopeAt(realFile.ast, pos + line.length, realFile.scope);\n            if (inner == scopeStart || !inner.fnType) break tieTogether;\n            var fOld = inner.fnType, fNew = newInner.fnType;\n            if (!fNew || (fNew.name != fOld.name && fOld.name)) break tieTogether;\n            for (var i = 0, e = Math.min(fOld.args.length, fNew.args.length); i < e; ++i)\n              fOld.args[i].propagate(fNew.args[i]);\n            fOld.self.propagate(fNew.self);\n            fNew.retval.propagate(fOld.retval);\n          }\n        }\n      }\n    });\n    return file;\n  }\n\n  // Budget management\n\n  function astSize(node) {\n    var size = 0;\n    walk.simple(node, {Expression: function() { ++size; }});\n    return size;\n  }\n\n  function parentDepth(srv, parent) {\n    var depth = 0;\n    while (parent) {\n      parent = srv.fileMap[parent].parent;\n      ++depth;\n    }\n    return depth;\n  }\n\n  function budgetName(srv, file) {\n    for (;;) {\n      var parent = srv.fileMap[file.parent];\n      if (!parent.parent) break;\n      file = parent;\n    }\n    return file.name;\n  }\n\n  function chargeOnBudget(srv, file) {\n    var bName = budgetName(srv, file);\n    var size = astSize(file.ast);\n    var known = srv.budgets[bName];\n    if (known == null)\n      known = srv.budgets[bName] = srv.options.dependencyBudget;\n    if (known < size) return false;\n    srv.budgets[bName] = known - size;\n    return true;\n  }\n\n  // Query helpers\n\n  function isPosition(val) {\n    return typeof val == \"number\" || typeof val == \"object\" &&\n      typeof val.line == \"number\" && typeof val.ch == \"number\";\n  }\n\n  // Baseline query document validation\n  function invalidDoc(doc) {\n    if (doc.query) {\n      if (typeof doc.query.type != \"string\") return \".query.type must be a string\";\n      if (doc.query.start && !isPosition(doc.query.start)) return \".query.start must be a position\";\n      if (doc.query.end && !isPosition(doc.query.end)) return \".query.end must be a position\";\n    }\n    if (doc.files) {\n      if (!Array.isArray(doc.files)) return \"Files property must be an array\";\n      for (var i = 0; i < doc.files.length; ++i) {\n        var file = doc.files[i];\n        if (typeof file != \"object\") return \".files[n] must be objects\";\n        else if (typeof file.name != \"string\") return \".files[n].name must be a string\";\n        else if (file.type == \"delete\") continue;\n        else if (typeof file.text != \"string\") return \".files[n].text must be a string\";\n        else if (file.type == \"part\") {\n          if (!isPosition(file.offset) && typeof file.offsetLines != \"number\")\n            return \".files[n].offset must be a position\";\n        } else if (file.type != \"full\") return \".files[n].type must be \\\"full\\\" or \\\"part\\\"\";\n      }\n    }\n  }\n\n  var offsetSkipLines = 25;\n\n  function forwardCharacters(file, start, chars) {\n    var pos = start + chars, m;\n    if (file.hasAstral) {\n      astral.lastIndex = start;\n      while ((m = astral.exec(file.text)) && m.index < pos) pos++;\n    }\n    return pos;\n  }\n\n  function findLineStart(file, line) {\n    var text = file.text, offsets = file.lineOffsets || (file.lineOffsets = [0]);\n    var pos = 0, curLine = 0;\n    var storePos = Math.min(Math.floor(line / offsetSkipLines), offsets.length - 1);\n    var pos = offsets[storePos], curLine = storePos * offsetSkipLines;\n\n    while (curLine < line) {\n      ++curLine;\n      pos = text.indexOf(\"\\n\", pos) + 1;\n      if (pos === 0) return null;\n      if (curLine % offsetSkipLines === 0) offsets.push(pos);\n    }\n    return pos;\n  }\n\n  var resolvePos = exports.resolvePos = function(file, pos, tolerant) {\n    if (typeof pos != \"number\") {\n      var lineStart = findLineStart(file, pos.line);\n      if (lineStart == null) {\n        if (tolerant) pos = file.text.length;\n        else throw ternError(\"File doesn't contain a line \" + pos.line);\n      } else {\n        pos = forwardCharacters(file, lineStart, pos.ch);\n      }\n    } else {\n      pos = forwardCharacters(file, 0, pos);\n    }\n    if (pos > file.text.length) {\n      if (tolerant) pos = file.text.length;\n      else throw ternError(\"Position \" + pos + \" is outside of file.\");\n    }\n    return pos;\n  };\n\n  function charDistanceBetween(file, start, end) {\n    var diff = end - start, m;\n    if (file.hasAstral) {\n      astral.lastIndex = start;\n      while ((m = astral.exec(file.text)) && m.index < end) diff--;\n    }\n    return diff;\n  }\n\n  function asLineChar(file, pos) {\n    if (!file) return {line: 0, ch: 0};\n    var offsets = file.lineOffsets || (file.lineOffsets = [0]);\n    var text = file.text, line, lineStart;\n    for (var i = offsets.length - 1; i >= 0; --i) if (offsets[i] <= pos) {\n      line = i * offsetSkipLines;\n      lineStart = offsets[i];\n    }\n    for (;;) {\n      var eol = text.indexOf(\"\\n\", lineStart);\n      if (eol >= pos || eol < 0) break;\n      lineStart = eol + 1;\n      ++line;\n    }\n    return {line: line, ch: charDistanceBetween(file, lineStart, pos)};\n  }\n\n  var outputPos = exports.outputPos = function(query, file, pos) {\n    if (query.lineCharPositions) {\n      var out = asLineChar(file, pos);\n      if (file.type == \"part\")\n        out.line += file.offsetLines != null ? file.offsetLines : asLineChar(file.backing, file.offset).line;\n      return out;\n    } else {\n      return charDistanceBetween(file, 0, pos) + (file.type == \"part\" ? file.offset : 0);\n    }\n  };\n\n  // Delete empty fields from result objects\n  function clean(obj) {\n    for (var prop in obj) if (obj[prop] == null) delete obj[prop];\n    return obj;\n  }\n  function maybeSet(obj, prop, val) {\n    if (val != null) obj[prop] = val;\n  }\n\n  // Built-in query types\n\n  function compareCompletions(a, b) {\n    if (typeof a != \"string\") { a = a.name; b = b.name; }\n    var aUp = /^[A-Z]/.test(a), bUp = /^[A-Z]/.test(b);\n    if (aUp == bUp) return a < b ? -1 : a == b ? 0 : 1;\n    else return aUp ? 1 : -1;\n  }\n\n  function isStringAround(node, start, end) {\n    return node.type == \"Literal\" && typeof node.value == \"string\" &&\n      node.start == start - 1 && node.end <= end + 1;\n  }\n\n  function pointInProp(objNode, point) {\n    for (var i = 0; i < objNode.properties.length; i++) {\n      var curProp = objNode.properties[i];\n      if (curProp.key && curProp.key.start <= point && curProp.key.end >= point)\n        return curProp;\n    }\n  }\n\n  var jsKeywords = (\"break do instanceof typeof case else new var \" +\n    \"catch finally return void continue for switch while debugger \" +\n    \"function this with default if throw delete in try\").split(\" \");\n  var jsKeywordsES6 = jsKeywords.concat(\"export class extends const super yield import let static\".split(\" \"));\n\n  var addCompletion = exports.addCompletion = function(query, completions, name, aval, depth) {\n    var typeInfo = query.types || query.docs || query.urls || query.origins;\n    var wrapAsObjs = typeInfo || query.depths;\n\n    for (var i = 0; i < completions.length; ++i) {\n      var c = completions[i];\n      if ((wrapAsObjs ? c.name : c) == name) return;\n    }\n    var rec = wrapAsObjs ? {name: name} : name;\n    completions.push(rec);\n\n    if (aval && typeInfo) {\n      infer.resetGuessing();\n      var type = aval.getType();\n      rec.guess = infer.didGuess();\n      if (query.types)\n        rec.type = infer.toString(aval);\n      if (query.docs)\n        maybeSet(rec, \"doc\", parseDoc(query, aval.doc || type && type.doc));\n      if (query.urls)\n        maybeSet(rec, \"url\", aval.url || type && type.url);\n      if (query.origins)\n        maybeSet(rec, \"origin\", aval.origin || type && type.origin);\n    }\n    if (query.depths) rec.depth = depth || 0;\n    return rec;\n  };\n\n  function findCompletions(srv, query, file) {\n    if (query.end == null) throw ternError(\"missing .query.end field\");\n    var fromPlugin = srv.signalReturnFirst(\"completion\", file, query);\n    if (fromPlugin) return fromPlugin;\n\n    var wordStart = resolvePos(file, query.end), wordEnd = wordStart, text = file.text;\n    while (wordStart && acorn.isIdentifierChar(text.charCodeAt(wordStart - 1))) --wordStart;\n    if (query.expandWordForward !== false)\n      while (wordEnd < text.length && acorn.isIdentifierChar(text.charCodeAt(wordEnd))) ++wordEnd;\n    var word = text.slice(wordStart, wordEnd), completions = [], ignoreObj;\n    if (query.caseInsensitive) word = word.toLowerCase();\n\n    function gather(prop, obj, depth, addInfo) {\n      // 'hasOwnProperty' and such are usually just noise, leave them\n      // out when no prefix is provided.\n      if ((objLit || query.omitObjectPrototype !== false) && obj == srv.cx.protos.Object && !word) return;\n      if (query.filter !== false && word &&\n          (query.caseInsensitive ? prop.toLowerCase() : prop).indexOf(word) !== 0) return;\n      if (ignoreObj && ignoreObj.props[prop]) return;\n      var result = addCompletion(query, completions, prop, obj && obj.props[prop], depth);\n      if (addInfo && result && typeof result != \"string\") addInfo(result);\n    }\n\n    var hookname, prop, objType, isKey;\n\n    var exprAt = infer.findExpressionAround(file.ast, null, wordStart, file.scope);\n    var memberExpr, objLit;\n    // Decide whether this is an object property, either in a member\n    // expression or an object literal.\n    if (exprAt) {\n      var exprNode = exprAt.node;\n\n      if (query.inLiteral === false && exprNode.type === \"Literal\" &&\n          (typeof exprNode.value === 'string' || exprNode.regex))\n        return {\n          start: outputPos(query, file, wordStart),\n          end: outputPos(query, file, wordEnd),\n          completions: []\n        };\n\n      if (exprNode.type == \"MemberExpression\" && exprNode.object.end < wordStart) {\n        memberExpr = exprAt;\n      } else if (isStringAround(exprNode, wordStart, wordEnd)) {\n        var parent = infer.parentNode(exprNode, file.ast);\n        if (parent.type == \"MemberExpression\" && parent.property == exprNode)\n          memberExpr = {node: parent, state: exprAt.state};\n      } else if (exprNode.type == \"ObjectExpression\") {\n        var objProp = pointInProp(exprNode, wordEnd);\n        if (objProp) {\n          objLit = exprAt;\n          prop = isKey = objProp.key.name || objProp.key.value;\n        } else if (!word && !/:\\s*$/.test(file.text.slice(0, wordStart))) {\n          objLit = exprAt;\n          prop = isKey = true;\n        }\n      }\n    }\n\n    if (objLit) {\n      // Since we can't use the type of the literal itself to complete\n      // its properties (it doesn't contain the information we need),\n      // we have to try asking the surrounding expression for type info.\n      objType = infer.typeFromContext(file.ast, objLit);\n      ignoreObj = objLit.node.objType;\n    } else if (memberExpr) {\n      prop = memberExpr.node.property;\n      prop = prop.type == \"Literal\" ? prop.value.slice(1) : prop.name;\n      memberExpr.node = memberExpr.node.object;\n      objType = infer.expressionType(memberExpr);\n    } else if (text.charAt(wordStart - 1) == \".\") {\n      var pathStart = wordStart - 1;\n      while (pathStart && (text.charAt(pathStart - 1) == \".\" || acorn.isIdentifierChar(text.charCodeAt(pathStart - 1)))) pathStart--;\n      var path = text.slice(pathStart, wordStart - 1);\n      if (path) {\n        objType = infer.def.parsePath(path, file.scope).getObjType();\n        prop = word;\n      }\n    }\n\n    if (prop != null) {\n      srv.cx.completingProperty = prop;\n\n      if (objType) infer.forAllPropertiesOf(objType, gather);\n\n      if (!completions.length && query.guess !== false && objType && objType.guessProperties)\n        objType.guessProperties(function(p, o, d) {if (p != prop && p != \"\" && p != \"<i>\") gather(p, o, d);});\n      if (!completions.length && word.length >= 2 && query.guess !== false)\n        for (var prop in srv.cx.props) gather(prop, srv.cx.props[prop][0], 0);\n      hookname = \"memberCompletion\";\n    } else {\n      infer.forAllLocalsAt(file.ast, wordStart, file.scope, gather);\n      if (query.includeKeywords) {\n        (srv.options.ecmaVersion >= 6 ? jsKeywordsES6 : jsKeywords).forEach(function(kw) {\n          gather(kw, null, 0, function(rec) { rec.isKeyword = true; });\n        });\n      }\n      hookname = \"variableCompletion\";\n    }\n    srv.signal(hookname, file, wordStart, wordEnd, gather);\n\n    if (query.sort !== false) completions.sort(compareCompletions);\n    srv.cx.completingProperty = null;\n\n    return {start: outputPos(query, file, wordStart),\n            end: outputPos(query, file, wordEnd),\n            isProperty: !!prop,\n            isObjectKey: !!isKey,\n            completions: completions};\n  }\n\n  function findProperties(srv, query) {\n    var prefix = query.prefix, found = [];\n    for (var prop in srv.cx.props)\n      if (prop != \"<i>\" && (!prefix || prop.indexOf(prefix) === 0)) found.push(prop);\n    if (query.sort !== false) found.sort(compareCompletions);\n    return {completions: found};\n  }\n\n  function inBody(node, pos) {\n    var body = node.body, start, end;\n    if (!body) return false;\n    if (Array.isArray(body)) {\n      start = body[0].start;\n      end = body[body.length - 1].end;\n    } else {\n      start = body.start;\n      end = body.end;\n    }\n    return start <= pos && end >= pos;\n  }\n\n  var findExpr = exports.findQueryExpr = function(file, query, wide) {\n    if (query.end == null) throw ternError(\"missing .query.end field\");\n\n    if (query.variable) {\n      var scope = infer.scopeAt(file.ast, resolvePos(file, query.end), file.scope);\n      return {node: {type: \"Identifier\", name: query.variable, start: query.end, end: query.end + 1},\n              state: scope};\n    } else {\n      var start = query.start && resolvePos(file, query.start), end = resolvePos(file, query.end);\n      var expr = infer.findExpressionAt(file.ast, start, end, file.scope);\n      if (!expr) {\n        var span = infer.findClosestExpression(file.ast, start, end, file.scope);\n        if (span && !inBody(span.node, end) &&\n            (wide || (start == null ? end : start) - span.node.start < 20 || span.node.end - end < 20))\n          expr = span;\n      }\n      if (!expr) {\n        var around = infer.findExpressionAround(file.ast, start, end, file.scope);\n        if (around && !inBody(around.node, end) &&\n            (around.node.type == \"ObjectExpression\" || wide ||\n             (start == null ? end : start) - around.node.start < 20 || around.node.end - end < 20))\n          expr = around;\n      }\n      return expr;\n    }\n  };\n\n  function findExprAround(file, query, wide) {\n    var start = query.start && resolvePos(file, query.start), end = resolvePos(file, query.end);\n    var expr = null;\n    var around = infer.findExpressionAround(file.ast, start, end, file.scope);\n    if (around && !inBody(around.node, end) &&\n        (around.node.type == \"ObjectExpression\" || wide ||\n         (start == null ? end : start) - around.node.start < 20 || around.node.end - end < 20))\n      expr = around;\n    return expr;\n  }\n\n  function findExprOrThrow(file, query, wide) {\n    var expr = findExpr(file, query, wide);\n    if (expr) return expr;\n    throw ternError(\"No expression at the given position.\");\n  }\n\n  function ensureObj(tp) {\n    if (!tp || !(tp = tp.getType()) || !(tp instanceof infer.Obj)) return null;\n    return tp;\n  }\n\n  function findExprType(srv, query, file, expr) {\n    var type;\n    if (expr) {\n      infer.resetGuessing();\n      type = infer.expressionType(expr);\n    }\n    var typeHandlers = srv.hasHandler(\"typeAt\");\n    if (typeHandlers) {\n      var pos = resolvePos(file, query.end);\n      for (var i = 0; i < typeHandlers.length; i++)\n        type = typeHandlers[i](file, pos, expr, type);\n    }\n    if (!type) throw ternError(\"No type found at the given position.\");\n\n    var objProp;\n    if (expr.node.type == \"ObjectExpression\" && query.end != null &&\n        (objProp = pointInProp(expr.node, resolvePos(file, query.end)))) {\n      var name = objProp.key.name;\n      var fromCx = ensureObj(infer.typeFromContext(file.ast, expr));\n      if (fromCx && fromCx.hasProp(name)) {\n        type = fromCx.hasProp(name);\n      } else {\n        var fromLocal = ensureObj(type);\n        if (fromLocal && fromLocal.hasProp(name))\n          type = fromLocal.hasProp(name);\n      }\n    }\n    return type;\n  }\n\n  function findTypeAtExpr(srv, query, file, expr) {\n    var exprName, exprType;\n    var type = findExprType(srv, query, file, expr), exprType = type;\n    if (query.preferFunction)\n      type = type.getFunctionType() || type.getType();\n    else\n      type = type.getType();\n\n    if (expr) {\n      if (expr.node.type == \"Identifier\")\n        exprName = expr.node.name;\n      else if (expr.node.type == \"MemberExpression\" && !expr.node.computed)\n        exprName = expr.node.property.name;\n      else if (expr.node.type == \"MethodDefinition\" && !expr.node.computed)\n        exprName = expr.node.key.name;\n    }\n\n    if (query.depth != null && typeof query.depth != \"number\")\n      throw ternError(\".query.depth must be a number\");\n\n    return [type, exprName, exprType];\n  }\n\n  function findTypeAt(srv, query, file) {\n    var type, exprName, exprType;\n    var expr = findExpr(file, query);\n    var typeResult = findTypeAtExpr(srv, query, file, expr);\n    type = typeResult[0];\n    if (!type) {\n      expr = findExprAround(file, query);\n      typeResult = findTypeAtExpr(srv, query, file, expr);\n      type = typeResult[0];\n    }\n    exprName = typeResult[1];\n    exprType = typeResult[2];\n\n    var result = {guess: infer.didGuess(),\n                  type: infer.toString(exprType, query.depth),\n                  name: type && type.name,\n                  exprName: exprName,\n                  doc: exprType.doc,\n                  url: exprType.url};\n    if (type) storeTypeDocs(query, type, result);\n\n    return clean(result);\n  }\n\n  function parseDoc(query, doc) {\n    if (!doc) return null;\n    if (query.docFormat == \"full\") return doc;\n    var parabreak = /.\\n[\\s@\\n]/.exec(doc);\n    if (parabreak) doc = doc.slice(0, parabreak.index + 1);\n    doc = doc.replace(/\\n\\s*/g, \" \");\n    if (doc.length < 100) return doc;\n    var sentenceEnd = /[\\.!?] [A-Z]/g;\n    sentenceEnd.lastIndex = 80;\n    var found = sentenceEnd.exec(doc);\n    if (found) doc = doc.slice(0, found.index + 1);\n    return doc;\n  }\n\n  function findDocs(srv, query, file) {\n    var expr = findExpr(file, query);\n    var type = findExprType(srv, query, file, expr);\n    var inner = type.getType();\n    if (!inner) {\n      expr = findExprAround(file, query);\n      type = findExprType(srv, query, file, expr);\n      inner = type.getType();\n    }\n    var result = {url: type.url, doc: parseDoc(query, type.doc), type: infer.toString(type)};\n    if (inner) storeTypeDocs(query, inner, result);\n    return clean(result);\n  }\n\n  function storeTypeDocs(query, type, out) {\n    if (!out.url) out.url = type.url;\n    if (!out.doc) out.doc = parseDoc(query, type.doc);\n    if (!out.origin) out.origin = type.origin;\n    var ctor, boring = infer.cx().protos;\n    if (!out.url && !out.doc && type.proto && (ctor = type.proto.hasCtor) &&\n        type.proto != boring.Object && type.proto != boring.Function && type.proto != boring.Array) {\n      out.url = ctor.url;\n      out.doc = parseDoc(query, ctor.doc);\n    }\n  }\n\n  var getSpan = exports.getSpan = function(obj) {\n    if (!obj.origin) return;\n    if (obj.originNode) {\n      var node = obj.originNode;\n      if (/^Function/.test(node.type) && node.id) node = node.id;\n      return {origin: obj.origin, node: node};\n    }\n    if (obj.span) return {origin: obj.origin, span: obj.span};\n  };\n\n  var storeSpan = exports.storeSpan = function(srv, query, span, target) {\n    target.origin = span.origin;\n    if (span.span) {\n      var m = /^(\\d+)\\[(\\d+):(\\d+)\\]-(\\d+)\\[(\\d+):(\\d+)\\]$/.exec(span.span);\n      target.start = query.lineCharPositions ? {line: Number(m[2]), ch: Number(m[3])} : Number(m[1]);\n      target.end = query.lineCharPositions ? {line: Number(m[5]), ch: Number(m[6])} : Number(m[4]);\n    } else {\n      var file = srv.fileMap[span.origin];\n      target.start = outputPos(query, file, span.node.start);\n      target.end = outputPos(query, file, span.node.end);\n    }\n  };\n\n  function findDef(srv, query, file) {\n    var expr = findExpr(file, query);\n    var type = findExprType(srv, query, file, expr);\n    if (infer.didGuess()) return {};\n\n    var span = getSpan(type);\n    var result = {url: type.url, doc: parseDoc(query, type.doc), origin: type.origin};\n\n    if (type.types) for (var i = type.types.length - 1; i >= 0; --i) {\n      var tp = type.types[i];\n      storeTypeDocs(query, tp, result);\n      if (!span) span = getSpan(tp);\n    }\n\n    if (span && span.node) { // refers to a loaded file\n      var spanFile = span.node.sourceFile || srv.fileMap[span.origin];\n      var start = outputPos(query, spanFile, span.node.start), end = outputPos(query, spanFile, span.node.end);\n      result.start = start; result.end = end;\n      result.file = span.origin;\n      var cxStart = Math.max(0, span.node.start - 50);\n      result.contextOffset = span.node.start - cxStart;\n      result.context = spanFile.text.slice(cxStart, cxStart + 50);\n    } else if (span) { // external\n      result.file = span.origin;\n      storeSpan(srv, query, span, result);\n    }\n    return clean(result);\n  }\n\n  function findRefsToVariable(srv, query, file, expr, isRename) {\n    var name = expr.node.name;\n\n    for (var scope = expr.state; scope && !(name in scope.props); scope = scope.prev) {}\n    if (!scope) throw ternError(\"Could not find a definition for \" + name);\n\n    var type, refs = [];\n    function storeRef(file) {\n      return function(node, scopeHere, ancestors) {\n        var value = {file: file.name,\n                     start: outputPos(query, file, node.start),\n                     end: outputPos(query, file, node.end)};\n        if (isRename) {\n          for (var s = scopeHere; s != scope; s = s.prev) {\n            var exists = s.hasProp(isRename);\n            if (exists)\n              throw ternError(\"Renaming `\" + name + \"` to `\" + isRename + \"` would make a variable at line \" +\n                              (asLineChar(file, node.start).line + 1) + \" point to the definition at line \" +\n                              (asLineChar(file, exists.name.start).line + 1));\n          }\n          var parent = ancestors[ancestors.length - 2];\n          if (parent && parent.type == \"Property\" && parent.key == parent.value)\n            value.isShorthand = true;\n        }\n        refs.push(value);\n      };\n    }\n\n    if (scope.originNode) {\n      type = \"local\";\n      if (isRename) {\n        for (var prev = scope.prev; prev; prev = prev.prev)\n          if (isRename in prev.props) break;\n        if (prev) infer.findRefs(scope.originNode, scope, isRename, prev, function(node) {\n          throw ternError(\"Renaming `\" + name + \"` to `\" + isRename + \"` would shadow the definition used at line \" +\n                          (asLineChar(file, node.start).line + 1));\n        });\n      }\n      infer.findRefs(scope.originNode, scope, name, scope, storeRef(file));\n    } else {\n      type = \"global\";\n      if (query.onlySourceFile) {\n        infer.findRefs(file.ast, file.scope, name, scope, storeRef(file));\n      } else {\n        for (var i = 0; i < srv.files.length; ++i) {\n          var cur = srv.files[i];\n          infer.findRefs(cur.ast, cur.scope, name, scope, storeRef(cur));\n        }\n      }\n    }\n\n    return {refs: refs, type: type, name: name};\n  }\n\n  function findRefsToProperty(srv, query, sourceFile, expr, prop) {\n    var exprType = infer.expressionType(expr);\n    if (expr.node.type == \"MethodDefinition\") {\n      exprType = exprType.propertyOf;\n    }\n    var objType = exprType.getObjType();\n    if (!objType) throw ternError(\"Couldn't determine type of base object.\");\n\n    var refs = [];\n    function storeRef(file) {\n      return function(node) {\n        refs.push({file: file.name,\n                   start: outputPos(query, file, node.start),\n                   end: outputPos(query, file, node.end)});\n      };\n    }\n\n    if (query.onlySourceFile) {\n        infer.findPropRefs(sourceFile.ast, sourceFile.scope, objType, prop.name, storeRef(sourceFile));\n    } else {\n      for (var i = 0; i < srv.files.length; ++i) {\n        var cur = srv.files[i];\n        infer.findPropRefs(cur.ast, cur.scope, objType, prop.name, storeRef(cur));\n      }\n    }\n\n    return {refs: refs, name: prop.name};\n  }\n\n  function findRefs(srv, query, file) {\n    var expr = findExprOrThrow(file, query, true);\n    if (expr && expr.node.type == \"Identifier\") {\n      return findRefsToVariable(srv, query, file, expr);\n    } else if (expr && expr.node.type == \"MemberExpression\" && !expr.node.computed) {\n      var p = expr.node.property;\n      expr.node = expr.node.object;\n      return findRefsToProperty(srv, query, file, expr, p);\n    } else if (expr && expr.node.type == \"ObjectExpression\") {\n      var pos = resolvePos(file, query.end);\n      for (var i = 0; i < expr.node.properties.length; ++i) {\n        var k = expr.node.properties[i].key;\n        if (k.start <= pos && k.end >= pos)\n          return findRefsToProperty(srv, query, file, expr, k);\n      }\n    } else if (expr && expr.node.type == \"MethodDefinition\") {\n      var p = expr.node.key;\n      return findRefsToProperty(srv, query, file, expr, p);\n    }\n    throw ternError(\"Not at a variable or property name.\");\n  }\n\n  function buildRename(srv, query, file) {\n    if (typeof query.newName != \"string\") throw ternError(\".query.newName should be a string\");\n    var expr = findExprOrThrow(file, query);\n    if (!expr || expr.node.type != \"Identifier\") throw ternError(\"Not at a variable.\");\n\n    var data = findRefsToVariable(srv, query, file, expr, query.newName), refs = data.refs;\n    delete data.refs;\n    data.files = srv.files.map(function(f){return f.name;});\n\n    var changes = data.changes = [];\n    for (var i = 0; i < refs.length; ++i) {\n      var use = refs[i];\n      if (use.isShorthand) use.text = expr.node.name + \": \" + query.newName;\n      else use.text = query.newName;\n      changes.push(use);\n    }\n\n    return data;\n  }\n\n  function listFiles(srv) {\n    return {files: srv.files.map(function(f){return f.name;})};\n  }\n\n  exports.version = \"0.24.3\";\n});\n"],"file":"tern.js"}