{"version":3,"sources":["node-loader.js"],"names":["nodeLoader","nodeLoadstartTime","Date","now","phcodeExecHandlerMap","nodeConnectorIDMap","pendingExecPromiseMap","currentCommandID","wssEndpoint","controlSocket","dataSocket","SOCKET_TYPE_DATA","SOCKET_TYPE_CONTROL","LARGE_DATA_THRESHOLD","MAX_RECONNECT_BACKOFF_TIME_MS","NODE_CONNECTOR_CREATE_TIMEOUT","MAX_QUEUE_LENGTH","pendingNodeConnectorExecMap","pendingNodeConnectorEventMap","isTimerRunningMap","WS_COMMAND","RESPONSE","EXEC","EVENT","LARGE_DATA_SOCKET_ANNOUNCE","CONTROL_SOCKET_ANNOUNCE","WS_ERR_CODES","NO_SUCH_FN","mergeMetadataAndArrayBuffer","metadata","bufferData","ArrayBuffer","hasBufferData","Error","metadataString","JSON","stringify","metadataUint8Array","TextEncoder","encode","metadataBuffer","buffer","sizePrefixLength","byteLength","concatenatedBuffer","concatenatedUint8Array","Uint8Array","DataView","setUint32","set","splitMetadataAndBuffer","buffer1Length","getUint32","buffer1","slice","parse","TextDecoder","decode","buffer2","MAX_PENDING_SEND_BUFFER","pendingSendBuffer","_drainPendingSendBuffer","copyPendingSendBuffer","commandObject","dataBuffer","_sendWithAppropriateSocket","_isSocketOpen","socket","readyState","WebSocket","OPEN","socketToUse","atleastOneSocketUsable","send","length","push","_sendInitCommand","commandCode","commandID","data","_sendExec","nodeConnectorID","execHandlerFnName","dataObjectToSend","command","_sendExecResponse","defaultWS","response","originalCommand","error","_sendEvent","eventName","event","_sendError","err","defaultMessage","message","code","stack","_isObject","variable","_extractBuffer","result","_isJSONStringifiable","e","_errNClearQueue","pendingExecList","ws","_queueExec","setTimeout","_drainExecQueue","_execPhcodeConnectorFn","moduleExports","Promise","then","catch","_queueEvent","pendingEventList","_drainEventQueue","_triggerEvent","nodeConnector","trigger","processWSCommand","pendingExecPromise","cause","nodeStack","reject","resolve","console","createNodeConnector","newNodeConnector","execPeer","triggerPeer","window","EventDispatcher","makeEventDispatcher","_silentlyCloseSocket","autoReconnect","close","_wait","timeMS","async","_establishAndMaintainConnection","socketType","firstConnectCB","binaryType","resolved","wsClosePromiseResolve","wsClosePromise","isLargeDataWS","addEventListener","backoffTime","Math","min","setNodeWSEndpoint","websocketEndpoint","nodeSetupDonePromise","NODE_COMMANDS","COMMAND_RESPONSE_PREFIX","COMMAND_ERROR_PREFIX","child","pendingCommands","PHNODE_PREFERENCES_KEY","setInspectEnabled","enabled","prefs","localStorage","getItem","inspectEnabled","setItem","isInspectEnabled","getRandomNumber","max","floor","random","nodeTerminationResolve","nodeTerminationPromise","PhNodeEngine","isNodeReady","nodeErrorLogCount","MAX_NODE_ERROR_LOGS_ALLOWED","NODE_ERROR_LOGS_RESET_INTERVAL","setInterval","debugMode","__TAURI__","path","resolveResource","Phoenix","platform","cliArgs","invoke","nodeSrcPath","dirname","inspectPort","isTestWindow","argsArray","shell","Command","sidecar","on","isNodeTerminated","log","signal","logger","reportError","stdout","line","startsWith","replace","jsonMsg","type","stderr","spawn","execNode","commandData","newCommandID","resolveP","rejectP","write","promise","terminateNode","getInspectPort","fs","phoenixFSURL","forceUseNodeWSEndpoint","phoenixNodeURL","_nodeLoadTime","isNativeApp"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*global Phoenix, fs, logger*/\n\nfunction nodeLoader() {\n    const nodeLoadstartTime = Date.now();\n    const phcodeExecHandlerMap = {};\n    const nodeConnectorIDMap = {};\n    // This holds the list {resolve, reject} for all waiting exec functions executed with execPeer here.\n    const pendingExecPromiseMap = {};\n    let currentCommandID = 1; // should be greater than 0!\n    let wssEndpoint, controlSocket, dataSocket;\n    const SOCKET_TYPE_DATA = \"data\",\n        SOCKET_TYPE_CONTROL = \"control\";\n    const LARGE_DATA_THRESHOLD = 2*1024*1024; // 2MB\n    const MAX_RECONNECT_BACKOFF_TIME_MS = 1000;\n\n    // If a NodeConnector has been created on this end, we can promptly process events and exec messages. However,\n    // in cases where a NodeConnector hasn't been created yet on this end, we temporarily queue execs and event triggers\n    // for up to 10 seconds. This approach ensures that the other side remains unaware of the status of the\n    // NodeConnector at both ends, allowing them to initiate message transmission via the WebSocket as soon as they\n    // invoke the createNodeConnector API on their side.\n\n    // Timeout duration for NodeConnector creation (10 seconds)\n    const NODE_CONNECTOR_CREATE_TIMEOUT = 10000;\n    // Max number of messages to queue for a single node connector.\n    const MAX_QUEUE_LENGTH = 2000;\n\n    // These arrays hold queues of event and exec messages received from the other side while a NodeConnector\n    // was not yet created on this end. Messages are queued for up to 10 seconds.\n    const pendingNodeConnectorExecMap = {};\n    const pendingNodeConnectorEventMap = {};\n\n    // This timer clears the pending maps above if a NodeConnector is not created within 10 seconds.\n    const isTimerRunningMap = {};\n\n\n    const WS_COMMAND = {\n        RESPONSE: \"response\",\n        EXEC: \"exec\",\n        EVENT: \"event\",\n        LARGE_DATA_SOCKET_ANNOUNCE: \"largeDataSock\",\n        CONTROL_SOCKET_ANNOUNCE: \"controlSock\"\n    };\n\n    const WS_ERR_CODES = {\n        NO_SUCH_FN: \"NoSuchFn\"\n    };\n\n    /**\n     *\n     * @param metadata {Object} Max size can be 4GB\n     * @param bufferData {ArrayBuffer} [optional]\n     * @return {ArrayBuffer}\n     * @private\n     */\n    function mergeMetadataAndArrayBuffer(metadata, bufferData) {\n        if (bufferData instanceof ArrayBuffer) {\n            metadata.hasBufferData = true;\n        }\n        bufferData = bufferData || new ArrayBuffer(0);\n        if (typeof metadata !== 'object') {\n            throw new Error(\"metadata should be an object, but was \" + typeof metadata);\n        }\n        if (!(bufferData instanceof ArrayBuffer)) {\n            throw new Error(\"Expected bufferData to be an instance of ArrayBuffer, but was \" + typeof bufferData);\n        }\n\n        const metadataString = JSON.stringify(metadata);\n        const metadataUint8Array = new TextEncoder().encode(metadataString);\n        const metadataBuffer = metadataUint8Array.buffer;\n        const sizePrefixLength = 4; // 4 bytes for a 32-bit integer\n\n        if (metadataBuffer.byteLength > 4294000000) {\n            throw new Error(\"metadata too large. Should be below 4,294MB, but was \" + metadataBuffer.byteLength);\n        }\n\n        const concatenatedBuffer = new ArrayBuffer(sizePrefixLength + metadataBuffer.byteLength + bufferData.byteLength);\n        const concatenatedUint8Array = new Uint8Array(concatenatedBuffer);\n\n        // Write the length of metadataBuffer as a 32-bit integer\n        new DataView(concatenatedBuffer).setUint32(0, metadataBuffer.byteLength, true);\n\n        // Copy the metadataUint8Array and bufferData (if provided) to the concatenatedUint8Array\n        concatenatedUint8Array.set(metadataUint8Array, sizePrefixLength);\n        if (bufferData.byteLength > 0) {\n            concatenatedUint8Array.set(new Uint8Array(bufferData), sizePrefixLength + metadataBuffer.byteLength);\n        }\n\n        return concatenatedBuffer;\n    }\n\n    function splitMetadataAndBuffer(concatenatedBuffer) {\n        if(!(concatenatedBuffer instanceof ArrayBuffer)){\n            throw new Error(\"Expected ArrayBuffer message from websocket\");\n        }\n        const sizePrefixLength = 4;\n        const buffer1Length = new DataView(concatenatedBuffer).getUint32(0, true); // Little endian\n\n        const buffer1 = concatenatedBuffer.slice(sizePrefixLength, sizePrefixLength + buffer1Length);\n        const metadata = JSON.parse(new TextDecoder().decode(buffer1));\n        let buffer2;\n        if (concatenatedBuffer.byteLength > sizePrefixLength + buffer1Length) {\n            buffer2 = concatenatedBuffer.slice(sizePrefixLength + buffer1Length);\n        }\n        if(!buffer2 && metadata.hasBufferData) {\n            // This happens if the sender is sending 0 length buffer. So we have to create an empty buffer here\n            buffer2 = new ArrayBuffer(0);\n        }\n\n        return {\n            metadata,\n            bufferData: buffer2\n        };\n    }\n\n    const MAX_PENDING_SEND_BUFFER = 10000;\n    let pendingSendBuffer = [];\n\n    function _drainPendingSendBuffer() {\n        const copyPendingSendBuffer = pendingSendBuffer;\n        // empty to prevent race conditions\n        pendingSendBuffer = [];\n        // Using a for...of loop for better readability\n        for(let {commandObject, dataBuffer} of copyPendingSendBuffer) {\n            _sendWithAppropriateSocket(commandObject, dataBuffer);\n        }\n    }\n\n    function _isSocketOpen(socket) {\n        return socket && socket.readyState === WebSocket.OPEN;\n    }\n\n    function _sendWithAppropriateSocket(commandObject, dataBuffer) {\n        let socketToUse = controlSocket || dataSocket;\n        const atleastOneSocketUsable = _isSocketOpen(controlSocket) || _isSocketOpen(dataSocket);\n        if(!socketToUse || !atleastOneSocketUsable){\n            // We got a send event before a websocket connection is established by phcode. Queue it to send later.\n            if(pendingSendBuffer.length > MAX_PENDING_SEND_BUFFER){\n                throw new Error(\"Too many node ws messages queued before a node connection was established to phnode.\");\n            }\n            pendingSendBuffer.push({commandObject, dataBuffer});\n            return;\n        }\n        if((dataBuffer && dataBuffer.byteLength > LARGE_DATA_THRESHOLD && dataSocket && _isSocketOpen(dataSocket))\n        || (_isSocketOpen(dataSocket) && !_isSocketOpen(controlSocket))) {\n            socketToUse = dataSocket;\n        }\n        socketToUse.send(mergeMetadataAndArrayBuffer(commandObject, dataBuffer));\n    }\n\n    function _sendInitCommand(socket, commandCode) {\n        currentCommandID++;\n        const commandID = currentCommandID;\n        socket.send(mergeMetadataAndArrayBuffer({\n            commandCode: commandCode,\n            commandID: commandID,\n            data: null\n        }, null));\n    }\n\n    function _sendExec(nodeConnectorID, commandID, execHandlerFnName, dataObjectToSend = null, dataBuffer = null) {\n        const command = {\n            nodeConnectorID: nodeConnectorID,\n            commandID: commandID,\n            execHandlerFnName,\n            commandCode: WS_COMMAND.EXEC,\n            data: dataObjectToSend\n        };\n        _sendWithAppropriateSocket(command, dataBuffer);\n    }\n\n    /**\n     *\n     * @param defaultWS If specified, will use the given socket.\n     * @param metadata\n     * @param dataObjectToSend\n     * @param dataBuffer {ArrayBuffer}\n     * @private\n     */\n    function _sendExecResponse(defaultWS, metadata, dataObjectToSend = null, dataBuffer = null) {\n        const response = {\n            originalCommand: metadata.commandCode,\n            commandCode: WS_COMMAND.RESPONSE,\n            commandID: metadata.commandID,\n            error: metadata.error,\n            data: dataObjectToSend\n        };\n        let socketToUse = defaultWS || controlSocket;\n        if(dataBuffer && dataBuffer.byteLength > LARGE_DATA_THRESHOLD && dataSocket) {\n            socketToUse = dataSocket;\n        }\n        socketToUse.send(mergeMetadataAndArrayBuffer(response, dataBuffer));\n    }\n\n    function _sendEvent(nodeConnectorID, eventName, dataObjectToSend = null, dataBuffer = null) {\n        const event = {\n            nodeConnectorID,\n            eventName,\n            commandCode: WS_COMMAND.EVENT,\n            data: dataObjectToSend\n        };\n        _sendWithAppropriateSocket(event, dataBuffer);\n    }\n\n    function _sendError(defaultWS, metadata, err= { }, defaultMessage = \"Operation failed! \") {\n        metadata.error = {\n            message: err.message || defaultMessage,\n            code: err.code,\n            stack: err.stack\n        };\n        _sendExecResponse(defaultWS, metadata);\n    }\n\n    function _isObject(variable) {\n        return typeof variable === 'object' && variable !== null;\n    }\n\n    function _extractBuffer(result) {\n        if(_isObject(result) && result.buffer instanceof ArrayBuffer) {\n            const buffer = result.buffer;\n            delete result.buffer;\n            return buffer;\n        }\n        return null;\n    }\n\n    function _isJSONStringifiable(result) {\n        try {\n            JSON.stringify(result);\n            return true;\n        } catch (e){\n            return false;\n        }\n    }\n\n    function _errNClearQueue(nodeConnectorID) {\n        const pendingExecList = pendingNodeConnectorExecMap[nodeConnectorID];\n        pendingNodeConnectorExecMap[nodeConnectorID] = [];\n        for(const { ws, metadata } of pendingExecList) {\n            _sendError(\n                ws, metadata,\n                new Error(`NodeConnector ${nodeConnectorID} not found to exec function ${metadata.execHandlerFnName}`)\n            );\n        }\n    }\n\n    function _queueExec(nodeConnectorID, ws, metadata, bufferData) {\n        let pendingExecList = pendingNodeConnectorExecMap[nodeConnectorID];\n        if(!pendingExecList){\n            pendingExecList = [];\n            pendingNodeConnectorExecMap[nodeConnectorID] = pendingExecList;\n        }\n        if(pendingExecList.length > MAX_QUEUE_LENGTH) {\n            _sendError(ws, metadata,\n                new Error(`Too Many exec while waiting for NodeConnector ${nodeConnectorID} creation to exec fn ${metadata.execHandlerFnName}`));\n            return;\n        }\n        pendingExecList.push({ws, metadata, bufferData});\n        if(!isTimerRunningMap[nodeConnectorID]){\n            isTimerRunningMap[nodeConnectorID] = true;\n            setTimeout(() => {\n                // the node connector was not established\n                isTimerRunningMap[nodeConnectorID] = false;\n                _errNClearQueue(nodeConnectorID);\n            }, NODE_CONNECTOR_CREATE_TIMEOUT);\n        }\n    }\n\n    function _drainExecQueue(nodeConnectorID) {\n        let pendingExecList = pendingNodeConnectorExecMap[nodeConnectorID] || [];\n        pendingNodeConnectorExecMap[nodeConnectorID] = [];\n        for(const {ws, metadata, bufferData} of pendingExecList) {\n            _execPhcodeConnectorFn(ws, metadata, bufferData);\n        }\n    }\n\n    function _execPhcodeConnectorFn(ws, metadata, dataBuffer) {\n        const nodeConnectorID = metadata.nodeConnectorID;\n        const execHandlerFnName = metadata.execHandlerFnName;\n        const moduleExports = phcodeExecHandlerMap[nodeConnectorID];\n        if(!moduleExports){\n            // node connector not yet created. Queue it.\n            _queueExec(nodeConnectorID, ws, metadata, dataBuffer);\n            return;\n        }\n        try{\n            if(typeof moduleExports[execHandlerFnName] !== 'function'){\n                const err = new Error(\"execHandlerFnName: \" + execHandlerFnName\n                    + \" no such function in node connector module: \" + nodeConnectorID);\n                err.code = WS_ERR_CODES.NO_SUCH_FN;\n                throw err;\n            }\n            const response = moduleExports[execHandlerFnName](metadata.data, dataBuffer);\n            if(!(response instanceof Promise)) {\n                throw new Error(`execHandlerFnName: ${nodeConnectorID}::${execHandlerFnName} : `\n                    + \" is expected to return a promise that resolve to ({data, ?buffer})\");\n            }\n            response\n                .then((result)=>{\n                    const buffer = _extractBuffer(result);\n                    if(!_isJSONStringifiable(result)) {\n                        throw new Error(`execHandlerFnName: ${nodeConnectorID}::${execHandlerFnName} : `\n                            + \" is expected to return a promise that resolve to an object that can be JSON.stringify -ed. To pass an array buffer, use resolve({buffer:arrayBufferObj})\");\n                    }\n                    _sendExecResponse(ws, metadata, result, buffer);\n                }).catch(err =>{\n                _sendError(ws, metadata, err,\n                    `Error executing function in: ${nodeConnectorID}:${execHandlerFnName}`);\n            });\n        } catch (e) {\n            _sendError(ws, metadata, e, \"Phcode Could not execute function in: \" + nodeConnectorID);\n        }\n    }\n\n    function _queueEvent(nodeConnectorID, ws, metadata, bufferData) {\n        let pendingEventList = pendingNodeConnectorEventMap[nodeConnectorID];\n        if(!pendingEventList){\n            pendingEventList = [];\n            pendingNodeConnectorEventMap[nodeConnectorID] = pendingEventList;\n        }\n        if(pendingEventList.length > MAX_QUEUE_LENGTH) {\n            _sendError(ws, metadata,\n                new Error(`Too Many events: ${metadata.eventName} while waiting for NodeConnector ${nodeConnectorID} creation`));\n            return;\n        }\n        pendingEventList.push({ws, metadata, bufferData});\n        if(!isTimerRunningMap[nodeConnectorID]){\n            isTimerRunningMap[nodeConnectorID] = true;\n            setTimeout(() => {\n                // the node connector was not established\n                isTimerRunningMap[nodeConnectorID] = false;\n                _errNClearQueue(nodeConnectorID);\n            }, NODE_CONNECTOR_CREATE_TIMEOUT);\n        }\n    }\n\n    function _drainEventQueue(nodeConnectorID) {\n        let pendingEventList = pendingNodeConnectorEventMap[nodeConnectorID] || [];\n        pendingNodeConnectorEventMap[nodeConnectorID] = [];\n        for(const {ws, metadata, bufferData} of pendingEventList) {\n            _triggerEvent(ws, metadata, bufferData);\n        }\n    }\n\n    function _triggerEvent(ws, metadata, dataBuffer) {\n        const nodeConnectorID = metadata.nodeConnectorID;\n        const nodeConnector = nodeConnectorIDMap[nodeConnectorID];\n        if(!nodeConnector){\n            // node connector not yet created. Queue it.\n            _queueEvent(nodeConnectorID, ws, metadata, dataBuffer);\n            return;\n        }\n        nodeConnector.trigger(metadata.eventName, metadata.data, dataBuffer);\n    }\n\n    function processWSCommand(ws, metadata, dataBuffer) {\n        try{\n            switch (metadata.commandCode) {\n            case WS_COMMAND.EXEC:\n                _execPhcodeConnectorFn(ws, metadata, dataBuffer);\n                return;\n            case WS_COMMAND.EVENT:\n                _triggerEvent(ws, metadata, dataBuffer);\n                return;\n            case WS_COMMAND.RESPONSE:\n                const commandID = metadata.commandID;\n                const pendingExecPromise = pendingExecPromiseMap[commandID];\n                if(!pendingExecPromise){\n                    throw new Error(\"Unable to find response handler for \"+ JSON.stringify(metadata));\n                }\n                if(metadata.error) {\n                    const error = new Error(metadata.error.message, {cause: metadata.error.stack});\n                    error.code = metadata.error.code;\n                    error.nodeStack = metadata.error.stack;\n                    pendingExecPromise.reject(error);\n                } else {\n                    const result = metadata.data;\n                    if(dataBuffer instanceof ArrayBuffer) {\n                        result.buffer = dataBuffer;\n                    }\n                    pendingExecPromise.resolve(result);\n                }\n                delete pendingExecPromiseMap[commandID];\n                break;\n            default: console.error(\"unknown command: \"+ metadata);\n            }\n        } catch (e) {\n            console.error(e);\n        }\n    }\n\n    function createNodeConnector(nodeConnectorID, moduleExports) {\n        if(nodeConnectorIDMap[nodeConnectorID]) {\n            throw new Error(\"A node connector of the name is already registered: \" + nodeConnectorID);\n        }\n        if(!_isObject(moduleExports) || !nodeConnectorID) {\n            throw new Error(\"Invalid Argument. Expected createNodeConnector(string, module/Object) for \" + nodeConnectorID);\n        }\n\n        phcodeExecHandlerMap[nodeConnectorID] = moduleExports;\n        const newNodeConnector = {\n            /**\n             * Executes a peer function with specified parameters. Most of the time you would use dataObjectToSend to send\n             * simple JSON serializable objects. But in the event you have to send a binary ArrayBuffer, you can use\n             * the optional `dataBuffer` field. Note that at this time, you can only send and receive a single binary buffer\n             *\n             * @param {string} execHandlerFnName - The name of the function to execute on the peer.\n             * @param {Object|string|null} dataObjectToSend - Optional data to send along with the function call.\n             * @param {ArrayBuffer|null} dataBuffer - Optional binary data to send along with the function call.\n             *\n             * @returns {Promise} - A promise that resolves or rejects based on the result of the function execution.\n             *\n             * @throws {Error} - If `dataBuffer` is provided and is not an instance of `ArrayBuffer`.\n             */\n            execPeer: function (execHandlerFnName, dataObjectToSend = null, dataBuffer = null) {\n                if ((dataBuffer && !(dataBuffer instanceof ArrayBuffer)) || dataObjectToSend instanceof ArrayBuffer) {\n                    throw new Error(\"execPeer should be called with exactly 3 arguments or less (FnName:string, data:Object|string, buffer:ArrayBuffer)\");\n                }\n                if (dataBuffer instanceof ArrayBuffer && !_isObject(dataObjectToSend)) {\n                    throw new Error(\"execPeer second argument should be an object if sending binary data (FnName:string, data:Object, buffer:ArrayBuffer)\");\n                }\n                return new Promise((resolve, reject) =>{\n                    currentCommandID ++;\n                    pendingExecPromiseMap[currentCommandID] = {resolve, reject};\n                    _sendExec(nodeConnectorID, currentCommandID, execHandlerFnName, dataObjectToSend, dataBuffer);\n                });\n            },\n            /**\n             * Triggers an event to be sent to a peer. Most of the time you would use dataObjectToSend to send\n             * simple JSON serializable objects. But in the event you have to send a binary ArrayBuffer, you can use\n             * the optional `dataBuffer` field. Note that at this time, you can only send and receive a single binary buffer\n             *\n             * @param {string} eventName - The name of the event to trigger.\n             * @param {Object|string|null} dataObjectToSend - Optional data associated with the event. Can be an object, string, or null.\n             * @param {ArrayBuffer|null} dataBuffer - Optional binary data associated with the event. Must be an ArrayBuffer or null.\n             *\n             * @throws {Error} Throws an error if dataBuffer is provided but is not an ArrayBuffer.\n             */\n            triggerPeer: function (eventName, dataObjectToSend = null, dataBuffer = null) {\n                if (dataBuffer && !(dataBuffer instanceof ArrayBuffer)) {\n                    throw new Error(\"triggerPeer should be called with exactly 3 arguments (eventName:string, data:Object|string, buffer:ArrayBuffer)\");\n                }\n                _sendEvent(nodeConnectorID, eventName, dataObjectToSend, dataBuffer);\n            }\n        };\n        window.EventDispatcher.makeEventDispatcher(newNodeConnector);\n        nodeConnectorIDMap[nodeConnectorID] = newNodeConnector;\n\n        // At this point, it's possible that a node connector has been created on the other end, and it might have sent\n        // us exec and trigger events that need to be processed. These events will be queued for execution, and we will\n        // handle them after the current event loop call.\n        // We use a setTimeout with a zero-millisecond delay to ensure that the event queues are drained during the\n        // next tick of the event loop.\n        setTimeout(() => {\n            _drainExecQueue(nodeConnectorID);\n            _drainEventQueue(nodeConnectorID);\n        }, 0);\n\n        // At this time, the node connector at the other side may not be created, but it is still safe to use this\n        // node connector now as the events will be queued at the other end for up to 10 seconds for a node connector\n        // to be created at the other end.\n        return newNodeConnector;\n    }\n\n    function _silentlyCloseSocket(socket) {\n        if(!socket) {\n            return;\n        }\n        try{\n            socket.autoReconnect = false;\n            socket.close();\n        } catch (e) {\n            console.error(\"node-loader: \", e);\n        }\n    }\n\n    function _wait(timeMS) {\n        return new Promise((resolve)=>{\n            setTimeout(resolve, timeMS);\n        });\n    }\n\n    async function _establishAndMaintainConnection(socketType, firstConnectCB) {\n        let ws = new WebSocket(wssEndpoint);\n        ws.binaryType = 'arraybuffer';\n        ws.autoReconnect = true;\n        const resolved = false;\n        while(ws.autoReconnect) {\n            let wsClosePromiseResolve;\n            const wsClosePromise = new Promise((resolve) => {wsClosePromiseResolve = resolve;});\n            if(socketType === SOCKET_TYPE_CONTROL) {\n                controlSocket = ws;\n            } else {\n                ws.isLargeDataWS = true;\n                dataSocket = ws;\n            }\n            // eslint-disable-next-line no-loop-func\n            ws.addEventListener(\"open\", () =>{\n                ws.backoffTime = 0;\n                if(!resolved) {\n                    firstConnectCB();\n                }\n                if(ws.isLargeDataWS){\n                    _sendInitCommand(ws, WS_COMMAND.LARGE_DATA_SOCKET_ANNOUNCE);\n                } else {\n                    _sendInitCommand(ws, WS_COMMAND.CONTROL_SOCKET_ANNOUNCE);\n                }\n                _drainPendingSendBuffer();\n            });\n\n            // eslint-disable-next-line no-loop-func\n            ws.addEventListener('message', function (event) {\n                const {metadata, bufferData} = splitMetadataAndBuffer(event.data);\n                processWSCommand(ws, metadata, bufferData);\n            });\n\n            ws.addEventListener('error', function (event) {\n                console.error(\"PhoenixFS websocket error event: \", event);\n            });\n\n            ws.addEventListener('close', function () {\n                wsClosePromiseResolve();\n            });\n            await wsClosePromise;\n            const backoffTime = Math.min(ws.backoffTime * 2, MAX_RECONNECT_BACKOFF_TIME_MS) || 1;\n            ws.backoffTime = backoffTime;\n            await _wait(backoffTime);\n            if(ws.autoReconnect) {\n                ws = new WebSocket(wssEndpoint);\n                ws.backoffTime = backoffTime;\n                ws.binaryType = 'arraybuffer';\n                ws.autoReconnect = true;\n            }\n        }\n    }\n\n    async function setNodeWSEndpoint(websocketEndpoint) {\n        return new Promise((resolve, reject)=>{\n            if(websocketEndpoint === wssEndpoint) {\n                reject(new Error(\"A connection on the same websocket address is in progress: \" + websocketEndpoint));\n            }\n            _silentlyCloseSocket(controlSocket);\n            controlSocket = null;\n            _silentlyCloseSocket(dataSocket);\n            dataSocket = null;\n            wssEndpoint = websocketEndpoint;\n            let resolved = false;\n            function firstConnectCB() {\n                if(!resolved){\n                    resolve();\n                    resolved = true;\n                }\n            }\n            _establishAndMaintainConnection(SOCKET_TYPE_CONTROL, firstConnectCB);\n            _establishAndMaintainConnection(SOCKET_TYPE_DATA, firstConnectCB);\n        });\n    }\n\n\n    window.nodeSetupDonePromise = new Promise((resolve, reject) =>{\n        const NODE_COMMANDS = {\n            TERMINATE: \"terminate\",\n            PING: \"ping\",\n            SET_DEBUG_MODE: \"setDebugMode\",\n            GET_ENDPOINTS: \"getEndpoints\"\n        };\n        const COMMAND_RESPONSE_PREFIX = 'phnodeResp_1!5$:'; // a string thats not likely to just start with in\n        const COMMAND_ERROR_PREFIX = 'phnodeErr_1!5$:';\n        let command, child;\n        let resolved = false;\n        let commandID = 0, pendingCommands = {};\n        const PHNODE_PREFERENCES_KEY = \"PhNode.Prefs\";\n        function setInspectEnabled(enabled) {\n            // cannot use PhStore instead of localStorage here as this is required at boot. Should be fine\n            // as this to use non-persistent local storage(due to safari ITP) here as this is a debug flag.\n            const prefs = JSON.parse(localStorage.getItem(PHNODE_PREFERENCES_KEY) || \"{}\");\n            prefs.inspectEnabled = enabled;\n            localStorage.setItem(PHNODE_PREFERENCES_KEY, JSON.stringify(prefs));\n        }\n        function isInspectEnabled() {\n            // cannot use PhStore instead of localStorage here as this is required at boot.\n            const prefs = JSON.parse(localStorage.getItem(PHNODE_PREFERENCES_KEY) || \"{}\");\n            return !!prefs.inspectEnabled;\n        }\n\n        function getRandomNumber(min, max) {\n            return Math.floor(Math.random() * (max - min + 1)) + min;\n        }\n\n        let nodeTerminationResolve;\n        const nodeTerminationPromise = new Promise((resolve) => { nodeTerminationResolve = resolve;});\n        window.nodeTerminationPromise = nodeTerminationPromise;\n\n        // createNodeConnector can me immediately used after this, no need to wait for node nodeSetupDonePromise\n        // All messages to be sent to node will be queued and sent when node comes online in its time.\n        window.PhNodeEngine = {\n            createNodeConnector,\n            setInspectEnabled,\n            isInspectEnabled\n        };\n        window.isNodeReady = false;\n        let nodeErrorLogCount = 0;\n        // 10 node error logs are allowed on console every 2 seconds to prevent freeze due to\n        const MAX_NODE_ERROR_LOGS_ALLOWED = 10;\n        const NODE_ERROR_LOGS_RESET_INTERVAL = 2000;\n        setInterval(()=>{\n            // allow only logging up to x log lines in a given interval.\n            if(!window.debugMode && nodeErrorLogCount > MAX_NODE_ERROR_LOGS_ALLOWED){\n                console.error(\"Too many node Errors, some errors were omitted from console.\",\n                    \"Please enable `Debug menu> Phoenix code diagnostic tools> enable detailed logs` to view all.\");\n            }\n            nodeErrorLogCount = 0;\n        }, NODE_ERROR_LOGS_RESET_INTERVAL);\n\n        window.__TAURI__.path.resolveResource(\"src-node/index.js\")\n            .then(async nodeSrcPath=>{\n                if(Phoenix.platform === \"linux\") {\n                    // in linux installed distributions, src-node is present in the same dir as the executable.\n                    const cliArgs = await window.__TAURI__.invoke('_get_commandline_args');\n                    nodeSrcPath = `${window.path.dirname(cliArgs[0])}/src-node/index.js`;\n                }\n                // node is designed such that it is not required at boot time to lower startup time.\n                // Keep this so to increase boot speed.\n                const inspectPort = Phoenix.isTestWindow ? getRandomNumber(5000, 50000) : 9229;\n                const argsArray = isInspectEnabled() ? [`--inspect=${inspectPort}`, nodeSrcPath] : [nodeSrcPath, ''];\n                command = window.__TAURI__.shell.Command.sidecar('phnode', argsArray);\n                command.on('close', data => {\n                    window.isNodeTerminated = true;\n                    window.isNodeReady = false;\n                    nodeTerminationResolve();\n                    console.log(`PhNode: command finished with code ${data.code} and signal ${data.signal}`);\n                    if(!resolved) {\n                        reject(\"PhNode: closed - Terminated.\");\n                    }\n                });\n                command.on('error', error => {\n                    window.isNodeTerminated = true;\n                    window.isNodeReady = false;\n                    nodeTerminationResolve();\n                    console.error(`PhNode: command error: \"${error}\"`);\n                    if(!resolved) {\n                        logger.reportError(error, `PhNode failed to start!`);\n                        reject(\"PhNode: closed - Terminated.\");\n                    }\n                });\n                command.stdout.on('data', line => {\n                    if(line){\n                        if(line.startsWith(COMMAND_RESPONSE_PREFIX)){\n                            // its a js response object\n                            line = line.replace(COMMAND_RESPONSE_PREFIX, \"\");\n                            const jsonMsg = JSON.parse(line);\n                            pendingCommands[jsonMsg.commandID].resolve(jsonMsg.message);\n                            delete pendingCommands[jsonMsg.commandID];\n                        } else if(line.startsWith(COMMAND_ERROR_PREFIX)){\n                            // its a js response object\n                            line = line.replace(COMMAND_ERROR_PREFIX, \"\");\n                            const err = JSON.parse(line);\n                            logger.reportError(err, `PhNode ${err.type}:${err.code?err.code:''}`);\n                        } else {\n                            console.log(`PhNode: ${line}`);\n                        }\n                    }\n                });\n                command.stderr.on('data', line => {\n                    if(window.debugMode || nodeErrorLogCount < MAX_NODE_ERROR_LOGS_ALLOWED){\n                        // in release builds, too many node errors from file system/other sources can\n                        // happen, Eg. user opens a very large project and fs watchers goes bust.\n                        // if that happens, the app may get stuck logging large number of errors to console, so\n                        // we show atmost 10 error lines every 10 seconds in non-debug builds.\n                        console.error(`PhNode: ${line}`);\n                    }\n                    nodeErrorLogCount ++;\n                });\n                child = await command.spawn();\n\n                const execNode = function (commandCode, commandData) {\n                    if(window.isNodeTerminated){\n                        return Promise.reject(\"Node is terminated! Cannot execute: \" + commandCode);\n                    }\n                    const newCommandID = commandID ++;\n                    child.write(JSON.stringify({\n                        commandCode: commandCode, commandID: newCommandID, commandData\n                    }) + \"\\n\");\n                    let resolveP, rejectP;\n                    const promise = new Promise((resolve, reject) => { resolveP = resolve; rejectP=reject; });\n                    pendingCommands[newCommandID]= {resolve: resolveP, reject: rejectP};\n                    return promise;\n                };\n\n                window.PhNodeEngine.terminateNode = function () {\n                    if(!window.isNodeTerminated) {\n                        execNode(NODE_COMMANDS.TERMINATE);\n                    }\n                    return nodeTerminationPromise;\n                };\n                window.PhNodeEngine.getInspectPort = function () {\n                    return inspectPort;\n                };\n\n                execNode(NODE_COMMANDS.GET_ENDPOINTS)\n                    .then(message=>{\n                        fs.setNodeWSEndpoint(message.phoenixFSURL);\n                        fs.forceUseNodeWSEndpoint(true);\n                        setNodeWSEndpoint(message.phoenixNodeURL);\n                        window.isNodeReady = true;\n                        resolve(message);\n                        // node is designed such that it is not required at boot time to lower startup time.\n                        // Keep this so to increase boot speed.\n                        window.PhNodeEngine._nodeLoadTime = Date.now() - nodeLoadstartTime;\n                    });\n                execNode(NODE_COMMANDS.SET_DEBUG_MODE, window.debugMode);\n            });\n    });\n}\n\nif(Phoenix.isNativeApp) {\n    nodeLoader();\n}\n"],"file":"node-loader.js"}