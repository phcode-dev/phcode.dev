{"version":3,"sources":["features/SelectionViewManager.js"],"names":["define","require","exports","module","CommandManager","Commands","EditorManager","Menus","PreferencesManager","Strings","ViewUtils","AppInit","WorkspaceManager","EventDispatcher","ProviderRegistrationHandler","RegistrationHandler","previewContainerHTML","makeEventDispatcher","_EVENT_POPUP_CONTENT_MUTATED","observer","MutationObserver","mutations","mutation","type","trigger","_providerRegistrationHandler","registerSelectionViewProvider","registerProvider","bind","removeSelectionViewProvider","removeProvider","_getSelectionViewProviders","editor","SelectionViewProviders","language","getLanguageForSelection","enabledProviders","getProvidersForLanguageId","getId","item","push","provider","enabled","prefs","$previewContainer","lastMouseX","lastMouseY","$previewContent","CMD_ENABLE_SELECTION_VIEW","POPUP_DELAY","POINTER_HEIGHT","POPOVER_HORZ_MARGIN","getExtensionPrefs","definePreference","description","DESCRIPTION_SELECTION_VIEW_ENABLED","popoverState","hidePreview","visible","empty","hide","removeClass","getActiveEditor","focus","positionPreview","ybot","find","is","previewWidth","outerWidth","top","outerHeight","left","elementRect","height","width","clip","getElementClipSize","$","getRootElement","right","addClass","css","_createPopoverState","popoverResults","length","popover","content","result","append","pos","getCursorPos","startCoord","charCoords","endCoord","xpos","ytop","bottom","async","queryPreviewProviders","selectionObj","getSelections","selection","getSelection","start","line","end","ch","providers","popovers","providerPromises","getSelectionView","console","error","results","Promise","allSettled","status","value","_renderPreview","$popoverContent","show","on","currentQueryID","showPreview","savedQueryId","handleMouseUp","event","buttons","setTimeout","_processMouseMove","clientX","clientY","isSelectionViewShown","getHoveredEditor","mousePos","coordsChar","posWithinRange","onActiveEditorChange","_event","current","previous","document","off","updateMenuItemCheckmark","get","setChecked","setEnabled","_enabled","doNotSave","editorHolder","addEventListener","removeEventListener","set","save","toggleEnableSelectionView","_forceShow","_handleEscapeKeyEvent","preventDefault","stopPropagation","appReady","appendTo","observe","childList","subtree","register","getMenu","AppMenuBar","VIEW_MENU","addMenuItem","AFTER","VIEW_TOGGLE_INSPECTION","addEscapeKeyEventHandler","_queryPreviewProviders"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*jslint regexp: true */\n\n// @INCLUDE_IN_API_DOCS\n\n/**\n * SelectionViewManager provides support to add interactive preview popups on selection over the main editors.\n * This can be used to provide interactive editor controls on a selected element.\n *\n * Extensions can register to provide previews with `SelectionViewManager.registerSelectionViewProvider` API.\n * <img src = \"https://user-images.githubusercontent.com/5336369/186434397-3db55789-6077-4d02-b4e2-78ef3f663399.png\" alt=\"Phoenix code selection view\" />\n * <img src = \"https://user-images.githubusercontent.com/5336369/186434671-c1b263e5-19a9-4a9d-8f90-507df5f881b5.gif\" />\n *\n * ### See Related: QuickViewManager\n * [features/QuickViewManager](https://github.com/phcode-dev/phoenix/wiki/QuickViewManager-API) is similar to\n * SelectionViewManager API.\n * * SelectionViews popup only once user selects a text by mouse or hover over a region with text selection.\n * * Quickviews popup on mouse hover.\n * <img src = \"https://docs-images.phcode.dev/phcode-sdk/quick-view-youtube.png\" alt=\"Phoenix code selection view Youtube image\" />\n *\n * ## Usage\n * Lets build a \"hello world\" extension that displays \"hello world\" above selected text in the editor.\n * In your extension file, add the following code:\n *\n * @example\n * ```js\n * const SelectionViewManager = brackets.getModule(\"features/SelectionViewManager\");\n * // replace `all` with language ID(Eg. javascript) if you want to restrict the preview to js files only.\n * SelectionViewManager.registerSelectionViewProvider(exports, [\"all\"]);\n *\n * // provide a helpful name for the SelectionView. This will be useful if you have to debug the selection view\n * exports.SELECTION_VIEW_NAME = \"extension.someName\";\n * // now implement the getSelectionView function that will be invoked when ever user selection changes in the editor.\n * exports.getSelectionView = function(editor, selections) {\n *         return new Promise((resolve, reject)=>{\n *             resolve({\n *                 content: \"<div>hello world</div>\"\n *             });\n *         });\n *     };\n * ```\n *\n * ### How it works\n * When SelectionViewManager determines that the user intents to see SelectionViewr, `getSelectionView` function on all\n * registered SelectionView providers are invoked to get the Selection View popup. `getSelectionView` should return\n * a promise that resolves to the popup contents if the provider has a Selection View. Else just reject the promise.\n * If multiple providers returns SelectionView, all of them are displayed one by one.\n * See detailed API docs for implementation details below:\n *\n * ## API\n * ### registerSelectionViewProvider\n * Register a SelectionView provider with this api.\n *\n * @example\n * ```js\n * // syntax\n * SelectionViewManager.registerSelectionViewProvider(provider, supportedLanguages);\n * ```\n * The API requires two parameters:\n * 1. `provider`: must implement a  `getSelectionView` function which will be invoked to get the preview. See API doc below.\n * 1. `supportedLanguages`: An array of languages that the SelectionView supports. If `[\"all\"]` is supplied, then the\n *    SelectionView will be invoked for all languages. Restrict to specific languages: Eg: `[\"javascript\", \"html\", \"php\"]`\n *\n * @example\n * ```js\n * // to register a provider that will be invoked for all languages. where provider is any object that implements\n * // a getSelectionView function\n * SelectionViewManager.registerSelectionViewProvider(provider, [\"all\"]);\n *\n * // to register a provider that will be invoked for specific languages\n * SelectionViewManager.registerSelectionViewProvider(provider, [\"javascript\", \"html\", \"php\"]);\n * ```\n *\n * ### removeSelectionViewProvider\n * Removes a registered SelectionView provider. The API takes the same arguments as `registerSelectionViewProvider`.\n *\n * @example\n * ```js\n * // syntax\n * SelectionViewManager.removeSelectionViewProvider(provider, supportedLanguages);\n * // Example\n * SelectionViewManager.removeSelectionViewProvider(provider, [\"javascript\", \"html\"]);\n * ```\n *\n * ### getSelectionView\n * Each provider must implement the `getSelectionView` function that returns a promise. The promise either resolves with\n * the Selection View details object(described below) or rejects if there is no preview for the position.\n *\n * @example\n * ```js\n * // function signature\n * provider.getSelectionView = function(editor, selections) {\n *         return new Promise((resolve, reject)=>{\n *             resolve({\n *                 content: \"<div>hello world</div>\"\n *             });\n *         });\n *     };\n * ```\n *\n * #### parameters\n * The function will be called with the following arguments:\n * 1. `editor` - The editor over which the user hovers the mouse cursor.\n * 1. `selections` - An array containing the active selections when the selection view was trigerred.\n *\n * #### return types\n * The promise returned should resolve to an object with the following contents:\n * 1. `content`: Either `HTML` as text, a `DOM Node` or a `Jquery Element`.\n *\n * #### Modifying the SelectionView content after resolving `getSelectionView` promise\n * Some advanced/interactive extensions may need to do dom operations on the SelectionView content.\n * In such cases, it is advised to return a domNode/Jquery element as content in `getSelectionView`. Event Handlers\n * or further dom manipulations can be done on the returned content element.\n * The SelectionView may be dismissed at any time, so be sure to check if the DOM Node is visible in the editor before\n * performing any operations.\n *\n * #### Considerations\n * 1. SelectionView won't be displayed till all provider promises are settled. To improve performance, if your SelectionView\n *    handler takes time to resolve the SelectionView, resolve a dummy quick once you are sure that a SelectionView needs\n *    to be shown to the user. The div contents can be later updated as and when more details are available.\n * 1. Note that the SelectionView could be hidden/removed any time by the SelectionViewManager.\n * 1. If multiple providers returns a valid popup, all of them are displayed.\n *\n * @module features/SelectionViewManager\n */\n\ndefine(function (require, exports, module) {\n\n\n    // Brackets modules\n    const CommandManager    = require(\"command/CommandManager\"),\n        Commands            = require(\"command/Commands\"),\n        EditorManager       = require(\"editor/EditorManager\"),\n        Menus               = require(\"command/Menus\"),\n        PreferencesManager  = require(\"preferences/PreferencesManager\"),\n        Strings             = require(\"strings\"),\n        ViewUtils           = require(\"utils/ViewUtils\"),\n        AppInit             = require(\"utils/AppInit\"),\n        WorkspaceManager    = require(\"view/WorkspaceManager\"),\n        EventDispatcher     = require(\"utils/EventDispatcher\"),\n        ProviderRegistrationHandler = require(\"features/PriorityBasedRegistration\").RegistrationHandler;\n\n    const previewContainerHTML       = '<div id=\"selection-view-container\">\\n' +\n        '    <div class=\"preview-content\">\\n' +\n        '    </div>\\n' +\n        '</div>';\n\n    EventDispatcher.makeEventDispatcher(exports);\n    const _EVENT_POPUP_CONTENT_MUTATED = \"_popupContentMutated\";\n    // Create a new MutationObserver instance\n    const observer = new MutationObserver(mutations => {\n        for (let mutation of mutations) {\n            if (mutation.type === 'childList' || mutation.type === 'subtree') {\n                exports.trigger(_EVENT_POPUP_CONTENT_MUTATED, mutations);\n                break; // Optional: Break after the first change if only one change is needed\n            }\n        }\n    });\n\n    const _providerRegistrationHandler = new ProviderRegistrationHandler(),\n        registerSelectionViewProvider = _providerRegistrationHandler.registerProvider.bind(_providerRegistrationHandler),\n        removeSelectionViewProvider = _providerRegistrationHandler.removeProvider.bind(_providerRegistrationHandler);\n\n    function _getSelectionViewProviders(editor) {\n        let SelectionViewProviders = [];\n        let language = editor.getLanguageForSelection(),\n            enabledProviders = _providerRegistrationHandler.getProvidersForLanguageId(language.getId());\n\n        for(let item of enabledProviders){\n            SelectionViewProviders.push(item.provider);\n        }\n        return SelectionViewProviders;\n    }\n\n    let enabled,                             // Only show preview if true\n        prefs                      = null,   // Preferences\n        $previewContainer,                   // Preview container\n        lastMouseX = 0,\n        lastMouseY = 0,\n        $previewContent;                     // Preview content holder\n\n    // Constants\n    const CMD_ENABLE_SELECTION_VIEW       = \"view.enableSelectionView\",\n        // Pointer height, used to shift popover above pointer (plus a little bit of space)\n        POPUP_DELAY                 = 200,\n        POINTER_HEIGHT              = 10,\n        POPOVER_HORZ_MARGIN         =  5;   // Horizontal margin\n\n    prefs = PreferencesManager.getExtensionPrefs(\"SelectionView\");\n    prefs.definePreference(\"enabled\", \"boolean\", true, {\n        description: Strings.DESCRIPTION_SELECTION_VIEW_ENABLED\n    });\n\n    /**\n     * There are three states for this var:getToken\n     * 1. If null, there is no provider result for the given mouse position.\n     * 2. If non-null, and visible==true, there is a popover currently showing.\n     * 3. If non-null, but visible==false, we're waiting for HOVER_DELAY, which\n     *    is tracked by hoverTimer. The state changes to visible==true as soon as\n     *    there is a provider. If the mouse moves before then, timer is restarted.\n     * @typedef {Object} PopoverState\n     * @property {boolean} visible - Whether the popover is visible.\n     * @property {!Editor} editor - The editor instance associated with the popover.\n     * @property {!{line: number, ch: number}} start - Start of the matched text range.\n     * @property {!{line: number, ch: number}} end - End of the matched text range.\n     * @property {!string} content - HTML content to display in the popover.\n     * @property {number} xpos - X-coordinate of the center of the popover.\n     * @property {number} ytop - Y-coordinate of the top of the matched text when the popover is placed above the text.\n     * @property {number} ybot - Y-coordinate of the bottom of the matched text when the popover is moved below the text.\n     * @private\n     */\n    let popoverState = null;\n\n\n\n    // Popover widget management ----------------------------------------------\n\n    /**\n     * Cancels whatever popoverState was currently pending and sets it back to null. If the popover was visible,\n     * hides it; if the popover was invisible and still pending, cancels hoverTimer so it will never be shown.\n     * @private\n     */\n    function hidePreview() {\n        if (!popoverState) {\n            return;\n        }\n        if (popoverState.visible) {\n            $previewContent.empty();\n            $previewContainer.hide();\n            $previewContainer.removeClass(\"active\");\n            if(EditorManager.getActiveEditor()){\n                EditorManager.getActiveEditor().focus();\n            }\n        }\n        popoverState = null;\n    }\n\n    function positionPreview(editor) {\n        let ybot = popoverState.ybot;\n        if ($previewContent.find(\"#selection-view-popover-root\").is(':empty')){\n            hidePreview();\n            return;\n        }\n        let previewWidth  = $previewContainer.outerWidth(),\n            top           = lastMouseY - $previewContainer.outerHeight() - POINTER_HEIGHT,\n            left          = lastMouseX - previewWidth / 2,\n            elementRect = {\n                top: top,\n                left: left - POPOVER_HORZ_MARGIN,\n                height: $previewContainer.outerHeight() + POINTER_HEIGHT,\n                width: previewWidth + 2 * POPOVER_HORZ_MARGIN\n            },\n            clip = ViewUtils.getElementClipSize($(editor.getRootElement()), elementRect);\n\n        // Prevent horizontal clipping\n        if (clip.left > 0) {\n            left += clip.left;\n        } else if (clip.right > 0) {\n            left -= clip.right;\n        }\n\n        // If clipped on top, flip popover below line\n        if (clip.top > 0) {\n            top = ybot + POINTER_HEIGHT;\n            $previewContainer\n                .removeClass(\"preview-bubble-above\")\n                .addClass(\"preview-bubble-below\");\n        } else {\n            $previewContainer\n                .removeClass(\"preview-bubble-below\")\n                .addClass(\"preview-bubble-above\");\n        }\n\n        $previewContainer\n            .css({\n                left: left,\n                top: top\n            })\n            .addClass(\"active\");\n    }\n\n    // Preview hide/show logic ------------------------------------------------\n\n    function _createPopoverState(editor, popoverResults) {\n        if (popoverResults && popoverResults.length) {\n            let popover = {\n                content: $(\"<div id='selection-view-popover-root'></div>\")\n            };\n            // Each provider return popover { start, end, content}\n            for(let result of popoverResults){\n                popover.content.append(result.content);\n            }\n\n            let pos = editor.getCursorPos();\n            let startCoord = editor.charCoords(pos),\n                endCoord = editor.charCoords(pos);\n            popover.xpos = (endCoord.left - startCoord.left) / 2 + startCoord.left;\n            if(endCoord.left<startCoord.left){\n                // this probably spans multiple lines, just show at start cursor position\n                popover.xpos = startCoord.left;\n            }\n            popover.ytop = startCoord.top;\n            popover.ybot = startCoord.bottom;\n            popover.visible = false;\n            popover.editor  = editor;\n            popover.pos = pos;\n            return popover;\n        }\n\n        return null;\n    }\n\n    /**\n     * Returns a 'ready for use' popover state object or null if there is no popover:\n     * { visible: false, editor, start, end, content, xpos, ytop, ybot }\n     * @private\n     */\n    async function queryPreviewProviders(editor, selectionObj) {\n        if(!editor){\n            return null;\n        }\n\n        selectionObj = selectionObj || editor.getSelections();\n        if(selectionObj.length !== 1){\n            // we only show selection view over a single selection\n            return null;\n        }\n        let selection = editor.getSelection();\n        if(selection.start.line === selection.end.line &&  selection.start.ch === selection.end.ch){\n            //this is just a cursor\n            return null;\n        }\n        let providers = _getSelectionViewProviders(editor);\n        let popovers = [], providerPromises = [];\n        for(let provider of providers){\n            if(!provider.getSelectionView){\n                console.error(\"Error: SelectionView provider should implement getSelectionView function\", provider);\n                continue;\n            }\n            providerPromises.push(provider.getSelectionView(editor, selectionObj));\n        }\n        let results = await Promise.allSettled(providerPromises);\n        for(let result of results){\n            if(result.status === \"fulfilled\" && result.value){\n                popovers.push(result.value);\n            }\n        }\n\n        return _createPopoverState(editor, popovers);\n    }\n\n    /**\n     * Changes the current hidden popoverState to visible, showing it in the UI and highlighting\n     * its matching text in the editor.\n     * @private\n     */\n    function _renderPreview(editor) {\n        if (popoverState) {\n            let $popoverContent = $(popoverState.content);\n            $previewContent.empty();\n            $previewContent.append($popoverContent);\n            $previewContainer.show();\n            popoverState.visible = true;\n            positionPreview(editor);\n\n            exports.on(_EVENT_POPUP_CONTENT_MUTATED, ()=>{\n                if(!popoverState || !editor){\n                    return;\n                }\n                positionPreview(editor);\n            });\n        }\n    }\n\n    let currentQueryID = 0;\n    async function showPreview(editor, selectionObj) {\n        if (!editor) {\n            hidePreview();\n            return;\n        }\n\n        // Query providers and append to popoverState\n        currentQueryID++;\n        let savedQueryId = currentQueryID;\n        popoverState = await queryPreviewProviders(editor, selectionObj);\n        if(savedQueryId === currentQueryID){\n            // this is to prevent race conditions. For Eg., if the preview provider takes time to generate a preview,\n            // another query might have happened while the last query is still in progress. So we only render the most\n            // recent QueryID\n            _renderPreview(editor);\n        }\n    }\n\n    function handleMouseUp(event) {\n        if (!enabled) {\n            return;\n        }\n\n        hidePreview();\n        if (event.buttons !== 0) {\n            // Button is down - don't show popovers while dragging\n            return;\n        }\n        setTimeout(()=>{\n            // we do this delayed popup so that we get a consistent view of the editor selections\n            let editor = EditorManager.getActiveEditor();\n            if(editor){\n                showPreview(editor, editor.getSelections());\n            }\n        }, POPUP_DELAY);\n    }\n\n    function _processMouseMove(event) {\n        lastMouseX= event.clientX;\n        lastMouseY= event.clientY;\n        if (event.buttons !== 0) {\n            // Button is down - don't show popovers while dragging\n            return;\n        }\n        if (isSelectionViewShown()) {\n            return;\n        }\n        let editor = EditorManager.getHoveredEditor(event);\n        if (editor) {\n            // Find char mouse is over\n            let mousePos = editor.coordsChar({left: event.clientX, top: event.clientY});\n            let selectionObj = editor.getSelections();\n            if(selectionObj.length !== 1){\n                // we only show selection view over a single selection\n                return;\n            }\n            let selection = editor.getSelection();\n            if(selection.start.line === selection.end.line &&  selection.start.ch === selection.end.ch){\n                //this is just a cursor\n                return;\n            }\n            if (editor.posWithinRange(mousePos, selection.start, selection.end, true)) {\n                popoverState = {};\n                showPreview(editor, selectionObj);\n            }\n        }\n    }\n\n    function onActiveEditorChange(_event, current, previous) {\n        // Hide preview when editor changes\n        hidePreview();\n\n        if (previous && previous.document) {\n            previous.document.off(\"change\", hidePreview);\n        }\n\n        if (current && current.document) {\n            current.document.on(\"change\", hidePreview);\n        }\n    }\n\n    // Menu command handlers\n    function updateMenuItemCheckmark() {\n        CommandManager.get(CMD_ENABLE_SELECTION_VIEW).setChecked(enabled);\n    }\n\n    function setEnabled(_enabled, doNotSave) {\n        if (enabled !== _enabled) {\n            enabled = _enabled;\n            let editorHolder = $(\"#editor-holder\")[0];\n            if (enabled) {\n                // Note: listening to \"scroll\" also catches text edits, which bubble a scroll\n                // event up from the hidden text area. This means\n                // we auto-hide on text edit, which is probably actually a good thing.\n                editorHolder.addEventListener(\"mouseup\", handleMouseUp, true);\n                editorHolder.addEventListener(\"mousemove\", _processMouseMove, true);\n                editorHolder.addEventListener(\"scroll\", hidePreview, true);\n\n                // Setup doc \"change\" listener\n                onActiveEditorChange(null, EditorManager.getActiveEditor(), null);\n                EditorManager.on(\"activeEditorChange\", onActiveEditorChange);\n\n            } else {\n                editorHolder.removeEventListener(\"mouseup\", handleMouseUp, true);\n                editorHolder.addEventListener(\"mousemove\", _processMouseMove, true);\n                editorHolder.removeEventListener(\"scroll\", hidePreview, true);\n\n                // Cleanup doc \"change\" listener\n                onActiveEditorChange(null, null, EditorManager.getActiveEditor());\n                EditorManager.off(\"activeEditorChange\", onActiveEditorChange);\n\n                hidePreview();\n            }\n            if (!doNotSave) {\n                prefs.set(\"enabled\", enabled);\n                prefs.save();\n            }\n        }\n        // Always update the checkmark, even if the enabled flag hasn't changed.\n        updateMenuItemCheckmark();\n    }\n\n    function toggleEnableSelectionView() {\n        setEnabled(!enabled);\n    }\n\n    function _forceShow(popover) {\n        hidePreview();\n        popoverState = popover;\n        _renderPreview(popover.editor);\n    }\n\n    function _handleEscapeKeyEvent(event) {\n        if(isSelectionViewShown()){\n            hidePreview();\n            event.preventDefault();\n            event.stopPropagation();\n            return true;\n        }\n        return false;\n    }\n\n    AppInit.appReady(function () {\n        // Create the preview container\n        $previewContainer = $(previewContainerHTML).appendTo($(\"body\"));\n        $previewContent = $previewContainer.find(\".preview-content\");\n        observer.observe($previewContent[0], {\n            childList: true, // Observe direct children\n            subtree: true // And lower descendants too\n        });\n\n        // Register command\n        // Insert menu at specific pos since this may load before OR after code folding extension\n        CommandManager.register(Strings.CMD_ENABLE_SELECTION_VIEW, CMD_ENABLE_SELECTION_VIEW, toggleEnableSelectionView);\n        Menus.getMenu(Menus.AppMenuBar.VIEW_MENU).addMenuItem(\n            CMD_ENABLE_SELECTION_VIEW, null, Menus.AFTER, Commands.VIEW_TOGGLE_INSPECTION);\n\n        // Setup initial UI state\n        setEnabled(prefs.get(\"enabled\"), true);\n\n        prefs.on(\"change\", \"enabled\", function () {\n            setEnabled(prefs.get(\"enabled\"), true);\n        });\n\n        WorkspaceManager.addEscapeKeyEventHandler(\"selectionView\", _handleEscapeKeyEvent);\n    });\n\n    /**\n     * If quickview is displayed and visible on screen\n     * @return {boolean}\n     * @type {function}\n     */\n    function isSelectionViewShown() {\n        return (popoverState && popoverState.visible) || false;\n    }\n\n    // For unit testing\n    exports._queryPreviewProviders  = queryPreviewProviders;\n    exports._forceShow              = _forceShow;\n\n    exports.registerSelectionViewProvider = registerSelectionViewProvider;\n    exports.removeSelectionViewProvider   = removeSelectionViewProvider;\n    exports.isSelectionViewShown = isSelectionViewShown;\n});\n"],"file":"SelectionViewManager.js"}