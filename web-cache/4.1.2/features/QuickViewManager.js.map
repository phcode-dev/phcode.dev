{"version":3,"sources":["features/QuickViewManager.js"],"names":["define","require","exports","module","CommandManager","Commands","EditorManager","Menus","PreferencesManager","Strings","ViewUtils","AppInit","WorkspaceManager","EventDispatcher","ProviderRegistrationHandler","RegistrationHandler","makeEventDispatcher","_EVENT_POPUP_CONTENT_MUTATED","observer","MutationObserver","mutations","mutation","type","trigger","previewContainerHTML","_providerRegistrationHandler","registerQuickViewProvider","registerProvider","bind","removeQuickViewProvider","removeProvider","_getQuickViewProviders","editor","pos","language","getLanguageForPosition","getProvidersForLanguageId","getId","enabled","prefs","$previewContainer","$previewContent","_currentMousePos","animationRequest","quickViewLocked","CMD_ENABLE_QUICK_VIEW","QUICK_VIEW_EDITOR_MARKER","HOVER_DELAY","POINTER_HEIGHT","POPOVER_HORZ_MARGIN","getExtensionPrefs","definePreference","description","DESCRIPTION_QUICK_VIEW_ENABLED","popoverState","hidePreview","visible","marker","clear","empty","hide","removeClass","getActiveEditor","focus","mouseInPreviewContainer","unlockQuickView","window","clearTimeout","hoverTimer","positionPreview","xpos","ypos","ybot","find","is","previewWidth","outerWidth","top","outerHeight","left","elementRect","height","width","clip","getElementClipSize","$","getRootElement","right","addClass","css","_isResultBeforePopoverStart","popover","result","start","indexFromPos","_isResultAfterPopoverEnd","end","_createPopoverState","popoverResults","length","content","i","editsDoc","cssClass","append","startCoord","charCoords","endCoord","ytop","bottom","_getPopover","results","providerInfos","popovers","fulfilledProviderInfos","status","value","popoverResult","providerInfo","push","provider","filterQuickView","async","queryPreviewProviders","token","line","document","getLine","providerPromises","activeProviderInfos","getQuickView","console","error","Promise","allSettled","_renderPreview","markText","className","$popoverContent","show","off","on","currentQueryID","showPreview","getHoveredEditor","coordsChar","clientX","clientY","ch","getToken","savedQueryId","_isMouseFarFromPopup","previewRect","getBoundingClientRect","docRect","thresholdPercent","_isDistanceExceedThreshold","smaller","larger","total","threshold","x","y","processMouseMove","posWithinRange","setTimeout","handleMouseMove","event","contains","activeElement","buttons","requestAnimationFrame","docChanged","onActiveEditorChange","current","previous","updateMenuItemCheckmark","get","setChecked","mouseOut","_evt","toElement","_mouseEnteredPreviewContainer","_mouseExitedPreviewContainer","setEnabled","_enabled","doNotSave","editorHolder","previewContainer","addEventListener","removeEventListener","set","save","toggleEnableQuickView","enableQuickView","_forceShow","Math","floor","_handleEscapeKeyEvent","isQuickViewShown","preventDefault","stopPropagation","lockQuickView","appReady","appendTo","observe","childList","subtree","register","getMenu","AppMenuBar","VIEW_MENU","addMenuItem","AFTER","VIEW_TOGGLE_INSPECTION","addEscapeKeyEventHandler","_queryPreviewProviders"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*jslint regexp: true */\n\n// @INCLUDE_IN_API_DOCS\n\n/**\n * QuickViewManager provides support to add interactive preview popups on hover over the main editors.\n * Extensions can register to provide previews with `QuickViewManager.registerQuickViewProvider` API.\n * <img src = \"https://docs-images.phcode.dev/phcode-sdk/quick-view-image.png\" alt=\"Phoenix code quick view\" />\n * <img src = \"https://docs-images.phcode.dev/phcode-sdk/quick-view-youtube.png\" alt=\"Phoenix code quick view Youtube\" />\n *\n * ### See Related: SelectionViewManager\n * [features/SelectionViewManager](https://github.com/phcode-dev/phoenix/wiki/SelectionViewManager-API) is similar to\n * QuickViewManager API.\n * * SelectionViews popup only once user selects a text by mouse or hover over a region with text selection.\n * * Quickviews popup on mouse hover.\n * <img src = \"https://user-images.githubusercontent.com/5336369/186434397-3db55789-6077-4d02-b4e2-78ef3f663399.png\" alt=\"quick view pops on mouse hover\" />\n *\n *\n * ## Usage\n * Lets build a \"hello world\" extension that displays \"hello world\" on hover over a text in the editor.\n * In your extension file, add the following code:\n *\n * @example\n * ```js\n * const QuickViewManager = brackets.getModule(\"features/QuickViewManager\");\n * // replace `all` with language ID(Eg. javascript) if you want to restrict the preview to js files only.\n * QuickViewManager.registerQuickViewProvider(exports, [\"all\"]);\n *\n * // provide a helpful name for the QuickView. This will be useful if you implement `filterQuickView` function or\n * // have to debug the quick view.\n * exports.QUICK_VIEW_NAME = \"extension.someName\";\n * // now implement the getQuickView function that will be invoked when ever user hovers over a text in the editor.\n * exports.getQuickView = function(editor, pos, token, line) {\n *         return new Promise((resolve, reject)=>{\n *             resolve({\n *                 start: {line: pos.line, ch:token.start},\n *                 end: {line: pos.line, ch:token.end},\n *                 content: \"<div>hello world</div>\"\n *             });\n *         });\n *     };\n * // optional filter quick view function to handle multiple quick views\n * exports.filterQuickView = function(popovers){\n *     // popovers will be an array of all popovers rendered by providers\n *     return popovers; // dont filter show everything in this case\n * }\n * ```\n *\n * ### How it works\n * When QuickViewManager determines that the user intents to see QuickView on hover, `getQuickView` function on all\n * registered QuickView providers are invoked to get the quick view popup. `getQuickView` should return a promise\n * that resolves to the popup contents if the provider has a quick view. Else just reject the promise. If multiple\n * providers returns QuickView, all of them are displayed stacked one by one. You can alter this behavior by\n * providing a `filterQuickView` function in the provider where you can modify what previews will be shown.\n * See detailed API docs for implementation details below:\n *\n * ## API\n * ### registerQuickViewProvider\n * Register a QuickView provider with this api.\n *\n * @example\n * ```js\n * // syntax\n * QuickViewManager.registerQuickViewProvider(provider, supportedLanguages);\n * ```\n * The API requires two parameters:\n * 1. `provider`: must implement a  `getQuickView` function which will be invoked to get the preview. See API doc below.\n * 1. `supportedLanguages`: An array of languages that the QuickView supports. If `[\"all\"]` is supplied, then the\n *    QuickView will be invoked for all languages. Restrict to specific languages: Eg: `[\"javascript\", \"html\", \"php\"]`\n *\n *\n * @example\n * ```js\n * // to register a provider that will be invoked for all languages. where provider is any object that implements\n * // a getQuickView function\n * QuickViewManager.registerQuickViewProvider(provider, [\"all\"]);\n *\n * // to register a provider that will be invoked for specific languages\n * QuickViewManager.registerQuickViewProvider(provider, [\"javascript\", \"html\", \"php\"]);\n * ```\n *\n * ### removeQuickViewProvider\n * Removes a registered QuickView provider. The API takes the same arguments as `registerQuickViewProvider`.\n *\n * @example\n * ```js\n * // syntax\n * QuickViewManager.removeQuickViewProvider(provider, supportedLanguages);\n * // Example\n * QuickViewManager.removeQuickViewProvider(provider, [\"javascript\", \"html\"]);\n * ```\n *\n * ### getQuickView\n * Each provider must implement the `getQuickView` function that returns a promise. The promise either resolves with\n * the quick view details object(described below) or rejects if there is no preview for the position.\n *\n * @example\n * ```js\n * // function signature\n * provider.getQuickView = function(editor, pos, token, line) {\n *         return new Promise((resolve, reject)=>{\n *             resolve({\n *                 start: {line: pos.line, ch:token.start},\n *                 end: {line: pos.line, ch:token.end},\n *                 content: \"<div>hello world</div>\",\n *                 editsDoc: false // this is optional if the quick view edits the current doc\n *             });\n *         });\n *     };\n * ```\n *\n * #### parameters\n * The function will be called with the following arguments:\n * 1. `editor` - The editor over which the user hovers the mouse cursor.\n * 1. `pos` - the cursor position over which the user hovers.\n * 1. `token` - hovered token details\n * 1. `line` - the full line text as string.\n *\n * #### return types\n * The promise returned should resolve to an object with the following contents:\n * 1. `start` : Indicates the start cursor position from which the quick view is valid.\n * 1. `end` : Indicates the end cursor position to which the quick view is valid. These are generally used to highlight\n *    the hovered section of the text in the editor.\n * 1. `content`: Either `HTML` as text, a `DOM Node` or a `Jquery Element`.\n * 1. `editsDoc`: Optional, set to true if the quick view can edit the active document.\n *\n * #### Modifying the QuickView content after resolving `getQuickView` promise\n * Some advanced/interactive extensions may need to do dom operations on the quick view content.\n * In such cases, it is advised to return a domNode/Jquery element as content in `getQuickView`. Event Handlers\n * or further dom manipulations can be done on the returned content element.\n * The Quick view may be dismissed at any time, so be sure to check if the DOM Node is visible in the editor before\n * performing any operations.\n *\n * #### Considerations\n * 1. QuickView won't be displayed till all provider promises are settled. To improve performance, if your QuickView\n *    handler takes time to resolve the QuickView, resolve a dummy quick once you are sure that a QuickView needs\n *    to be shown to the user. The div contents can be later updated as and when more details are available.\n * 1. Note that the QuickView could be hidden/removed any time by the QuickViewManager.\n * 1. If multiple providers returns a valid popup, all of them are displayed except if the `filterQuickView` modifies\n *    the quick view render list. Note that `filterQuickView` is called only for those providers that\n *    provided a quick view.\n *\n * ### filterQuickView\n * Each provider can optionally implement the `filterQuickView` function to control what among the available\n * quick views should be rendered if multiple providers responded with a QuickView. The function will be called\n * once all `getQuickView` providers provided a valid preview object.\n *\n * @example\n * ```js\n * // function signature\n * provider.filterQuickView = function(popovers) {\n *          for(let popover of popovers){\n *             // here if we see that a quick view with name `exclusiveQuickView` is present, then we only show that\n *             // QuickView. popover.providerInfo object holds details of what provider provided the quick view.\n *             if(popover.providerInfo.provider.QUICK_VIEW_NAME === \"exclusiveQuickView\"){\n *                 return [popover]\n *             }\n *         }\n *         // if nothing is returned, then the `popovers` param will be used to show popover\n *     };\n * ```\n *\n * #### parameter\n * The function will be called with the `popovers` parameter which is an array of popover objects that was returned\n * by `getQuickView` function of all succeeded providers. Details of each provider that created a popover\n * will be present in `popovers[i].providerInfo` object.\n *\n * #### return\n * An array of popovers that needs to be rendered, or nothing(to render the original popover parameter as is).\n * @module features/QuickViewManager\n */\n\ndefine(function (require, exports, module) {\n\n\n    // Brackets modules\n    const CommandManager    = require(\"command/CommandManager\"),\n        Commands            = require(\"command/Commands\"),\n        EditorManager       = require(\"editor/EditorManager\"),\n        Menus               = require(\"command/Menus\"),\n        PreferencesManager  = require(\"preferences/PreferencesManager\"),\n        Strings             = require(\"strings\"),\n        ViewUtils           = require(\"utils/ViewUtils\"),\n        AppInit             = require(\"utils/AppInit\"),\n        WorkspaceManager    = require(\"view/WorkspaceManager\"),\n        EventDispatcher     = require(\"utils/EventDispatcher\"),\n        ProviderRegistrationHandler = require(\"features/PriorityBasedRegistration\").RegistrationHandler;\n\n    EventDispatcher.makeEventDispatcher(exports);\n    const _EVENT_POPUP_CONTENT_MUTATED = \"_popupContentMutated\";\n    // Create a new MutationObserver instance\n    const observer = new MutationObserver(mutations => {\n        for (let mutation of mutations) {\n            if (mutation.type === 'childList' || mutation.type === 'subtree') {\n                exports.trigger(_EVENT_POPUP_CONTENT_MUTATED, mutations);\n                break; // Optional: Break after the first change if only one change is needed\n            }\n        }\n    });\n\n    const previewContainerHTML       = '<div id=\"quick-view-container\">\\n' +\n        '    <div class=\"preview-content\">\\n' +\n        '    </div>\\n' +\n        '</div>';\n\n    const _providerRegistrationHandler = new ProviderRegistrationHandler(),\n        registerQuickViewProvider = _providerRegistrationHandler.registerProvider.bind(_providerRegistrationHandler),\n        removeQuickViewProvider = _providerRegistrationHandler.removeProvider.bind(_providerRegistrationHandler);\n\n    function _getQuickViewProviders(editor, pos) {\n        let language = editor.getLanguageForPosition(pos);\n        return  _providerRegistrationHandler.getProvidersForLanguageId(language.getId());\n    }\n\n    let enabled,                             // Only show preview if true\n        prefs                      = null,   // Preferences\n        $previewContainer,                   // Preview container\n        $previewContent,                     // Preview content holder\n        _currentMousePos,\n        animationRequest,\n        quickViewLocked = false;\n\n    // Constants\n    const CMD_ENABLE_QUICK_VIEW       = \"view.enableQuickView\",\n        QUICK_VIEW_EDITOR_MARKER = 'quickViewMark',\n        // Time (ms) mouse must remain over a provider's matched text before popover appears\n        HOVER_DELAY                 = 350,\n        // Pointer height, used to shift popover above pointer (plus a little bit of space)\n        POINTER_HEIGHT              = 10,\n        POPOVER_HORZ_MARGIN         =  5;   // Horizontal margin\n\n    prefs = PreferencesManager.getExtensionPrefs(\"quickview\");\n    prefs.definePreference(\"enabled\", \"boolean\", true, {\n        description: Strings.DESCRIPTION_QUICK_VIEW_ENABLED\n    });\n\n    /**\n     * There are three states for this var:getToken\n     * 1. If null, there is no provider result for the given mouse position.\n     * 2. If non-null, and visible==true, there is a popover currently showing.\n     * 3. If non-null, but visible==false, we're waiting for HOVER_DELAY, which\n     *    is tracked by hoverTimer. The state changes to visible==true as soon as\n     *    there is a provider. If the mouse moves before then, timer is restarted.\n     * @typedef {Object} PopoverState\n     * @property {boolean} visible - Whether the popover is visible.\n     * @property {!Editor} editor - The editor instance associated with the popover.\n     * @property {number} hoverTimer - The token returned by setTimeout().\n     * @property {!{line: number, ch: number}} start - Start of the matched text range.\n     * @property {!{line: number, ch: number}} end - End of the matched text range.\n     * @property {!string} content - HTML content to display in the popover.\n     * @property {number} xpos - X-coordinate of the center of the popover.\n     * @property {number} ytop - Y-coordinate of the top of the matched text when popover is above the text.\n     * @property {number} ybot - Y-coordinate of the bottom of the matched text when popover is below the text.\n     * @property {?CodeMirror.TextMarker} marker - The text marker; only set once `visible` is `true`.\n     * @private\n     */\n    let popoverState = null;\n\n\n\n    // Popover widget management ----------------------------------------------\n\n    /**\n     * Cancels whatever popoverState was currently pending and sets it back to null. If the popover was visible,\n     * hides it; if the popover was invisible and still pending, cancels hoverTimer so it will never be shown.\n     * @private\n     */\n    function hidePreview() {\n        if (!popoverState) {\n            return;\n        }\n\n        if (popoverState.visible) {\n            popoverState.marker.clear();\n            $previewContent.empty();\n            $previewContainer.hide();\n            $previewContainer.removeClass(\"active\");\n            if(EditorManager.getActiveEditor()){\n                EditorManager.getActiveEditor().focus();\n            }\n        }\n        mouseInPreviewContainer = false;\n        unlockQuickView();\n        window.clearTimeout(popoverState.hoverTimer);\n        popoverState = null;\n    }\n\n    function positionPreview(editor, xpos, ypos, ybot) {\n        if ($previewContent.find(\"#quick-view-popover-root\").is(':empty')){\n            hidePreview();\n            return;\n        }\n        let previewWidth  = $previewContainer.outerWidth(),\n            top           = ypos - $previewContainer.outerHeight() - POINTER_HEIGHT,\n            left          = xpos - previewWidth / 2,\n            elementRect = {\n                top: top,\n                left: left - POPOVER_HORZ_MARGIN,\n                height: $previewContainer.outerHeight() + POINTER_HEIGHT,\n                width: previewWidth + 2 * POPOVER_HORZ_MARGIN\n            },\n            clip = ViewUtils.getElementClipSize($(editor.getRootElement()), elementRect);\n\n        // Prevent horizontal clipping\n        if (clip.left > 0) {\n            left += clip.left;\n        } else if (clip.right > 0) {\n            left -= clip.right;\n        }\n\n        // If clipped on top, flip popover below line\n        if (clip.top > 0) {\n            top = ybot + POINTER_HEIGHT;\n            $previewContainer\n                .removeClass(\"preview-bubble-above\")\n                .addClass(\"preview-bubble-below\");\n        } else {\n            $previewContainer\n                .removeClass(\"preview-bubble-below\")\n                .addClass(\"preview-bubble-above\");\n        }\n\n        $previewContainer\n            .css({\n                left: left,\n                top: top\n            })\n            .addClass(\"active\");\n    }\n\n    // Preview hide/show logic ------------------------------------------------\n\n    function _isResultBeforePopoverStart(editor, popover, result){\n        if(!popover.start){\n            return true;\n        }\n        return editor.indexFromPos(result.start) < editor.indexFromPos(popover.start);\n    }\n\n    function _isResultAfterPopoverEnd(editor, popover, result){\n        if(!popover.end){\n            return true;\n        }\n        return editor.indexFromPos(popover.start) > editor.indexFromPos(result.end);\n    }\n\n    function _createPopoverState(editor, popoverResults) {\n        if (popoverResults && popoverResults.length) {\n            let popover = {\n                content: $(\"<div id='quick-view-popover-root'></div>\")\n            };\n            // Each provider return popover { start, end, content}\n            for(let i=0; i<popoverResults.length; i++) {\n                const result = popoverResults[i];\n                if(_isResultBeforePopoverStart(editor, popover, result)){\n                    popover.start = result.start;\n                }\n                if(_isResultAfterPopoverEnd(editor, popover, result)){\n                    popover.end = result.end;\n                }\n                if(result.editsDoc){\n                    popover.editsDoc = true;\n                }\n                let cssClass = `class='quick-view-partition quick-view-item'`;\n                if(i === (popoverResults.length - 1)) {\n                    cssClass = \"class='quick-view-item'\";\n                }\n                popover.content.append($(`<div ${cssClass} ></div>`).append(result.content));\n            }\n\n            let startCoord = editor.charCoords(popover.start),\n                endCoord = editor.charCoords(popover.end);\n            popover.xpos = (endCoord.left - startCoord.left) / 2 + startCoord.left;\n            if(endCoord.left<startCoord.left){\n                // this probably spans multiple lines, just show at start cursor position\n                popover.xpos = startCoord.left;\n            }\n            popover.ytop = startCoord.top;\n            popover.ybot = startCoord.bottom;\n            popover.visible = false;\n            popover.editor  = editor;\n            return popover;\n        }\n\n        return null;\n    }\n\n    /**\n     * Returns a popover array with the list of popovers to be rendered after filtering from providers.\n     * @param results\n     * @param providerInfos\n     * @return {Object[]}\n     * @private\n     */\n    function _getPopover(results, providerInfos) {\n        let popovers = [], fulfilledProviderInfos = [];\n        for(let i=0; i< results.length; i++){\n            let result = results[i];\n            if(result.status === \"fulfilled\" && result.value){\n                let popoverResult = result.value;\n                popoverResult.providerInfo = providerInfos[i];\n                fulfilledProviderInfos.push(providerInfos[i]);\n                popovers.push(popoverResult);\n            }\n        }\n\n        // filterQuickView is called only for those providers that provided a quick view.\n        for(let providerInfo of fulfilledProviderInfos){\n            let provider = providerInfo.provider;\n            if(provider.filterQuickView){\n                popovers = provider.filterQuickView(popovers) || popovers;\n            }\n        }\n\n        return popovers;\n    }\n\n    /**\n     * Returns a 'ready for use' popover state object:\n     * { visible: false, editor, start, end, content, ?onShow, xpos, ytop, ybot }\n     * Lacks only hoverTimer (supplied by handleMouseMove()) and marker (supplied by showPreview()).\n     * @private\n     */\n    async function queryPreviewProviders(editor, pos, token) {\n        let line = editor.document.getLine(pos.line);\n        let providerInfos = _getQuickViewProviders(editor, pos);\n        let providerPromises = [], activeProviderInfos = [];\n        for(let providerInfo of providerInfos){\n            let provider = providerInfo.provider;\n            if(!provider.getQuickView){\n                console.error(\"Quickview provider does not implement the required getQuickView function\", provider);\n                continue;\n            }\n            providerPromises.push(provider.getQuickView(editor, pos, token, line));\n            activeProviderInfos.push(providerInfo);\n        }\n        let results = await Promise.allSettled(providerPromises);\n\n        return _createPopoverState(editor, _getPopover(results, activeProviderInfos));\n    }\n\n    /**\n     * Changes the current hidden popoverState to visible, showing it in the UI and highlighting\n     * its matching text in the editor.\n     * @private\n     */\n    function _renderPreview(editor) {\n        if (popoverState && popoverState.start && popoverState.end) {\n            popoverState.marker = editor.markText(\n                QUICK_VIEW_EDITOR_MARKER,\n                popoverState.start,\n                popoverState.end,\n                {className: \"quick-view-highlight\"}\n            );\n\n            let $popoverContent = $(popoverState.content);\n            $previewContent.append($popoverContent);\n            $previewContainer.show();\n            popoverState.visible = true;\n            positionPreview(editor, popoverState.xpos, popoverState.ytop, popoverState.ybot);\n\n            exports.off(_EVENT_POPUP_CONTENT_MUTATED);\n            exports.on(_EVENT_POPUP_CONTENT_MUTATED, ()=>{\n                if(!popoverState || !editor){\n                    return;\n                }\n                positionPreview(editor, popoverState.xpos, popoverState.ytop, popoverState.ybot);\n            });\n        }\n    }\n\n    let currentQueryID = 0;\n    async function showPreview(editor) {\n        let token;\n\n        // Figure out which editor we are over\n        if (!editor) {\n            editor = EditorManager.getHoveredEditor(_currentMousePos);\n        }\n\n        if (!editor) {\n            hidePreview();\n            return;\n        }\n\n        // Find char mouse is over\n        let pos = editor.coordsChar({left: _currentMousePos.clientX, top: _currentMousePos.clientY});\n\n        // No preview if mouse is past last char on line\n        if (pos.ch >= editor.document.getLine(pos.line).length) {\n            return;\n        }\n\n        // Query providers and append to popoverState\n        token = editor.getToken(pos);\n        currentQueryID++;\n        let savedQueryId = currentQueryID;\n        popoverState = await queryPreviewProviders(editor, pos, token);\n        if(savedQueryId === currentQueryID){\n            // this is to prevent race conditions. For Eg., if the preview provider takes time to generate a preview,\n            // another query might have happened while the last query is still in progress. So we only render the most\n            // recent QueryID\n            _renderPreview(editor);\n        }\n    }\n\n    function _isMouseFarFromPopup() {\n        const previewRect = $previewContainer[0].getBoundingClientRect();\n        const docRect = {\n            height: $(document).height(),\n            width: $(document).width()\n        };\n        const thresholdPercent = 5;\n        function _isDistanceExceedThreshold(smaller, larger, total, threshold) {\n            return ((larger - smaller)/total)*100 > threshold;\n        }\n        let x= _currentMousePos.clientX, y=_currentMousePos.clientY;\n        if((x<previewRect.left && _isDistanceExceedThreshold(x, previewRect.left, docRect.width, thresholdPercent))\n            ||(x>previewRect.right && _isDistanceExceedThreshold(previewRect.right, x, docRect.width, thresholdPercent))\n            ||(y<previewRect.top && _isDistanceExceedThreshold(y, previewRect.top, docRect.height, thresholdPercent))\n            ||(y>previewRect.bottom && _isDistanceExceedThreshold(previewRect.bottom, y, docRect.height, thresholdPercent))){\n            return true;\n        }\n        return false;\n    }\n\n    function processMouseMove() {\n        animationRequest = null;\n\n        if (mouseInPreviewContainer || quickViewLocked) {\n            return;\n        }\n\n        let editor = null;\n\n        if (popoverState && popoverState.visible) {\n            // Only figure out which editor we are over when there is already a popover\n            // showing (otherwise wait until after delay to minimize processing)\n            editor = EditorManager.getHoveredEditor(_currentMousePos);\n            if (editor) {\n                // Find char mouse is over\n                let pos = editor.coordsChar({left: _currentMousePos.clientX, top: _currentMousePos.clientY});\n                if (popoverState.start && popoverState.end &&\n                        editor.posWithinRange(pos, popoverState.start, popoverState.end, true) &&\n                        (pos.ch < editor.document.getLine(pos.line).length)) {\n\n                    // That one's still relevant - nothing more to do\n                    // Note: posWithinRange() includes mouse past end of line, so need to check for that case\n                    return;\n                }\n                if(_isMouseFarFromPopup()){\n                    hidePreview();\n                    return;\n                }\n            }\n        }\n\n        popoverState = popoverState || {};\n\n        // Set timer to scan and show. This will get cancelled (in hidePreview())\n        // if mouse movement rendered this popover inapplicable before timer fires.\n        // When showing \"immediately\", still use setTimeout() to make this async\n        // so we return from this mousemove event handler ASAP.\n        clearTimeout(popoverState.hoverTimer);\n        popoverState.hoverTimer = window.setTimeout(function () {\n            if(!mouseInPreviewContainer && !quickViewLocked){\n                hidePreview();\n                popoverState = {};\n                showPreview(editor);\n            }\n        }, HOVER_DELAY);\n    }\n\n    function handleMouseMove(event) {\n        // Keep track of mouse position\n        _currentMousePos = {\n            clientX: event.clientX,\n            clientY: event.clientY\n        };\n\n        if (!enabled || quickViewLocked\n            || $previewContainer[0].contains(window.document.activeElement)) {\n            // activeElement check as, if the popup has an active element, say a text input, user may\n            // move the mouse outside popup to type in the input, in which case we should not close popup.\n            return;\n        }\n\n        if (event.buttons !== 0 && !mouseInPreviewContainer) {\n            // Button is down - don't show popovers while dragging\n            hidePreview();\n            return;\n        }\n\n        // Prevent duplicate animation frame requests\n        if (!animationRequest) {\n            animationRequest = window.requestAnimationFrame(processMouseMove);\n        }\n    }\n\n    function docChanged() {\n        if(popoverState && !popoverState.editsDoc){\n            hidePreview();\n        }\n    }\n\n    function onActiveEditorChange(event, current, previous) {\n        // Hide preview when editor changes\n        hidePreview();\n\n        if (previous && previous.document) {\n            previous.document.off(\"change\", docChanged);\n        }\n\n        if (current && current.document) {\n            current.document.on(\"change\", docChanged);\n        }\n    }\n\n    // Menu command handlers\n    function updateMenuItemCheckmark() {\n        CommandManager.get(CMD_ENABLE_QUICK_VIEW).setChecked(enabled);\n    }\n\n    let mouseInPreviewContainer = false;\n    function mouseOut(_evt) {\n        setTimeout(()=>{\n            if(mouseInPreviewContainer || $previewContainer[0].contains(_evt.toElement) || quickViewLocked){\n                return;\n            }\n            hidePreview();\n        }, HOVER_DELAY);\n    }\n\n    function _mouseEnteredPreviewContainer() {\n        mouseInPreviewContainer = true;\n    }\n\n    function _mouseExitedPreviewContainer() {\n        mouseInPreviewContainer = false;\n    }\n\n    function setEnabled(_enabled, doNotSave) {\n        if (enabled !== _enabled) {\n            enabled = _enabled;\n            let editorHolder = $(\"#editor-holder\")[0];\n            let previewContainer = $previewContainer[0];\n            if (enabled) {\n                // Note: listening to \"scroll\" also catches text edits, which bubble a scroll\n                // event up from the hidden text area. This means\n                // we auto-hide on text edit, which is probably actually a good thing.\n                editorHolder.addEventListener(\"mousemove\", handleMouseMove, true);\n                editorHolder.addEventListener(\"scroll\", hidePreview, true);\n                editorHolder.addEventListener(\"mouseout\", mouseOut, true);\n                previewContainer.addEventListener(\"mouseover\", _mouseEnteredPreviewContainer, true);\n                previewContainer.addEventListener(\"mouseout\", _mouseExitedPreviewContainer, true);\n\n                // Setup doc \"change\" listener\n                onActiveEditorChange(null, EditorManager.getActiveEditor(), null);\n                EditorManager.on(\"activeEditorChange\", onActiveEditorChange);\n\n            } else {\n                editorHolder.removeEventListener(\"mousemove\", handleMouseMove, true);\n                editorHolder.removeEventListener(\"scroll\", hidePreview, true);\n                editorHolder.removeEventListener(\"mouseout\", mouseOut, true);\n                previewContainer.removeEventListener(\"mouseover\", _mouseEnteredPreviewContainer, true);\n                previewContainer.removeEventListener(\"mouseout\", _mouseExitedPreviewContainer, true);\n\n\n                // Cleanup doc \"change\" listener\n                onActiveEditorChange(null, null, EditorManager.getActiveEditor());\n                EditorManager.off(\"activeEditorChange\", onActiveEditorChange);\n\n                hidePreview();\n            }\n            if (!doNotSave) {\n                prefs.set(\"enabled\", enabled);\n                prefs.save();\n            }\n        }\n        // Always update the checkmark, even if the enabled flag hasn't changed.\n        updateMenuItemCheckmark();\n    }\n\n    function toggleEnableQuickView() {\n        let enableQuickView = !enabled;\n        if(!enableQuickView){\n            unlockQuickView();\n        }\n        setEnabled(enableQuickView);\n    }\n\n    function _forceShow(popover) {\n        hidePreview();\n        _currentMousePos = {\n            clientX: popover.xpos,\n            clientY: Math.floor((popover.ybot + popover.ytop) / 2)\n        };\n        popoverState = popover;\n        _renderPreview(popover.editor);\n    }\n\n    function _handleEscapeKeyEvent(event) {\n        if(isQuickViewShown()){\n            hidePreview();\n            event.preventDefault();\n            event.stopPropagation();\n            return true;\n        }\n        return false;\n    }\n\n    AppInit.appReady(function () {\n        // Create the preview container\n        $previewContainer = $(previewContainerHTML).appendTo($(\"body\"));\n        $previewContent = $previewContainer.find(\".preview-content\");\n        observer.observe($previewContent[0], {\n            childList: true, // Observe direct children\n            subtree: true // And lower descendants too\n        });\n\n        // Register command\n        // Insert menu at specific pos since this may load before OR after code folding extension\n        CommandManager.register(Strings.CMD_ENABLE_QUICK_VIEW, CMD_ENABLE_QUICK_VIEW, toggleEnableQuickView);\n        Menus.getMenu(Menus.AppMenuBar.VIEW_MENU).addMenuItem(\n            CMD_ENABLE_QUICK_VIEW, null, Menus.AFTER, Commands.VIEW_TOGGLE_INSPECTION);\n\n        // Setup initial UI state\n        setEnabled(prefs.get(\"enabled\"), true);\n\n        prefs.on(\"change\", \"enabled\", function () {\n            setEnabled(prefs.get(\"enabled\"), true);\n        });\n\n        WorkspaceManager.addEscapeKeyEventHandler(\"quickView\", _handleEscapeKeyEvent);\n    });\n\n    /**\n     * If quickview is displayed and visible on screen\n     * @return {boolean}\n     * @type {function}\n     */\n    function isQuickViewShown() {\n        return (popoverState && popoverState.visible) || false;\n    }\n\n    /**\n     * locks the current QuickView if shown to be permanently displayed on screen till the `unlockQuickView` function\n     * is called or document changes.\n     *\n     * @type {function}\n     */\n    function lockQuickView() {\n        if(isQuickViewShown()){\n            quickViewLocked = true;\n        }\n    }\n\n    /**\n     * unlocks the current QuickView locked by `lockQuickView` fucntion.\n     *\n     * @type {function}\n     */\n    function unlockQuickView() {\n        quickViewLocked = false;\n    }\n\n    // For unit testing\n    exports._queryPreviewProviders  = queryPreviewProviders;\n    exports._forceShow              = _forceShow;\n\n    exports.registerQuickViewProvider = registerQuickViewProvider;\n    exports.removeQuickViewProvider   = removeQuickViewProvider;\n    exports.isQuickViewShown = isQuickViewShown;\n    exports.lockQuickView = lockQuickView;\n    exports.unlockQuickView = unlockQuickView;\n});\n"],"file":"QuickViewManager.js"}