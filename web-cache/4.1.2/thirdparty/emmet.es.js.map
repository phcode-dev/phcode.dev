{"version":3,"sources":["thirdparty/emmet.es.js"],"names":["isNumber$1","code","isAlpha$1","from","to","isAlphaNumericWord","isAlphaWord","isUmlaut","isWhiteSpace$3","isSpace","isQuote$2","Scanner","[object Object]","str","start","end","length","this","string","pos","charCodeAt","match","ch","peek","ok","next","eof","eat","n","substring","slice","message","ScannerError","Error","super","tokenScanner$1","tokens","size","peek$3","scanner","readable$1","consume$2","test","token","error$1","err","abbreviation","abbr","options","result","statements","type","elements","ctx","node","stack","element$2","group","push","isChildOperator","isSiblingOperator$1","isClimbOperator","pop","isGroupStart","isBracket$2","repeat","repeater$1","attr","elem","name","attributes","value","selfClose","elementName","isEmpty","isRepeater","text","getText","shortAttribute","attributeSet","isCloseOperator","concat","Array","isArray","isAttributeSetStart","attribute","isAttributeSetEnd","isWhiteSpace$2","isOperator$1","count","createLiteral$1","multiple","jsx","expression","literal$1$1","quoted","isEquals","quote","isQuote$1","single","allowBrackets","brackets","context","open","isCapitalizedLiteral","isClassNameOperator","isElementName$1","isTextStart","isOpen","Boolean","operator","isSingle","isLiteral$2","Chars$3","escaped","Escape","tokenize$1","source","getToken$1","error","field$2","repeaterPlaceholder","repeaterNumber","repeater","whiteSpace$1","literal$2","operator$1","bracket$1","expressionStart","current","Slash","prev","Dollar","isAllowedOperator","CurlyBracketOpen","CurlyBracketClose","isElementName","isAllowedSpace","isAllowedRepeater","bracketType","eatWhile","SingleQuote","isOpenBracket$2","op","operatorType$1","Asterisk","implicit","Number","Hash","reverse","base","parent","At","Climb","Dash","index","Colon","consumePlaceholder$2","stream","RoundBracketOpen","RoundBracketClose","SquareBracketOpen","SquareBracketClose","Child","Sibling","Dot","Equals","Excl","Chars","operators","child","class","climb","id","equal","close","sibling","tokenVisitor","Literal","Quote","Bracket","Operator","Field","state","getVariable","i","repeaters","inserted","lastIx","parentIx","Math","max","parentRepeater","String","WhiteSpace","stringify$1","urlRegex","emailRegex","convert","textInserted","cleanText","filter","s","trim","children","convertGroup","repeatGuard","maxRepeat","POSITIVE_INFINITY","_a","undefined","join","varValue","variables","deepest","deepestNode","last$1","insertText","href","insertHref","convertStatement","original","Object","assign","items","isGroup","convertElement","target","stringifyName","stringifyValue$1","selfClosing","convertAttribute","some","isField$1","attachRepeater","implied","isBoolean","valueType","shift","boolean","arr","lastToken","startsWith","hrefAttribute","find","item","parseAbbreviation","OperatorType","Chars$2","tokenize","isValue","getToken","mergeTokens","shouldConsumeDashAfter","short","field$1","customProperty","numberValue","colorValue","stringValue","bracket","whiteSpace","literal$1","consumePlaceholder$1","isIdentPrefix","isKeyword","isLiteral$1","createLiteral","consumeNumber","rawValue","Percent","unit","finished","valueStart","color","alpha","isHex","colorAlpha","Transparent","r","g","b","a","parseColor","raw","isBracket$1","operatorType","afterNegative","hasDecimal","prevPos","hasFloat","Important","Comma","ArgumentDelimiter","PropertyDelimiter","ValueDelimiter","parseInt","last","tokenScanner","peek$2","readable","consume$1","parser","property","consumeProperty","isSiblingOperator","important","valueFragment","valueMode","isLiteral","isFunctionStart","isValueDelimiter","isWhiteSpace$1","isImportant","consumeValue","isFragmentDelimiter","inArgument","args","consumeArguments","arguments","isOpenBracket$1","isCloseBracket$1","isArgumentDelimiter","isBracket","isOperator","t1","t2","parse$2","mergeAttributes","config","lookup","attrName","mergeValue","mergeDeclarations","glue","append","t","dest","src","walk$1","fn","ancestors","callback","forEach","find$1","findDeepest","isNode","resolveSnippets","reversed","warn","resolve","snippet","snippets","includes","snippetAbbr","walkResolve","topNode","mergeNodes","resolved","expressionEnd","createOutputStream","level","offset","line","column","processText","_push","pushString","lines","splitByLines$1","il","pushNewline","indent","baseIndent","newline","pushIndent","pushField","placeholder","field","tagName","strCase","attrQuote","isBooleanAttribute","toLowerCase","isInline","inlineElements","split","toUpperCase","elementMap","p","ul","ol","table","tr","tbody","thead","tfoot","colgroup","select","optgroup","audio","video","object","map","implicitTag","resolveImplicitTag","getParentElement","contextName","parentName","lowercase","latin","common","words","ru","sp","vocabularies","reLorem","lorem","m","db","minWordCount","maxWordCount","wordCount","rand","findRepeater","paragraph","floor","random","sample","len","iterations","min","choice","val","sentence","capitalize","word","insertCommas","hasComma","totalCommas","dict","startWithCommon","totalWords","element","xsl","matchesName","isAllowed","reElement","reModifier","blockCandidates1","className","blockCandidates2","bem","expandClassNames","expandShortNotation","data","getBEMData","classNames","cl","ix","indexOf","uniqueClass","block","findBlockName","updateClass","path","prefix","originalClass","getBlockName","arrClassNames","_bem","classValue","stringifyValue","parseBEM","getBEMDataFromContext","depth","maxParentIx","label","input","isEmptyAttribute","walk","visitor","createWalkState","out","caret","isSnippet","isInlineElement","isField","pushTokens","largestIndex","splitByLines","shouldOutputAttribute","TemplateChars","template","consumePlaceholder","peek$1","Start","namePos","afterPos","isTokenStart","isToken","End","before","after","Underscore","createCommentState","enabled","trigger","commentNodeBefore","shouldComment","comment","output","commentNodeAfter","attrs","htmlTagRegex","reservedKeywords","Set","html","element$1","format","shouldFormat$1","getIndent","pushAttribute","pushSnippet","innerFormat","hasNewline","startsWithBlockTag","valuePrefix","lQuote","rQuote","getMultiValue","isPropKey","fieldIx","findIndex","trimLeft","adjacentInline","matches","exec","key","has","indentFormat","primary","secondary","collectAttributes","shouldFormat","beforeName","afterName","pushPrimaryAttributes","pushSecondaryAttributes","pushValue","isPrimaryAttribute","replace","beforeAttribute","booleanValue","glueAttribute","afterAttribute","lineLengths","maxLength","valueLength","beforeTextLine","afterTextLine","haml","slim","pug","formatters","parse$1","oldTextValue","parseOpt","transform","stringify","formatter","syntax","CSSSnippetType","reProperty","opt","createSnippet","keywords","parsed","parseValue","cssVal","collectKeywords","Property","dependencies","Raw","nest","sort","snippetsSort","cur","isProperty","v","scoreMatch","str1","str2","partialMatch","str1Len","str2Len","minLength","j","score","ch1","ch2","found","acronym","matchRatio","delta","maxScore","sum","shortHex","asHex","asRGB","isShortHex","toShortHex","toHex","values","frac","num","digits","toFixed","hex","toString","pad","CSSAbbreviationScope","Global","Section","Value","css","isJSON","toCamelCase","propertyValue","outputImportant","outputToken","getSingleNumeric","getQuote","outputValue","separator","prevEnd","_","letter","gradientName","parse","cache","stylesheetSnippets","convertSnippets","isValueScope","filteredSnippets","getSnippetsForScope","resolveNode","keys","resolveGradient","propName","resolveValueKeywords","findBestMatch","resolveAsProperty","resolveAsSnippet","resolveNumericValue","gradientFn","cssValue","inlineValue","getUnmatchedPart","kw","resolveKeyword","defaultValue","hasField","wrapWithField","minScore","reField","inputValue","literal","tail","matchedItem","getScoringPart","lastPos","ref","dep","aliases","unitless","q","markupSnippets","a:blank","a:link","a:mail","a:tel","acr|acronym","basefont","br","frame","hr","bdo","bdo:r","bdo:l","col","link","link:css","link:print","link:favicon","link:mf|link:manifest","link:touch","link:rss","link:atom","link:im|link:import","meta","meta:utf","meta:vp","meta:compat","meta:edge","meta:redirect","meta:refresh","meta:kw","meta:desc","style","script","script:src","script:module","img","img:s|img:srcset","img:z|img:sizes","picture","src|source","src:sc|source:src","src:s|source:srcset","src:t|source:type","src:z|source:sizes","src:m|source:media","src:mt|source:media:type","src:mz|source:media:sizes","src:zt|source:sizes:type","iframe","embed","param","area","area:d","area:c","area:r","area:p","form","form:get","form:post","inp","input:h|input:hidden","input:t|input:text","input:search","input:email","input:url","input:p|input:password","input:datetime","input:date","input:datetime-local","input:month","input:week","input:time","input:tel","input:number","input:color","input:c|input:checkbox","input:r|input:radio","input:range","input:f|input:file","input:s|input:submit","input:i|input:image","input:b|input:btn|input:button","input:reset","isindex","select:d|select:disabled","opt|option","textarea","tarea:c|textarea:cols","tarea:r|textarea:rows","tarea:cr|textarea:cols:rows","marquee","menu:c|menu:context","menu:t|menu:toolbar","html:xml","keygen","command","btn:s|button:s|button:submit","btn:r|button:r|button:reset","btn:b|button:b|button:button","btn:d|button:d|button:disabled","fst:d|fset:d|fieldset:d|fieldset:disabled","bq","fig","figc","pic","ifr","emb","obj","cap","colg","fst","btn","optg","tarea","leg","sect","art","hdr","ftr","adr","dlg","prog","mn","tem","fset","datal","kg","det","cmd","meter","time","ri:d|ri:dpr","ri:v|ri:viewport","ri:a|ri:art","ri:t|ri:type","!!!","doc","!|html:5","c","cc:ie","cc:noie","@f","@ff","@i|@import","@kf","@m|@media","ac","ai","anim","animdel","animdir","animdur","animfm","animic","animn","animps","animtf","ap","as","bd","bdb","bdbc","bdbi","bdbk","bdbli","bdblrs","bdbri","bdbrrs","bdbs","bdbw","bdc","bdci","bdcl","bdf","bdi","bdl","bdlc","bdlen","bdli","bdls","bdlw","bdr","bdrc","bdri","bdrs","bdrst","bdrw","bds","bdsp","bdt","bdtc","bdti","bdtli","bdtlrs","bdtri","bdtrrs","bdts","bdtw","bdw","bbs","bbe","bis","bie","bfv","bg","bg:n","bga","bgbk","bgc","bgcp","bgi","bgo","bgp","bgpx","bgpy","bgr","bgsz","bs","bxsh","bxsz","cg","cr","cra","cm","cnt","coi","colm","colmc","colmf","colmg","colmr","colmrc","colmrs","colmrw","colms","colmw","cor","cp","cps","d","ec","f","fd","fef","fem","femp","fems","ff","fft","ffa","ffv","fl","fs","fsm","fv","fvs","fw","fx","fxb","fxd","fxf","fxg","fxsh","fxw","fsz","fsza","gtc","gtr","gta","gt","gg","gcg","grg","gac","gar","gaf","gd","gc","gcs","gce","gr","grs","gre","ga","h","is","jc","ji","js","l","lg","lh","lis","lisi","lisp","list","lts","mah","mar","maw","mb","mih","mir","miw","ml","mr","mt","mbs","mbe","mis","mie","olc","olo","ols","olw","op|opa","ord","ori","orp","ov","ovs","ovx","ovy","pb","pgba","pgbb","pgbi","pl","pr","pt","pbs","pbe","pis","pie","spbs","spbe","spis","spie","qen","qru","rg","rsz","ta","tal","tbl","td","te","th","ti","tj","tov","trf","trfo","trfs","trs","trsde","trsdu","trsp","trstf","tsh","tt","tw","us","va","w|wid","whs","whsc","wido","wm","wob","wos","wow","z","zom","xslSnippets","tm|tmatch","tn|tname","call","api","imp","inc","wh|xsl:when","ot","if","par","pare","var","vare","wp","co","for|each","tex","com","msg","fall","nam","pres","strip","proc","choose","pugSnippets","lang","locale","charset","indentation","defaultSyntaxes","markup","stylesheet","defaultOptions$1","output.indent","output.baseIndent","output.newline","output.tagCase","output.attributeCase","output.attributeQuotes","output.format","output.formatLeafNode","output.formatSkip","output.formatForce","output.inlineBreak","output.compactBoolean","output.booleanAttributes","output.reverseAttributes","output.selfClosingStyle","output.field","output.text","markup.href","comment.enabled","comment.trigger","comment.before","comment.after","bem.enabled","bem.element","bem.modifier","jsx.enabled","stylesheet.keywords","stylesheet.unitless","stylesheet.shortHex","stylesheet.between","stylesheet.after","stylesheet.intUnit","stylesheet.floatUnit","stylesheet.unitAliases","e","x","stylesheet.json","stylesheet.jsonDoubleQuotes","stylesheet.fuzzySearchMinScore","stylesheet.strictMatch","defaultConfig","syntaxConfig","parseSnippets","xhtml","xml","markup.attributes","class*","for","markup.valuePrefix","vue","svelte","sass","stylus","k","resolveConfig","globals","mergedData","typeDefaults","typeOverride","syntaxDefaults","syntaxOverride","backwardScanner","sol","previous","consume","consumeWhile","Chars$1","Brackets","isQuote","DoubleQuote","consumeQuoted","bracePairs","SquareL","SquareR","RoundL","RoundR","CurlyL","CurlyR","isHtml","AngleRight","isWhiteSpace","consumeIdent","AngleLeft","consumeAttributeWithUnquotedValue","consumeAttribute","consumeAttributeWithQuotedValue","isCloseBracket","isOpenBracket","isUnquotedValue","isIdent","isAlpha","isNumber","Space","Tab","isNaN","specialChars","defaultOptions","lookAhead","extractAbbreviation","offsetPastAutoClosed","getStartOffset","isCloseBrace","isOpenBrace","isAbbreviation","location","compiledPrefix","consumePair","consumeArray","consumed","expandAbbreviation","resolvedConfig"],"mappings":"AAGA,SAASA,WAAWC,MAChB,OAAOA,KAAO,IAAMA,KAAO,GAK/B,SAASC,UAAUD,KAAME,KAAMC,IAI3B,OAFAA,GAAKA,IAAM,IACXH,OAAQ,MAFRE,KAAOA,MAAQ,KAGQF,MAAQG,GAEnC,SAASC,mBAAmBJ,MACxB,OAAOD,WAAWC,OAASK,YAAYL,MAE3C,SAASK,YAAYL,MACjB,OAAgB,KAATA,MAAuBC,UAAUD,MAK5C,SAASM,SAASN,MACd,OAAgB,MAATA,MACQ,KAARA,MACS,MAATA,MACS,MAATA,MACS,MAATA,MACS,MAATA,KAMX,SAASO,eAAeP,MACpB,OAAgB,KAATA,MACS,IAATA,MACS,MAATA,KAKX,SAASQ,QAAQR,MACb,OAAOO,eAAeP,OACN,KAATA,MACS,KAATA,KAKX,SAASS,UAAUT,MACf,OAAgB,KAATA,MAAgC,KAATA,KAMlC,MAAMU,QACFC,YAAYC,IAAKC,MAAOC,KACT,MAAPA,KAA8B,iBAARF,MACtBE,IAAMF,IAAIG,QAEdC,KAAKC,OAASL,IACdI,KAAKE,IAAMF,KAAKH,MAAQA,OAAS,EACjCG,KAAKF,IAAMA,KAAO,EAKtBH,MACI,OAAOK,KAAKE,KAAOF,KAAKF,IAO5BH,MAAME,MAAOC,KACT,OAAO,IAAIJ,QAAQM,KAAKC,OAAQJ,MAAOC,KAM3CH,OACI,OAAOK,KAAKC,OAAOE,WAAWH,KAAKE,KAMvCP,OACI,GAAIK,KAAKE,IAAMF,KAAKC,OAAOF,OACvB,OAAOC,KAAKC,OAAOE,WAAWH,KAAKE,OAS3CP,IAAIS,OACA,MAAMC,GAAKL,KAAKM,OACVC,GAAsB,mBAAVH,MAAuBA,MAAMC,IAAMA,KAAOD,MAI5D,OAHIG,IACAP,KAAKQ,OAEFD,GAMXZ,SAASS,OACL,MAAMP,MAAQG,KAAKE,IACnB,MAAQF,KAAKS,OAAST,KAAKU,IAAIN,SAC/B,OAAOJ,KAAKE,MAAQL,MAMxBF,OAAOgB,GACHX,KAAKE,KAAQS,GAAK,EAMtBhB,UACI,OAAOK,KAAKY,UAAUZ,KAAKH,MAAOG,KAAKE,KAK3CP,UAAUE,MAAOC,KACb,OAAOE,KAAKC,OAAOY,MAAMhB,MAAOC,KAKpCH,MAAMmB,QAASZ,IAAMF,KAAKE,KACtB,OAAO,IAAIa,gBAAgBD,cAAcZ,IAAM,IAAKA,IAAKF,KAAKC,SAGtE,MAAMc,qBAAqBC,MACvBrB,YAAYmB,QAASZ,IAAKN,KACtBqB,MAAMH,SACNd,KAAKE,IAAMA,IACXF,KAAKC,OAASL,KAItB,SAASsB,eAAeC,QACpB,MAAO,CACHA,OAAAA,OACAtB,MAAO,EACPK,IAAK,EACLkB,KAAMD,OAAOpB,QAGrB,SAASsB,OAAOC,SACZ,OAAOA,QAAQH,OAAOG,QAAQpB,KAElC,SAASM,KAAKc,SACV,OAAOA,QAAQH,OAAOG,QAAQpB,OAElC,SAASW,MAAMS,QAASpC,KAAOoC,QAAQzB,MAAOV,GAAKmC,QAAQpB,KACvD,OAAOoB,QAAQH,OAAON,MAAM3B,KAAMC,IAEtC,SAASoC,WAAWD,SAChB,OAAOA,QAAQpB,IAAMoB,QAAQF,KAEjC,SAASI,UAAUF,QAASG,MACxB,MAAMC,MAAQL,OAAOC,SACrB,SAAII,QAASD,KAAKC,UACdJ,QAAQpB,OACD,GAIf,SAASyB,QAAQL,QAASR,QAASY,MAAQL,OAAOC,UAC1CI,OAAwB,MAAfA,MAAM7B,QACfiB,gBAAkBY,MAAM7B,SAE5B,MAAM+B,IAAM,IAAIZ,MAAMF,SAEtB,OADAc,IAAS,IAAIF,OAASA,MAAM7B,MACrB+B,IAGX,SAASC,aAAaC,KAAMC,QAAU,IAClC,MAAMT,QAAUJ,eAAeY,MACzBE,OAASC,WAAWX,QAASS,SACnC,GAAIR,WAAWD,SACX,MAAMK,QAAQL,QAAS,wBAE3B,OAAOU,OAEX,SAASC,WAAWX,QAASS,SACzB,MAAMC,OAAS,CACXE,KAAM,aACNC,SAAU,IAEd,IAAIC,IAAMJ,OACNK,KACJ,MAAMC,MAAQ,GACd,KAAOf,WAAWD,WACVe,KAAOE,UAAUjB,QAASS,UAAYS,MAAMlB,QAASS,WAErD,GADAK,IAAID,SAASM,KAAKJ,MACdb,UAAUF,QAASoB,iBACnBJ,MAAMG,KAAKL,KACXA,IAAMC,SAEL,CAAA,GAAIb,UAAUF,QAASqB,qBACxB,SAEC,GAAInB,UAAUF,QAASsB,iBACxB,GACQN,MAAMvC,SACNqC,IAAME,MAAMO,aAEXrB,UAAUF,QAASsB,kBAOxC,OAAOZ,OAKX,SAASQ,MAAMlB,QAASS,SACpB,GAAIP,UAAUF,QAASwB,cAAe,CAClC,MAAMd,OAASC,WAAWX,QAASS,SAC7BL,MAAQlB,KAAKc,SAInB,OAHIyB,YAAYrB,MAAO,SAAS,KAC5BM,OAAOgB,OAASC,WAAW3B,UAExBU,QAMf,SAASO,UAAUjB,QAASS,SACxB,IAAImB,KACJ,MAAMC,KAAO,CACTjB,KAAM,eACNkB,UAAM,EACNC,gBAAY,EACZC,WAAO,EACPN,YAAQ,EACRO,WAAW,EACXpB,SAAU,IAKd,IAHIqB,YAAYlC,QAASS,WACrBoB,KAAKC,KAAOvC,MAAMS,UAEfC,WAAWD,UAEd,GADAA,QAAQzB,MAAQyB,QAAQpB,IACnBiD,KAAKH,QAAWS,QAAQN,QAAS3B,UAAUF,QAASoC,YAGpD,IAAKP,KAAKG,OAASK,KAAKrC,SACzB6B,KAAKG,MAAQM,QAAQtC,aAEpB,CAAA,KAAI4B,KAAOW,eAAevC,QAAS,KAAMS,UAAY8B,eAAevC,QAAS,QAASS,UAAY+B,aAAaxC,UAQ/G,EACImC,QAAQN,OAAS3B,UAAUF,QAASyC,mBACrCZ,KAAKI,WAAY,GACZJ,KAAKH,QAAUxB,UAAUF,QAASoC,cACnCP,KAAKH,OAAS1B,QAAQH,OAAOG,QAAQpB,IAAM,KAGnD,MAdKiD,KAAKE,WAINF,KAAKE,WAAaF,KAAKE,WAAWW,OAAOd,MAHzCC,KAAKE,WAAaY,MAAMC,QAAQhB,MAAQA,KAAKrC,QAAU,CAACqC,WAP5DC,KAAKH,OAAS1B,QAAQH,OAAOG,QAAQpB,IAAM,GAuBnD,OAAQuD,QAAQN,WAAe,EAAPA,KAK5B,SAASW,aAAaxC,SAClB,GAAIE,UAAUF,QAAS6C,qBAAsB,CACzC,MAAMd,WAAa,GACnB,IAAIH,KACJ,KAAO3B,WAAWD,UACd,GAAI4B,KAAOkB,UAAU9C,SACjB+B,WAAWZ,KAAKS,UAEf,CAAA,GAAI1B,UAAUF,QAAS+C,mBACxB,MAEC,IAAK7C,UAAUF,QAASgD,gBACzB,MAAM3C,QAAQL,uBAAwBD,OAAOC,SAASY,eAG9D,OAAOmB,YAMf,SAASQ,eAAevC,QAASY,KAAMH,SACnC,GAAIwC,aAAalD,OAAOC,SAAUY,MAAO,CACrCZ,QAAQpB,MAER,IAAIsE,MAAQ,EACZ,KAAOD,aAAalD,OAAOC,SAAUY,OACjCZ,QAAQpB,MACRsE,QAEJ,MAAMtB,KAAO,CACTE,KAAM,CAACqB,gBAAgBvC,QAa3B,OAXIsC,MAAQ,IACRtB,KAAKwB,UAAW,GAGhB3C,QAAQ4C,KAAOhB,KAAKrC,UACpB4B,KAAKI,MAAQM,QAAQtC,SACrB4B,KAAK0B,YAAa,GAGlB1B,KAAKI,MAAQuB,YAAYvD,SAAWT,MAAMS,cAAW,EAElD4B,MAMf,SAASkB,UAAU9C,SACf,GAAIwD,OAAOxD,SAEP,MAAO,CACHgC,MAAOzC,MAAMS,UAGrB,GAAIuD,YAAYvD,SAAS,GAAO,CAC5B,MAAM8B,KAAOvC,MAAMS,SACnB,IAAIgC,MAMJ,OALI9B,UAAUF,QAASyD,YACfD,OAAOxD,UAAYuD,YAAYvD,SAAS,MACxCgC,MAAQzC,MAAMS,UAGf,CAAE8B,KAAAA,KAAME,MAAAA,QAGvB,SAASL,WAAW3B,SAChB,OAAOoC,WAAWrC,OAAOC,UACnBA,QAAQH,OAAOG,QAAQpB,YACvB,EAKV,SAAS4E,OAAOxD,SACZ,MAAMzB,MAAQyB,QAAQpB,IAChB8E,MAAQ3D,OAAOC,SACrB,GAAI2D,UAAUD,OAAQ,CAElB,IADA1D,QAAQpB,MACDqB,WAAWD,UACd,GAAI2D,UAAUzE,KAAKc,SAAU0D,MAAME,QAE/B,OADA5D,QAAQzB,MAAQA,OACT,EAGf,MAAM8B,QAAQL,QAAS,iBAAkB0D,OAE7C,OAAO,EAKX,SAASH,YAAYvD,QAAS6D,eAC1B,MAAMtF,MAAQyB,QAAQpB,IAChBkF,SAAW,CACbhB,UAAW,EACXQ,WAAY,EACZpC,MAAO,GAEX,KAAOjB,WAAWD,UAAU,CACxB,MAAMI,MAAQL,OAAOC,SACrB,GAAI8D,SAASR,WAEL7B,YAAYrB,MAAO,gBACnB0D,SAAS1D,MAAM2D,UAAY3D,MAAM4D,KAAO,GAAK,OAGhD,CAAA,GAAIL,UAAUvD,QAAU6C,aAAa7C,QAAU4C,eAAe5C,QAAUgC,WAAWhC,OACpF,MAEC,GAAIqB,YAAYrB,OAAQ,CACzB,IAAKyD,cACD,MAEJ,GAAIzD,MAAM4D,KACNF,SAAS1D,MAAM2D,eAEd,CAAA,IAAKD,SAAS1D,MAAM2D,SAGrB,MAGAD,SAAS1D,MAAM2D,aAGvB/D,QAAQpB,MAEZ,OAAIL,QAAUyB,QAAQpB,MAClBoB,QAAQzB,MAAQA,OACT,GAOf,SAAS2D,YAAYlC,QAASS,SAC1B,MAAMlC,MAAQyB,QAAQpB,IACtB,GAAI6B,QAAQ4C,KAAOnD,UAAUF,QAASiE,sBAGlC,KAAOhE,WAAWD,UAAU,CACxB,MAAMpB,IAAEA,KAAQoB,QAChB,IAAKE,UAAUF,QAASkE,uBAAyBhE,UAAUF,QAASiE,sBAAuB,CACvFjE,QAAQpB,IAAMA,IACd,OAIZ,KAAOqB,WAAWD,UAAYE,UAAUF,QAASmE,mBAGjD,OAAInE,QAAQpB,MAAQL,QAChByB,QAAQzB,MAAQA,OACT,GAOf,SAAS8D,KAAKrC,SACV,MAAMzB,MAAQyB,QAAQpB,IACtB,GAAIsB,UAAUF,QAASoE,aAAc,CACjC,IAAIN,SAAW,EACf,KAAO7D,WAAWD,UAAU,CACxB,MAAMI,MAAQlB,KAAKc,SACnB,GAAIyB,YAAYrB,MAAO,cACnB,GAAIA,MAAM4D,KACNF,eAEC,CAAA,IAAKA,SACN,MAGAA,YAKZ,OADA9D,QAAQzB,MAAQA,OACT,EAEX,OAAO,EAEX,SAAS+D,QAAQtC,SACb,IAAIpC,KAAOoC,QAAQzB,MACfV,GAAKmC,QAAQpB,IAOjB,OANI6C,YAAYzB,QAAQH,OAAOjC,MAAO,cAAc,IAChDA,OAEA6D,YAAYzB,QAAQH,OAAOhC,GAAK,GAAI,cAAc,IAClDA,KAEG0B,MAAMS,QAASpC,KAAMC,IAEhC,SAAS4D,YAAYrB,MAAO2D,QAASM,QACjC,OAAOC,QAAQlE,OAAwB,YAAfA,MAAMQ,QACrBmD,SAAW3D,MAAM2D,UAAYA,WACpB,MAAVM,QAAkBjE,MAAM4D,OAASK,SAE7C,SAASpB,aAAa7C,MAAOQ,MACzB,OAAO0D,QAAQlE,OAAwB,aAAfA,MAAMQ,QAAyBA,MAAQR,MAAMmE,WAAa3D,OAEtF,SAAS+C,UAAUvD,MAAOoE,UACtB,OAAOF,QAAQlE,OAAwB,UAAfA,MAAMQ,OAAiC,MAAZ4D,UAAoBpE,MAAMwD,SAAWY,WAE5F,SAASxB,eAAe5C,OACpB,OAAOkE,QAAQlE,OAAwB,eAAfA,MAAMQ,MAElC,SAAS6C,SAASrD,OACd,OAAO6C,aAAa7C,MAAO,SAE/B,SAASgC,WAAWhC,OAChB,OAAOkE,QAAQlE,OAAwB,aAAfA,MAAMQ,MAElC,SAAS6D,YAAYrE,OACjB,MAAsB,YAAfA,MAAMQ,KAEjB,SAASqD,qBAAqB7D,OAC1B,GAAIqE,YAAYrE,OAAQ,CACpB,MAAMrB,GAAKqB,MAAM4B,MAAMnD,WAAW,GAClC,OAAOE,IAAM,IAAMA,IAAM,GAE7B,OAAO,EAEX,SAASoF,gBAAgB/D,OACrB,MAAsB,YAAfA,MAAMQ,MAAqC,mBAAfR,MAAMQ,MAA4C,wBAAfR,MAAMQ,KAEhF,SAASsD,oBAAoB9D,OACzB,OAAO6C,aAAa7C,MAAO,SAE/B,SAASyC,oBAAoBzC,OACzB,OAAOqB,YAAYrB,MAAO,aAAa,GAE3C,SAAS2C,kBAAkB3C,OACvB,OAAOqB,YAAYrB,MAAO,aAAa,GAE3C,SAASgE,YAAYhE,OACjB,OAAOqB,YAAYrB,MAAO,cAAc,GAE5C,SAASoB,aAAapB,OAClB,OAAOqB,YAAYrB,MAAO,SAAS,GAEvC,SAAS+C,gBAAgBnB,OACrB,MAAO,CAAEpB,KAAM,UAAWoB,MAAAA,OAE9B,SAASG,QAAQN,MACb,OAAQA,KAAKC,OAASD,KAAKG,QAAUH,KAAKE,WAE9C,SAASX,gBAAgBhB,OACrB,OAAO6C,aAAa7C,MAAO,SAE/B,SAASiB,oBAAoBjB,OACzB,OAAO6C,aAAa7C,MAAO,WAE/B,SAASkB,gBAAgBlB,OACrB,OAAO6C,aAAa7C,MAAO,SAE/B,SAASqC,gBAAgBrC,OACrB,OAAO6C,aAAa7C,MAAO,SAG/B,IAAIsE,QAoDJ,SAASC,QAAQ3E,SACb,QAAIA,QAAQZ,IAAIsF,QAAQE,UACpB5E,QAAQzB,MAAQyB,QAAQpB,IACnBoB,QAAQb,OACTa,QAAQpB,OAEL,GAKf,SAASiG,WAAWC,QAChB,MAAM9E,QAAU,IAAI5B,QAAQ0G,QACtBpE,OAAS,GACTI,IAAM,CACRI,MAAO,EACP4B,UAAW,EACXQ,WAAY,EACZI,MAAO,GAEX,IAAI3E,GAAK,EACLqB,MACJ,MAAQJ,QAAQb,OAAO,CAGnB,GAFAJ,GAAKiB,QAAQhB,SACboB,MAAQ2E,WAAW/E,QAASc,MAWxB,MAAMd,QAAQgF,MAAM,wBATpBtE,OAAOS,KAAKf,OACO,UAAfA,MAAMQ,KACNE,IAAI4C,MAAQ3E,KAAO+B,IAAI4C,MAAQ,EAAI3E,GAEf,YAAfqB,MAAMQ,OACXE,IAAIV,MAAM2D,UAAY3D,MAAM4D,KAAO,GAAK,GAOpD,OAAOtD,OAKX,SAASqE,WAAW/E,QAASc,KACzB,OAAOmE,QAAQjF,QAASc,MACjBoE,oBAAoBlF,UACpBmF,eAAenF,UACfoF,SAASpF,UACTqF,aAAarF,UACbsF,UAAUtF,QAASc,MACnByE,WAAWvF,UACX0D,MAAM1D,UACNwF,UAAUxF,SAKrB,SAASsF,UAAUtF,QAASc,KACxB,MAAMvC,MAAQyB,QAAQpB,IAChB6G,gBAAkB3E,IAAIwC,WAC5B,IAAItB,MAAQ,GACZ,MAAQhC,QAAQb,OAAO,CAEnB,GAAIwF,QAAQ3E,SAAU,CAClBgC,OAAShC,QAAQ0F,UACjB,SAEJ,MAAM3G,GAAKiB,QAAQhB,OACnB,GAAID,KAAO2F,QAAQiB,QAAU7E,IAAI4C,QAAU5C,IAAIwC,aAAexC,IAAIgC,UAAW,CAEzE,MAAM8C,KAAO5F,QAAQrB,OAAOE,WAAWmB,QAAQpB,IAAM,GAC/CM,KAAOc,QAAQrB,OAAOE,WAAWmB,QAAQpB,IAAM,GACrD,GAAInB,WAAWmI,OAASnI,WAAWyB,MAAO,CACtC8C,OAAShC,QAAQrB,OAAOqB,QAAQpB,OAChC,UAGR,GAAIG,KAAO+B,IAAI4C,OAAS3E,KAAO2F,QAAQmB,QAAUC,kBAAkB/G,GAAI+B,KAInE,MAEJ,GAAI2E,iBAEA,GAAI1G,KAAO2F,QAAQqB,iBACfjF,IAAIwC,kBAEH,GAAIvE,KAAO2F,QAAQsB,kBAAmB,CACvC,KAAIlF,IAAIwC,WAAamC,iBAIjB,MAHA3E,IAAIwC,mBAOX,IAAKxC,IAAI4C,MAAO,CAEjB,IAAK5C,IAAIgC,YAAcmD,cAAclH,IACjC,MAEJ,GAAImH,eAAenH,GAAI+B,MAAQqF,kBAAkBpH,GAAI+B,MAAQ3C,UAAUY,KAAOqH,YAAYrH,IAEtF,MAGRiD,OAAShC,QAAQrB,OAAOqB,QAAQpB,OAEpC,GAAIL,QAAUyB,QAAQpB,IAElB,OADAoB,QAAQzB,MAAQA,MACT,CACHqC,KAAM,UACNoB,MAAAA,MACAzD,MAAAA,MACAC,IAAKwB,QAAQpB,KAOzB,SAASyG,aAAarF,SAClB,MAAMzB,MAAQyB,QAAQpB,IACtB,GAAIoB,QAAQqG,SAASnI,SACjB,MAAO,CACH0C,KAAM,aACNrC,MAAAA,MACAC,IAAKwB,QAAQpB,IACboD,MAAOhC,QAAQV,UAAUf,MAAOyB,QAAQpB,MAOpD,SAAS8E,MAAM1D,SACX,MAAMjB,GAAKiB,QAAQhB,OACnB,GAAIb,UAAUY,IACV,MAAO,CACH6B,KAAM,QACNgD,OAAQ7E,KAAO2F,QAAQ4B,YACvB/H,MAAOyB,QAAQpB,MACfJ,IAAKwB,QAAQpB,KAOzB,SAAS4G,UAAUxF,SACf,MAAMjB,GAAKiB,QAAQhB,OACb+E,QAAUqC,YAAYrH,IAC5B,GAAIgF,QACA,MAAO,CACHnD,KAAM,UACNoD,KAAMuC,gBAAgBxH,IACtBgF,QAAAA,QACAxF,MAAOyB,QAAQpB,MACfJ,IAAKwB,QAAQpB,KAOzB,SAAS2G,WAAWvF,SAChB,MAAMwG,GAAKC,eAAezG,QAAQhB,QAClC,GAAIwH,GACA,MAAO,CACH5F,KAAM,WACN2D,SAAUiC,GACVjI,MAAOyB,QAAQpB,MACfJ,IAAKwB,QAAQpB,KAQzB,SAASwG,SAASpF,SACd,MAAMzB,MAAQyB,QAAQpB,IACtB,GAAIoB,QAAQZ,IAAIsF,QAAQgC,UAAW,CAC/B1G,QAAQzB,MAAQyB,QAAQpB,IACxB,IAAIsE,MAAQ,EACRyD,UAAW,EAOf,OANI3G,QAAQqG,SAAS5I,YACjByF,MAAQ0D,OAAO5G,QAAQ0F,WAGvBiB,UAAW,EAER,CACH/F,KAAM,WACNsC,MAAAA,MACAlB,MAAO,EACP2E,SAAAA,SACApI,MAAAA,MACAC,IAAKwB,QAAQpB,MAOzB,SAASsG,oBAAoBlF,SACzB,MAAMzB,MAAQyB,QAAQpB,IACtB,GAAIoB,QAAQZ,IAAIsF,QAAQmB,SAAW7F,QAAQZ,IAAIsF,QAAQmC,MACnD,MAAO,CACHjG,KAAM,sBACNoB,WAAO,EACPzD,MAAAA,MACAC,IAAKwB,QAAQpB,KAGrBoB,QAAQpB,IAAML,MAKlB,SAAS4G,eAAenF,SACpB,MAAMzB,MAAQyB,QAAQpB,IACtB,GAAIoB,QAAQqG,SAAS3B,QAAQmB,QAAS,CAClC,MAAM/F,KAAOE,QAAQpB,IAAML,MAC3B,IAAIuI,SAAU,EACVC,KAAO,EACPC,OAAS,EACb,GAAIhH,QAAQZ,IAAIsF,QAAQuC,IAAK,CAEzB,KAAOjH,QAAQZ,IAAIsF,QAAQwC,QACvBF,SAEJF,QAAU9G,QAAQZ,IAAIsF,QAAQyC,MAC9BnH,QAAQzB,MAAQyB,QAAQpB,IACpBoB,QAAQqG,SAAS5I,cACjBsJ,KAAOH,OAAO5G,QAAQ0F,YAI9B,OADA1F,QAAQzB,MAAQA,MACT,CACHqC,KAAM,iBACNd,KAAAA,KACAgH,QAAAA,QACAC,KAAAA,KACAC,OAAAA,OACAzI,MAAAA,MACAC,IAAKwB,QAAQpB,MAIzB,SAASqG,QAAQjF,QAASc,KACtB,MAAMvC,MAAQyB,QAAQpB,IAEtB,IAAKkC,IAAIwC,YAAcxC,IAAIgC,YAAc9C,QAAQZ,IAAIsF,QAAQmB,SAAW7F,QAAQZ,IAAIsF,QAAQqB,kBAAmB,CAE3G,IAAIqB,MADJpH,QAAQzB,MAAQyB,QAAQpB,IAExB,IAAIkD,KAAO,GAUX,GATI9B,QAAQqG,SAAS5I,aAEjB2J,MAAQR,OAAO5G,QAAQ0F,WACvB5D,KAAO9B,QAAQZ,IAAIsF,QAAQ2C,OAASC,qBAAqBtH,SAAW,IAE/DrC,UAAUqC,QAAQhB,UAEvB8C,KAAOwF,qBAAqBtH,UAE5BA,QAAQZ,IAAIsF,QAAQsB,mBACpB,MAAO,CACHpF,KAAM,QACNwG,MAAAA,MAAOtF,KAAAA,KACPvD,MAAAA,MACAC,IAAKwB,QAAQpB,KAGrB,MAAMoB,QAAQgF,MAAM,eAIxBhF,QAAQpB,IAAML,MAKlB,SAAS+I,qBAAqBC,QAC1B,MAAMvG,MAAQ,GAEd,IADAuG,OAAOhJ,MAAQgJ,OAAO3I,KACd2I,OAAOpI,OACX,GAAIoI,OAAOnI,IAAIsF,QAAQqB,kBACnB/E,MAAMG,KAAKoG,OAAO3I,UAEjB,GAAI2I,OAAOnI,IAAIsF,QAAQsB,mBAAoB,CAC5C,IAAKhF,MAAMvC,OAAQ,CACf8I,OAAO3I,MACP,MAEJoC,MAAMO,WAGNgG,OAAO3I,MAGf,GAAIoC,MAAMvC,OAEN,MADA8I,OAAO3I,IAAMoC,MAAMO,MACbgG,OAAOvC,MAAM,eAEvB,OAAOuC,OAAO7B,UAKlB,SAASI,kBAAkB/G,GAAI+B,KAC3B,MAAM0F,GAAKC,eAAe1H,IAC1B,SAAKyH,IAAM1F,IAAI4C,OAAS5C,IAAIwC,eAKpBxC,IAAIgC,WAAoB,UAAP0D,IAM7B,SAASN,eAAenH,GAAI+B,KACxB,OAAO5C,QAAQa,MAAQ+B,IAAIwC,WAK/B,SAAS6C,kBAAkBpH,GAAI+B,KAC3B,OAAO/B,KAAO2F,QAAQgC,WAAa5F,IAAIgC,YAAchC,IAAIwC,WAK7D,SAAS8C,YAAYrH,IACjB,OAAIA,KAAO2F,QAAQ8C,kBAAoBzI,KAAO2F,QAAQ+C,kBAC3C,QAEP1I,KAAO2F,QAAQgD,mBAAqB3I,KAAO2F,QAAQiD,mBAC5C,YAEP5I,KAAO2F,QAAQqB,kBAAoBhH,KAAO2F,QAAQsB,kBAC3C,kBADX,EAOJ,SAASS,eAAe1H,IACpB,OAAQA,KAAO2F,QAAQkD,MAAS,QACxB7I,KAAO2F,QAAQmD,SAAW,YAC1B9I,KAAO2F,QAAQwC,OAAS,SACxBnI,KAAO2F,QAAQoD,KAAO,SACtB/I,KAAO2F,QAAQmC,MAAQ,MACvB9H,KAAO2F,QAAQiB,OAAS,SACxB5G,KAAO2F,QAAQqD,QAAU,cAC1B,EAKX,SAASxB,gBAAgBxH,IACrB,OAAOA,KAAO2F,QAAQqB,kBACfhH,KAAO2F,QAAQgD,mBACf3I,KAAO2F,QAAQ8C,iBAK1B,SAASvB,cAAclH,IACnB,OAAOjB,mBAAmBiB,KACnBf,SAASe,KACTA,KAAO2F,QAAQyC,MACfpI,KAAO2F,QAAQ2C,OACftI,KAAO2F,QAAQsD,MA3a1B,SAAWC,OAEPA,MAAMA,MAAwB,iBAAI,KAAO,mBAEzCA,MAAMA,MAAyB,kBAAI,KAAO,oBAE1CA,MAAMA,MAAc,OAAI,IAAM,SAE9BA,MAAMA,MAAc,OAAI,IAAM,SAE9BA,MAAMA,MAAyB,kBAAI,IAAM,oBAEzCA,MAAMA,MAA0B,mBAAI,IAAM,qBAE1CA,MAAMA,MAAgB,SAAI,IAAM,WAEhCA,MAAMA,MAAY,KAAI,IAAM,OAE5BA,MAAMA,MAAc,OAAI,IAAM,SAE9BA,MAAMA,MAAY,KAAI,IAAM,OAE5BA,MAAMA,MAAW,IAAI,IAAM,MAE3BA,MAAMA,MAAa,MAAI,IAAM,QAE7BA,MAAMA,MAAa,MAAI,IAAM,QAE7BA,MAAMA,MAAY,KAAI,IAAM,OAE5BA,MAAMA,MAAU,GAAI,IAAM,KAE1BA,MAAMA,MAAkB,WAAI,IAAM,aAElCA,MAAMA,MAAwB,iBAAI,IAAM,mBAExCA,MAAMA,MAAyB,kBAAI,IAAM,oBAEzCA,MAAMA,MAAe,QAAI,IAAM,UAE/BA,MAAMA,MAAa,MAAI,IAAM,QAE7BA,MAAMA,MAAa,MAAI,IAAM,QAE7BA,MAAMA,MAAmB,YAAI,IAAM,cAEnCA,MAAMA,MAAmB,YAAI,IAAM,cA9CvC,CA+CGvD,UAAYA,QAAU,KA+XzB,MAAMwD,UAAY,CACdC,MAAO,IACPC,MAAO,IACPC,MAAO,IACPC,GAAI,IACJC,MAAO,IACPC,MAAO,IACPC,QAAS,KAEPC,aAAe,CACjBC,QAAQvI,OACGA,MAAM4B,MAEjB4G,MAAMxI,OACKA,MAAMwD,OAAS,IAAO,IAEjCiF,QAAQzI,OACkB,cAAlBA,MAAM2D,QACC3D,MAAM4D,KAAO,IAAM,IAEH,eAAlB5D,MAAM2D,QACJ3D,MAAM4D,KAAO,IAAM,IAGnB5D,MAAM4D,KAAO,IAAM,IAGlC8E,SAAS1I,OACE8H,UAAU9H,MAAMmE,UAE3BwE,MAAK,CAAC3I,MAAO4I,QACU,MAAf5I,MAAMgH,MAEChH,MAAM0B,WACD1B,MAAMgH,SAAShH,MAAM0B,cACrB1B,MAAMgH,QAEbhH,MAAM0B,KAEJkH,MAAMC,YAAY7I,MAAM0B,MAE5B,GAEXzD,oBAAoB+B,MAAO4I,OAEvB,IAAI5D,SACJ,IAAK,IAAI8D,EAAIF,MAAMG,UAAU1K,OAAS,EAAGyK,GAAK,EAAGA,IAC7C,GAAIF,MAAMG,UAAUD,GAAGvC,SAAU,CAC7BvB,SAAW4D,MAAMG,UAAUD,GAC3B,MAIR,OADAF,MAAMI,UAAW,EACVJ,MAAM1G,QAAQ8C,UAAYA,SAASpD,QAE9C3D,eAAe+B,MAAO4I,OAClB,IAAIhH,MAAQ,EACZ,MAAMqH,OAASL,MAAMG,UAAU1K,OAAS,EAElC2G,SAAW4D,MAAMG,UAAUE,QACjC,GAAIjE,WACApD,MAAQ5B,MAAM0G,QACR1G,MAAM2G,KAAO3B,SAASlC,MAAQkC,SAASpD,MAAQ,EAC/C5B,MAAM2G,KAAO3B,SAASpD,MACxB5B,MAAM4G,QAAQ,CACd,MAAMsC,SAAWC,KAAKC,IAAI,EAAGH,OAASjJ,MAAM4G,QAC5C,GAAIsC,WAAaD,OAAQ,CACrB,MAAMI,eAAiBT,MAAMG,UAAUG,UACvCtH,OAASoD,SAASlC,MAAQuG,eAAezH,OAIrD,IAAItB,OAASgJ,OAAO1H,OACpB,KAAOtB,OAAOjC,OAAS2B,MAAMN,MACzBY,OAAS,IAAMA,OAEnB,OAAOA,QAEXiJ,WAAWvJ,OACAA,MAAM4B,OAMrB,SAAS4H,YAAYxJ,MAAO4I,OACxB,IAAKN,aAAatI,MAAMQ,MACpB,MAAM,IAAIlB,uBAAuBU,MAAMQ,QAE3C,OAAO8H,aAAatI,MAAMQ,MAAMR,MAAO4I,OAG3C,MAAMa,SAAW,iDACXC,WAAa,2CAKnB,SAASC,QAAQvJ,KAAMC,QAAU,IAC7B,IAAIuJ,cAAe,EACfC,UACAxJ,QAAQ4B,OAEJ4H,UADAtH,MAAMC,QAAQnC,QAAQ4B,MACV5B,QAAQ4B,KAAK6H,OAAOC,GAAKA,EAAEC,QAG3B3J,QAAQ4B,MAG5B,MAAM3B,OAAS,CACXE,KAAM,eACNyJ,SAAUC,aAAa9J,KAAM,CACzB4I,UAAU,EACVD,UAAW,GACX9G,KAAM5B,QAAQ4B,KACd4H,UAAAA,UACAM,YAAa9J,QAAQ+J,WAAa5D,OAAO6D,kBACzCpM,QAAQO,KACJ,IAAI8L,GAEJ,IAAI1I,MACJ,GAFAgI,cAAe,EAEXrH,MAAMC,QAAQnC,QAAQ4B,MAAO,CAC7B,QAAYsI,IAAR/L,KAAqBA,KAAO,GAAKA,IAAMqL,UAAUxL,OACjD,OAAOwL,UAAUrL,KAErBoD,WAAgB2I,IAAR/L,IAAoB6B,QAAQ4B,KAAKzD,KAAO6B,QAAQ4B,KAAKuI,KAAK,WAGlE5I,MAAgC,QAAvB0I,GAAKjK,QAAQ4B,YAAyB,IAAPqI,GAAgBA,GAAK,GAEjE,OAAO1I,OAEX3D,YAAYyD,MACR,MAAM+I,SAAWpK,QAAQqK,WAAarK,QAAQqK,UAAUhJ,MACxD,OAAmB,MAAZ+I,SAAmBA,SAAW/I,SAIjD,GAAoB,MAAhBrB,QAAQ4B,OAAiB2H,aAAc,CAGvC,MAAMe,QAAUC,YAAYC,OAAOvK,OAAO2J,WAC1C,GAAIU,QAAS,CACT,MAAM1I,KAAOM,MAAMC,QAAQnC,QAAQ4B,MAAQ5B,QAAQ4B,KAAKuI,KAAK,MAAQnK,QAAQ4B,KAC7E6I,WAAWH,QAAS1I,MACC,MAAjB0I,QAAQjJ,MAAgBrB,QAAQ0K,MAEhCC,WAAWL,QAAS1I,OAIhC,OAAO3B,OAKX,SAAS2K,iBAAiBtK,KAAMiI,OAC5B,IAAItI,OAAS,GACb,GAAIK,KAAKW,OAAQ,CAGb,MAAM4J,SAAWvK,KAAKW,OAChBA,OAAS6J,OAAOC,OAAO,GAAIF,UAIjC,IAAIG,MAHJ/J,OAAOwB,MAAQxB,OAAOiF,UAAYhE,MAAMC,QAAQoG,MAAM3G,MAChD2G,MAAMiB,UAAUxL,OACfiD,OAAOwB,OAAS,EAEvB8F,MAAMG,UAAUhI,KAAKO,QACrB,IAAK,IAAIwH,EAAI,EAAGA,EAAIxH,OAAOwB,MAAOgG,IAAK,CAMnC,GALAxH,OAAOM,MAAQkH,EACfnI,KAAKW,OAASA,OACd+J,MAAQC,QAAQ3K,MACVuJ,aAAavJ,KAAMiI,OACnB2C,eAAe5K,KAAMiI,OACvBtH,OAAOiF,WAAaqC,MAAMI,SAAU,CAGpC,MAAMwC,OAASX,OAAOQ,OAChBV,QAAUa,QAAUZ,YAAYY,QAClCb,SACAG,WAAWH,QAAS/B,MAAM1G,QAAQZ,OAAOM,QAMjD,GAHAtB,OAASA,OAAOgC,OAAO+I,SAGjBzC,MAAMuB,aAAe,EACvB,MAGRvB,MAAMG,UAAU5H,MAChBR,KAAKW,OAAS4J,SACV5J,OAAOiF,WACPqC,MAAMI,UAAW,QAIrB1I,OAASA,OAAOgC,OAAOgJ,QAAQ3K,MAAQuJ,aAAavJ,KAAMiI,OAAS2C,eAAe5K,KAAMiI,QAE5F,OAAOtI,OAEX,SAASiL,eAAe5K,KAAMiI,OAC1B,IAAIqB,SAAW,GACf,MAAMxI,KAAO,CACTjB,KAAM,mBACNkB,KAAMf,KAAKe,MAAQ+J,cAAc9K,KAAKe,KAAMkH,OAC5ChH,MAAOjB,KAAKiB,OAAS8J,iBAAiB/K,KAAKiB,MAAOgH,OAClDjH,gBAAY,EACZsI,SAAAA,SACA3I,OAAQX,KAAKW,QAAU6J,OAAOC,OAAO,GAAIzK,KAAKW,QAC9CqK,YAAahL,KAAKkB,WAEtB,IAAIvB,OAAS,CAACmB,MACd,IAAK,MAAMsG,SAASpH,KAAKF,SACrBwJ,SAAWA,SAAS3H,OAAO2I,iBAAiBlD,MAAOa,QAEvD,GAAIjI,KAAKgB,WAAY,CACjBF,KAAKE,WAAa,GAClB,IAAK,MAAMH,QAAQb,KAAKgB,WACpBF,KAAKE,WAAWZ,KAAK6K,iBAAiBpK,KAAMoH,QAapD,OARKnH,KAAKC,MAASD,KAAKE,aAAcF,KAAKG,OAAUH,KAAKG,MAAMiK,KAAKC,WAMjErK,KAAKwI,SAAWA,SAHhB3J,OAASA,OAAOgC,OAAO2H,UAKpB3J,OAEX,SAAS4J,aAAavJ,KAAMiI,OACxB,IAAItI,OAAS,GACb,IAAK,MAAMyH,SAASpH,KAAKF,SACrBH,OAASA,OAAOgC,OAAO2I,iBAAiBlD,MAAOa,QAKnD,OAHIjI,KAAKW,SACLhB,OAASyL,eAAezL,OAAQK,KAAKW,SAElChB,OAEX,SAASsL,iBAAiBjL,KAAMiI,OAC5B,IAAIoD,SAAU,EACVC,WAAY,EACZC,UAAYvL,KAAKuC,WAAa,aAAe,MAC7CtB,MACJ,MAAMF,KAAOf,KAAKe,MAAQ+J,cAAc9K,KAAKe,KAAMkH,OAOnD,GANIlH,MAAoB,MAAZA,KAAK,KACbsK,SAAU,GAEVtK,MAAkC,MAA1BA,KAAKA,KAAKrD,OAAS,KAC3B4N,WAAY,GAEZtL,KAAKiB,MAAO,CACZ,MAAMnC,OAASkB,KAAKiB,MAAMzC,QAC1B,GAAIoE,UAAU9D,OAAO,IAAK,CAGtB,MAAM6D,MAAQ7D,OAAO0M,QACjB1M,OAAOpB,QAAUwM,OAAOpL,QAAQe,OAAS8C,MAAM9C,MAC/Cf,OAAO0B,MAEX+K,UAAY5I,MAAME,OAAS,cAAgB,mBAEtCnC,YAAY5B,OAAO,GAAI,cAAc,KAE1CyM,UAAY,aACZzM,OAAO0M,QACH9K,YAAYwJ,OAAOpL,QAAS,cAAc,IAC1CA,OAAO0B,OAGfS,MAAQ8J,iBAAiBjM,OAAQmJ,OAErC,MAAO,CACHlH,KAAMuK,WAAaD,QACbtK,KAAKvC,MAAM6M,QAAU,EAAI,EAAGC,WAAa,OAAI,GAC7CvK,KACNE,MAAAA,MACAwK,QAASH,UACTD,QAAAA,QACAE,UAAAA,UACAlJ,SAAUrC,KAAKqC,UAMvB,SAASyI,cAAchM,OAAQmJ,OAC3B,IAAI1K,IAAM,GACV,IAAK,IAAI4K,EAAI,EAAGA,EAAIrJ,OAAOpB,OAAQyK,IAC/B5K,KAAOsL,YAAY/J,OAAOqJ,GAAIF,OAElC,OAAO1K,IAKX,SAASwN,iBAAiBjM,OAAQmJ,OAC9B,MAAMtI,OAAS,GACf,IAAIpC,IAAM,GACV,IAAK,IAAI4K,EAAI,EAAG9I,MAAO8I,EAAIrJ,OAAOpB,OAAQyK,IAElCgD,UADJ9L,MAAQP,OAAOqJ,KAKP5K,MACAoC,OAAOS,KAAK7C,KACZA,IAAM,IAEVoC,OAAOS,KAAKf,QAGZ9B,KAAOsL,YAAYxJ,MAAO4I,OAMlC,OAHI1K,KACAoC,OAAOS,KAAK7C,KAEToC,OAEX,SAASgL,QAAQ3K,MACb,MAAqB,eAAdA,KAAKH,KAEhB,SAASsL,UAAU9L,OACf,MAAwB,iBAAVA,OAAqC,UAAfA,MAAMQ,MAAmC,MAAfR,MAAMgH,MAExE,SAAS6D,OAAOwB,KACZ,OAAOA,IAAIA,IAAIhO,OAAS,GAE5B,SAASuM,YAAYjK,MACjB,OAAOA,KAAKsJ,SAAS5L,OAASuM,YAAYC,OAAOlK,KAAKsJ,WAAatJ,KAEvE,SAASmK,WAAWnK,KAAMsB,MACtB,GAAItB,KAAKiB,MAAO,CACZ,MAAM0K,UAAYzB,OAAOlK,KAAKiB,OACL,iBAAd0K,UACP3L,KAAKiB,MAAMjB,KAAKiB,MAAMvD,OAAS,IAAM4D,KAGrCtB,KAAKiB,MAAMb,KAAKkB,WAIpBtB,KAAKiB,MAAQ,CAACK,MAGtB,SAAS+I,WAAWrK,KAAMsB,MACtB,IAAIqI,GACJ,IAAIS,KAAO,GACPtB,SAAS1J,KAAKkC,MAET,OAAOlC,KADZgL,KAAO9I,OACoB8I,KAAKwB,WAAW,QACvCxB,eAAiBA,QAGhBrB,WAAW3J,KAAKkC,QACrB8I,eAAiB9I,QAErB,MAAMuK,cAA2C,QAA1BlC,GAAK3J,KAAKgB,kBAA+B,IAAP2I,QAAgB,EAASA,GAAGmC,KAAKjL,MAAsB,SAAdA,KAAKE,MAClG8K,cAMKA,cAAc5K,QACpB4K,cAAc5K,MAAQ,CAACmJ,QANlBpK,KAAKgB,aACNhB,KAAKgB,WAAa,IAEtBhB,KAAKgB,WAAWZ,KAAK,CAAEW,KAAM,OAAQE,MAAO,CAACmJ,MAAOmB,UAAW,iBAMvE,SAASH,eAAeV,MAAOrG,UAC3B,IAAK,MAAM0H,QAAQrB,MACVqB,KAAKpL,SACNoL,KAAKpL,OAAS6J,OAAOC,OAAO,GAAIpG,WAGxC,OAAOqG,MAMX,SAASsB,kBAAkBvM,KAAMC,SAC7B,IACI,MAAMZ,OAAyB,iBAATW,KAAoBqE,WAAWrE,MAAQA,KAC7D,OAAOuJ,QAAQxJ,aAAaV,OAAQY,SAAUA,SAElD,MAAOH,KAIH,MAHIA,eAAeb,cAAgC,iBAATe,OACtCF,IAAId,cAAgBgB,SAAS,IAAIkB,OAAOpB,IAAI1B,SAE1C0B,KAId,IAAI0M,aASAC,QA0CJ,SAASC,SAAS1M,KAAM2M,SACpB,IAAIrJ,SAAW,EACX1D,MACJ,MAAMJ,QAAU,IAAI5B,QAAQoC,MACtBX,OAAS,GACf,MAAQG,QAAQb,OAAO,CAEnB,KADAiB,MAAQgN,SAASpN,QAAsB,IAAb8D,WAAmBqJ,UAEzC,MAAMnN,QAAQgF,MAAM,wBAExB,GAAmB,YAAf5E,MAAMQ,QACDkD,UAAY1D,MAAM4D,MACnBqJ,YAAYrN,QAASH,SAEzBiE,UAAY1D,MAAM4D,KAAO,GAAK,GACf,GACX,MAAMhE,QAAQgF,MAAM,qBAAsB5E,MAAM7B,OAGxDsB,OAAOsB,KAAKf,OAGRkN,uBAAuBlN,SAAWA,MAAQmE,SAASvE,WACnDH,OAAOsB,KAAKf,OAGpB,OAAOP,OAKX,SAASuN,SAASpN,QAASuN,OACvB,OAAOC,QAAQxN,UACRyN,eAAezN,UACf0N,YAAY1N,UACZ2N,WAAW3N,UACX4N,YAAY5N,UACZ6N,QAAQ7N,UACRuE,SAASvE,UACT8N,WAAW9N,UACX+N,UAAU/N,QAASuN,OAE9B,SAASC,QAAQxN,SACb,MAAMzB,MAAQyB,QAAQpB,IACtB,GAAIoB,QAAQZ,IAAI6N,QAAQpH,SAAW7F,QAAQZ,IAAI6N,QAAQlH,kBAAmB,CAEtE,IAAIqB,MADJpH,QAAQzB,MAAQyB,QAAQpB,IAExB,IAAIkD,KAAO,GAUX,GATI9B,QAAQqG,SAAS5I,aAEjB2J,MAAQR,OAAO5G,QAAQ0F,WACvB5D,KAAO9B,QAAQZ,IAAI6N,QAAQ5F,OAAS2G,qBAAqBhO,SAAW,IAE/DrC,UAAUqC,QAAQhB,UAEvB8C,KAAOkM,qBAAqBhO,UAE5BA,QAAQZ,IAAI6N,QAAQjH,mBACpB,MAAO,CACHpF,KAAM,QACNwG,MAAAA,MAAOtF,KAAAA,KACPvD,MAAAA,MACAC,IAAKwB,QAAQpB,KAGrB,MAAMoB,QAAQgF,MAAM,eAIxBhF,QAAQpB,IAAML,MAKlB,SAASyP,qBAAqBzG,QAC1B,MAAMvG,MAAQ,GAEd,IADAuG,OAAOhJ,MAAQgJ,OAAO3I,KACd2I,OAAOpI,OACX,GAAIoI,OAAOnI,IAAI6N,QAAQlH,kBACnB/E,MAAMG,KAAKoG,OAAO3I,UAEjB,GAAI2I,OAAOnI,IAAI6N,QAAQjH,mBAAoB,CAC5C,IAAKhF,MAAMvC,OAAQ,CACf8I,OAAO3I,MACP,MAEJoC,MAAMO,WAGNgG,OAAO3I,MAGf,GAAIoC,MAAMvC,OAEN,MADA8I,OAAO3I,IAAMoC,MAAMO,MACbgG,OAAOvC,MAAM,eAEvB,OAAOuC,OAAO7B,UASlB,SAASqI,UAAU/N,QAASuN,OACxB,MAAMhP,MAAQyB,QAAQpB,IAetB,GAdIoB,QAAQZ,IAAI6O,eAIZjO,QAAQqG,SAAS9H,MAAQ2P,UAAYC,aAEhCnO,QAAQZ,IAAIrB,aACjBiC,QAAQqG,SAASkH,MAAQY,YAAcD,YAIvClO,QAAQZ,IAAI6N,QAAQnF,KACpB9H,QAAQqG,SAAS8H,cAEjB5P,QAAUyB,QAAQpB,IAElB,OADAoB,QAAQzB,MAAQA,MACT6P,cAAcpO,QAASA,QAAQzB,MAAQA,OAGtD,SAAS6P,cAAcpO,QAASzB,MAAQyB,QAAQzB,MAAOC,IAAMwB,QAAQpB,KACjE,MAAO,CACHgC,KAAM,UACNoB,MAAOhC,QAAQV,UAAUf,MAAOC,KAChCD,MAAAA,MACAC,IAAAA,KAOR,SAASkP,YAAY1N,SACjB,MAAMzB,MAAQyB,QAAQpB,IACtB,GAAIyP,cAAcrO,SAAU,CACxBA,QAAQzB,MAAQA,MAChB,MAAM+P,SAAWtO,QAAQ0F,UAIzB,OAFA1F,QAAQzB,MAAQyB,QAAQpB,IACxBoB,QAAQZ,IAAI6N,QAAQsB,UAAYvO,QAAQqG,SAAStI,aAC1C,CACH6C,KAAM,cACNoB,MAAO4E,OAAO0H,UACdA,SAAAA,SACAE,KAAMxO,QAAQ0F,UACdnH,MAAAA,MACAC,IAAKwB,QAAQpB,MAOzB,SAASgP,YAAY5N,SACjB,MAAMjB,GAAKiB,QAAQhB,OACbT,MAAQyB,QAAQpB,IACtB,IAAI6P,UAAW,EACf,GAAItQ,UAAUY,IAAK,CAEf,IADAiB,QAAQpB,OACAoB,QAAQb,OAAO,CAEnB,GAAIa,QAAQZ,IAAIL,IAAK,CACjB0P,UAAW,EACX,MAGAzO,QAAQpB,MAIhB,OADAoB,QAAQzB,MAAQA,MACT,CACHqC,KAAM,cACNoB,MAAOhC,QAAQV,UAAUf,MAAQ,EAAGyB,QAAQpB,KAAO6P,SAAW,EAAI,IAClE/K,MAAO3E,KAAOkO,QAAQ3G,YAAc,SAAW,SAC/C/H,MAAAA,MACAC,IAAKwB,QAAQpB,MAOzB,SAAS+O,WAAW3N,SAMhB,MAAMzB,MAAQyB,QAAQpB,IACtB,GAAIoB,QAAQZ,IAAI6N,QAAQpG,MAAO,CAC3B,MAAM6H,WAAa1O,QAAQpB,IAC3B,IAAI+P,MAAQ,GACRC,MAAQ,GAYZ,GAXI5O,QAAQqG,SAASwI,QACjBF,MAAQ3O,QAAQV,UAAUoP,WAAY1O,QAAQpB,KAC9CgQ,MAAQE,WAAW9O,UAEdA,QAAQZ,IAAI6N,QAAQ8B,cACzBJ,MAAQ,IACRC,MAAQE,WAAW9O,UAAY,KAG/B4O,MAAQE,WAAW9O,SAEnB2O,OAASC,OAAS5O,QAAQb,MAAO,CACjC,MAAM6P,EAAEA,EAACC,EAAEA,EAACC,EAAEA,EAACC,EAAEA,GAAMC,WAAWT,MAAOC,OACzC,MAAO,CACHhO,KAAM,aACNoO,EAAAA,EAAGC,EAAAA,EAAGC,EAAAA,EAAGC,EAAAA,EACTE,IAAKrP,QAAQV,UAAUf,MAAQ,EAAGyB,QAAQpB,KAC1CL,MAAAA,MACAC,IAAKwB,QAAQpB,KAKjB,OAAOwP,cAAcpO,QAASzB,OAGtCyB,QAAQpB,IAAML,MAKlB,SAASuQ,WAAW9O,SAChB,MAAMzB,MAAQyB,QAAQpB,IACtB,OAAIoB,QAAQZ,IAAI6N,QAAQnF,MACpB9H,QAAQzB,MAAQA,MACZyB,QAAQqG,SAAS5I,YACVuC,QAAQ0F,UAEZ,KAEJ,GAKX,SAASoI,WAAW9N,SAChB,MAAMzB,MAAQyB,QAAQpB,IACtB,GAAIoB,QAAQqG,SAASnI,SACjB,MAAO,CACH0C,KAAM,aACNrC,MAAAA,MACAC,IAAKwB,QAAQpB,KAOzB,SAAS6O,eAAezN,SACpB,MAAMzB,MAAQyB,QAAQpB,IACtB,GAAIoB,QAAQZ,IAAI6N,QAAQ9F,OAASnH,QAAQZ,IAAI6N,QAAQ9F,MAGjD,OAFAnH,QAAQzB,MAAQA,MAChByB,QAAQqG,SAAS6H,WACV,CACHtN,KAAM,iBACNoB,MAAOhC,QAAQ0F,UACfnH,MAAAA,MACAC,IAAKwB,QAAQpB,KAGrBoB,QAAQpB,IAAML,MAKlB,SAASsP,QAAQ7N,SACb,MAAMjB,GAAKiB,QAAQhB,OACnB,GAAIsQ,YAAYvQ,IACZ,MAAO,CACH6B,KAAM,UACNoD,KAAMjF,KAAOkO,QAAQzF,iBACrBjJ,MAAOyB,QAAQpB,MACfJ,IAAKwB,QAAQpB,KAOzB,SAAS2F,SAASvE,SACd,MAAMwG,GAAK+I,aAAavP,QAAQhB,QAChC,GAAIwH,GACA,MAAO,CACH5F,KAAM,WACN2D,SAAUiC,GACVjI,MAAOyB,QAAQpB,MACfJ,IAAKwB,QAAQpB,KAQzB,SAASyP,cAAc9G,QACnB,MAAMhJ,MAAQgJ,OAAO3I,IACrB2I,OAAOnI,IAAI6N,QAAQ9F,MACnB,MAAMqI,cAAgBjI,OAAO3I,IACvB6Q,WAAalI,OAAOlB,SAAS5I,YAC7BiS,QAAUnI,OAAO3I,IACvB,GAAI2I,OAAOnI,IAAI6N,QAAQnF,KAAM,CAGzB,MAAM6H,SAAWpI,OAAOlB,SAAS5I,YAC5BgS,YAAeE,WAEhBpI,OAAO3I,IAAM8Q,SAOrB,OAHInI,OAAO3I,MAAQ4Q,gBACfjI,OAAO3I,IAAML,OAEVgJ,OAAO3I,MAAQL,MAE1B,SAAS0P,cAAcvQ,MACnB,OAAOA,OAASuP,QAAQhG,IAAMvJ,OAASuP,QAAQpH,OAKnD,SAAS0J,aAAaxQ,IAClB,OAAQA,KAAOkO,QAAQpF,SAAWmF,aAAanF,SACvC9I,KAAOkO,QAAQjF,MAAQgF,aAAa4C,WACpC7Q,KAAOkO,QAAQ4C,OAAS7C,aAAa8C,mBACrC/Q,KAAOkO,QAAQ5F,OAAS2F,aAAa+C,mBACrChR,KAAOkO,QAAQ9F,MAAQ6F,aAAagD,qBACrC,EAKX,SAASnB,MAAMnR,MACX,OAAOD,WAAWC,OAASC,UAAUD,KAAM,GAAI,IAEnD,SAASwQ,UAAUxQ,MACf,OAAOI,mBAAmBJ,OAASA,OAASuP,QAAQ9F,KAExD,SAASmI,YAAY5R,MACjB,OAAOA,OAASuP,QAAQzF,kBAAoB9J,OAASuP,QAAQxF,kBAEjE,SAAS0G,YAAYzQ,MACjB,OAAOK,YAAYL,OAASA,OAASuP,QAAQsB,SAAW7Q,OAASuP,QAAQtH,MAK7E,SAASyJ,WAAWpN,MAAO4M,OACvB,IAAII,EAAI,IACJC,EAAI,IACJC,EAAI,IACJC,EAAIvI,OAAgB,MAATgI,OAA2B,KAAVA,MAAeA,MAAQ,GACvD,GAAc,MAAV5M,MACAmN,EAAI,OAGJ,OAAQnN,MAAMvD,QACV,KAAK,EACD,MACJ,KAAK,EACDuQ,EAAIC,EAAIC,EAAIlN,MAAQA,MACpB,MACJ,KAAK,EACDgN,EAAIC,EAAIC,EAAIlN,MACZ,MACJ,KAAK,EACDgN,EAAIhN,MAAM,GAAKA,MAAM,GACrBiN,EAAIjN,MAAM,GAAKA,MAAM,GACrBkN,EAAIlN,MAAM,GAAKA,MAAM,GACrB,MACJ,QAEIgN,GADAhN,OAASA,OACCzC,MAAM,EAAG,GACnB0P,EAAIjN,MAAMzC,MAAM,EAAG,GACnB2P,EAAIlN,MAAMzC,MAAM,EAAG,GAG/B,MAAO,CACHyP,EAAGiB,SAASjB,EAAG,IACfC,EAAGgB,SAAShB,EAAG,IACfC,EAAGe,SAASf,EAAG,IACfC,EAAAA,GAOR,SAAS7B,uBAAuBlN,OAC5B,MAAsB,eAAfA,MAAMQ,MAAyC,gBAAfR,MAAMQ,OAA2BR,MAAMoO,KAUlF,SAASnB,YAAYrN,QAASH,QAC1B,IAAItB,MAAQ,EACRC,IAAM,EACV,KAAOqB,OAAOpB,QAAQ,CAClB,MAAM2B,MAAQ8P,KAAKrQ,QACnB,GAAmB,YAAfO,MAAMQ,MAAqC,gBAAfR,MAAMQ,KAQlC,MAPArC,MAAQ6B,MAAM7B,MACTC,MACDA,IAAM4B,MAAM5B,KAEhBqB,OAAO0B,MAMXhD,QAAUC,KACVqB,OAAOsB,KAAKiN,cAAcpO,QAASzB,MAAOC,MAGlD,SAAS0R,KAAKzD,KACV,OAAOA,IAAIA,IAAIhO,OAAS,GAG5B,SAAS0R,aAAatQ,QAClB,MAAO,CACHA,OAAAA,OACAtB,MAAO,EACPK,IAAK,EACLkB,KAAMD,OAAOpB,QAGrB,SAAS2R,OAAOpQ,SACZ,OAAOA,QAAQH,OAAOG,QAAQpB,KAElC,SAASyR,SAASrQ,SACd,OAAOA,QAAQpB,IAAMoB,QAAQF,KAEjC,SAASwQ,UAAUtQ,QAASG,MACxB,QAAIA,KAAKiQ,OAAOpQ,YACZA,QAAQpB,OACD,GAIf,SAASoG,MAAMhF,QAASR,QAASY,MAAQgQ,OAAOpQ,UACxCI,OAAwB,MAAfA,MAAM7B,QACfiB,gBAAkBY,MAAM7B,SAE5B,MAAM+B,IAAM,IAAIZ,MAAMF,SAEtB,OADAc,IAAS,IAAIF,OAASA,MAAM7B,MACrB+B,IAGX,SAASiQ,OAAO1Q,OAAQY,QAAU,IAC9B,MAAMT,QAAUmQ,aAAatQ,QACvBa,OAAS,GACf,IAAI8P,SACJ,KAAOH,SAASrQ,UACZ,GAAIwQ,SAAWC,gBAAgBzQ,QAASS,SACpCC,OAAOS,KAAKqP,eAEX,IAAKF,UAAUtQ,QAAS0Q,mBACzB,MAAM1L,MAAMhF,QAAS,oBAG7B,OAAOU,OAKX,SAAS+P,gBAAgBzQ,QAASS,SAC9B,IAAIqB,KACA6O,WAAY,EACZC,cACJ,MAAM5O,MAAQ,GACR5B,MAAQgQ,OAAOpQ,SACf6Q,YAAcpQ,QAAQuB,MAW5B,IAVK6O,YAAaC,UAAU1Q,QAAW2Q,gBAAgB/Q,WACnDA,QAAQpB,MACRkD,KAAO1B,MAAM4B,MAEbsO,UAAUtQ,QAASgR,mBAGnBH,WACAP,UAAUtQ,QAASiR,gBAEhBZ,SAASrQ,UACZ,GAAIsQ,UAAUtQ,QAASkR,aACnBP,WAAY,OAEX,GAAIC,cAAgBO,aAAanR,QAAS6Q,WAC3C7O,MAAMb,KAAKyP,oBAEV,IAAKN,UAAUtQ,QAASoR,qBACzB,MAGR,GAAItP,MAAQE,MAAMvD,QAAUkS,UACxB,MAAO,CAAE7O,KAAAA,KAAME,MAAAA,MAAO2O,UAAAA,WAM9B,SAASQ,aAAanR,QAASqR,YAC3B,MAAM3Q,OAAS,GACf,IAAIN,MACAkR,KACJ,KAAOjB,SAASrQ,UAEZ,GAAImN,QADJ/M,MAAQgQ,OAAOpQ,UAEXA,QAAQpB,MACJkS,UAAU1Q,SAAWkR,KAAOC,iBAAiBvR,UAC7CU,OAAOS,KAAK,CACRP,KAAM,eACNkB,KAAM1B,MAAM4B,MACZwP,UAAWF,OAIf5Q,OAAOS,KAAKf,WAGf,CAAA,KAAI4Q,iBAAiB5Q,QAAWiR,YAAcJ,eAAe7Q,QAI9D,MAHAJ,QAAQpB,MAMhB,OAAO8B,OAAOjC,OACR,CAAEmC,KAAM,WAAYoB,MAAOtB,aAC3B,EAEV,SAAS6Q,iBAAiBvR,SACtB,MAAMzB,MAAQyB,QAAQpB,IACtB,GAAI0R,UAAUtQ,QAASyR,iBAAkB,CACrC,MAAMH,KAAO,GACb,IAAItP,MACJ,KAAOqO,SAASrQ,WAAasQ,UAAUtQ,QAAS0R,mBAC5C,GAAI1P,MAAQmP,aAAanR,SAAS,GAC9BsR,KAAKnQ,KAAKa,YAET,IAAKsO,UAAUtQ,QAASiR,kBAAoBX,UAAUtQ,QAAS2R,qBAChE,MAAM3M,MAAMhF,QAAS,oBAI7B,OADAA,QAAQzB,MAAQA,MACT+S,MAGf,SAASR,UAAU1Q,OACf,OAAOA,OAAwB,YAAfA,MAAMQ,KAE1B,SAASgR,UAAUxR,MAAO4D,MACtB,OAAO5D,OAAwB,YAAfA,MAAMQ,OAA+B,MAARoD,MAAgB5D,MAAM4D,OAASA,MAEhF,SAASyN,gBAAgBrR,OACrB,OAAOwR,UAAUxR,OAAO,GAE5B,SAASsR,iBAAiBtR,OACtB,OAAOwR,UAAUxR,OAAO,GAE5B,SAAS6Q,eAAe7Q,OACpB,OAAOA,OAAwB,eAAfA,MAAMQ,KAE1B,SAASiR,WAAWzR,MAAOmE,UACvB,OAAOnE,OAAwB,aAAfA,MAAMQ,QAAyB2D,UAAYnE,MAAMmE,WAAaA,UAElF,SAASmM,kBAAkBtQ,OACvB,OAAOyR,WAAWzR,MAAO4M,aAAanF,SAE1C,SAAS8J,oBAAoBvR,OACzB,OAAOyR,WAAWzR,MAAO4M,aAAa8C,mBAE1C,SAASsB,oBAAoBhR,OACzB,OAAOuR,oBAAoBvR,OAE/B,SAAS8Q,YAAY9Q,OACjB,OAAOyR,WAAWzR,MAAO4M,aAAa4C,WAE1C,SAASzC,QAAQ/M,OACb,MAAsB,gBAAfA,MAAMQ,MACS,eAAfR,MAAMQ,MACS,gBAAfR,MAAMQ,MACS,YAAfR,MAAMQ,MACS,UAAfR,MAAMQ,MACS,mBAAfR,MAAMQ,KAEjB,SAASoQ,iBAAiB5Q,OACtB,OAAOyR,WAAWzR,MAAO4M,aAAa+C,oBAC/B8B,WAAWzR,MAAO4M,aAAagD,gBAE1C,SAASe,gBAAgB/Q,SACrB,MAAM8R,GAAK9R,QAAQH,OAAOG,QAAQpB,KAC5BmT,GAAK/R,QAAQH,OAAOG,QAAQpB,IAAM,GACxC,OAAOkT,IAAMC,IAAMjB,UAAUgB,KAAmB,YAAZC,GAAGnR,KAM3C,SAASoR,QAAQxR,KAAMC,SACnB,IACI,MAAMZ,OAAyB,iBAATW,KAAoB0M,SAAS1M,KAAMC,SAAWA,QAAQuB,OAASxB,KACrF,OAAO+P,OAAO1Q,OAAQY,SAE1B,MAAOH,KAIH,MAHIA,eAAeb,cAAgC,iBAATe,OACtCF,IAAId,cAAgBgB,SAAS,IAAIkB,OAAOpB,IAAI1B,SAE1C0B,KAQd,SAAS2R,gBAAgBlR,KAAMmR,QAC3B,IAAKnR,KAAKgB,WACN,OAEJ,MAAMA,WAAa,GACboQ,OAAS,GACf,IAAK,MAAMvQ,QAAQb,KAAKgB,WACpB,GAAIH,KAAKE,KAAM,CACX,MAAMsQ,SAAWxQ,KAAKE,KACtB,GAAIsQ,YAAYD,OAAQ,CACpB,MAAMvM,KAAOuM,OAAOC,UACH,UAAbA,SACAxM,KAAK5D,MAAQqQ,WAAWzM,KAAK5D,MAAOJ,KAAKI,MAAO,KAGhDsQ,kBAAkB1M,KAAMhE,KAAMsQ,aAKlCnQ,WAAWZ,KAAKgR,OAAOC,UAAY7G,OAAOC,OAAO,GAAI5J,YAIzDG,WAAWZ,KAAKS,MAGxBb,KAAKgB,WAAaA,WAKtB,SAASsQ,WAAWzM,KAAM1G,KAAMqT,MAC5B,GAAI3M,MAAQ1G,KAAM,CACV0G,KAAKnH,QAAU8T,MACfC,OAAO5M,KAAM2M,MAEjB,IAAK,MAAME,KAAKvT,KACZsT,OAAO5M,KAAM6M,GAEjB,OAAO7M,KAEX,MAAMlF,OAASkF,MAAQ1G,KACvB,OAAOwB,QAAUA,OAAOnB,QAK5B,SAAS+S,kBAAkBI,KAAMC,IAAKT,QAelC,OAdAQ,KAAK5Q,KAAO6Q,IAAI7Q,KACXoQ,OAAOzR,QAAQ,8BAChBiS,KAAK1Q,MAAQ2Q,IAAI3Q,OAGhB0Q,KAAKtG,UACNsG,KAAKtG,QAAUuG,IAAIvG,SAElBsG,KAAKlG,UACNkG,KAAKlG,QAAUmG,IAAInG,SAEA,eAAnBkG,KAAKpG,YACLoG,KAAKpG,UAAYqG,IAAIrG,WAElBoG,KAEX,SAASF,OAAO3S,OAAQmC,OACpB,MAAMqH,OAASxJ,OAAOpB,OAAS,EACD,iBAAnBoB,OAAOwJ,SAAyC,iBAAVrH,MAC7CnC,OAAOwJ,SAAWrH,MAGlBnC,OAAOsB,KAAKa,OAUpB,SAAS4Q,OAAO7R,KAAM8R,GAAI7J,OACtB,MAAM8J,UAAY,CAAC/R,MACbgS,SAAYjS,MACd+R,GAAG/R,IAAKgS,UAAW9J,OACnB8J,UAAU3R,KAAKL,KACfA,IAAIuJ,SAAS2I,QAAQD,UACrBD,UAAUvR,OAEdR,KAAKsJ,SAAS2I,QAAQD,UAK1B,SAASE,OAAOlS,KAAMgS,UAClB,IAAK,IAAI7J,EAAI,EAAGA,EAAInI,KAAKsJ,SAAS5L,OAAQyK,IAAK,CAC3C,MAAMf,MAAQpH,KAAKsJ,SAASnB,GAC5B,GAAI6J,SAAS5K,OACT,OAAOA,MAEX,MAAMzH,OAASuS,OAAO9K,MAAO4K,UAC7B,GAAIrS,OACA,OAAOA,QAOnB,SAASwS,YAAYnS,MACjB,IAAIiG,OACJ,KAAOjG,KAAKsJ,SAAS5L,QACjBuI,OAASjG,KACTA,KAAOA,KAAKsJ,SAAStJ,KAAKsJ,SAAS5L,OAAS,GAEhD,MAAO,CAAEuI,OAAAA,OAAQjG,KAAAA,MAErB,SAASoS,OAAOpS,MACZ,MAAqB,qBAAdA,KAAKH,KAYhB,SAASwS,gBAAgB5S,KAAM0R,QAC3B,MAAMlR,MAAQ,GACRqS,SAAWnB,OAAOzR,QAAQ,6BAC1B6S,KAAEA,MAASpB,OACXqB,QAAWpL,QACb,MAAMqL,QAAUrL,MAAMrG,MAAQoQ,OAAOuB,SAAStL,MAAMrG,MAKpD,IAAK0R,SAAWxS,MAAM0S,SAASF,SAC3B,OAAO,KAEX,IAAIG,YACJ,IAEIA,YAAc5G,kBAAkByG,QAAStB,QAE7C,MAAO5R,KAEH,OADAgT,MAAAA,MAA4CA,yBAAyBE,mBAAoBlT,KAClF,KAEXU,MAAMG,KAAKqS,SACXI,YAAYD,YAAaJ,SACzBvS,MAAMO,MAEN,IAAK,MAAMsS,WAAWF,YAAYtJ,SAAU,CACxC,GAAIlC,MAAMpG,WAAY,CAClB,MAAMnE,KAAOiW,QAAQ9R,YAAc,GAC7BlE,GAAKsK,MAAMpG,YAAc,GAC/B8R,QAAQ9R,WAAasR,SAAWxV,GAAG6E,OAAO9E,MAAQA,KAAK8E,OAAO7E,IAElEiW,WAAW3L,MAAO0L,SAEtB,OAAOF,aAGX,OADAC,YAAYpT,KAAM+S,SACX/S,KAEX,SAASoT,YAAY7S,KAAMwS,QAASrB,QAChC,IAAI7H,SAAW,GACf,IAAK,MAAMlC,SAASpH,KAAKsJ,SAAU,CAC/B,MAAM0J,SAAWR,QAAQpL,OACzB,GAAI4L,SAAU,CACV1J,SAAWA,SAAS3H,OAAOqR,SAAS1J,UACpC,MAAMU,QAAUmI,YAAYa,UACxBZ,OAAOpI,QAAQhK,QACfgK,QAAQhK,KAAKsJ,SAAWU,QAAQhK,KAAKsJ,SAAS3H,OAAOkR,YAAYzL,MAAOoL,gBAI5ElJ,SAASlJ,KAAKgH,OACdA,MAAMkC,SAAWuJ,YAAYzL,MAAOoL,SAG5C,OAAOxS,KAAKsJ,SAAWA,SAK3B,SAASyJ,WAAWlW,KAAMC,IAClBD,KAAKmO,cACLlO,GAAGkO,aAAc,GAEH,MAAdnO,KAAKoE,QACLnE,GAAGmE,MAAQpE,KAAKoE,OAEhBpE,KAAK8D,SACL7D,GAAG6D,OAAS9D,KAAK8D,SA72BzB,SAAWsL,cACPA,aAAsB,QAAI,IAC1BA,aAAwB,UAAI,IAC5BA,aAAgC,kBAAI,IACpCA,aAA6B,eAAI,IACjCA,aAAgC,kBAAI,IALxC,CAMGA,eAAiBA,aAAe,KAGnC,SAAW/E,OAEPA,MAAMA,MAAY,KAAI,IAAM,OAE5BA,MAAMA,MAAc,OAAI,IAAM,SAE9BA,MAAMA,MAAY,KAAI,IAAM,OAE5BA,MAAMA,MAAW,IAAI,IAAM,MAE3BA,MAAMA,MAAa,MAAI,IAAM,QAE7BA,MAAMA,MAAa,MAAI,IAAM,QAE7BA,MAAMA,MAAY,KAAI,IAAM,OAE5BA,MAAMA,MAAU,GAAI,IAAM,KAE1BA,MAAMA,MAAe,QAAI,IAAM,UAE/BA,MAAMA,MAAkB,WAAI,IAAM,aAElCA,MAAMA,MAAwB,iBAAI,IAAM,mBAExCA,MAAMA,MAAyB,kBAAI,IAAM,oBAEzCA,MAAMA,MAAwB,iBAAI,KAAO,mBAEzCA,MAAMA,MAAyB,kBAAI,KAAO,oBAE1CA,MAAMA,MAAe,QAAI,IAAM,UAE/BA,MAAMA,MAAmB,YAAI,IAAM,cAEnCA,MAAMA,MAAmB,YAAI,IAAM,cAEnCA,MAAMA,MAAmB,YAAI,KAAO,cAEpCA,MAAMA,MAAa,MAAI,IAAM,QAtCjC,CAuCGgF,UAAYA,QAAU,KAi0BzB,MAAMxH,gBAAkB,IAClBuO,cAAgB,IACtB,SAASC,mBAAmBxT,QAASyT,MAAQ,GACzC,MAAO,CACHzT,QAAAA,QACAuB,MAAO,GACPkS,MAAAA,MACAC,OAAQ,EACRC,KAAM,EACNC,OAAQ,GAMhB,SAASlT,KAAKoG,OAAQlF,MAClB,MAAMiS,YAAc/M,OAAO9G,QAAQ,eACnC8T,MAAMhN,OAAQ+M,YAAYjS,KAAMkF,OAAO4M,OAAQ5M,OAAO6M,KAAM7M,OAAO8M,SAKvE,SAASG,WAAWjN,OAAQvF,OAGxB,MAAMyS,MAAQC,eAAe1S,OAC7B,IAAK,IAAIkH,EAAI,EAAGyL,GAAKF,MAAMhW,OAAS,EAAGyK,GAAKyL,GAAIzL,IAC5C/H,KAAKoG,OAAQkN,MAAMvL,IACfA,IAAMyL,IACNC,YAAYrN,QAAQ,GAOhC,SAASqN,YAAYrN,OAAQsN,QACzB,MAAMC,WAAavN,OAAO9G,QAAQ,qBAC5BsU,QAAUxN,OAAO9G,QAAQ,kBAC/BU,KAAKoG,OAAQwN,QAAUD,YACvBvN,OAAO6M,OACP7M,OAAO8M,OAASS,WAAWrW,OACvBoW,QACAG,WAAWzN,QAAmB,IAAXsN,OAAkBtN,OAAO2M,MAAQW,QAM5D,SAASG,WAAWzN,OAAQzH,KAAOyH,OAAO2M,OACtC,MAAMW,OAAStN,OAAO9G,QAAQ,iBAC9BU,KAAKoG,OAAQsN,OAAOnT,OAAO6H,KAAKC,IAAI1J,KAAM,KAK9C,SAASmV,UAAU1N,OAAQH,MAAO8N,aAC9B,MAAMC,MAAQ5N,OAAO9G,QAAQ,gBAE7B8T,MAAMhN,OAAQ4N,MAAM/N,MAAO8N,YAAa3N,OAAO4M,OAAQ5M,OAAO6M,KAAM7M,OAAO8M,SAK/E,SAASe,QAAQtT,KAAMoQ,QACnB,OAAOmD,QAAQvT,KAAMoQ,OAAOzR,QAAQ,mBAKxC,SAAS2R,SAAStQ,KAAMoQ,QACpB,OAAOmD,QAAQvT,KAAMoQ,OAAOzR,QAAQ,yBAKxC,SAAS6U,UAAU1T,KAAMsQ,OAAQ7N,QAC7B,MAAuB,eAAnBzC,KAAK0K,UACEjI,OAASoB,gBAAkBuO,cAEc,WAA7C9B,OAAOzR,QAAQ,0BAAyC,IAAO,IAK1E,SAAS8U,mBAAmB3T,KAAMsQ,QAC9B,OAAOtQ,KAAK4K,SACL0F,OAAOzR,QAAQ,4BAA4BiT,UAAU9R,KAAKE,MAAQ,IAAI0T,eAKjF,SAASvT,UAAUiQ,QACf,OAAQA,OAAOzR,QAAQ,4BACnB,IAAK,QAAS,MAAO,KACrB,IAAK,MAAO,MAAO,IACnB,QAAS,MAAO,IAOxB,SAASgV,SAAS1U,KAAMmR,QACpB,MAAoB,iBAATnR,KACAmR,OAAOzR,QAAQiV,eAAehC,SAAS3S,KAAKyU,eAGhDzU,KAAKe,KAAO2T,SAAS1U,KAAKe,KAAMoQ,QAAU5N,QAAQvD,KAAKiB,QAAUjB,KAAKgB,YAKjF,SAAS2S,eAAerS,MACpB,OAAOA,KAAKsT,MAAM,eAKtB,SAASpB,MAAMhN,OAAQlF,MACnBkF,OAAOvF,OAASK,KAChBkF,OAAO4M,QAAU9R,KAAK5D,OACtB8I,OAAO8M,QAAUhS,KAAK5D,OAE1B,SAAS4W,QAAQ/W,IAAKsC,MAClB,OAAIA,KACgB,UAATA,KAAmBtC,IAAIsX,cAAgBtX,IAAIkX,cAE/ClX,IAGX,MAAMuX,WAAa,CACfC,EAAG,OACHC,GAAI,KACJC,GAAI,KACJC,MAAO,KACPC,GAAI,KACJC,MAAO,KACPC,MAAO,KACPC,MAAO,KACPC,SAAU,MACVC,OAAQ,SACRC,SAAU,SACVC,MAAO,SACPC,MAAO,SACPC,OAAQ,QACRC,IAAK,QAET,SAASC,YAAY9V,KAAM+R,UAAWZ,SAC7BnR,KAAKe,MAAQf,KAAKgB,YACnB+U,mBAAmB/V,KAAM+R,UAAWZ,QAG5C,SAAS4E,mBAAmB/V,KAAM+R,UAAWZ,QACzC,MAAMlL,OAAS+P,iBAAiBjE,WAC1BkE,YAAc9E,OAAOnO,QAAUmO,OAAOnO,QAAQjC,KAAO,GACrDmV,WAAaC,UAAUlQ,OAASA,OAAOlF,KAAOkV,aACpDjW,KAAKe,KAAO+T,WAAWoB,cACfxB,SAASwB,WAAY/E,QAAU,OAAS,OAEpD,SAASgF,UAAU5Y,KACf,OAAQA,KAAO,IAAIkX,cAKvB,SAASuB,iBAAiBjE,WACtB,IAAK,IAAI5J,EAAI4J,UAAUrU,OAAS,EAAGyK,GAAK,EAAGA,IAAK,CAC5C,MAAMrH,KAAOiR,UAAU5J,GACvB,GAAIiK,OAAOtR,MACP,OAAOA,MAKnB,IAAIsV,MAAQ,CACXC,OAAU,CAAC,QAAS,QAAS,QAAS,MAAO,OAAQ,cAAe,cAAe,QACnFC,MAAS,CAAC,iBAAkB,cAAe,eAAgB,UAAW,UACrE,OAAQ,OAAQ,MAAO,QAAS,MAAO,MAAO,WAAY,YAC1D,OAAQ,cAAe,QAAS,MAAO,WAAY,MAAO,WAC1D,SAAU,MAAO,OAAQ,UAAW,UAAW,cAC/C,UAAW,QAAS,QAAS,WAAY,QAAS,OAAQ,QAC1D,OAAQ,QAAS,SAAU,WAAY,QAAS,OAAQ,QACxD,QAAS,QAAS,QAAS,OAAQ,MAAO,KAAM,KAAM,eACtD,UAAW,YAAa,UAAW,YAAa,WAAY,UAC5D,UAAW,UAAW,OAAQ,YAAa,cAAe,MAC1D,iBAAkB,WAAY,WAAY,SAAU,WACpD,WAAY,UAAW,OAAQ,cAAe,OAAQ,WACtD,YAAa,MAAO,aAAc,aAAc,SAAU,OAC1D,MAAO,UAAW,QAAS,QAAS,SAAU,OAAQ,QACtD,aAAc,WAAY,YAAa,QAAS,UAAW,SAC3D,UAAW,cAAe,QAAS,YAAa,QAAS,OACzD,QAAS,WAAY,UAAW,OAAQ,aAAc,UACtD,YAAa,QAAS,UAAW,OAAQ,aAAc,YACvD,QAAS,aAAc,QAAS,QAAS,UAAW,aAAc,KAClE,OAAQ,OAAQ,WAAY,OAAQ,aAAc,QAAS,WAC3D,aAAc,QAAS,eAAgB,MAAO,aAC9C,YAAa,YAAa,KAAM,QAAS,QAAS,QAAS,OAC3D,KAAM,KAAM,OAAQ,QAAS,UAAW,KAAM,KAAM,KAAM,OAC1D,gBAAiB,UAAW,OAAQ,SAAU,MAAO,YACrD,SAAU,cAAe,SAAU,aAAc,OAAQ,YACzD,aAAc,UAAW,cAAe,aAAc,UACtD,QAAS,QAAS,SAAU,aAAc,WAAY,SACtD,aAAc,MAAO,OAAQ,WAAY,QAAS,IAAK,YACvD,MAAO,QAAS,SAAU,UAAW,WAAY,QAAS,SAC1D,SAAU,aAGRC,GAAK,CACRF,OAAU,CAAC,gBAAiB,KAAM,aAAc,SAAU,WAAY,UAAW,cAAe,QAAS,SAAU,UACnHC,MAAS,CAAC,QAAS,UAAW,MAAO,YAAa,QAAS,YAAa,YACvE,WAAY,YAAa,SAAU,YAAa,SAAU,OAC1D,SAAU,UAAW,eAAgB,KAAK,QAAS,eACnD,YAAa,MAAO,oBAAqB,SAAU,UAAW,WAC9D,cAAe,WAAY,QAAS,MAAO,OAAQ,aACnD,aAAc,KAAM,QAAS,SAAU,MAAO,UAAW,WACzD,WAAY,mBAAoB,QAAS,QAAS,UAAW,OAC7D,YAAa,UAAU,UAAW,SAAU,QAAS,QAAS,QAC9D,SAAU,QAAS,UAAW,MAAO,aAAc,UAAW,UAC9D,eAAgB,IAAK,OAAQ,UAAW,QAAS,SAAU,UAC3D,WAAY,SAAU,UAAW,KAAM,QAAS,MAAO,QACvD,OAAQ,QAAS,KAAM,SAAU,OAAQ,QAAS,YAAa,OAC/D,YAAa,UAAW,KAAM,OAAQ,WAAY,SAClD,cAAe,SAAU,UAAW,YAAa,MAAO,SACxD,YAAa,SAAU,QAAS,SAAU,SAAU,UAAW,SAC/D,YAAa,YAAa,UAAW,UAAW,eAAgB,SAChE,WAAY,WAAY,eAAgB,SAAU,WAAY,MAC9D,OAAQ,YAAa,OAAQ,OAAQ,SAAU,WAAY,WAC3D,MAAO,eAAiB,OAAQ,MAAO,iBAAkB,YACzD,MAAO,eAAgB,MAAO,OAAQ,WAAY,MAAO,YACzD,cAAe,KAAM,QAAS,OAAQ,aAAc,SAAU,eAC9D,WAAY,MAAO,YAAa,OAAQ,OAAQ,SAAU,MAC1D,eAAgB,WAAY,cAAe,YAAa,UACxD,YAAa,SAAU,QAAS,aAAc,OAAQ,YACtD,UAAW,eAAgB,QAAS,QAAS,QAAS,WACtD,OAAQ,aAAc,KAAM,QAAS,MAAO,KAAM,MAAO,QAGvDE,GAAK,CACRH,OAAU,CAAC,QAAS,MAAO,QAAS,MAAO,KAAM,QAAS,QAAS,MACnEC,MAAS,CAAC,YAAa,cAAe,cAAe,UAAW,OAC/D,WAAY,QAAS,UAAW,YAAa,QAAS,QAAS,aAAc,YAC7E,OAAQ,eAAgB,OAAQ,OAAQ,YAAa,OAAQ,SAC7D,SAAU,KAAM,OAAQ,WAAY,SAAU,YAC9C,YAAa,QAAS,YAAa,aAAc,OAAQ,WAAY,SACrE,OAAQ,SAAU,OAAQ,QAAS,UAAW,OAAQ,YACtD,QAAS,SAAU,UAAW,QAAS,MAAO,KAAM,IAAK,aACzD,eAAgB,WAAY,WAAY,WAAY,YAAa,WACjE,WAAY,WAAY,OAAQ,WAAY,eAAgB,QAC5D,iBAAkB,aAAc,aAAc,UAAW,SACzD,UAAW,SAAU,SAAU,YAAa,QAAS,YACrD,UAAW,QAAS,eAAgB,QAAS,aAAc,SAC3D,MAAO,QAAS,WAAY,QAAS,aAAc,QAAS,UAC5D,cAAe,cAAe,QAAS,UAAW,cAAe,SACjE,UAAW,aAAc,QAAS,WAAY,UAAW,SACzD,QAAS,YAAa,SAAU,SAAU,aAAc,UACxD,UAAW,SAAU,YAAa,cAAe,WAAY,YAC7D,YAAa,aAAc,OAAQ,WAAY,QAAS,QAAS,IACjE,UAAW,YAAa,WAAY,OAAQ,aAAc,SAAU,WACpE,iBAAkB,WAAY,aAAc,OAAQ,gBACpD,eAAgB,QAAS,IAAK,WAAY,QAAS,QAAS,SAC5D,SAAU,aAAc,OAAQ,YAAa,SAAU,KAAM,WAAY,MAAO,MAChF,YAAa,UAAW,SAAU,YAAa,QAAS,WACxD,UAAW,YAAa,QAAS,WAAY,SAAU,YACvD,SAAU,WAAY,SAAU,aAAc,YAC9C,MAAO,aAAc,UAAW,WAAY,UAAW,WACvD,aAAc,UAAW,OAAQ,aAAc,OAAQ,IAAK,YAC5D,WAAY,QAAS,OAAQ,UAAW,aAAc,UAAW,OACjE,SAAU,aAGZ,MAAMG,aAAe,CAAEF,GAAAA,GAAIC,GAAAA,GAAIJ,MAAAA,OACzBM,QAAU,+BAChB,SAASC,MAAM3W,KAAM+R,UAAWZ,QAC5B,IAAIyF,EACJ,GAAI5W,KAAKe,OAAS6V,EAAI5W,KAAKe,KAAKhD,MAAM2Y,UAAW,CAC7C,MAAMG,GAAKJ,aAAaG,EAAE,KAAOH,aAAaL,MACxCU,aAAeF,EAAE,GAAKpO,KAAKC,IAAI,EAAG5C,OAAO+Q,EAAE,KAAO,GAClDG,aAAeH,EAAE,GAAKpO,KAAKC,IAAIqO,aAAcjR,OAAO+Q,EAAE,GAAGpY,MAAM,KAAOsY,aACtEE,UAAYC,KAAKH,aAAcC,cAC/BpW,OAASX,KAAKW,QAAUuW,aAAanF,WAC3C/R,KAAKe,KAAOf,KAAKgB,gBAAa,EAC9BhB,KAAKiB,MAAQ,CAACkW,UAAUN,GAAIG,WAAYrW,QAA2B,IAAjBA,OAAOM,QACrDjB,KAAKW,QAAUoR,UAAUrU,OAAS,GAClCqY,mBAAmB/V,KAAM+R,UAAWZ,SAOhD,SAAS8F,KAAKpa,KAAMC,IAChB,OAAO0L,KAAK4O,MAAM5O,KAAK6O,UAAYva,GAAKD,MAAQA,MAEpD,SAASya,OAAO5L,IAAKvJ,OACjB,MAAMoV,IAAM7L,IAAIhO,OACV8Z,WAAahP,KAAKiP,IAAIF,IAAKpV,OAC3BxC,OAAS,GACf,KAAOA,OAAOjC,OAAS8Z,YAAY,CAC/B,MAAMja,IAAMmO,IAAIuL,KAAK,EAAGM,MACnB5X,OAAOgT,SAASpV,MACjBoC,OAAOS,KAAK7C,KAGpB,OAAOoC,OAEX,SAAS+X,OAAOC,KACZ,OAAOA,IAAIV,KAAK,EAAGU,IAAIja,OAAS,IAEpC,SAASka,SAAStB,MAAO7Y,KAIrB,OAHI6Y,MAAM5Y,SACN4Y,MAAQ,CAACuB,WAAWvB,MAAM,KAAK3U,OAAO2U,MAAM9X,MAAM,KAE/C8X,MAAMzM,KAAK,MAAQpM,KAAOia,OAAO,UAE5C,SAASG,WAAWC,MAChB,OAAOA,KAAK,GAAGjD,cAAgBiD,KAAKtZ,MAAM,GAM9C,SAASuZ,aAAazB,OAClB,GAAIA,MAAM5Y,OAAS,EACf,OAAO4Y,MAGX,MAAMiB,KADNjB,MAAQA,MAAM9X,SACId,OACZsa,SAAW,KACjB,IAAIC,YAAc,EAEdA,YADAV,IAAM,GAAKA,KAAO,EACJN,KAAK,EAAG,GAEjBM,IAAM,GAAKA,KAAO,GACTN,KAAK,EAAG,GAGRA,KAAK,EAAG,GAE1B,IAAK,IAAI9O,EAAI,EAAGtK,IAAKsK,EAAI8P,YAAa9P,IAClCtK,IAAMoZ,KAAK,EAAGM,IAAM,GACfS,SAAS5Y,KAAKkX,MAAMzY,QACrByY,MAAMzY,MAAQ,KAGtB,OAAOyY,MAQX,SAASa,UAAUe,KAAMlB,UAAWmB,iBAChC,MAAMxY,OAAS,GACf,IAAIyY,WAAa,EACb9B,MAMJ,IALI6B,iBAAmBD,KAAK7B,SAExB+B,aADA9B,MAAQ4B,KAAK7B,OAAO7X,MAAM,EAAGwY,YACTtZ,OACpBiC,OAAOS,KAAKwX,SAASG,aAAazB,OAAQ,OAEvC8B,WAAapB,WAEhBoB,aADA9B,MAAQgB,OAAOY,KAAK5B,MAAO9N,KAAKiP,IAAIR,KAAK,EAAG,IAAKD,UAAYoB,cACzC1a,OACpBiC,OAAOS,KAAKwX,SAASG,aAAazB,SAEtC,OAAO3W,OAAOkK,KAAK,KAEvB,SAASqN,aAAanF,WAClB,IAAK,IAAI5J,EAAI4J,UAAUrU,OAAS,EAAGyK,GAAK,EAAGA,IAAK,CAC5C,MAAMkQ,QAAUtG,UAAU5J,GAC1B,GAAqB,qBAAjBkQ,QAAQxY,MAA+BwY,QAAQ1X,OAC/C,OAAO0X,QAAQ1X,QAS3B,SAAS2X,IAAItY,MACLuY,YAAYvY,KAAKe,OAASf,KAAKgB,aAAehB,KAAKsJ,SAAS5L,QAAUsC,KAAKiB,SAC3EjB,KAAKgB,WAAahB,KAAKgB,WAAWmI,OAAOqP,YAGjD,SAASA,UAAU3X,MACf,MAAqB,WAAdA,KAAKE,KAEhB,SAASwX,YAAYxX,MACjB,MAAgB,iBAATA,MAAoC,mBAATA,KAGtC,MAAM0X,UAAY,8BACZC,WAAa,+BACbC,iBAAoBC,WAAc,YAAYxZ,KAAKwZ,WACnDC,iBAAoBD,WAAc,UAAUxZ,KAAKwZ,WACvD,SAASE,IAAI9Y,KAAM+R,UAAWZ,QAC1B4H,iBAAiB/Y,MACjBgZ,oBAAoBhZ,KAAM+R,UAAWZ,QAOzC,SAAS4H,iBAAiB/Y,MACtB,MAAMiZ,KAAOC,WAAWlZ,MAClBmZ,WAAa,GACnB,IAAK,MAAMC,MAAMH,KAAKE,WAAY,CAE9B,MAAME,GAAKD,GAAGE,QAAQ,KAClBD,GAAK,IAAMD,GAAGxN,WAAW,MACzBuN,WAAW/Y,KAAKgZ,GAAG5a,MAAM,EAAG6a,KAC5BF,WAAW/Y,KAAKgZ,GAAG5a,MAAM6a,MAGzBF,WAAW/Y,KAAKgZ,IAGpBD,WAAWzb,SACXub,KAAKE,WAAaA,WAAWhQ,OAAOoQ,aACpCN,KAAKO,MAAQC,cAAcR,KAAKE,YAChCO,YAAY1Z,KAAMiZ,KAAKE,WAAWtP,KAAK,OAM/C,SAASmP,oBAAoBhZ,KAAM+R,UAAWZ,QAC1C,MAAM8H,KAAOC,WAAWlZ,MAClBmZ,WAAa,IACbzZ,QAAEA,SAAYyR,OACdwI,KAAO5H,UAAUvT,MAAM,GAAGmD,OAAO3B,MACvC,IAAK,IAAIoZ,MAAMH,KAAKE,WAAY,CAC5B,IAAIS,OAAS,GACThD,EACJ,MAAMiD,cAAgBT,IAElBxC,EAAIwC,GAAGrb,MAAM0a,cACbmB,OAASE,aAAaH,KAAM/C,EAAE,GAAGlZ,OAAQyT,OAAOnO,SAAWtD,QAAQ,eAAiBkX,EAAE,GACtFuC,WAAW/Y,KAAKwZ,QAChBR,GAAKA,GAAG5a,MAAMoY,EAAE,GAAGlZ,UAGnBkZ,EAAIwC,GAAGrb,MAAM2a,eACRkB,SACDA,OAASE,aAAaH,KAAM/C,EAAE,GAAGlZ,QACjCyb,WAAW/Y,KAAKwZ,SAEpBT,WAAW/Y,QAAQwZ,SAASla,QAAQ,kBAAkBkX,EAAE,MACxDwC,GAAKA,GAAG5a,MAAMoY,EAAE,GAAGlZ,SAEnB0b,KAAOS,eAGPV,WAAW/Y,KAAKyZ,eAGxB,MAAME,cAAgBZ,WAAWhQ,OAAOoQ,aACpCQ,cAAcrc,QACdgc,YAAY1Z,KAAM+Z,cAAclQ,KAAK,MAM7C,SAASqP,WAAWlZ,MAChB,IAAKA,KAAKga,KAAM,CACZ,IAAIC,WAAa,GACjB,GAAIja,KAAKgB,WACL,IAAK,MAAMH,QAAQb,KAAKgB,WACpB,GAAkB,UAAdH,KAAKE,MAAoBF,KAAKI,MAAO,CACrCgZ,WAAaC,eAAerZ,KAAKI,OACjC,MAIZjB,KAAKga,KAAOG,SAASF,YAEzB,OAAOja,KAAKga,KAEhB,SAASI,sBAAsBpX,SAI3B,OAHKA,QAAQgX,OACThX,QAAQgX,KAAOG,SAASnX,QAAQhC,YAAcgC,QAAQhC,WAAWqG,OAAS,KAEvErE,QAAQgX,KAKnB,SAASG,SAASF,YACd,MAAMd,WAAac,WAAaA,WAAWrF,MAAM,OAAS,GAC1D,MAAO,CACHuE,WAAAA,WACAK,MAAOC,cAAcN,aAO7B,SAASW,aAAa/H,UAAWsI,MAAQ,EAAGrX,SACxC,MAAMsX,YAAc,EACpB,IAAI/R,SAAWC,KAAKC,IAAIsJ,UAAUrU,OAAS2c,MADvB,GAEpB,EAAG,CACC,MAAMpU,OAAS8L,UAAUxJ,UACzB,GAAItC,OAAQ,CACR,MAAMgT,KAAOC,WAAWjT,QACxB,GAAIgT,KAAKO,MACL,OAAOP,KAAKO,aAPJ,EAUGjR,YACvB,GAAIvF,QAAS,CACT,MAAMiW,KAAOmB,sBAAsBpX,SACnC,GAAIiW,KAAKO,MACL,OAAOP,KAAKO,MAGpB,MAAO,GAEX,SAASC,cAAcN,YACnB,OAAOrN,KAAKqN,WAAYR,mBACjB7M,KAAKqN,WAAYN,wBACjB,EAKX,SAAS/M,KAAKqN,WAAYhQ,QACtB,IAAK,MAAMiQ,MAAMD,WAAY,CACzB,GAAIV,UAAUrZ,KAAKga,KAAOV,WAAWtZ,KAAKga,IACtC,MAEJ,GAAIjQ,OAAOiQ,IACP,OAAOA,IAInB,SAASM,YAAY1Z,KAAMiB,OACvB,IAAK,MAAMJ,QAAQb,KAAKgB,WACpB,GAAkB,UAAdH,KAAKE,KAAkB,CACvBF,KAAKI,MAAQ,CAACA,OACd,OAIZ,SAASiZ,eAAejZ,OACpB,IAAItB,OAAS,GACb,IAAK,MAAM+R,KAAKzQ,MACZtB,QAAuB,iBAAN+R,EAAiBA,EAAIA,EAAE3Q,KAE5C,OAAOpB,OAEX,SAAS4Z,YAAYxN,KAAMsN,GAAI3N,KAC3B,QAASK,MAAQL,IAAI4N,QAAQvN,QAAUsN,GAO3C,SAASkB,MAAMva,MACX,GAAkB,UAAdA,KAAKe,KAAkB,CACvB,MAAMyZ,MAAQtI,OAAOlS,KAAM1B,GAAiB,UAAXA,EAAEyC,MAA+B,aAAXzC,EAAEyC,MACrDyZ,QAEIxa,KAAKgB,aACLhB,KAAKgB,WAAahB,KAAKgB,WAAWmI,OAAOtI,QACd,QAAdA,KAAKE,MAAkB0Z,iBAAiB5Z,SAIrD2Z,MAAMxZ,aACNwZ,MAAMxZ,WAAawZ,MAAMxZ,WAAWmI,OAAOtI,QAChB,OAAdA,KAAKE,MAAiB0Z,iBAAiB5Z,WAMpE,SAAS4Z,iBAAiB5Z,MACtB,IAAKA,KAAKI,MACN,OAAO,EAEX,GAA0B,IAAtBJ,KAAKI,MAAMvD,OAAc,CACzB,MAAM2B,MAAQwB,KAAKI,MAAM,GACzB,GAAI5B,OAA0B,iBAAVA,QAAuBA,MAAM0B,KAE7C,OAAO,EAGf,OAAO,EAGX,SAAS2Z,KAAKjb,KAAMkb,QAAS1S,OACzB,MAAM+J,SAAW,CAACjS,IAAKsG,MAAOqE,SAC1B,MAAMzE,OAAEA,OAAMtB,QAAEA,SAAYsD,MAC5BA,MAAMhC,OAAStB,QACfsD,MAAMtD,QAAU5E,IAChB4a,QAAQ5a,IAAKsG,MAAOqE,MAAOzC,MAAO9J,MAClC8J,MAAMtD,QAAUA,QAChBsD,MAAMhC,OAASA,QAEb9H,KAAO,CAAC6B,KAAMqG,MAAOqE,SACvBzC,MAAM8J,UAAU3R,KAAK6H,MAAMtD,SAC3BqN,SAAShS,KAAMqG,MAAOqE,OACtBzC,MAAM8J,UAAUvR,OAEpBf,KAAK6J,SAAS2I,QAAQD,UAE1B,SAAS4I,gBAAgBzJ,QACrB,MAAO,CAEHxM,QAAS,KACTsB,YAAQ,EACR8L,UAAW,GACXZ,OAAAA,OACAiD,MAAO,EACPyG,IAAK3H,mBAAmB/B,OAAOzR,UAIvC,MAAMob,MAAQ,CAAC,CAAEjb,KAAM,QAASwG,MAAO,EAAGtF,KAAM,KAIhD,SAASga,UAAU/a,MACf,QAAOA,QAAQA,KAAKe,OAASf,KAAKgB,YAMtC,SAASga,gBAAgBhb,KAAMmR,QAC3B,QAAOnR,MAAO0U,SAAS1U,KAAMmR,QAKjC,SAAS8J,QAAQ5b,OACb,MAAwB,iBAAVA,OAAqC,UAAfA,MAAMQ,KAE9C,SAASqb,WAAWpc,OAAQmJ,OACxB,MAAM4S,IAAEA,KAAQ5S,MAChB,IAAIkT,cAAgB,EACpB,IAAK,MAAMzJ,KAAK5S,OACK,iBAAN4S,EACP+B,WAAWoH,IAAKnJ,IAGhBwC,UAAU2G,IAAK5S,MAAMmM,MAAQ1C,EAAErL,MAAOqL,EAAE3Q,MACpC2Q,EAAErL,MAAQ8U,eACVA,aAAezJ,EAAErL,SAIP,IAAlB8U,eACAlT,MAAMmM,OAAS+G,aAAe,GAOtC,SAASC,aAAatc,QAClB,MAAMa,OAAS,GACf,IAAI0T,KAAO,GACX,IAAK,MAAM3B,KAAK5S,OACZ,GAAiB,iBAAN4S,EAAgB,CACvB,MAAMgC,MAAQhC,EAAEkD,MAAM,aAEtB,IADAvB,KAAKjT,KAAKsT,MAAMlI,SAAW,IACpBkI,MAAMhW,QACTiC,OAAOS,KAAKiT,MACZA,KAAO,CAACK,MAAMlI,SAAW,SAI7B6H,KAAKjT,KAAKsR,GAIlB,OADA2B,KAAK3V,QAAUiC,OAAOS,KAAKiT,MACpB1T,OAKX,SAAS0b,sBAAsBxa,MAG3B,OAAQA,KAAKwK,SAA8B,QAAnBxK,KAAK0K,aAA0B1K,KAAKI,OAASJ,KAAKI,MAAMvD,OAAS,EAG7F,IAAI4d,cAmBJ,SAASC,SAASja,MACd,MAAMxC,OAAS,GACTG,QAAU,CAAEpB,IAAK,EAAGyD,KAAAA,MAC1B,IAAI6S,YACAf,OAASnU,QAAQpB,IACjBA,IAAMoB,QAAQpB,IAClB,KAAOoB,QAAQpB,IAAMoB,QAAQqC,KAAK5D,QAC9BG,IAAMoB,QAAQpB,KACVsW,YAAcqH,mBAAmBvc,WAC7BmU,SAAWnU,QAAQpB,KACnBiB,OAAOsB,KAAKkB,KAAK9C,MAAM4U,OAAQvV,MAEnCiB,OAAOsB,KAAK+T,aACZf,OAASnU,QAAQpB,KAGjBoB,QAAQpB,MAMhB,OAHIuV,SAAWnU,QAAQpB,KACnBiB,OAAOsB,KAAKkB,KAAK9C,MAAM4U,SAEpBtU,OAKX,SAAS0c,mBAAmBvc,SACxB,GAAIwc,OAAOxc,WAAaqc,cAAcI,MAAO,CACzC,MAAMle,QAAUyB,QAAQpB,IACxB,IAAI8d,QAAUne,MACVoe,SAAWpe,MACXyC,MAAQ,EACZ,KAAOhB,QAAQpB,IAAMoB,QAAQqC,KAAK5D,QAAQ,CACtC,MAAMf,KAAO8e,OAAOxc,SACpB,GAAI4c,aAAalf,MAAO,CAEpB,IADAgf,QAAU1c,QAAQpB,IACXie,QAAQL,OAAOxc,WAClBA,QAAQpB,MAEZ+d,SAAW3c,QAAQpB,QAElB,CACD,GAAIlB,OAAS2e,cAAcI,MACvBzb,aAEC,GAAItD,OAAS2e,cAAcS,KACZ,KAAV9b,MACF,MAAO,CACH+b,OAAQ/c,QAAQqC,KAAK9C,MAAMhB,MAAOme,SAClCM,MAAOhd,QAAQqC,KAAK9C,MAAMod,SAAU3c,QAAQpB,OAC5CkD,KAAM9B,QAAQqC,KAAK9C,MAAMmd,QAASC,WAI9C3c,QAAQpB,SAKxB,SAAS4d,OAAOxc,QAASpB,IAAMoB,QAAQpB,KACnC,OAAOoB,QAAQqC,KAAKxD,WAAWD,KAEnC,SAASge,aAAalf,MAClB,OAAOA,MAAQ,IAAMA,MAAQ,GAEjC,SAASmf,QAAQnf,MACb,OAAOkf,aAAalf,OACZA,KAAO,IAAMA,KAAO,IACrBA,OAAS2e,cAAcY,YACvBvf,OAAS2e,cAAclV,KAGlC,SAAS+V,mBAAmBhL,QACxB,MAAMzR,QAAEA,SAAYyR,OACpB,MAAO,CACHiL,QAAS1c,QAAQ,mBACjB2c,QAAS3c,QAAQ,mBACjBsc,OAAQtc,QAAQ,kBAAoB6b,SAAS7b,QAAQ,wBAAqB,EAC1Euc,MAAOvc,QAAQ,iBAAmB6b,SAAS7b,QAAQ,uBAAoB,GAM/E,SAAS4c,kBAAkBtc,KAAMiI,OACzBsU,cAAcvc,KAAMiI,QAAUA,MAAMuU,QAAQR,QAC5CS,OAAOzc,KAAMiI,MAAMuU,QAAQR,OAAQ/T,OAM3C,SAASyU,iBAAiB1c,KAAMiI,OACxBsU,cAAcvc,KAAMiI,QAAUA,MAAMuU,QAAQP,OAC5CQ,OAAOzc,KAAMiI,MAAMuU,QAAQP,MAAOhU,OAM1C,SAASsU,cAAcvc,KAAMiI,OACzB,MAAMuU,QAAEA,SAAYvU,MACpB,KAAKuU,QAAQJ,SAAYI,QAAQH,SAAYrc,KAAKe,MAASf,KAAKgB,YAC5D,OAAO,EAEX,IAAK,MAAMH,QAAQb,KAAKgB,WACpB,GAAIH,KAAKE,MAAQyb,QAAQH,QAAQ1J,SAAS9R,KAAKE,MAC3C,OAAO,EAGf,OAAO,EAKX,SAAS0b,OAAOzc,KAAMlB,OAAQmJ,OAC1B,MAAM0U,MAAQ,IACR9B,IAAEA,KAAQ5S,MAEhB,IAAK,MAAMpH,QAAQb,KAAKgB,WAChBH,KAAKE,MAAQF,KAAKI,QAClB0b,MAAM9b,KAAKE,KAAK8T,eAAiBhU,KAAKI,OAI9C,IAAK,MAAM5B,SAASP,OACK,iBAAVO,MACPoU,WAAWoH,IAAKxb,OAEXsd,MAAMtd,MAAM0B,QACjB0S,WAAWoH,IAAKxb,MAAM2c,QACtBd,WAAWyB,MAAMtd,MAAM0B,MAAOkH,OAC9BwL,WAAWoH,IAAKxb,MAAM4c,SAvJlC,SAAWX,eAEPA,cAAcA,cAAqB,MAAI,IAAM,QAE7CA,cAAcA,cAAmB,IAAI,IAAM,MAE3CA,cAAcA,cAA0B,WAAI,IAAM,aAElDA,cAAcA,cAAoB,KAAI,IAAM,OARhD,CASGA,gBAAkBA,cAAgB,KAmJrC,MAAMsB,aAAe,oBACfC,iBAAmB,IAAIC,IAAI,CAC7B,MAAO,QAAS,KAAM,QAAS,QAAS,QAAS,MAAO,MAAO,WAC/D,QAAS,WAAY,KAAM,SAAU,SAAU,KAAM,aAAc,MAAO,SAC1E,SAAU,OAAQ,QAAS,MAAO,QAAS,SAAU,OAAQ,OAAQ,UAEzE,SAASC,KAAKtd,KAAM0R,QAChB,MAAMlJ,MAAQ2S,gBAAgBzJ,QAG9B,OAFAlJ,MAAMuU,QAAUL,mBAAmBhL,QACnCuJ,KAAKjb,KAAMud,UAAW/U,OACfA,MAAM4S,IAAI5Z,MASrB,SAAS+b,UAAUhd,KAAMqG,MAAOqE,MAAOzC,MAAO9J,MAC1C,MAAM0c,IAAEA,IAAG1J,OAAEA,QAAWlJ,MAClBgV,OAASC,eAAeld,KAAMqG,MAAOqE,MAAOzC,OAE5CkL,MAAQgK,UAAUlV,OAGxB,GAFA4S,IAAI1H,OAASA,MACb8J,QAAUpJ,YAAYgH,KAAK,GACvB7a,KAAKe,KAAM,CACX,MAAMA,KAAOsT,QAAQrU,KAAKe,KAAMoQ,QAGhC,GAFAmL,kBAAkBtc,KAAMiI,OACxBwL,WAAWoH,QAAS9Z,QAChBf,KAAKgB,WACL,IAAK,MAAMH,QAAQb,KAAKgB,WAChBqa,sBAAsBxa,OACtBuc,cAAcvc,KAAMoH,OAIhC,IAAIjI,KAAKgL,aAAgBhL,KAAKsJ,SAAS5L,QAAWsC,KAAKiB,MAGlD,CAED,GADAwS,WAAWoH,IAAK,MACXwC,YAAYrd,KAAMiI,MAAO9J,MAAO,CACjC,GAAI6B,KAAKiB,MAAO,CACZ,MAAMqc,YAActd,KAAKiB,MAAMiK,KAAKqS,aAAeC,mBAAmBxd,KAAKiB,MAAOkQ,QAClFmM,aAAezJ,YAAY5L,MAAM4S,MAAOA,IAAI1H,OAC5C+H,WAAWlb,KAAKiB,MAAOgH,OACvBqV,aAAezJ,YAAY5L,MAAM4S,MAAOA,IAAI1H,OAGhD,GADAnT,KAAKsJ,SAAS2I,QAAQ9T,OACjB6B,KAAKiB,QAAUjB,KAAKsJ,SAAS5L,OAAQ,CACtC,MAAM4f,YAAcnM,OAAOzR,QAAQ,0BAC5ByR,OAAOzR,QAAQ,sBAAsBiT,SAAS3S,KAAKe,MAC1Duc,aAAezJ,YAAY5L,MAAM4S,MAAOA,IAAI1H,OAC5C+H,WAAWJ,MAAO7S,OAClBqV,aAAezJ,YAAY5L,MAAM4S,MAAOA,IAAI1H,QAGpDM,WAAWoH,SAAU9Z,SACrB2b,iBAAiB1c,KAAMiI,YArBvBwL,WAAWoH,OAAQ3Z,UAAUiQ,iBAwB3BkM,YAAYrd,KAAMiI,MAAO9J,OAAS6B,KAAKiB,QAE7Cia,WAAWlb,KAAKiB,MAAOgH,OACvBjI,KAAKsJ,SAAS2I,QAAQ9T,OAE1B,GAAI8e,QAAU5W,QAAUqE,MAAMhN,OAAS,GAAKuK,MAAMhC,OAAQ,CACtD,MAAMmN,OAAS2H,UAAU9S,MAAMhC,QAAU,EAAI,EAC7C4N,YAAYgH,IAAKA,IAAI1H,MAAQC,QAEjCyH,IAAI1H,OAASA,MAKjB,SAASiK,cAAcvc,KAAMoH,OACzB,MAAM4S,IAAEA,IAAG1J,OAAEA,QAAWlJ,MACxB,GAAIpH,KAAKE,KAAM,CACX,MAAMC,WAAamQ,OAAOzR,QAAQ,qBAC5B+d,YAActM,OAAOzR,QAAQ,sBACnC,IAAIqB,KAAEA,KAAIE,MAAEA,OAAUJ,KAClB6c,OAASnJ,UAAU1T,KAAMsQ,QAAQ,GACjCwM,OAASpJ,UAAU1T,KAAMsQ,QACzBnQ,aACAD,KAAO6c,cAAc7c,KAAMC,WAAYH,KAAKwB,WAAatB,MAE7DA,KAAOsQ,SAAStQ,KAAMoQ,QAClBA,OAAOzR,QAAQ,gBAAkBmB,KAAKwB,WACtCqb,OAAShZ,gBACTiZ,OAAS1K,eAEb,MAAM2G,OAAS6D,YACTG,cAAc/c,KAAKE,KAAM0c,YAAa5c,KAAKwB,UAC3C,KACN,GAAIuX,QAA2E,KAAhE3Y,MAAAA,WAAqC,EAASA,MAAMvD,SAAqC,iBAAbuD,MAAM,GAAiB,CAE9G,MAAM0W,IAAM1W,MAAM,GAClBA,MAAQ,CAAC4c,UAAUlG,QAAUiC,UAAUjC,SAAWiC,WAAWjC,SACzDxG,OAAOzR,QAAQ,iBACfge,OAAShZ,gBACTiZ,OAAS1K,eAGbuB,mBAAmB3T,KAAMsQ,UAAYlQ,MAIhCkQ,OAAOzR,QAAQ,2BAChBuB,MAAQ,CAACF,OAGPE,QACNA,MAAQ6Z,OAEZrH,WAAWoH,IAAK,IAAM9Z,MAClBE,OACAwS,WAAWoH,IAAK,IAAM6C,QACtBxC,WAAWja,MAAOgH,OAClBwL,WAAWoH,IAAK8C,SAEmC,SAA9CxM,OAAOzR,QAAQ,4BACpB+T,WAAWoH,IAAK,IAAM6C,OAASC,SAI3C,SAASN,YAAYrd,KAAMiI,MAAO9J,MAC9B,GAAI6B,KAAKiB,OAASjB,KAAKsJ,SAAS5L,OAAQ,CAGpC,MAAMogB,QAAU9d,KAAKiB,MAAM8c,UAAU9C,SACrC,IAAiB,IAAb6C,QAAgB,CAChB5C,WAAWlb,KAAKiB,MAAMzC,MAAM,EAAGsf,SAAU7V,OACzC,MAAMoL,KAAOpL,MAAM4S,IAAIxH,KACvB,IAAIxV,IAAMigB,QAAU,EAOpB,OANA9d,KAAKsJ,SAAS2I,QAAQ9T,MAElB8J,MAAM4S,IAAIxH,OAASA,MAAmC,iBAApBrT,KAAKiB,MAAMpD,MAC7C4V,WAAWxL,MAAM4S,IAAK7a,KAAKiB,MAAMpD,OAAOmgB,YAE5C9C,WAAWlb,KAAKiB,MAAMzC,MAAMX,KAAMoK,QAC3B,GAGf,OAAO,EAKX,SAASiV,eAAeld,KAAMqG,MAAOqE,MAAOzC,OACxC,MAAMkJ,OAAEA,OAAMlL,OAAEA,QAAWgC,MAC3B,IAAKkJ,OAAOzR,QAAQ,iBAChB,OAAO,EAEX,GAAc,IAAV2G,QAAgBJ,OAEhB,OAAO,EAGX,GAAIA,QAAU8U,UAAU9U,SAA4B,IAAjByE,MAAMhN,OACrC,OAAO,EAKX,GAAIqd,UAAU/a,MAAO,CAEjB,MAAMid,OAASlC,UAAUrQ,MAAMrE,MAAQ,KAAO0U,UAAUrQ,MAAMrE,MAAQ,KAE/DrG,KAAKiB,MAAMiK,KAAKqS,aAEfvd,KAAKiB,MAAMiK,KAAK+P,UAAYjb,KAAKsJ,SAAS5L,OAClD,GAAIuf,OACA,OAAO,EAGf,GAAIvI,SAAS1U,KAAMmR,QAAS,CAExB,GAAc,IAAV9K,OAEA,IAAK,IAAI8B,EAAI,EAAGA,EAAIuC,MAAMhN,OAAQyK,IAC9B,IAAKuM,SAAShK,MAAMvC,GAAIgJ,QACpB,OAAO,OAId,IAAKuD,SAAShK,MAAMrE,MAAQ,GAAI8K,QAEjC,OAAO,EAEX,GAAIA,OAAOzR,QAAQ,sBAAuB,CAEtC,IAAIue,eAAiB,EACjBjC,OAAS3V,MACT4V,MAAQ5V,MACZ,KAAO2U,gBAAgBtQ,QAAQsR,QAAS7K,SACpC8M,iBAEJ,KAAOjD,gBAAgBtQ,QAAQuR,OAAQ9K,SACnC8M,iBAEJ,GAAIA,gBAAkB9M,OAAOzR,QAAQ,sBACjC,OAAO,EAIf,IAAK,IAAIyI,EAAI,EAAGyL,GAAK5T,KAAKsJ,SAAS5L,OAAQyK,EAAIyL,GAAIzL,IAC/C,GAAI+U,eAAeld,KAAKsJ,SAASnB,GAAIA,EAAGnI,KAAKsJ,SAAUrB,OACnD,OAAO,EAGf,OAAO,EAEX,OAAO,EAKX,SAASkV,UAAUlV,OACf,MAAMkJ,OAAEA,OAAMlL,OAAEA,QAAWgC,MAC3B,OAAKhC,QAAU8U,UAAU9U,SAAYA,OAAOlF,MAAQoQ,OAAOzR,QAAQ,qBAAqBiT,SAAS1M,OAAOlF,MAC7F,EAEJ,EAKX,SAASwc,WAAWtc,OAChB,MAAwB,iBAAVA,OAAsB,QAAQ7B,KAAK6B,OAKrD,SAASuc,mBAAmBvc,MAAOkQ,QAC/B,GAAIlQ,MAAMvD,QAA8B,iBAAbuD,MAAM,GAAiB,CAC9C,MAAMid,QAAUtB,aAAauB,KAAKld,MAAM,IACxC,IAAKid,MAAAA,aAAyC,EAASA,QAAQxgB,UAAYyT,OAAOzR,QAAwB,eAAEiT,SAASuL,QAAQ,GAAGzJ,eAC5H,OAAO,EAGf,OAAO,EAEX,SAASmJ,cAAcQ,IAAKnF,KAAM5W,UAC9B,OAAQA,UAAY4W,QAAQmF,SAAYnF,KAAKmF,KAEjD,SAASP,UAAU9c,MACf,OAAQ8b,iBAAiBwB,IAAItd,OAAS,sBAAsB3B,KAAK2B,MAGrE,SAASud,aAAa7e,KAAM0R,OAAQzR,SAChC,MAAMuI,MAAQ2S,gBAAgBzJ,QAG9B,OAFAlJ,MAAMvI,QAAUA,SAAW,GAC3Bgb,KAAKjb,KAAM4Y,QAASpQ,OACbA,MAAM4S,IAAI5Z,MASrB,SAASoX,QAAQrY,KAAMqG,MAAOqE,MAAOzC,MAAO9J,MACxC,MAAM0c,IAAEA,IAAGnb,QAAEA,SAAYuI,OACnBsW,QAAEA,QAAOC,UAAEA,WAAcC,kBAAkBze,MAE3CmT,MAAQlL,MAAMhC,OAAS,EAAI,EACjC4U,IAAI1H,OAASA,MAETuL,aAAa1e,KAAMqG,MAAOqE,MAAOzC,QACjC4L,YAAYgH,KAAK,IAEjB7a,KAAKe,MAAuB,QAAdf,KAAKe,MAAmBwd,QAAQ7gB,QAC9C+V,WAAWoH,KAAMnb,QAAQif,YAAc,IAAM3e,KAAKe,MAAQrB,QAAQkf,WAAa,KAEnFC,sBAAsBN,QAAStW,OAC/B6W,wBAAwBN,UAAUrV,OAAOkS,uBAAwBpT,QAC7DjI,KAAKgL,aAAgBhL,KAAKiB,OAAUjB,KAAKsJ,SAAS5L,QAMlDqhB,UAAU/e,KAAMiI,OAChBjI,KAAKsJ,SAAS2I,QAAQ9T,OANlB8J,MAAMvI,QAAQwB,WACduS,WAAWoH,IAAK5S,MAAMvI,QAAQwB,WAOtC2Z,IAAI1H,OAASA,MAOjB,SAASsL,kBAAkBze,MACvB,MAAMue,QAAU,GACVC,UAAY,GAClB,GAAIxe,KAAKgB,WACL,IAAK,MAAMH,QAAQb,KAAKgB,WAChBge,mBAAmBne,MACnB0d,QAAQne,KAAKS,MAGb2d,UAAUpe,KAAKS,MAI3B,MAAO,CAAE0d,QAAAA,QAASC,UAAAA,WAKtB,SAASK,sBAAsBlC,MAAO1U,OAClC,IAAK,MAAMpH,QAAQ8b,MACf,GAAI9b,KAAKI,MACL,GAAkB,UAAdJ,KAAKE,KAAkB,CACvB0S,WAAWxL,MAAM4S,IAAK,KAEtB,MAAM/b,OAAS+B,KAAKI,MAAM4U,IAAInE,GAAkB,iBAANA,EAAiBA,EAAEuN,QAAQ,OAAQ,KAAOvN,GACpFwJ,WAAWpc,OAAQmJ,YAInBwL,WAAWxL,MAAM4S,IAAK,KACtBK,WAAWra,KAAKI,MAAOgH,OAQvC,SAAS6W,wBAAwBnC,MAAO1U,OACpC,GAAI0U,MAAMjf,OAAQ,CACd,MAAMmd,IAAEA,IAAG1J,OAAEA,OAAMzR,QAAEA,SAAYuI,MACjCvI,QAAQwf,iBAAmBzL,WAAWoH,IAAKnb,QAAQwf,iBACnD,IAAK,IAAI/W,EAAI,EAAGA,EAAIwU,MAAMjf,OAAQyK,IAAK,CACnC,MAAMtH,KAAO8b,MAAMxU,GACnBsL,WAAWoH,IAAKxJ,SAASxQ,KAAKE,MAAQ,GAAIoQ,SACtCqD,mBAAmB3T,KAAMsQ,UAAYtQ,KAAKI,OACrCkQ,OAAOzR,QAAQ,0BAA4BA,QAAQyf,cACpD1L,WAAWoH,IAAK,IAAMnb,QAAQyf,eAIlC1L,WAAWoH,IAAK,IAAMtG,UAAU1T,KAAMsQ,QAAQ,IAC9C+J,WAAWra,KAAKI,OAAS6Z,MAAO7S,OAChCwL,WAAWoH,IAAKtG,UAAU1T,KAAMsQ,UAEhChJ,IAAMwU,MAAMjf,OAAS,GAAKgC,QAAQ0f,eAClC3L,WAAWoH,IAAKnb,QAAQ0f,eAGhC1f,QAAQ2f,gBAAkB5L,WAAWoH,IAAKnb,QAAQ2f,iBAM1D,SAASN,UAAU/e,KAAMiI,OAErB,IAAKjI,KAAKiB,OAASjB,KAAKsJ,SAAS5L,OAC7B,OAEJ,MAAMuD,MAAQjB,KAAKiB,OAAS6Z,MACtBpH,MAAQ0H,aAAana,QACrB4Z,IAAEA,IAAGnb,QAAEA,SAAYuI,MACzB,GAAqB,IAAjByL,MAAMhW,QACFsC,KAAKe,MAAQf,KAAKgB,aAClBZ,KAAKya,IAAK,KAEdK,WAAWja,MAAOgH,WAEjB,CAGD,MAAMqX,YAAc,GACpB,IAAIC,UAAY,EAEhB,IAAK,MAAMlM,QAAQK,MAAO,CACtB,MAAM6D,IAAMiI,YAAYnM,MACxBiM,YAAYlf,KAAKmX,KACbA,IAAMgI,YACNA,UAAYhI,KAIpBsD,IAAI1H,QACJ,IAAK,IAAIhL,EAAI,EAAGA,EAAIuL,MAAMhW,OAAQyK,IAC9B0L,YAAYgH,KAAK,GACjBnb,QAAQ+f,gBAAkBrf,KAAKya,IAAKnb,QAAQ+f,gBAC5CvE,WAAWxH,MAAMvL,GAAIF,OACjBvI,QAAQggB,gBACRtf,KAAKya,IAAK,IAAIla,OAAO4e,UAAYD,YAAYnX,KAC7C/H,KAAKya,IAAKnb,QAAQggB,gBAG1B7E,IAAI1H,SAGZ,SAAS6L,mBAAmBne,MACxB,MAAqB,UAAdA,KAAKE,MAAkC,OAAdF,KAAKE,KAKzC,SAASye,YAAY1gB,QACjB,IAAIyY,IAAM,EACV,IAAK,MAAMlY,SAASP,OAChByY,KAAwB,iBAAVlY,MAAqBA,MAAM3B,OAAS2B,MAAM0B,KAAKrD,OAEjE,OAAO6Z,IAEX,SAASmH,aAAa1e,KAAMqG,MAAOqE,MAAOzC,OAEtC,SAAKA,MAAMhC,QAAoB,IAAVI,SAGb0U,UAAU/a,MAGtB,SAAS2f,KAAKlgB,KAAM0R,QAChB,OAAOmN,aAAa7e,KAAM0R,OAAQ,CAC9BwN,WAAY,IACZO,gBAAiB,IACjBG,eAAgB,IAChBD,cAAe,IACfM,cAAe,KACfP,aAAc,OACdje,UAAW,MAInB,SAAS0e,KAAKngB,KAAM0R,QAChB,OAAOmN,aAAa7e,KAAM0R,OAAQ,CAC9B+N,gBAAiB,IACjBE,cAAe,IACfK,eAAgB,KAChBve,UAAW,MAInB,SAAS2e,IAAIpgB,KAAM0R,QACf,OAAOmN,aAAa7e,KAAM0R,OAAQ,CAC9B+N,gBAAiB,IACjBG,eAAgB,IAChBD,cAAe,KACfK,eAAgB,KAChBve,UAAyD,QAA9CiQ,OAAOzR,QAAQ,2BAAuC,IAAM,KAI/E,MAAMogB,WAAa,CAAE/C,KAAAA,KAAM4C,KAAAA,KAAMC,KAAAA,KAAMC,IAAAA,KAKvC,SAASE,QAAQtgB,KAAM0R,QACnB,IAAI6O,aACJ,GAAoB,iBAATvgB,KAAmB,CAC1B,MAAMwgB,SAAWzV,OAAOC,OAAO,GAAI0G,QAC/BA,OAAOzR,QAAQ,iBACfugB,SAAS3d,KAAM,GAEf6O,OAAOzR,QAAQ,iBACfugB,SAAS7V,MAAO,GAEpB3K,KAAOuM,kBAAkBvM,KAAMwgB,UAG/BD,aAAe7O,OAAO7P,KACtB6P,OAAO7P,UAAOsI,EASlB,OAFAiI,OADApS,KAAO4S,gBAAgB5S,KAAM0R,QAChB+O,UAAW/O,QACxBA,OAAO7P,KAAO0e,MAAAA,aAAmDA,aAAe7O,OAAO7P,KAChF7B,KAKX,SAAS0gB,UAAU1gB,KAAM0R,QACrB,MAAMiP,UAAYN,WAAW3O,OAAOkP,SAAWtD,KAC/C,OAAOqD,UAAU3gB,KAAM0R,QAK3B,SAAS+O,UAAUlgB,KAAM+R,UAAWZ,QAChC2E,YAAY9V,KAAM+R,UAAWZ,QAC7BD,gBAAgBlR,KAAMmR,QACtBwF,MAAM3W,KAAM+R,UAAWZ,QACD,QAAlBA,OAAOkP,QACP/H,IAAItY,MAEY,WAAhBmR,OAAOtR,MACP0a,MAAMva,MAENmR,OAAOzR,QAAQ,gBACfoZ,IAAI9Y,KAAM+R,UAAWZ,QAI7B,IAAImP,gBACJ,SAAWA,gBACPA,eAAoB,IAAI,MACxBA,eAAyB,SAAI,WAFjC,CAGGA,iBAAmBA,eAAiB,KACvC,MAAMC,WAAa,wCACbC,IAAM,CAAEvf,OAAO,GAIrB,SAASwf,cAAcrC,IAAKnd,OAIxB,MAAM2V,EAAI3V,MAAMlD,MAAMwiB,YACtB,GAAI3J,EAAG,CACH,MAAM8J,SAAW,GACXC,OAAS/J,EAAE,GAAKA,EAAE,GAAGhC,MAAM,KAAKiB,IAAI+K,YAAc,GACxD,IAAK,MAAM7U,QAAQ4U,OACf,IAAK,MAAME,UAAU9U,KACjB+U,gBAAgBD,OAAQH,UAGhC,MAAO,CACH7gB,KAAMygB,eAAeS,SACrB3C,IAAAA,IACA3O,SAAUmH,EAAE,GACZ3V,MAAO0f,OACPD,SAAAA,SACAM,aAAc,IAGtB,MAAO,CAAEnhB,KAAMygB,eAAeW,IAAK7C,IAAAA,IAAKnd,MAAAA,OAM5C,SAASigB,KAAKxO,UACVA,SAAWA,SAASlU,QAAQ2iB,KAAKC,cACjC,MAAMnhB,MAAQ,GACd,IAAI4E,KAIJ,IAAK,MAAMwc,OAAO3O,SAASvJ,OAAOmY,YAAa,CAI3C,KAAOrhB,MAAMvC,QAAQ,CAEjB,GADAmH,KAAO5E,MAAMA,MAAMvC,OAAS,GACxB2jB,IAAI5R,SAAS7D,WAAW/G,KAAK4K,WACwB,KAAlD4R,IAAI5R,SAAS3R,WAAW+G,KAAK4K,SAAS/R,QAAwB,CACjEmH,KAAKmc,aAAa5gB,KAAKihB,KACvBphB,MAAMG,KAAKihB,KACX,MAEJphB,MAAMO,MAELP,MAAMvC,QACPuC,MAAMG,KAAKihB,KAGnB,OAAO3O,SAKX,SAAS0O,aAAahT,EAAGD,GACrB,OAAIC,EAAEgQ,MAAQjQ,EAAEiQ,IACL,EAEJhQ,EAAEgQ,IAAMjQ,EAAEiQ,KAAO,EAAI,EAEhC,SAASwC,WAAW3f,OAChB,OAAOgQ,QAAQhQ,MAAMoI,OAAQmX,KAAK,GAAGvf,MAEzC,SAASqgB,WAAW7O,SAChB,OAAOA,QAAQ5S,OAASygB,eAAeS,SAE3C,SAASD,gBAAgBD,OAAQlP,MAC7B,IAAK,MAAM4P,KAAKV,OAAO5f,MACnB,GAAe,YAAXsgB,EAAE1hB,KACF8R,KAAK4P,EAAEtgB,OAASsgB,OAEf,GAAe,iBAAXA,EAAE1hB,KACP8R,KAAK4P,EAAExgB,MAAQwgB,OAEd,GAAe,UAAXA,EAAE1hB,KAAkB,CAEzB,MAAMoB,MAAQsgB,EAAExgB,KAAKsI,OACjBpI,QACA0Q,KAAK1Q,OAAS,CAAEpB,KAAM,UAAWoB,MAAAA,SAgBjD,SAASugB,WAAWC,KAAMC,KAAMC,cAAe,GAG3C,IAFAF,KAAOA,KAAKhN,kBACZiN,KAAOA,KAAKjN,eAER,OAAO,EAGX,IAAKgN,OAASC,MAAQD,KAAK3jB,WAAW,KAAO4jB,KAAK5jB,WAAW,GACzD,OAAO,EAEX,MAAM8jB,QAAUH,KAAK/jB,OACfmkB,QAAUH,KAAKhkB,OACrB,IAAKikB,cAAgBC,QAAUC,QAC3B,OAAO,EAWX,MAAMC,UAAYtZ,KAAKiP,IAAImK,QAASC,SAC9BtC,UAAY/W,KAAKC,IAAImZ,QAASC,SACpC,IAAI1Z,EAAI,EACJ4Z,EAAI,EACJC,MAAQzC,UACR0C,IAAM,EACNC,IAAM,EACNC,OAAQ,EACRC,SAAU,EACd,KAAOja,EAAIyZ,SAAS,CAIhB,IAHAK,IAAMR,KAAK3jB,WAAWqK,GACtBga,OAAQ,EACRC,SAAU,EACHL,EAAIF,SAAS,CAEhB,GAAII,OADJC,IAAMR,KAAK5jB,WAAWikB,IACL,CACbI,OAAQ,EACRH,OAASzC,WAAa6C,QAAUja,EAAI4Z,GACpC,MAGJK,QAAkB,KAARF,IACVH,IAEJ,IAAKI,MAAO,CACR,IAAKR,aACD,OAAO,EAEX,MAEJxZ,IAEJ,MAAMka,WAAala,EAAIoX,UACjB+C,MAAQ/C,UAAYuC,UACpBS,SAAWC,IAAIjD,WAAaiD,IAAIF,OACtC,OAAQN,MAAQK,WAAcE,SAKlC,SAASC,IAAIlkB,GACT,OAAOA,GAAKA,EAAI,GAAK,EAGzB,SAASsP,MAAMvO,MAAOojB,UAClB,OAAKpjB,MAAM4O,GAAM5O,MAAM6O,GAAM7O,MAAM8O,GAAM9O,MAAM+O,EAG1B,IAAZ/O,MAAM+O,EACJsU,MAAMrjB,MAAOojB,UAEjBE,MAAMtjB,OALF,cAWf,SAASqjB,MAAMrjB,MAAOmN,OAClB,MAAMsF,GAAMtF,OAASoW,WAAWvjB,MAAM4O,IAAM2U,WAAWvjB,MAAM6O,IAAM0U,WAAWvjB,MAAM8O,GAC9E0U,WAAaC,MACnB,MAAO,IAAMhR,GAAGzS,MAAM4O,GAAK6D,GAAGzS,MAAM6O,GAAK4D,GAAGzS,MAAM8O,GAKtD,SAASwU,MAAMtjB,OACX,MAAM0jB,OAAS,CAAC1jB,MAAM4O,EAAG5O,MAAM6O,EAAG7O,MAAM8O,GAIxC,OAHgB,IAAZ9O,MAAM+O,GACN2U,OAAO3iB,KAAK4iB,KAAK3jB,MAAM+O,EAAG,OAEF,IAAlB2U,OAAOrlB,OAAe,MAAQ,UAAUqlB,OAAOlZ,KAAK,SAElE,SAASmZ,KAAKC,IAAKC,OAAS,GACxB,OAAOD,IAAIE,QAAQD,QAAQjE,QAAQ,SAAU,IAEjD,SAAS2D,WAAWQ,KAChB,QAASA,IAAM,IAEnB,SAASP,WAAWI,KAChB,OAAQA,KAAO,GAAGI,SAAS,IAE/B,SAASP,MAAMG,KACX,OAAOK,IAAIL,IAAII,SAAS,IAAK,GAEjC,SAASC,IAAIriB,MAAOsW,KAChB,KAAOtW,MAAMvD,OAAS6Z,KAClBtW,MAAQ,IAAMA,MAElB,OAAOA,MAGX,MAAMsiB,qBAAuB,CAEzBC,OAAQ,WAERC,QAAS,YAET1C,SAAU,aAEV2C,MAAO,WAEX,SAASC,IAAIlkB,KAAM0R,QACf,IAAIxH,GACJ,MAAMkR,IAAM3H,mBAAmB/B,OAAOzR,SAChCud,OAAS9L,OAAOzR,QAAQ,kBACC,QAAzBiK,GAAKwH,OAAOnO,eAA4B,IAAP2G,QAAgB,EAASA,GAAG5I,QAAUwiB,qBAAqBE,UAE9FhkB,KAAOA,KAAK0J,OAAOnJ,MAAQA,KAAKyS,UAEpC,IAAK,IAAItK,EAAI,EAAGA,EAAI1I,KAAK/B,OAAQyK,IACzB8U,QAAgB,IAAN9U,GACV0L,YAAYgH,KAAK,GAErBpL,SAAShQ,KAAK0I,GAAI0S,IAAK1J,QAE3B,OAAO0J,IAAI5Z,MAKf,SAASwO,SAASzP,KAAM6a,IAAK1J,QACzB,MAAMyS,OAASzS,OAAOzR,QAAQ,mBAC9B,GAAIM,KAAKe,KAAM,CAEX,MAAMA,KAAO6iB,OAASC,YAAY7jB,KAAKe,MAAQf,KAAKe,KACpD0S,WAAWoH,IAAK9Z,KAAOoQ,OAAOzR,QAAQ,uBAClCM,KAAKiB,MAAMvD,OACXomB,cAAc9jB,KAAM6a,IAAK1J,QAGzB+C,UAAU2G,IAAK,EAAG,IAElB+I,OAGAxjB,KAAKya,IAAK,MAGVkJ,gBAAgB/jB,KAAM6a,KAAK,GAC3Bza,KAAKya,IAAK1J,OAAOzR,QAAQ,0BAG5B,CAED,IAAK,MAAMmhB,UAAU7gB,KAAKiB,MACtB,IAAK,MAAMsgB,KAAKV,OAAO5f,MACnB+iB,YAAYzC,EAAG1G,IAAK1J,QAG5B4S,gBAAgB/jB,KAAM6a,IAAK7a,KAAKiB,MAAMvD,OAAS,IAGvD,SAASomB,cAAc9jB,KAAM6a,IAAK1J,QAC9B,MAAMyS,OAASzS,OAAOzR,QAAQ,mBACxBujB,IAAMW,OAASK,iBAAiBjkB,MAAQ,KAC9C,IAAIijB,KAASA,IAAIxV,MAAqB,OAAbwV,IAAIxV,KAKxB,CACD,MAAM9K,MAAQuhB,SAAS/S,QACvByS,QAAUxjB,KAAKya,IAAKlY,OACpB,IAAK,IAAIwF,EAAI,EAAGA,EAAInI,KAAKiB,MAAMvD,OAAQyK,IACzB,IAANA,GACA/H,KAAKya,IAAK,MAEdsJ,YAAYnkB,KAAKiB,MAAMkH,GAAI0S,IAAK1J,QAEpCyS,QAAUxjB,KAAKya,IAAKlY,YAXpBvC,KAAKya,IAAKlS,OAAOsa,IAAIhiB,QAc7B,SAAS8iB,gBAAgB/jB,KAAM6a,IAAKuJ,WAC5BpkB,KAAK4P,YACDwU,WACAhkB,KAAKya,IAAK,KAEdza,KAAKya,IAAK,eAGlB,SAASsJ,YAAYljB,MAAO4Z,IAAK1J,QAC7B,IAAK,IAAIhJ,EAAI,EAAGkc,SAAW,EAAGlc,EAAIlH,MAAMA,MAAMvD,OAAQyK,IAAK,CACvD,MAAM9I,MAAQ4B,MAAMA,MAAMkH,GAGhB,IAANA,GAA2B,UAAf9I,MAAMQ,MAAoBR,MAAM7B,QAAU6mB,SACtDjkB,KAAKya,IAAK,KAEdmJ,YAAY3kB,MAAOwb,IAAK1J,QACxBkT,QAAUhlB,MAAW,KAG7B,SAAS2kB,YAAY3kB,MAAOwb,IAAK1J,QAC7B,GAAmB,eAAf9R,MAAMQ,KACNO,KAAKya,IAAKjN,MAAMvO,MAAO8R,OAAOzR,QAAQ,8BAErC,GAAmB,YAAfL,MAAMQ,MAAqC,mBAAfR,MAAMQ,KACvC4T,WAAWoH,IAAKxb,MAAM4B,YAErB,GAAmB,gBAAf5B,MAAMQ,KACX4T,WAAWoH,IAAKmI,KAAK3jB,MAAM4B,MAAO,GAAK5B,MAAMoO,WAE5C,GAAmB,gBAAfpO,MAAMQ,KAAwB,CACnC,MAAM8C,MAAwB,WAAhBtD,MAAMsD,MAAqB,IAAM,IAC/C8Q,WAAWoH,IAAKlY,MAAQtD,MAAM4B,MAAQ0B,YAErC,GAAmB,UAAftD,MAAMQ,KACXqU,UAAU2G,IAAKxb,MAAMgH,MAAOhH,MAAM0B,WAEjC,GAAmB,iBAAf1B,MAAMQ,KAAyB,CACpCO,KAAKya,IAAKxb,MAAM0B,KAAO,KACvB,IAAK,IAAIoH,EAAI,EAAGA,EAAI9I,MAAMoR,UAAU/S,OAAQyK,IACpCA,GACA/H,KAAKya,IAAK,MAEdsJ,YAAY9kB,MAAMoR,UAAUtI,GAAI0S,IAAK1J,QAEzC/Q,KAAKya,IAAK,MAMlB,SAASoJ,iBAAiBjkB,MACtB,GAA0B,IAAtBA,KAAKiB,MAAMvD,OAAc,CACzB,MAAMmjB,OAAS7gB,KAAKiB,MAAM,GAC1B,GAA4B,IAAxB4f,OAAO5f,MAAMvD,QAAyC,gBAAzBmjB,OAAO5f,MAAM,GAAGpB,KAC7C,OAAOghB,OAAO5f,MAAM,IAOhC,SAAS4iB,YAAYtmB,KACjB,OAAOA,IAAI0hB,QAAQ,UAAW,CAACqF,EAAGC,SAAWA,OAAO1P,eAExD,SAASqP,SAAS/S,QACd,OAAOA,OAAOzR,QAAQ,+BAAiC,IAAM,IAGjE,MAAM8kB,aAAe,KAKrB,SAASC,MAAMhlB,KAAM0R,QACjB,IAAIxH,GACJ,MAAM+I,UAAoC,QAAvB/I,GAAKwH,OAAOuT,aAA0B,IAAP/a,QAAgB,EAASA,GAAGgb,qBAAuBC,gBAAgBzT,OAAOuB,UACtH/S,OAAS,GACXwR,OAAOuT,QACPvT,OAAOuT,MAAMC,mBAAqBjS,UAElB,iBAATjT,OACPA,KAAOwR,QAAQxR,KAAM,CAAEwB,MAAO4jB,aAAa1T,WAE/C,MAAM2T,iBAAmBC,oBAAoBrS,SAAUvB,QACvD,IAAK,MAAMnR,QAAQP,KAAM,CACrB,MAAMuT,SAAWgS,YAAYhlB,KAAM8kB,iBAAkB3T,QACjD6B,UACArT,OAAOS,KAAK4S,UAGpB,OAAOrT,OAKX,SAASilB,gBAAgBlS,UACrB,MAAM/S,OAAS,GACf,IAAK,MAAMye,OAAO5T,OAAOya,KAAKvS,UAC1B/S,OAAOS,KAAKqgB,cAAcrC,IAAK1L,SAAS0L,OAE5C,OAAO8C,KAAKvhB,QAMhB,SAASqlB,YAAYhlB,KAAM0S,SAAUvB,QACjC,IAAK+T,gBAAgBllB,KAAMmR,QAAS,CAChC,MAAM6Q,MAAQ7Q,OAAOzR,QAAQ,kCAC7B,GAAImlB,aAAa1T,QAAS,CAEtB,MAAMgU,SAAWhU,OAAOnO,QAAQjC,KAC1B0R,QAAUC,SAAS5G,KAAK1C,GAAKA,EAAEvJ,OAASygB,eAAeS,UAAY3X,EAAEqG,WAAa0V,UACxFC,qBAAqBplB,KAAMmR,OAAQsB,QAASuP,OAC5ChiB,KAAKyS,QAAUA,aAEd,GAAIzS,KAAKe,KAAM,CAChB,MAAM0R,QAAU4S,cAAcrlB,KAAKe,KAAM2R,SAAUsP,OAAO,GAE1D,GADAhiB,KAAKyS,QAAUA,QACXA,QAAS,CACT,MAAMO,SAAWP,QAAQ5S,OAASygB,eAAeS,SAC3CuE,kBAAkBtlB,KAAMyS,QAAStB,QACjCoU,iBAAiBvlB,KAAMyS,SAC7B,GAAIO,SACAhT,KAAOgT,cAEN,GAAI7B,OAAOzR,QAAQ,0BACpB,OAAO,OASvB,OAJIM,KAAKe,MAAQoQ,OAAOnO,UAEpBwiB,oBAAoBxlB,KAAMmR,QAEvBnR,KAKX,SAASklB,gBAAgBllB,KAAMmR,QAC3B,IAAIsU,WAAa,KACjB,MAAM5E,OAA+B,IAAtB7gB,KAAKiB,MAAMvD,OAAesC,KAAKiB,MAAM,GAAK,KACzD,GAAI4f,QAAkC,IAAxBA,OAAO5f,MAAMvD,OAAc,CACrC,MAAM6jB,EAAIV,OAAO5f,MAAM,GACR,iBAAXsgB,EAAE1hB,MAA2B0hB,EAAExgB,OAASyjB,eACxCiB,WAAalE,GAGrB,SAAIkE,YAAczlB,KAAKe,OAASyjB,gBASxBiB,WARCA,WAQYjb,OAAOC,OAAOD,OAAOC,OAAO,GAAIgb,YAAa,CAAE1kB,KAAM,oBAPrD,CACTlB,KAAM,eACNkB,KAAM,kBACN0P,UAAW,CAACiV,SAAStR,MAAM,EAAG,OAMjCjD,OAAOnO,UACRhD,KAAKe,KAAO,oBAEhBf,KAAKiB,MAAQ,CAACykB,SAASD,cAChB,GAOf,SAASH,kBAAkBtlB,KAAMyS,QAAStB,QACtC,MAAM1R,KAAOO,KAAKe,KAOZ4kB,YAAcC,iBAAiBnmB,KAAMgT,QAAQ2L,KACnD,GAAIuH,YAAa,CACb,GAAI3lB,KAAKiB,MAAMvD,OAEX,OAAO,KAEX,MAAMmoB,GAAKC,eAAeH,YAAaxU,OAAQsB,SAC/C,IAAKoT,GACD,OAAO,KAEX7lB,KAAKiB,MAAMb,KAAKslB,SAASG,KAG7B,GADA7lB,KAAKe,KAAO0R,QAAQhD,SAChBzP,KAAKiB,MAAMvD,OAEX0nB,qBAAqBplB,KAAMmR,OAAQsB,cAElC,GAAIA,QAAQxR,MAAMvD,OAAQ,CAC3B,MAAMqoB,aAAetT,QAAQxR,MAAM,GAInCjB,KAAKiB,MAAiC,IAAzBwR,QAAQxR,MAAMvD,QAAgBqoB,aAAa7a,KAAK8a,UACvDD,aACAA,aAAalQ,IAAIvX,GAAK2nB,cAAc3nB,EAAG6S,SAEjD,OAAOnR,KAEX,SAASolB,qBAAqBplB,KAAMmR,OAAQsB,QAASyT,UACjD,IAAK,MAAMrF,UAAU7gB,KAAKiB,MAAO,CAC7B,MAAMA,MAAQ,GACd,IAAK,MAAM5B,SAASwhB,OAAO5f,MACvB,GAAmB,YAAf5B,MAAMQ,KACNoB,MAAMb,KAAK0lB,eAAezmB,MAAM4B,MAAOkQ,OAAQsB,QAASyT,WAAa7mB,YAEpE,GAAmB,iBAAfA,MAAMQ,KAAyB,CAGpC,MAAM9B,MAAQ+nB,eAAezmB,MAAM0B,KAAMoQ,OAAQsB,QAASyT,UACtDnoB,OAAwB,iBAAfA,MAAM8B,KACfoB,MAAMb,KAAKoK,OAAOC,OAAOD,OAAOC,OAAO,GAAI1M,OAAQ,CAAE0S,UAAWpR,MAAMoR,UAAU9O,OAAO5D,MAAM0S,UAAUjS,MAAMa,MAAMoR,UAAU/S,YAG7HuD,MAAMb,KAAKf,YAIf4B,MAAMb,KAAKf,OAGnBwhB,OAAO5f,MAAQA,OAMvB,SAASskB,iBAAiBvlB,KAAMyS,SAI5B,IAAIW,OAAS,EACTwD,EACJ,MAAMuP,QAAU,wBACVC,WAAapmB,KAAKiB,MAAM,GACxBkjB,YAAc,GACpB,KAAOvN,EAAIuP,QAAQhI,KAAK1L,QAAQxR,QACxBmS,SAAWwD,EAAEvQ,OACb8d,YAAY/jB,KAAKimB,QAAQ5T,QAAQxR,MAAMzC,MAAM4U,OAAQwD,EAAEvQ,SAE3D+M,OAASwD,EAAEvQ,MAAQuQ,EAAE,GAAGlZ,OACpB0oB,YAAcA,WAAWnlB,MAAMvD,OAC/BymB,YAAY/jB,KAAKgmB,WAAWnlB,MAAMuK,SAGlC2Y,YAAY/jB,KAAKgU,MAAMvO,OAAO+Q,EAAE,IAAKA,EAAE,GAAKA,EAAE,GAAGpY,MAAM,GAAK,KAGpE,MAAM8nB,KAAO7T,QAAQxR,MAAMzC,MAAM4U,QAMjC,OALIkT,MACAnC,YAAY/jB,KAAKimB,QAAQC,OAE7BtmB,KAAKe,UAAO,EACZf,KAAKiB,MAAQ,CAACykB,YAAYvB,cACnBnkB,KAQX,SAASqlB,cAAc5lB,KAAMiL,MAAOwb,SAAW,EAAGvE,cAAe,GAC7D,IAAI4E,YAAc,KACdhE,SAAW,EACf,IAAK,MAAMxW,QAAQrB,MAAO,CACtB,MAAMsX,MAAQR,WAAW/hB,KAAM+mB,eAAeza,MAAO4V,cACrD,GAAc,IAAVK,MAEA,OAAOjW,KAEPiW,OAASA,OAASO,WAClBA,SAAWP,MACXuE,YAAcxa,MAGtB,OAAOwW,UAAY2D,SAAWK,YAAc,KAEhD,SAASC,eAAeza,MACpB,MAAuB,iBAATA,KAAoBA,KAAOA,KAAKqS,IAOlD,SAASwH,iBAAiBnmB,KAAMlC,KAC5B,IAAK,IAAI4K,EAAI,EAAGse,QAAU,EAAGte,EAAI1I,KAAK/B,OAAQyK,IAAK,CAE/C,IAAiB,KADjBse,QAAUlpB,IAAI+b,QAAQ7Z,KAAK0I,GAAIse,UAE3B,OAAOhnB,KAAKjB,MAAM2J,GAEtBse,UAEJ,MAAO,GAMX,SAASX,eAAeD,GAAI1U,OAAQsB,QAASyT,UACzC,IAAIQ,IACJ,GAAIjU,QAAS,CACT,GAAIiU,IAAMrB,cAAcQ,GAAIrb,OAAOya,KAAKxS,QAAQiO,UAAWwF,UACvD,OAAOzT,QAAQiO,SAASgG,KAE5B,IAAK,MAAMC,OAAOlU,QAAQuO,aACtB,GAAI0F,IAAMrB,cAAcQ,GAAIrb,OAAOya,KAAK0B,IAAIjG,UAAWwF,UACnD,OAAOS,IAAIjG,SAASgG,KAIhC,OAAIA,IAAMrB,cAAcQ,GAAI1U,OAAOzR,QAAQ,uBAAwBwmB,WACxDG,QAAQK,KAEZ,KAKX,SAASlB,oBAAoBxlB,KAAMmR,QAC/B,MAAMyV,QAAUzV,OAAOzR,QAAQ,0BACzBmnB,SAAW1V,OAAOzR,QAAQ,uBAChC,IAAK,MAAM6hB,KAAKvhB,KAAKiB,MACjB,IAAK,MAAMyQ,KAAK6P,EAAEtgB,MACC,gBAAXyQ,EAAE7R,OACE6R,EAAEjE,KACFiE,EAAEjE,KAAOmZ,QAAQlV,EAAEjE,OAASiE,EAAEjE,KAEb,IAAZiE,EAAEzQ,OAAgB4lB,SAASlU,SAAS3S,KAAKe,QAC9C2Q,EAAEjE,KAAOiE,EAAEnE,SAASoF,SAAS,KACvBxB,OAAOzR,QAAQ,wBACfyR,OAAOzR,QAAQ,wBASzC,SAASgmB,YAAYnV,MACjB,MAAO,CACH1Q,KAAM,WACNoB,MAAOsP,MAMf,SAAS8V,QAAQplB,OACb,MAAO,CAAEpB,KAAM,UAAWoB,MAAAA,OAK9B,SAASmT,MAAM/N,MAAOtF,MAClB,MAAO,CAAElB,KAAM,QAASwG,MAAAA,MAAOtF,KAAAA,MAKnC,SAASilB,SAAS/kB,OACd,IAAK,MAAMsgB,KAAKtgB,MAAMA,MAClB,GAAe,UAAXsgB,EAAE1hB,MAAgC,iBAAX0hB,EAAE1hB,MAA2B0hB,EAAE9Q,UAAUvF,KAAK8a,UACrE,OAAO,EAGf,OAAO,EAKX,SAASC,cAAcjmB,KAAMmR,OAAQlJ,MAAQ,CAAE5B,MAAO,IAClD,IAAIpF,MAAQ,GACZ,IAAK,MAAMsgB,KAAKvhB,KAAKiB,MACjB,OAAQsgB,EAAE1hB,MACN,IAAK,aACDoB,MAAMb,KAAKgU,MAAMnM,MAAM5B,QAASuH,MAAM2T,EAAGpQ,OAAOzR,QAAQ,0BACxD,MACJ,IAAK,UACDuB,MAAMb,KAAKgU,MAAMnM,MAAM5B,QAASkb,EAAEtgB,QAClC,MACJ,IAAK,cACDA,MAAMb,KAAKgU,MAAMnM,MAAM5B,WAAYkb,EAAEtgB,QAAQsgB,EAAE9T,SAC/C,MACJ,IAAK,cACD,MAAMqZ,EAAgB,WAAZvF,EAAE5e,MAAqB,IAAO,IACxC1B,MAAMb,KAAKgU,MAAMnM,MAAM5B,QAASygB,EAAIvF,EAAEtgB,MAAQ6lB,IAC9C,MACJ,IAAK,eACD7lB,MAAMb,KAAKgU,MAAMnM,MAAM5B,QAASkb,EAAExgB,MAAOslB,QAAQ,MACjD,IAAK,IAAIle,EAAI,EAAGyL,GAAK2N,EAAE9Q,UAAU/S,OAAQyK,EAAIyL,GAAIzL,IAC7ClH,MAAQA,MAAMU,OAAOskB,cAAc1E,EAAE9Q,UAAUtI,GAAIgJ,OAAQlJ,OAAOhH,OAC9DkH,IAAMyL,GAAK,GACX3S,MAAMb,KAAKimB,QAAQ,OAG3BplB,MAAMb,KAAKimB,QAAQ,MACnB,MACJ,QACIplB,MAAMb,KAAKmhB,GAGvB,OAAO/W,OAAOC,OAAOD,OAAOC,OAAO,GAAIzK,MAAO,CAAEiB,MAAAA,QAKpD,SAAS4jB,aAAa1T,QAClB,QAAIA,OAAOnO,UACAmO,OAAOnO,QAAQjC,OAASwiB,qBAAqBG,QAAUvS,OAAOnO,QAAQjC,KAAK6K,WAAW,OAOrG,SAASmZ,oBAAoBrS,SAAUvB,QACnC,GAAIA,OAAOnO,QAAS,CAChB,GAAImO,OAAOnO,QAAQjC,OAASwiB,qBAAqBE,QAC7C,OAAO/Q,SAASvJ,OAAOC,GAAKA,EAAEvJ,OAASygB,eAAeW,KAE1D,GAAI9P,OAAOnO,QAAQjC,OAASwiB,qBAAqBxC,SAC7C,OAAOrO,SAASvJ,OAAOC,GAAKA,EAAEvJ,OAASygB,eAAeS,UAG9D,OAAOrO,SAGX,IAAIqU,eAAiB,CACpB3Y,EAAK,UACL4Y,UAAW,kEACXC,SAAU,wBACVC,SAAU,wBACVC,QAAS,sBACT1nB,KAAQ,cACR2nB,cAAe,iBACfphB,KAAQ,cACRqhB,SAAY,YACZC,GAAM,MACNC,MAAS,SACTC,GAAM,MACNC,IAAO,WACPC,QAAS,eACTC,QAAS,eACTC,IAAO,OACPC,KAAQ,6BACRC,WAAY,8BACZC,aAAc,0CACdC,eAAgB,sEAChBC,wBAAyB,iDACzBC,aAAc,qDACdC,WAAY,6EACZC,YAAa,gFACbC,sBAAuB,8CACvBC,KAAQ,QACRC,WAAY,kEACZC,UAAW,gFACXC,cAAe,uDACfC,YAAa,sCACbC,gBAAiB,oEACjBC,eAAgB,4CAChBC,UAAW,8BACXC,YAAa,iCACbC,MAAS,QACTC,OAAU,SACVC,aAAc,cACdC,gBAAiB,0BACjBC,IAAO,gBACPC,mBAAoB,sBACpBC,kBAAmB,4BACnBC,QAAW,UACXC,aAAc,UACdC,oBAAqB,mBACrBC,sBAAuB,iBACvBC,oBAAqB,oCACrBC,qBAAsB,uBACtBC,qBAAsB,4CACtBC,2BAA4B,mCAC5BC,4BAA6B,6BAC7BC,2BAA4B,0CAC5BC,OAAU,4BACVC,MAAS,mBACTrU,OAAU,oBACVsU,MAAS,qBACTrU,IAAO,YACPsU,KAAQ,+BACRC,SAAU,sBACVC,SAAU,qBACVC,SAAU,mBACVC,SAAU,mBACVC,KAAQ,eACRC,WAAY,mBACZC,YAAa,oBACbnQ,MAAS,aACTC,MAAS,yBACTmQ,IAAO,2BACPC,uBAAwB,0BACxBC,qBAAsB,iBACtBC,eAAgB,mBAChBC,cAAe,kBACfC,YAAa,gBACbC,yBAA0B,qBAC1BC,iBAAkB,qBAClBC,aAAc,iBACdC,uBAAwB,2BACxBC,cAAe,kBACfC,aAAc,iBACdC,aAAc,iBACdC,YAAa,gBACbC,eAAgB,mBAChBC,cAAe,kBACfC,yBAA0B,qBAC1BC,sBAAuB,kBACvBC,cAAe,kBACfC,qBAAsB,iBACtBC,uBAAwB,2BACxBC,sBAAuB,4BACvBC,iCAAkC,2BAClCC,cAAe,2BACfC,QAAW,WACX3W,OAAU,4BACV4W,2BAA4B,oBAC5BC,aAAc,gBACdC,SAAY,8BACZC,wBAAwB,2CACxBC,wBAAwB,2CACxBC,8BAA8B,wDAC9BC,QAAW,8BACXC,sBAAuB,qBACvBC,sBAAuB,qBACvBjX,MAAS,aACTD,MAAS,aACTmX,WAAY,2CACZC,OAAU,UACVC,QAAW,WACXC,+BAAiC,sBACjCC,8BAAgC,qBAChCC,+BAAiC,sBACjCC,iCAAmC,oBACnCC,4CAA8C,sBAE9CC,GAAM,aACNC,IAAO,SACPC,KAAQ,aACRC,IAAO,UACPC,IAAO,SACPC,IAAO,QACPC,IAAO,SACPC,IAAO,UACPC,KAAQ,WACRC,IAAO,WACPC,IAAO,SACPC,KAAQ,WACRC,MAAS,WACTC,IAAO,SACPC,KAAQ,UACRC,IAAO,UACPC,IAAO,SACPC,IAAO,SACPC,IAAO,UACPC,IAAO,SACPjxB,IAAO,SACPkxB,KAAQ,WACRC,GAAM,OACNC,IAAO,WACPC,KAAQ,WACRC,MAAS,WACTC,GAAM,SACNjU,IAAO,SACPkU,IAAO,UACPvM,IAAO,UACPwM,IAAO,UACP/V,KAAQ,cACRgW,MAAS,eACTC,KAAQ,iBAERC,cAAe,QACfC,mBAAoB,QACpBC,cAAe,gBACfC,eAAgB,gBAEhBC,MAAO,oBACPC,IAAO,uFACPC,WAAY,UAEZC,EAAK,wBACLC,QAAS,uCACTC,UAAW,2DAGRjL,mBAAqB,CACxBkL,KAAM,2DACNC,MAAO,kXACPC,aAAc,qBACdC,MAAO,0CACPC,YAAa,kCACbC,GAAM,qGACNC,GAAM,oEACNC,KAAQ,uHACRC,QAAW,uBACXC,QAAW,iEACXC,QAAW,6BACXC,OAAU,8CACVC,OAAU,uCACVC,MAAS,iBACTC,OAAU,sCACVC,OAAU,0HACVC,GAAM,kBACNC,GAAM,wEACN3iB,EAAK,SACL4iB,GAAM,uCACNC,IAAO,8CACPC,KAAQ,gCACRC,KAAQ,gCACRC,KAAQ,qBACRC,MAAS,8CACTC,OAAU,4BACVC,MAAS,+CACTC,OAAU,6BACVC,KAAQ,sBACRC,KAAQ,sBACRC,IAAO,yBACPC,KAAQ,yCACRC,KAAQ,oCACRC,IAAO,gEACPC,IAAO,yBACPC,IAAO,4CACPC,KAAQ,8BACRC,MAAS,gBACTC,KAAQ,8BACRC,KAAQ,oBACRC,KAAQ,oBACRC,IAAO,6CACPC,KAAQ,+BACRC,KAAQ,+BACRC,KAAQ,gBACRC,MAAS,qBACTC,KAAQ,qBACRC,IAAO,2GACPC,KAAQ,iBACRC,IAAO,2CACPC,KAAQ,6BACRC,KAAQ,6BACRC,MAAS,2CACTC,OAAU,yBACVC,MAAS,4CACTC,OAAU,0BACVC,KAAQ,mBACRC,KAAQ,mBACRC,IAAO,eACNC,IAAO,qBACPC,IAAO,mBACPC,IAAO,sBACPC,IAAO,oBACRC,IAAO,qCACPC,GAAM,uBACNC,OAAQ,mBACRC,IAAO,qCACPC,KAAQ,oDACRC,IAAO,6BACPC,KAAQ,6DACRC,IAAO,6BACPC,IAAO,uDACPC,IAAO,oCACPC,KAAQ,wBACRC,KAAQ,wBACRC,IAAO,4DACPC,KAAQ,gCACPC,GAAM,aACPC,KAAQ,qEACRC,KAAQ,+CACRjF,EAAK,kBACJkF,GAAM,aACPC,GAAM,oCACNC,IAAO,8CACP1b,GAAM,6BACN2b,GAAM,aACNC,IAAO,oHACPC,IAAO,oBACPC,KAAQ,UACRC,MAAS,eACTC,MAAS,cACTC,MAAS,aACTC,MAAS,cACTC,OAAU,oBACVC,OAAU,oBACVC,OAAU,oBACVC,MAAS,cACTC,MAAS,eACTC,IAAO,gBACPC,GAAM,4DACNC,IAAO,0BACPzU,IAAO,oEACP0U,EAAK,kTACLC,GAAM,wBACNC,EAAK,gCACLC,GAAM,iDACNC,IAAO,0CACPC,IAAO,iBACPC,KAAQ,uCACRC,KAAQ,mDACRC,GAAM,yDACNC,IAAO,oEACPC,IAAO,6DACPC,IAAO,0CACPC,GAAM,wBACNC,GAAM,mCACNC,IAAO,uDACP/I,IAAO,oIACPgJ,GAAM,iCACNC,IAAO,uDACPC,GAAM,yCACNC,GAAM,OACNC,IAAO,8DACPC,IAAO,uDACPC,IAAO,YACPC,IAAO,YACPC,KAAQ,cACRC,IAAO,qCACPC,IAAO,YACPC,KAAQ,mBACRvpB,EAAK,MACLwpB,IAAO,8CACPC,IAAO,2CACPC,IAAO,sBACPC,GAAM,gBACNC,GAAM,WACNC,IAAO,kBACPC,IAAO,eACPC,IAAO,kCACPC,IAAO,+BACPC,IAAO,wDACPC,GAAM,OACNC,GAAM,cACNC,IAAO,oBACPC,IAAO,kBACPC,GAAM,WACNC,IAAO,iBACPC,IAAO,eACPC,GAAM,YACNC,EAAK,SACJC,GAAM,cACPC,GAAM,uGACNC,GAAM,yCACNC,GAAM,wCACNC,EAAK,OACLC,GAAM,yCACNC,GAAM,cACNC,IAAO,aACPC,KAAQ,mBACRC,KAAQ,qCACRC,KAAQ,0FACRC,IAAO,wBACP5iB,EAAK,SACL6iB,IAAO,aACPC,IAAO,iBACPC,IAAO,YACPC,GAAM,gBACNC,IAAO,aACPC,IAAO,iBACPC,IAAO,YACPC,GAAM,cACNC,GAAM,eACNC,GAAM,aACLC,IAAO,qBACPC,IAAO,mBACPC,IAAO,sBACPC,IAAO,oBACRrlB,GAAM,UACNslB,IAAO,iCACPC,IAAO,iBACPC,IAAO,0EACPC,IAAO,kCACPC,SAAU,UACVC,IAAO,QACPC,IAAO,iCACPC,IAAO,UACPC,GAAM,6CACNC,IAAO,8DACPC,IAAO,+CACPC,IAAO,+CACPnmB,EAAK,UACLomB,GAAM,iBACNC,KAAQ,0CACRC,KAAQ,2CACRC,KAAQ,+BACRC,GAAM,eACN19B,IAAO,mDACP29B,GAAM,gBACNC,GAAM,cACLC,IAAO,sBACPC,IAAO,oBACPC,IAAO,uBACPC,IAAO,qBACPC,KAAQ,6BACRC,KAAQ,2BACRC,KAAQ,8BACRC,KAAQ,4BACTnV,EAAK,SACLoV,IAAO,6CACPC,IAAO,6CACPluB,EAAK,QACJmuB,GAAM,UACPC,IAAO,uCACP3qB,EAAK,MACL4qB,GAAM,uCACNC,IAAO,oCACPC,IAAO,qBACPC,GAAM,uDACNC,GAAM,yDACNC,GAAM,gDACNC,GAAM,cACNC,GAAM,wFACN//B,GAAM,uCACNggC,IAAO,8BACP3nB,GAAM,eACN4nB,IAAO,iWACPC,KAAQ,mBACRC,KAAQ,8BACRC,IAAO,iCACPC,MAAS,6BACTC,MAAS,gCACTC,KAAQ,gCACRC,MAAS,qCACTC,IAAO,sDACPC,GAAM,qDACNC,GAAM,8CACNC,GAAM,mBACNnc,EAAK,qCACLoc,GAAM,2EACNC,QAAS,QACTC,IAAO,kDACPC,KAAQ,oEACRC,KAAQ,SACRC,GAAM,qEACNC,IAAO,uCACPC,IAAO,eACPC,IAAO,yDACPC,EAAK,UACLC,IAAO,UAGJC,YAAc,CACdC,YAAa,2BACbC,WAAY,qBACZC,KAAQ,0BACR5N,GAAM,mCACN6N,IAAO,oBACPC,IAAO,mBACPC,IAAO,oBACP5gC,GAAM,aACN6gC,cAAe,iBACfC,GAAM,gBACNC,GAAM,eACNC,IAAO,kBACPC,KAAQ,yBACRC,IAAO,qBACPC,KAAQ,4BACRC,GAAM,8BACNhhB,IAAO,0BACPtd,KAAQ,oBACRD,KAAQ,sBACR8b,MAAS,0BACTkZ,GAAM,mBACNwJ,GAAM,sBACN1nB,IAAO,uBACP2nB,WAAY,uBACZC,IAAO,WACPC,IAAO,cACPC,IAAO,4BACPC,KAAQ,eACRzc,IAAO,oBACP0c,IAAO,mDACPC,KAAQ,+BACRC,MAAS,4BACTC,KAAQ,mCACR3e,KAAQ,yBACR4e,OAAU,oCACVznB,IAAO,uFACPiX,MAAO,4CAGPyQ,YAAc,CACjBzQ,MAAO,kBAGJxlB,UAAY,CACfk2B,KAAQ,KACRC,OAAU,QACVC,QAAW,QACXC,YAAe,KACfpsB,QAAW,MAMZ,MAAMqsB,gBAAkB,CACpBC,OAAQ,OACRC,WAAY,OAEVC,iBAAmB,CACrB7rB,eAAkB,CACd,IAAK,OAAQ,UAAW,SAAU,IAAK,WAAY,MACnD,MAAO,KAAM,SAAU,OAAQ,OAAQ,MAAO,MAAO,KAAM,OAAQ,IACnE,SAAU,MAAO,QAAS,MAAO,MAAO,QAAS,MAAO,SAAU,IAClE,IAAK,OAAQ,SAAU,QAAS,OAAQ,SAAU,SAAU,MAAO,MACnE,WAAY,KAAM,IAAK,OAE3B8rB,gBAAiB,KACjBC,oBAAqB,GACrBC,iBAAkB,KAClBC,iBAAkB,GAClBC,uBAAwB,GACxBC,yBAA0B,SAC1BC,iBAAiB,EACjBC,yBAAyB,EACzBC,oBAAqB,CAAC,QACtBC,qBAAsB,CAAC,QACvBC,qBAAsB,EACtBC,yBAAyB,EACzBC,2BAA4B,CACxB,kBAAmB,WAAY,QAAS,YACxC,WAAY,UAAW,WAAY,QAAS,WAAY,iBACxD,SAAU,QAAS,OAAQ,WAAY,QAAS,aAAc,WAC9D,WAAY,WAAY,WAAY,iBAExCC,4BAA4B,EAC5BC,0BAA2B,OAC3BC,eAAgB,CAACn7B,MAAO8N,cAAgBA,YACxCstB,cAAengC,MAAQA,KACvBogC,eAAe,EACfC,mBAAmB,EACnBC,kBAAmB,CAAC,KAAM,SAC1BC,iBAAkB,GAClBC,gBAAiB,kCACjBC,eAAe,EACfC,cAAe,KACfC,eAAgB,IAChBC,eAAe,EACfC,sBAAuB,CAAC,OAAQ,UAAW,QAAS,QACpDC,sBAAuB,CAAC,UAAW,cAAe,UAAW,cAAe,OAAQ,OAAQ,YAAa,eACzGC,uBAAuB,EACvBC,qBAAsB,KACtBC,mBAAoB,IACpBC,qBAAsB,KACtBC,uBAAwB,KACxBC,yBAA0B,CAAEC,EAAG,KAAM5tB,EAAG,IAAK6tB,EAAG,KAAM30B,EAAG,OACzD40B,mBAAmB,EACnBC,+BAA+B,EAC/BC,iCAAkC,EAClCC,0BAA0B,GAExBC,cAAgB,CAClBpjC,KAAM,SACNwgB,OAAQ,OACRtW,UAAAA,UACA2I,SAAU,GACVhT,QAAS8gC,kBAKP0C,aAAe,CACjB5C,OAAQ,CACJ5tB,SAAUywB,cAAcpc,iBAE5Bqc,MAAO,CACH1jC,QAAS,CACL6hC,0BAA2B,UAGnC8B,IAAK,CACD3jC,QAAS,CACL6hC,0BAA2B,QAGnCjpB,IAAK,CACD5F,SAAUywB,cAAc7E,aACxB5+B,QAAS,CACL6hC,0BAA2B,QAGnCj/B,IAAK,CACD5C,QAAS,CACLwiC,eAAe,EACfoB,oBAAqB,CACjBj8B,MAAS,YACTk8B,SAAU,YACVC,IAAO,WAEXC,qBAAsB,CAClBF,SAAU,YAItBG,IAAK,CACDhkC,QAAS,CACL4jC,oBAAqB,CACjBC,SAAU,YAItBI,OAAQ,CACJjkC,QAAS,CACLwiC,eAAe,IAGvBriB,IAAK,CACDnN,SAAUywB,cAAcnD,cAE5BO,WAAY,CACR7tB,SAAUywB,cAAcxe,qBAE5Bif,KAAM,CACFlkC,QAAS,CACL6iC,mBAAoB,KAG5BsB,OAAQ,CACJnkC,QAAS,CACL4iC,qBAAsB,IACtBC,mBAAoB,MAQhC,SAASY,cAAczwB,UACnB,MAAM/S,OAAS,GAMf,OALA6K,OAAOya,KAAKvS,UAAUT,QAAQ6xB,IAC1B,IAAK,MAAM/iC,QAAQ+iC,EAAElvB,MAAM,KACvBjV,OAAOoB,MAAQ2R,SAASoxB,KAGzBnkC,OAEX,SAASokC,cAAc5yB,OAAS,GAAI6yB,QAAU,IAC1C,MAAMnkC,KAAOsR,OAAOtR,MAAQ,SACtBwgB,OAASlP,OAAOkP,QAAUggB,gBAAgBxgC,MAChD,OAAO2K,OAAOC,OAAOD,OAAOC,OAAOD,OAAOC,OAAO,GAAIw4B,eAAgB9xB,QAAS,CAAEtR,KAAAA,KAC5EwgB,OAAAA,OAAQtW,UAAWk6B,WAAWpkC,KAAMwgB,OAAQ,YAAalP,OAAQ6yB,SAAUtxB,SAAUuxB,WAAWpkC,KAAMwgB,OAAQ,WAAYlP,OAAQ6yB,SAAUtkC,QAASukC,WAAWpkC,KAAMwgB,OAAQ,UAAWlP,OAAQ6yB,WAEzM,SAASC,WAAWpkC,KAAMwgB,OAAQjC,IAAKjN,OAAQ6yB,QAAU,IACrD,MAAME,aAAehB,aAAarjC,MAC5BskC,aAAeH,QAAQnkC,MACvBukC,eAAiBlB,aAAa7iB,QAC9BgkB,eAAiBL,QAAQ3jB,QAC/B,OAAO7V,OAAOC,OAAOD,OAAOC,OAAOD,OAAOC,OAAOD,OAAOC,OAAOD,OAAOC,OAAOD,OAAOC,OAAO,GAAIw4B,cAAc7kB,MAAQ8lB,cAAgBA,aAAa9lB,MAASgmB,gBAAkBA,eAAehmB,MAAS+lB,cAAgBA,aAAa/lB,MAASimB,gBAAkBA,eAAejmB,MAAQjN,OAAOiN,MAM/R,SAASkmB,gBAAgBhjC,KAAM9D,MAAQ,GACnC,MAAO,CAAE8D,KAAAA,KAAM9D,MAAAA,MAAOK,IAAKyD,KAAK5D,QAKpC,SAAS6mC,IAAItlC,SACT,OAAOA,QAAQpB,MAAQoB,QAAQzB,MAKnC,SAASS,KAAKgB,QAASmU,OAAS,GAC5B,OAAOnU,QAAQqC,KAAKxD,WAAWmB,QAAQpB,IAAM,EAAIuV,QAKrD,SAASoxB,SAASvlC,SACd,IAAKslC,IAAItlC,SACL,OAAOA,QAAQqC,KAAKxD,aAAamB,QAAQpB,KAMjD,SAAS4mC,QAAQxlC,QAASlB,OACtB,GAAIwmC,IAAItlC,SACJ,OAAO,EAEX,MAAMf,GAAsB,mBAAVH,MACZA,MAAME,KAAKgB,UACXlB,QAAUE,KAAKgB,SAIrB,OAHIf,IACAe,QAAQpB,QAEHK,GAEb,SAASwmC,aAAazlC,QAASlB,OAC3B,MAAMP,MAAQyB,QAAQpB,IACtB,KAAO4mC,QAAQxlC,QAASlB,SAGxB,OAAOkB,QAAQpB,IAAML,MAGzB,IAAImnC,QA8BAC,SArBJ,SAASC,QAAQnV,GACb,OAAOA,IAAMiV,QAAQp/B,aAAemqB,IAAMiV,QAAQG,YAMtD,SAASC,cAAc9lC,SACnB,MAAMzB,MAAQyB,QAAQpB,IAChB8E,MAAQ6hC,SAASvlC,SACvB,GAAI4lC,QAAQliC,OACR,MAAQ4hC,IAAItlC,UACR,GAAIulC,SAASvlC,WAAa0D,OAAS1E,KAAKgB,WAAa0lC,QAAQ9gC,OACzD,OAAO,EAKnB,OADA5E,QAAQpB,IAAML,OACP,GA1BX,SAAW0J,OACPA,MAAMA,MAAmB,YAAI,IAAM,cACnCA,MAAMA,MAAmB,YAAI,IAAM,cACnCA,MAAMA,MAAc,OAAI,IAAM,SAHlC,CAIGy9B,UAAYA,QAAU,KA0BzB,SAAWC,UACPA,SAASA,SAAkB,QAAI,IAAM,UACrCA,SAASA,SAAkB,QAAI,IAAM,UACrCA,SAASA,SAAiB,OAAI,IAAM,SACpCA,SAASA,SAAiB,OAAI,IAAM,SACpCA,SAASA,SAAiB,OAAI,KAAO,SACrCA,SAASA,SAAiB,OAAI,KAAO,SANzC,CAOGA,WAAaA,SAAW,KAC3B,MAAMI,WAAa,CACf1nC,CAACsnC,SAASK,SAAUL,SAASM,QAC7B5nC,CAACsnC,SAASO,QAASP,SAASQ,OAC5B9nC,CAACsnC,SAASS,QAAST,SAASU,QAGhC,IAAIp+B,MAoBJ,SAASq+B,OAAOtmC,SACZ,MAAMzB,MAAQyB,QAAQpB,IACtB,IAAK4mC,QAAQxlC,QAASiI,MAAMs+B,YACxB,OAAO,EAEX,IAAItnC,IAAK,EAET,IADAumC,QAAQxlC,QAASiI,MAAMtC,QACf2/B,IAAItlC,UAAU,CAElB,GADAylC,aAAazlC,QAASwmC,cAClBC,aAAazmC,SAAU,CAGvB,GAAIwlC,QAAQxlC,QAASiI,MAAMtC,OAAQ,CAE/B1G,GAAKumC,QAAQxlC,QAASiI,MAAMy+B,WAC5B,MAEC,GAAIlB,QAAQxlC,QAASiI,MAAMy+B,WAAY,CAExCznC,IAAK,EACL,MAEC,GAAIumC,QAAQxlC,QAASwmC,cAEtB,SAEC,GAAIhB,QAAQxlC,QAASiI,MAAMF,QAAS,CAErC,GAAI0+B,aAAazmC,SACb,SAEJ,MAEC,GAAI2mC,kCAAkC3mC,SAAU,CAEjDf,IAAK,EACL,MAGJ,MAEJ,IAAI2nC,iBAAiB5mC,SAGrB,MAGJ,OADAA,QAAQpB,IAAML,MACPU,GAMX,SAAS2nC,iBAAiB5mC,SACtB,OAAO6mC,gCAAgC7mC,UAAY2mC,kCAAkC3mC,SAEzF,SAAS6mC,gCAAgC7mC,SACrC,MAAMzB,MAAQyB,QAAQpB,IACtB,SAAIknC,cAAc9lC,UAAYwlC,QAAQxlC,QAASiI,MAAMF,SAAW0+B,aAAazmC,YAG7EA,QAAQpB,IAAML,OACP,GAEX,SAASooC,kCAAkC3mC,SACvC,MAAMzB,MAAQyB,QAAQpB,IAChBoC,MAAQ,GACd,MAAQskC,IAAItlC,UAAU,CAClB,MAAMjB,GAAKC,KAAKgB,SAChB,GAAI8mC,eAAe/nC,IACfiC,MAAMG,KAAKpC,SAEV,GAAIgoC,cAAchoC,KACnB,GAAIiC,MAAMO,QAAUwkC,WAAWhnC,IAE3B,WAGH,IAAKioC,gBAAgBjoC,IACtB,MAEJiB,QAAQpB,MAEZ,QAAIL,QAAUyB,QAAQpB,MAAO4mC,QAAQxlC,QAASiI,MAAMF,UAAW0+B,aAAazmC,YAG5EA,QAAQpB,IAAML,OACP,GAKX,SAASkoC,aAAazmC,SAClB,OAAOylC,aAAazlC,QAASinC,SAKjC,SAASA,QAAQloC,IACb,OAAOA,KAAOkJ,MAAMZ,OAAStI,KAAOkJ,MAAMd,MAAQ+/B,QAAQnoC,KAAOooC,SAASpoC,IAK9E,SAASmoC,QAAQnoC,IAEb,OADAA,KAAM,KACO,IAAMA,IAAM,GAK7B,SAASooC,SAASpoC,IACd,OAAOA,GAAK,IAAMA,GAAK,GAK3B,SAASynC,aAAaznC,IAClB,OAAOA,KAAOkJ,MAAMm/B,OAASroC,KAAOkJ,MAAMo/B,IAK9C,SAASL,gBAAgBjoC,IACrB,OAAQuoC,MAAMvoC,KAAOA,KAAOkJ,MAAMF,SAAWy+B,aAAaznC,MAAQ6mC,QAAQ7mC,IAE9E,SAASgoC,cAAchoC,IACnB,OAAOA,KAAO4mC,SAASS,QAAUrnC,KAAO4mC,SAASO,QAAUnnC,KAAO4mC,SAASK,QAE/E,SAASc,eAAe/nC,IACpB,OAAOA,KAAO4mC,SAASU,QAAUtnC,KAAO4mC,SAASQ,QAAUpnC,KAAO4mC,SAASM,SArJ/E,SAAWh+B,OACPA,MAAMA,MAAW,IAAI,GAAK,MAC1BA,MAAMA,MAAa,MAAI,IAAM,QAE7BA,MAAMA,MAAY,KAAI,IAAM,OAE5BA,MAAMA,MAAa,MAAI,IAAM,QAE7BA,MAAMA,MAAa,MAAI,IAAM,QAE7BA,MAAMA,MAAc,OAAI,IAAM,SAE9BA,MAAMA,MAAiB,UAAI,IAAM,YAEjCA,MAAMA,MAAkB,WAAI,IAAM,aAdtC,CAeGA,QAAUA,MAAQ,KAyIrB,MAAMvK,KAAQqB,IAAOA,GAAGF,WAAW,GAC7B0oC,aAAe,iBAAiB5xB,MAAM,IAAIiB,IAAIlZ,MAC9C8pC,eAAiB,CACnB5mC,KAAM,SACN6mC,WAAW,EACX9sB,OAAQ,IAWZ,SAAS+sB,oBAAoBtzB,KAAMxV,IAAMwV,KAAK3V,OAAQgC,QAAU,IAE5D,MAAM8gB,IAAMhW,OAAOC,OAAOD,OAAOC,OAAO,GAAIg8B,gBAAiB/mC,SAK7D,IAAI1B,GAJJH,IAAM2K,KAAKiP,IAAIpE,KAAK3V,OAAQ8K,KAAKC,IAAI,EAAU,MAAP5K,IAAcwV,KAAK3V,OAASG,MAChE2iB,IAAIkmB,YACJ7oC,IAAM+oC,qBAAqBvzB,KAAMxV,IAAK2iB,MAG1C,MAAMhjB,MAAQqpC,eAAexzB,KAAMxV,IAAK2iB,IAAI5G,QAAU,IACtD,IAAe,IAAXpc,MACA,OAEJ,MAAMyB,QAAUqlC,gBAAgBjxB,KAAM7V,OACtCyB,QAAQpB,IAAMA,IACd,MAAMoC,MAAQ,GACd,MAAQskC,IAAItlC,UAAU,CAElB,GADAjB,GAAKC,KAAKgB,SACNgB,MAAM0S,SAASiyB,SAASU,QAAS,CACjC,GAAItnC,KAAO4mC,SAASU,OAAQ,CACxBrlC,MAAMG,KAAKpC,IACXiB,QAAQpB,MACR,SAEJ,GAAIG,KAAO4mC,SAASS,OAAQ,CACxBpmC,QAAQpB,MACR,UAGR,GAAIipC,aAAa9oC,GAAIwiB,IAAI3gB,MACrBI,MAAMG,KAAKpC,SAEV,GAAI+oC,YAAY/oC,GAAIwiB,IAAI3gB,OACzB,GAAII,MAAMO,QAAUwkC,WAAWhnC,IAE3B,UAGH,CAAA,GAAIiC,MAAM0S,SAASiyB,SAASM,UAAYjlC,MAAM0S,SAASiyB,SAASU,QAAS,CAE1ErmC,QAAQpB,MACR,SAEC,GAAI0nC,OAAOtmC,WAAa+nC,eAAehpC,IACxC,MAEJiB,QAAQpB,MAEZ,IAAKoC,MAAMvC,QAAUuB,QAAQpB,MAAQA,IAAK,CAGtC,MAAM2B,aAAe6T,KAAK7U,MAAMS,QAAQpB,IAAKA,KAAKohB,QAAQ,WAAY,IACtE,MAAO,CACHzf,aAAAA,aACAynC,SAAUppC,IAAM2B,aAAa9B,OAC7BF,MAAOkC,QAAQka,OACTpc,MAAQkC,QAAQka,OAAOlc,OACvBG,IAAM2B,aAAa9B,OACzBD,IAAKI,MAQjB,SAAS+oC,qBAAqBvzB,KAAMxV,IAAK6B,SAMrC,IAJImlC,QAAQxxB,KAAKvV,WAAWD,OACxBA,MAGGipC,aAAazzB,KAAKvV,WAAWD,KAAM6B,QAAQG,OAC9ChC,MAEJ,OAAOA,IAMX,SAASgpC,eAAexzB,KAAMxV,IAAK+b,QAC/B,IAAKA,OACD,OAAO,EAEX,MAAM3a,QAAUqlC,gBAAgBjxB,MAC1B6zB,eAAiBttB,OAAOhF,MAAM,IAAIiB,IAAIlZ,MAE5C,IAAIgD,OACJ,IAFAV,QAAQpB,IAAMA,KAEN0mC,IAAItlC,UACR,IAAIkoC,YAAYloC,QAAS2lC,SAASM,QAASN,SAASK,WAAYkC,YAAYloC,QAAS2lC,SAASU,OAAQV,SAASS,QAA/G,CAIA,GADA1lC,OAASV,QAAQpB,IACbupC,aAAanoC,QAASioC,gBACtB,OAAOvnC,OAEXV,QAAQpB,MAEZ,OAAQ,EAKZ,SAASspC,YAAYloC,QAASwI,MAAOxE,MACjC,MAAMzF,MAAQyB,QAAQpB,IACtB,GAAI4mC,QAAQxlC,QAASwI,OACjB,MAAQ88B,IAAItlC,UAAU,CAClB,GAAIwlC,QAAQxlC,QAASgE,MACjB,OAAO,EAEXhE,QAAQpB,MAIhB,OADAoB,QAAQpB,IAAML,OACP,EAKX,SAAS4pC,aAAanoC,QAASyM,KAC3B,MAAMlO,MAAQyB,QAAQpB,IACtB,IAAIwpC,UAAW,EACf,IAAK,IAAIl/B,EAAIuD,IAAIhO,OAAS,EAAGyK,GAAK,IAAMo8B,IAAItlC,UACnCwlC,QAAQxlC,QAASyM,IAAIvD,IADwBA,IAIlDk/B,SAAiB,IAANl/B,EAKf,OAHKk/B,WACDpoC,QAAQpB,IAAML,OAEX6pC,SAEX,SAASL,eAAehpC,IACpB,OAAQA,GAAK,IAAMA,GAAK,IAChBA,GAAK,IAAMA,GAAK,KAChBA,GAAK,IAAMA,GAAK,IACjBwoC,aAAa7zB,SAAS3U,IAEjC,SAAS+oC,YAAY/oC,GAAIqiB,QACrB,OAAOriB,KAAO4mC,SAASO,QAAsB,WAAX9kB,SAAwBriB,KAAO4mC,SAASK,SAAWjnC,KAAO4mC,SAASS,QAEzG,SAASyB,aAAa9oC,GAAIqiB,QACtB,OAAOriB,KAAO4mC,SAASQ,QAAsB,WAAX/kB,SAAwBriB,KAAO4mC,SAASM,SAAWlnC,KAAO4mC,SAASU,QAGzG,SAASgC,mBAAmB7nC,KAAM0R,QAC9B,MAAMo2B,eAAiBxD,cAAc5yB,QACrC,MAA+B,eAAxBo2B,eAAe1nC,KAChB0gC,WAAW9gC,KAAM8nC,gBACjBjH,OAAO7gC,KAAM8nC,gBAOvB,SAASjH,OAAO7gC,KAAM0R,QAClB,OAAOgP,UAAUJ,QAAQtgB,KAAM0R,QAASA,QAO5C,SAASovB,WAAW9gC,KAAM0R,QACtB,OAAOwS,IAAIc,MAAMhlB,KAAM0R,QAASA,eAG3BoS,qBAAsB+jB,8BAA+BX,+BAAgCrG,OAAQt0B,wCAAyC+T,uBAAwB0E,yBAA0BG,2CAA4Cmf,cAAe5jB,6BAA8BwD,2BAA4B4c,WAAYtvB","sourcesContent":["/**\n * Check if given code is a number\n */\nfunction isNumber$1(code) {\n    return code > 47 && code < 58;\n}\n/**\n * Check if given character code is alpha code (letter through A to Z)\n */\nfunction isAlpha$1(code, from, to) {\n    from = from || 65; // A\n    to = to || 90; // Z\n    code &= ~32; // quick hack to convert any char code to uppercase char code\n    return code >= from && code <= to;\n}\nfunction isAlphaNumericWord(code) {\n    return isNumber$1(code) || isAlphaWord(code);\n}\nfunction isAlphaWord(code) {\n    return code === 95 /* _ */ || isAlpha$1(code);\n}\n/**\n * Check for Umlauts i.e. , , , ,  and \n */\nfunction isUmlaut(code) {\n    return code === 196\n        || code == 214\n        || code === 220\n        || code === 228\n        || code === 246\n        || code === 252;\n}\n/**\n * Check if given character code is a white-space character: a space character\n * or line breaks\n */\nfunction isWhiteSpace$3(code) {\n    return code === 32 /* space */\n        || code === 9 /* tab */\n        || code === 160; /* non-breaking space */\n}\n/**\n * Check if given character code is a space character\n */\nfunction isSpace(code) {\n    return isWhiteSpace$3(code)\n        || code === 10 /* LF */\n        || code === 13; /* CR */\n}\n/**\n * Check if given character code is a quote character\n */\nfunction isQuote$2(code) {\n    return code === 39 /* ' */ || code === 34 /* \" */;\n}\n\n/**\n * A streaming, character code-based string reader\n */\nclass Scanner {\n    constructor(str, start, end) {\n        if (end == null && typeof str === 'string') {\n            end = str.length;\n        }\n        this.string = str;\n        this.pos = this.start = start || 0;\n        this.end = end || 0;\n    }\n    /**\n     * Returns true only if the stream is at the end of the file.\n     */\n    eof() {\n        return this.pos >= this.end;\n    }\n    /**\n     * Creates a new stream instance which is limited to given `start` and `end`\n     * range. E.g. its `eof()` method will look at `end` property, not actual\n     * stream end\n     */\n    limit(start, end) {\n        return new Scanner(this.string, start, end);\n    }\n    /**\n     * Returns the next character code in the stream without advancing it.\n     * Will return NaN at the end of the file.\n     */\n    peek() {\n        return this.string.charCodeAt(this.pos);\n    }\n    /**\n     * Returns the next character in the stream and advances it.\n     * Also returns <code>undefined</code> when no more characters are available.\n     */\n    next() {\n        if (this.pos < this.string.length) {\n            return this.string.charCodeAt(this.pos++);\n        }\n    }\n    /**\n     * `match` can be a character code or a function that takes a character code\n     * and returns a boolean. If the next character in the stream 'matches'\n     * the given argument, it is consumed and returned.\n     * Otherwise, `false` is returned.\n     */\n    eat(match) {\n        const ch = this.peek();\n        const ok = typeof match === 'function' ? match(ch) : ch === match;\n        if (ok) {\n            this.next();\n        }\n        return ok;\n    }\n    /**\n     * Repeatedly calls <code>eat</code> with the given argument, until it\n     * fails. Returns <code>true</code> if any characters were eaten.\n     */\n    eatWhile(match) {\n        const start = this.pos;\n        while (!this.eof() && this.eat(match)) { /* */ }\n        return this.pos !== start;\n    }\n    /**\n     * Backs up the stream n characters. Backing it up further than the\n     * start of the current token will cause things to break, so be careful.\n     */\n    backUp(n) {\n        this.pos -= (n || 1);\n    }\n    /**\n     * Get the string between the start of the current token and the\n     * current stream position.\n     */\n    current() {\n        return this.substring(this.start, this.pos);\n    }\n    /**\n     * Returns substring for given range\n     */\n    substring(start, end) {\n        return this.string.slice(start, end);\n    }\n    /**\n     * Creates error object with current stream state\n     */\n    error(message, pos = this.pos) {\n        return new ScannerError(`${message} at ${pos + 1}`, pos, this.string);\n    }\n}\nclass ScannerError extends Error {\n    constructor(message, pos, str) {\n        super(message);\n        this.pos = pos;\n        this.string = str;\n    }\n}\n\nfunction tokenScanner$1(tokens) {\n    return {\n        tokens,\n        start: 0,\n        pos: 0,\n        size: tokens.length\n    };\n}\nfunction peek$3(scanner) {\n    return scanner.tokens[scanner.pos];\n}\nfunction next(scanner) {\n    return scanner.tokens[scanner.pos++];\n}\nfunction slice(scanner, from = scanner.start, to = scanner.pos) {\n    return scanner.tokens.slice(from, to);\n}\nfunction readable$1(scanner) {\n    return scanner.pos < scanner.size;\n}\nfunction consume$2(scanner, test) {\n    const token = peek$3(scanner);\n    if (token && test(token)) {\n        scanner.pos++;\n        return true;\n    }\n    return false;\n}\nfunction error$1(scanner, message, token = peek$3(scanner)) {\n    if (token && token.start != null) {\n        message += ` at ${token.start}`;\n    }\n    const err = new Error(message);\n    err['pos'] = token && token.start;\n    return err;\n}\n\nfunction abbreviation(abbr, options = {}) {\n    const scanner = tokenScanner$1(abbr);\n    const result = statements(scanner, options);\n    if (readable$1(scanner)) {\n        throw error$1(scanner, 'Unexpected character');\n    }\n    return result;\n}\nfunction statements(scanner, options) {\n    const result = {\n        type: 'TokenGroup',\n        elements: []\n    };\n    let ctx = result;\n    let node;\n    const stack = [];\n    while (readable$1(scanner)) {\n        if (node = element$2(scanner, options) || group(scanner, options)) {\n            ctx.elements.push(node);\n            if (consume$2(scanner, isChildOperator)) {\n                stack.push(ctx);\n                ctx = node;\n            }\n            else if (consume$2(scanner, isSiblingOperator$1)) {\n                continue;\n            }\n            else if (consume$2(scanner, isClimbOperator)) {\n                do {\n                    if (stack.length) {\n                        ctx = stack.pop();\n                    }\n                } while (consume$2(scanner, isClimbOperator));\n            }\n        }\n        else {\n            break;\n        }\n    }\n    return result;\n}\n/**\n * Consumes group from given scanner\n */\nfunction group(scanner, options) {\n    if (consume$2(scanner, isGroupStart)) {\n        const result = statements(scanner, options);\n        const token = next(scanner);\n        if (isBracket$2(token, 'group', false)) {\n            result.repeat = repeater$1(scanner);\n        }\n        return result;\n    }\n}\n/**\n * Consumes single element from given scanner\n */\nfunction element$2(scanner, options) {\n    let attr;\n    const elem = {\n        type: 'TokenElement',\n        name: void 0,\n        attributes: void 0,\n        value: void 0,\n        repeat: void 0,\n        selfClose: false,\n        elements: []\n    };\n    if (elementName(scanner, options)) {\n        elem.name = slice(scanner);\n    }\n    while (readable$1(scanner)) {\n        scanner.start = scanner.pos;\n        if (!elem.repeat && !isEmpty(elem) && consume$2(scanner, isRepeater)) {\n            elem.repeat = scanner.tokens[scanner.pos - 1];\n        }\n        else if (!elem.value && text(scanner)) {\n            elem.value = getText(scanner);\n        }\n        else if (attr = shortAttribute(scanner, 'id', options) || shortAttribute(scanner, 'class', options) || attributeSet(scanner)) {\n            if (!elem.attributes) {\n                elem.attributes = Array.isArray(attr) ? attr.slice() : [attr];\n            }\n            else {\n                elem.attributes = elem.attributes.concat(attr);\n            }\n        }\n        else {\n            if (!isEmpty(elem) && consume$2(scanner, isCloseOperator)) {\n                elem.selfClose = true;\n                if (!elem.repeat && consume$2(scanner, isRepeater)) {\n                    elem.repeat = scanner.tokens[scanner.pos - 1];\n                }\n            }\n            break;\n        }\n    }\n    return !isEmpty(elem) ? elem : void 0;\n}\n/**\n * Consumes attribute set from given scanner\n */\nfunction attributeSet(scanner) {\n    if (consume$2(scanner, isAttributeSetStart)) {\n        const attributes = [];\n        let attr;\n        while (readable$1(scanner)) {\n            if (attr = attribute(scanner)) {\n                attributes.push(attr);\n            }\n            else if (consume$2(scanner, isAttributeSetEnd)) {\n                break;\n            }\n            else if (!consume$2(scanner, isWhiteSpace$2)) {\n                throw error$1(scanner, `Unexpected \"${peek$3(scanner).type}\" token`);\n            }\n        }\n        return attributes;\n    }\n}\n/**\n * Consumes attribute shorthand (class or id) from given scanner\n */\nfunction shortAttribute(scanner, type, options) {\n    if (isOperator$1(peek$3(scanner), type)) {\n        scanner.pos++;\n        // Consume multiple operators\n        let count = 1;\n        while (isOperator$1(peek$3(scanner), type)) {\n            scanner.pos++;\n            count++;\n        }\n        const attr = {\n            name: [createLiteral$1(type)]\n        };\n        if (count > 1) {\n            attr.multiple = true;\n        }\n        // Consume expression after shorthand start for React-like components\n        if (options.jsx && text(scanner)) {\n            attr.value = getText(scanner);\n            attr.expression = true;\n        }\n        else {\n            attr.value = literal$1$1(scanner) ? slice(scanner) : void 0;\n        }\n        return attr;\n    }\n}\n/**\n * Consumes single attribute from given scanner\n */\nfunction attribute(scanner) {\n    if (quoted(scanner)) {\n        // Consumed quoted value: its a value for default attribute\n        return {\n            value: slice(scanner)\n        };\n    }\n    if (literal$1$1(scanner, true)) {\n        const name = slice(scanner);\n        let value;\n        if (consume$2(scanner, isEquals)) {\n            if (quoted(scanner) || literal$1$1(scanner, true)) {\n                value = slice(scanner);\n            }\n        }\n        return { name, value };\n    }\n}\nfunction repeater$1(scanner) {\n    return isRepeater(peek$3(scanner))\n        ? scanner.tokens[scanner.pos++]\n        : void 0;\n}\n/**\n * Consumes quoted value from given scanner, if possible\n */\nfunction quoted(scanner) {\n    const start = scanner.pos;\n    const quote = peek$3(scanner);\n    if (isQuote$1(quote)) {\n        scanner.pos++;\n        while (readable$1(scanner)) {\n            if (isQuote$1(next(scanner), quote.single)) {\n                scanner.start = start;\n                return true;\n            }\n        }\n        throw error$1(scanner, 'Unclosed quote', quote);\n    }\n    return false;\n}\n/**\n * Consumes literal (unquoted value) from given scanner\n */\nfunction literal$1$1(scanner, allowBrackets) {\n    const start = scanner.pos;\n    const brackets = {\n        attribute: 0,\n        expression: 0,\n        group: 0\n    };\n    while (readable$1(scanner)) {\n        const token = peek$3(scanner);\n        if (brackets.expression) {\n            // If were inside expression, we should consume all content in it\n            if (isBracket$2(token, 'expression')) {\n                brackets[token.context] += token.open ? 1 : -1;\n            }\n        }\n        else if (isQuote$1(token) || isOperator$1(token) || isWhiteSpace$2(token) || isRepeater(token)) {\n            break;\n        }\n        else if (isBracket$2(token)) {\n            if (!allowBrackets) {\n                break;\n            }\n            if (token.open) {\n                brackets[token.context]++;\n            }\n            else if (!brackets[token.context]) {\n                // Stop if found unmatched closing brace: it must be handled\n                // by parent consumer\n                break;\n            }\n            else {\n                brackets[token.context]--;\n            }\n        }\n        scanner.pos++;\n    }\n    if (start !== scanner.pos) {\n        scanner.start = start;\n        return true;\n    }\n    return false;\n}\n/**\n * Consumes element name from given scanner\n */\nfunction elementName(scanner, options) {\n    const start = scanner.pos;\n    if (options.jsx && consume$2(scanner, isCapitalizedLiteral)) {\n        // Check for edge case: consume immediate capitalized class names\n        // for React-like components, e.g. `Foo.Bar.Baz`\n        while (readable$1(scanner)) {\n            const { pos } = scanner;\n            if (!consume$2(scanner, isClassNameOperator) || !consume$2(scanner, isCapitalizedLiteral)) {\n                scanner.pos = pos;\n                break;\n            }\n        }\n    }\n    while (readable$1(scanner) && consume$2(scanner, isElementName$1)) {\n        // empty\n    }\n    if (scanner.pos !== start) {\n        scanner.start = start;\n        return true;\n    }\n    return false;\n}\n/**\n * Consumes text value from given scanner\n */\nfunction text(scanner) {\n    const start = scanner.pos;\n    if (consume$2(scanner, isTextStart)) {\n        let brackets = 0;\n        while (readable$1(scanner)) {\n            const token = next(scanner);\n            if (isBracket$2(token, 'expression')) {\n                if (token.open) {\n                    brackets++;\n                }\n                else if (!brackets) {\n                    break;\n                }\n                else {\n                    brackets--;\n                }\n            }\n        }\n        scanner.start = start;\n        return true;\n    }\n    return false;\n}\nfunction getText(scanner) {\n    let from = scanner.start;\n    let to = scanner.pos;\n    if (isBracket$2(scanner.tokens[from], 'expression', true)) {\n        from++;\n    }\n    if (isBracket$2(scanner.tokens[to - 1], 'expression', false)) {\n        to--;\n    }\n    return slice(scanner, from, to);\n}\nfunction isBracket$2(token, context, isOpen) {\n    return Boolean(token && token.type === 'Bracket'\n        && (!context || token.context === context)\n        && (isOpen == null || token.open === isOpen));\n}\nfunction isOperator$1(token, type) {\n    return Boolean(token && token.type === 'Operator' && (!type || token.operator === type));\n}\nfunction isQuote$1(token, isSingle) {\n    return Boolean(token && token.type === 'Quote' && (isSingle == null || token.single === isSingle));\n}\nfunction isWhiteSpace$2(token) {\n    return Boolean(token && token.type === 'WhiteSpace');\n}\nfunction isEquals(token) {\n    return isOperator$1(token, 'equal');\n}\nfunction isRepeater(token) {\n    return Boolean(token && token.type === 'Repeater');\n}\nfunction isLiteral$2(token) {\n    return token.type === 'Literal';\n}\nfunction isCapitalizedLiteral(token) {\n    if (isLiteral$2(token)) {\n        const ch = token.value.charCodeAt(0);\n        return ch >= 65 && ch <= 90;\n    }\n    return false;\n}\nfunction isElementName$1(token) {\n    return token.type === 'Literal' || token.type === 'RepeaterNumber' || token.type === 'RepeaterPlaceholder';\n}\nfunction isClassNameOperator(token) {\n    return isOperator$1(token, 'class');\n}\nfunction isAttributeSetStart(token) {\n    return isBracket$2(token, 'attribute', true);\n}\nfunction isAttributeSetEnd(token) {\n    return isBracket$2(token, 'attribute', false);\n}\nfunction isTextStart(token) {\n    return isBracket$2(token, 'expression', true);\n}\nfunction isGroupStart(token) {\n    return isBracket$2(token, 'group', true);\n}\nfunction createLiteral$1(value) {\n    return { type: 'Literal', value };\n}\nfunction isEmpty(elem) {\n    return !elem.name && !elem.value && !elem.attributes;\n}\nfunction isChildOperator(token) {\n    return isOperator$1(token, 'child');\n}\nfunction isSiblingOperator$1(token) {\n    return isOperator$1(token, 'sibling');\n}\nfunction isClimbOperator(token) {\n    return isOperator$1(token, 'climb');\n}\nfunction isCloseOperator(token) {\n    return isOperator$1(token, 'close');\n}\n\nvar Chars$3;\n(function (Chars) {\n    /** `{` character */\n    Chars[Chars[\"CurlyBracketOpen\"] = 123] = \"CurlyBracketOpen\";\n    /** `}` character */\n    Chars[Chars[\"CurlyBracketClose\"] = 125] = \"CurlyBracketClose\";\n    /** `\\\\` character */\n    Chars[Chars[\"Escape\"] = 92] = \"Escape\";\n    /** `=` character */\n    Chars[Chars[\"Equals\"] = 61] = \"Equals\";\n    /** `[` character */\n    Chars[Chars[\"SquareBracketOpen\"] = 91] = \"SquareBracketOpen\";\n    /** `]` character */\n    Chars[Chars[\"SquareBracketClose\"] = 93] = \"SquareBracketClose\";\n    /** `*` character */\n    Chars[Chars[\"Asterisk\"] = 42] = \"Asterisk\";\n    /** `#` character */\n    Chars[Chars[\"Hash\"] = 35] = \"Hash\";\n    /** `$` character */\n    Chars[Chars[\"Dollar\"] = 36] = \"Dollar\";\n    /** `-` character */\n    Chars[Chars[\"Dash\"] = 45] = \"Dash\";\n    /** `.` character */\n    Chars[Chars[\"Dot\"] = 46] = \"Dot\";\n    /** `/` character */\n    Chars[Chars[\"Slash\"] = 47] = \"Slash\";\n    /** `:` character */\n    Chars[Chars[\"Colon\"] = 58] = \"Colon\";\n    /** `!` character */\n    Chars[Chars[\"Excl\"] = 33] = \"Excl\";\n    /** `@` character */\n    Chars[Chars[\"At\"] = 64] = \"At\";\n    /** `_` character */\n    Chars[Chars[\"Underscore\"] = 95] = \"Underscore\";\n    /** `(` character */\n    Chars[Chars[\"RoundBracketOpen\"] = 40] = \"RoundBracketOpen\";\n    /** `)` character */\n    Chars[Chars[\"RoundBracketClose\"] = 41] = \"RoundBracketClose\";\n    /** `+` character */\n    Chars[Chars[\"Sibling\"] = 43] = \"Sibling\";\n    /** `>` character */\n    Chars[Chars[\"Child\"] = 62] = \"Child\";\n    /** `^` character */\n    Chars[Chars[\"Climb\"] = 94] = \"Climb\";\n    /** `'` character */\n    Chars[Chars[\"SingleQuote\"] = 39] = \"SingleQuote\";\n    /** `\"\"` character */\n    Chars[Chars[\"DoubleQuote\"] = 34] = \"DoubleQuote\";\n})(Chars$3 || (Chars$3 = {}));\n/**\n * If consumes escape character, sets current stream range to escaped value\n */\nfunction escaped(scanner) {\n    if (scanner.eat(Chars$3.Escape)) {\n        scanner.start = scanner.pos;\n        if (!scanner.eof()) {\n            scanner.pos++;\n        }\n        return true;\n    }\n    return false;\n}\n\nfunction tokenize$1(source) {\n    const scanner = new Scanner(source);\n    const result = [];\n    const ctx = {\n        group: 0,\n        attribute: 0,\n        expression: 0,\n        quote: 0\n    };\n    let ch = 0;\n    let token;\n    while (!scanner.eof()) {\n        ch = scanner.peek();\n        token = getToken$1(scanner, ctx);\n        if (token) {\n            result.push(token);\n            if (token.type === 'Quote') {\n                ctx.quote = ch === ctx.quote ? 0 : ch;\n            }\n            else if (token.type === 'Bracket') {\n                ctx[token.context] += token.open ? 1 : -1;\n            }\n        }\n        else {\n            throw scanner.error('Unexpected character');\n        }\n    }\n    return result;\n}\n/**\n * Returns next token from given scanner, if possible\n */\nfunction getToken$1(scanner, ctx) {\n    return field$2(scanner, ctx)\n        || repeaterPlaceholder(scanner)\n        || repeaterNumber(scanner)\n        || repeater(scanner)\n        || whiteSpace$1(scanner)\n        || literal$2(scanner, ctx)\n        || operator$1(scanner)\n        || quote(scanner)\n        || bracket$1(scanner);\n}\n/**\n * Consumes literal from given scanner\n */\nfunction literal$2(scanner, ctx) {\n    const start = scanner.pos;\n    const expressionStart = ctx.expression;\n    let value = '';\n    while (!scanner.eof()) {\n        // Consume escaped sequence no matter of context\n        if (escaped(scanner)) {\n            value += scanner.current();\n            continue;\n        }\n        const ch = scanner.peek();\n        if (ch === Chars$3.Slash && !ctx.quote && !ctx.expression && !ctx.attribute) {\n            // Special case for `/` character between numbers in class names\n            const prev = scanner.string.charCodeAt(scanner.pos - 1);\n            const next = scanner.string.charCodeAt(scanner.pos + 1);\n            if (isNumber$1(prev) && isNumber$1(next)) {\n                value += scanner.string[scanner.pos++];\n                continue;\n            }\n        }\n        if (ch === ctx.quote || ch === Chars$3.Dollar || isAllowedOperator(ch, ctx)) {\n            // 1. Found matching quote\n            // 2. The `$` character has special meaning in every context\n            // 3. Depending on context, some characters should be treated as operators\n            break;\n        }\n        if (expressionStart) {\n            // Consume nested expressions, e.g. span{{foo}}\n            if (ch === Chars$3.CurlyBracketOpen) {\n                ctx.expression++;\n            }\n            else if (ch === Chars$3.CurlyBracketClose) {\n                if (ctx.expression > expressionStart) {\n                    ctx.expression--;\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        else if (!ctx.quote) {\n            // Consuming element name\n            if (!ctx.attribute && !isElementName(ch)) {\n                break;\n            }\n            if (isAllowedSpace(ch, ctx) || isAllowedRepeater(ch, ctx) || isQuote$2(ch) || bracketType(ch)) {\n                // Stop for characters not allowed in unquoted literal\n                break;\n            }\n        }\n        value += scanner.string[scanner.pos++];\n    }\n    if (start !== scanner.pos) {\n        scanner.start = start;\n        return {\n            type: 'Literal',\n            value,\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes white space characters as string literal from given scanner\n */\nfunction whiteSpace$1(scanner) {\n    const start = scanner.pos;\n    if (scanner.eatWhile(isSpace)) {\n        return {\n            type: 'WhiteSpace',\n            start,\n            end: scanner.pos,\n            value: scanner.substring(start, scanner.pos)\n        };\n    }\n}\n/**\n * Consumes quote from given scanner\n */\nfunction quote(scanner) {\n    const ch = scanner.peek();\n    if (isQuote$2(ch)) {\n        return {\n            type: 'Quote',\n            single: ch === Chars$3.SingleQuote,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes bracket from given scanner\n */\nfunction bracket$1(scanner) {\n    const ch = scanner.peek();\n    const context = bracketType(ch);\n    if (context) {\n        return {\n            type: 'Bracket',\n            open: isOpenBracket$2(ch),\n            context,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes operator from given scanner\n */\nfunction operator$1(scanner) {\n    const op = operatorType$1(scanner.peek());\n    if (op) {\n        return {\n            type: 'Operator',\n            operator: op,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes node repeat token from current stream position and returns its\n * parsed value\n */\nfunction repeater(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(Chars$3.Asterisk)) {\n        scanner.start = scanner.pos;\n        let count = 1;\n        let implicit = false;\n        if (scanner.eatWhile(isNumber$1)) {\n            count = Number(scanner.current());\n        }\n        else {\n            implicit = true;\n        }\n        return {\n            type: 'Repeater',\n            count,\n            value: 0,\n            implicit,\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes repeater placeholder `$#` from given scanner\n */\nfunction repeaterPlaceholder(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(Chars$3.Dollar) && scanner.eat(Chars$3.Hash)) {\n        return {\n            type: 'RepeaterPlaceholder',\n            value: void 0,\n            start,\n            end: scanner.pos\n        };\n    }\n    scanner.pos = start;\n}\n/**\n * Consumes numbering token like `$` from given scanner state\n */\nfunction repeaterNumber(scanner) {\n    const start = scanner.pos;\n    if (scanner.eatWhile(Chars$3.Dollar)) {\n        const size = scanner.pos - start;\n        let reverse = false;\n        let base = 1;\n        let parent = 0;\n        if (scanner.eat(Chars$3.At)) {\n            // Consume numbering modifiers\n            while (scanner.eat(Chars$3.Climb)) {\n                parent++;\n            }\n            reverse = scanner.eat(Chars$3.Dash);\n            scanner.start = scanner.pos;\n            if (scanner.eatWhile(isNumber$1)) {\n                base = Number(scanner.current());\n            }\n        }\n        scanner.start = start;\n        return {\n            type: 'RepeaterNumber',\n            size,\n            reverse,\n            base,\n            parent,\n            start,\n            end: scanner.pos\n        };\n    }\n}\nfunction field$2(scanner, ctx) {\n    const start = scanner.pos;\n    // Fields are allowed inside expressions and attributes\n    if ((ctx.expression || ctx.attribute) && scanner.eat(Chars$3.Dollar) && scanner.eat(Chars$3.CurlyBracketOpen)) {\n        scanner.start = scanner.pos;\n        let index;\n        let name = '';\n        if (scanner.eatWhile(isNumber$1)) {\n            // Its a field\n            index = Number(scanner.current());\n            name = scanner.eat(Chars$3.Colon) ? consumePlaceholder$2(scanner) : '';\n        }\n        else if (isAlpha$1(scanner.peek())) {\n            // Its a variable\n            name = consumePlaceholder$2(scanner);\n        }\n        if (scanner.eat(Chars$3.CurlyBracketClose)) {\n            return {\n                type: 'Field',\n                index, name,\n                start,\n                end: scanner.pos\n            };\n        }\n        throw scanner.error('Expecting }');\n    }\n    // If we reached here then theres no valid field here, revert\n    // back to starting position\n    scanner.pos = start;\n}\n/**\n * Consumes a placeholder: value right after `:` in field. Could be empty\n */\nfunction consumePlaceholder$2(stream) {\n    const stack = [];\n    stream.start = stream.pos;\n    while (!stream.eof()) {\n        if (stream.eat(Chars$3.CurlyBracketOpen)) {\n            stack.push(stream.pos);\n        }\n        else if (stream.eat(Chars$3.CurlyBracketClose)) {\n            if (!stack.length) {\n                stream.pos--;\n                break;\n            }\n            stack.pop();\n        }\n        else {\n            stream.pos++;\n        }\n    }\n    if (stack.length) {\n        stream.pos = stack.pop();\n        throw stream.error(`Expecting }`);\n    }\n    return stream.current();\n}\n/**\n * Check if given character code is an operator and its allowed in current context\n */\nfunction isAllowedOperator(ch, ctx) {\n    const op = operatorType$1(ch);\n    if (!op || ctx.quote || ctx.expression) {\n        // No operators inside quoted values or expressions\n        return false;\n    }\n    // Inside attributes, only `equals` is allowed\n    return !ctx.attribute || op === 'equal';\n}\n/**\n * Check if given character is a space character and is allowed to be consumed\n * as a space token in current context\n */\nfunction isAllowedSpace(ch, ctx) {\n    return isSpace(ch) && !ctx.expression;\n}\n/**\n * Check if given character can be consumed as repeater in current context\n */\nfunction isAllowedRepeater(ch, ctx) {\n    return ch === Chars$3.Asterisk && !ctx.attribute && !ctx.expression;\n}\n/**\n * If given character is a bracket, returns its type\n */\nfunction bracketType(ch) {\n    if (ch === Chars$3.RoundBracketOpen || ch === Chars$3.RoundBracketClose) {\n        return 'group';\n    }\n    if (ch === Chars$3.SquareBracketOpen || ch === Chars$3.SquareBracketClose) {\n        return 'attribute';\n    }\n    if (ch === Chars$3.CurlyBracketOpen || ch === Chars$3.CurlyBracketClose) {\n        return 'expression';\n    }\n}\n/**\n * If given character is an operator, returns its type\n */\nfunction operatorType$1(ch) {\n    return (ch === Chars$3.Child && 'child')\n        || (ch === Chars$3.Sibling && 'sibling')\n        || (ch === Chars$3.Climb && 'climb')\n        || (ch === Chars$3.Dot && 'class')\n        || (ch === Chars$3.Hash && 'id')\n        || (ch === Chars$3.Slash && 'close')\n        || (ch === Chars$3.Equals && 'equal')\n        || void 0;\n}\n/**\n * Check if given character is an open bracket\n */\nfunction isOpenBracket$2(ch) {\n    return ch === Chars$3.CurlyBracketOpen\n        || ch === Chars$3.SquareBracketOpen\n        || ch === Chars$3.RoundBracketOpen;\n}\n/**\n * Check if given character is allowed in element name\n */\nfunction isElementName(ch) {\n    return isAlphaNumericWord(ch)\n        || isUmlaut(ch)\n        || ch === Chars$3.Dash\n        || ch === Chars$3.Colon\n        || ch === Chars$3.Excl;\n}\n\nconst operators = {\n    child: '>',\n    class: '.',\n    climb: '^',\n    id: '#',\n    equal: '=',\n    close: '/',\n    sibling: '+'\n};\nconst tokenVisitor = {\n    Literal(token) {\n        return token.value;\n    },\n    Quote(token) {\n        return token.single ? '\\'' : '\"';\n    },\n    Bracket(token) {\n        if (token.context === 'attribute') {\n            return token.open ? '[' : ']';\n        }\n        else if (token.context === 'expression') {\n            return token.open ? '{' : '}';\n        }\n        else {\n            return token.open ? '(' : '}';\n        }\n    },\n    Operator(token) {\n        return operators[token.operator];\n    },\n    Field(token, state) {\n        if (token.index != null) {\n            // Its a field: by default, return TextMate-compatible field\n            return token.name\n                ? `\\${${token.index}:${token.name}}`\n                : `\\${${token.index}`;\n        }\n        else if (token.name) {\n            // Its a variable\n            return state.getVariable(token.name);\n        }\n        return '';\n    },\n    RepeaterPlaceholder(token, state) {\n        // Find closest implicit repeater\n        let repeater;\n        for (let i = state.repeaters.length - 1; i >= 0; i--) {\n            if (state.repeaters[i].implicit) {\n                repeater = state.repeaters[i];\n                break;\n            }\n        }\n        state.inserted = true;\n        return state.getText(repeater && repeater.value);\n    },\n    RepeaterNumber(token, state) {\n        let value = 1;\n        const lastIx = state.repeaters.length - 1;\n        // const repeaterIx = Math.max(0, state.repeaters.length - 1 - token.parent);\n        const repeater = state.repeaters[lastIx];\n        if (repeater) {\n            value = token.reverse\n                ? token.base + repeater.count - repeater.value - 1\n                : token.base + repeater.value;\n            if (token.parent) {\n                const parentIx = Math.max(0, lastIx - token.parent);\n                if (parentIx !== lastIx) {\n                    const parentRepeater = state.repeaters[parentIx];\n                    value += repeater.count * parentRepeater.value;\n                }\n            }\n        }\n        let result = String(value);\n        while (result.length < token.size) {\n            result = '0' + result;\n        }\n        return result;\n    },\n    WhiteSpace(token) {\n        return token.value;\n    }\n};\n/**\n * Converts given value token to string\n */\nfunction stringify$1(token, state) {\n    if (!tokenVisitor[token.type]) {\n        throw new Error(`Unknown token ${token.type}`);\n    }\n    return tokenVisitor[token.type](token, state);\n}\n\nconst urlRegex = /^((https?:|ftp:|file:)?\\/\\/|(www|ftp)\\.)[^ ]*$/;\nconst emailRegex = /^[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,5}$/;\n/**\n * Converts given token-based abbreviation into simplified and unrolled node-based\n * abbreviation\n */\nfunction convert(abbr, options = {}) {\n    let textInserted = false;\n    let cleanText;\n    if (options.text) {\n        if (Array.isArray(options.text)) {\n            cleanText = options.text.filter(s => s.trim());\n        }\n        else {\n            cleanText = options.text;\n        }\n    }\n    const result = {\n        type: 'Abbreviation',\n        children: convertGroup(abbr, {\n            inserted: false,\n            repeaters: [],\n            text: options.text,\n            cleanText,\n            repeatGuard: options.maxRepeat || Number.POSITIVE_INFINITY,\n            getText(pos) {\n                var _a;\n                textInserted = true;\n                let value;\n                if (Array.isArray(options.text)) {\n                    if (pos !== undefined && pos >= 0 && pos < cleanText.length) {\n                        return cleanText[pos];\n                    }\n                    value = pos !== undefined ? options.text[pos] : options.text.join('\\n');\n                }\n                else {\n                    value = (_a = options.text) !== null && _a !== void 0 ? _a : '';\n                }\n                return value;\n            },\n            getVariable(name) {\n                const varValue = options.variables && options.variables[name];\n                return varValue != null ? varValue : name;\n            }\n        })\n    };\n    if (options.text != null && !textInserted) {\n        // Text given but no implicitly repeated elements: insert it into\n        // deepest child\n        const deepest = deepestNode(last$1(result.children));\n        if (deepest) {\n            const text = Array.isArray(options.text) ? options.text.join('\\n') : options.text;\n            insertText(deepest, text);\n            if (deepest.name === 'a' && options.href) {\n                // Automatically update value of `<a>` element if inserting URL or email\n                insertHref(deepest, text);\n            }\n        }\n    }\n    return result;\n}\n/**\n * Converts given statement to abbreviation nodes\n */\nfunction convertStatement(node, state) {\n    let result = [];\n    if (node.repeat) {\n        // Node is repeated: we should create copies of given node\n        // and supply context token with actual repeater state\n        const original = node.repeat;\n        const repeat = Object.assign({}, original);\n        repeat.count = repeat.implicit && Array.isArray(state.text)\n            ? state.cleanText.length\n            : (repeat.count || 1);\n        let items;\n        state.repeaters.push(repeat);\n        for (let i = 0; i < repeat.count; i++) {\n            repeat.value = i;\n            node.repeat = repeat;\n            items = isGroup(node)\n                ? convertGroup(node, state)\n                : convertElement(node, state);\n            if (repeat.implicit && !state.inserted) {\n                // Its an implicit repeater but no repeater placeholders found inside,\n                // we should insert text into deepest node\n                const target = last$1(items);\n                const deepest = target && deepestNode(target);\n                if (deepest) {\n                    insertText(deepest, state.getText(repeat.value));\n                }\n            }\n            result = result.concat(items);\n            // We should output at least one repeated item even if its reached\n            // repeat limit\n            if (--state.repeatGuard <= 0) {\n                break;\n            }\n        }\n        state.repeaters.pop();\n        node.repeat = original;\n        if (repeat.implicit) {\n            state.inserted = true;\n        }\n    }\n    else {\n        result = result.concat(isGroup(node) ? convertGroup(node, state) : convertElement(node, state));\n    }\n    return result;\n}\nfunction convertElement(node, state) {\n    let children = [];\n    const elem = {\n        type: 'AbbreviationNode',\n        name: node.name && stringifyName(node.name, state),\n        value: node.value && stringifyValue$1(node.value, state),\n        attributes: void 0,\n        children,\n        repeat: node.repeat && Object.assign({}, node.repeat),\n        selfClosing: node.selfClose,\n    };\n    let result = [elem];\n    for (const child of node.elements) {\n        children = children.concat(convertStatement(child, state));\n    }\n    if (node.attributes) {\n        elem.attributes = [];\n        for (const attr of node.attributes) {\n            elem.attributes.push(convertAttribute(attr, state));\n        }\n    }\n    // In case if current node is a text-only snippet without fields, we should\n    // put all children as siblings\n    if (!elem.name && !elem.attributes && elem.value && !elem.value.some(isField$1)) {\n        // XXX its unclear that `children` is not bound to `elem`\n        // due to concat operation\n        result = result.concat(children);\n    }\n    else {\n        elem.children = children;\n    }\n    return result;\n}\nfunction convertGroup(node, state) {\n    let result = [];\n    for (const child of node.elements) {\n        result = result.concat(convertStatement(child, state));\n    }\n    if (node.repeat) {\n        result = attachRepeater(result, node.repeat);\n    }\n    return result;\n}\nfunction convertAttribute(node, state) {\n    let implied = false;\n    let isBoolean = false;\n    let valueType = node.expression ? 'expression' : 'raw';\n    let value;\n    const name = node.name && stringifyName(node.name, state);\n    if (name && name[0] === '!') {\n        implied = true;\n    }\n    if (name && name[name.length - 1] === '.') {\n        isBoolean = true;\n    }\n    if (node.value) {\n        const tokens = node.value.slice();\n        if (isQuote$1(tokens[0])) {\n            // Its a quoted value: remove quotes from output but mark attribute\n            // value as quoted\n            const quote = tokens.shift();\n            if (tokens.length && last$1(tokens).type === quote.type) {\n                tokens.pop();\n            }\n            valueType = quote.single ? 'singleQuote' : 'doubleQuote';\n        }\n        else if (isBracket$2(tokens[0], 'expression', true)) {\n            // Value is expression: remove brackets but mark value type\n            valueType = 'expression';\n            tokens.shift();\n            if (isBracket$2(last$1(tokens), 'expression', false)) {\n                tokens.pop();\n            }\n        }\n        value = stringifyValue$1(tokens, state);\n    }\n    return {\n        name: isBoolean || implied\n            ? name.slice(implied ? 1 : 0, isBoolean ? -1 : void 0)\n            : name,\n        value,\n        boolean: isBoolean,\n        implied,\n        valueType,\n        multiple: node.multiple\n    };\n}\n/**\n * Converts given token list to string\n */\nfunction stringifyName(tokens, state) {\n    let str = '';\n    for (let i = 0; i < tokens.length; i++) {\n        str += stringify$1(tokens[i], state);\n    }\n    return str;\n}\n/**\n * Converts given token list to value list\n */\nfunction stringifyValue$1(tokens, state) {\n    const result = [];\n    let str = '';\n    for (let i = 0, token; i < tokens.length; i++) {\n        token = tokens[i];\n        if (isField$1(token)) {\n            // We should keep original fields in output since some editors has their\n            // own syntax for field or doesnt support fields at all so we should\n            // capture actual field location in output stream\n            if (str) {\n                result.push(str);\n                str = '';\n            }\n            result.push(token);\n        }\n        else {\n            str += stringify$1(token, state);\n        }\n    }\n    if (str) {\n        result.push(str);\n    }\n    return result;\n}\nfunction isGroup(node) {\n    return node.type === 'TokenGroup';\n}\nfunction isField$1(token) {\n    return typeof token === 'object' && token.type === 'Field' && token.index != null;\n}\nfunction last$1(arr) {\n    return arr[arr.length - 1];\n}\nfunction deepestNode(node) {\n    return node.children.length ? deepestNode(last$1(node.children)) : node;\n}\nfunction insertText(node, text) {\n    if (node.value) {\n        const lastToken = last$1(node.value);\n        if (typeof lastToken === 'string') {\n            node.value[node.value.length - 1] += text;\n        }\n        else {\n            node.value.push(text);\n        }\n    }\n    else {\n        node.value = [text];\n    }\n}\nfunction insertHref(node, text) {\n    var _a;\n    let href = '';\n    if (urlRegex.test(text)) {\n        href = text;\n        if (!/\\w+:/.test(href) && !href.startsWith('//')) {\n            href = `http://${href}`;\n        }\n    }\n    else if (emailRegex.test(text)) {\n        href = `mailto:${text}`;\n    }\n    const hrefAttribute = (_a = node.attributes) === null || _a === void 0 ? void 0 : _a.find(attr => attr.name === 'href');\n    if (!hrefAttribute) {\n        if (!node.attributes) {\n            node.attributes = [];\n        }\n        node.attributes.push({ name: 'href', value: [href], valueType: 'doubleQuote' });\n    }\n    else if (!hrefAttribute.value) {\n        hrefAttribute.value = [href];\n    }\n}\nfunction attachRepeater(items, repeater) {\n    for (const item of items) {\n        if (!item.repeat) {\n            item.repeat = Object.assign({}, repeater);\n        }\n    }\n    return items;\n}\n\n/**\n * Parses given abbreviation into node tree\n */\nfunction parseAbbreviation(abbr, options) {\n    try {\n        const tokens = typeof abbr === 'string' ? tokenize$1(abbr) : abbr;\n        return convert(abbreviation(tokens, options), options);\n    }\n    catch (err) {\n        if (err instanceof ScannerError && typeof abbr === 'string') {\n            err.message += `\\n${abbr}\\n${'-'.repeat(err.pos)}^`;\n        }\n        throw err;\n    }\n}\n\nvar OperatorType;\n(function (OperatorType) {\n    OperatorType[\"Sibling\"] = \"+\";\n    OperatorType[\"Important\"] = \"!\";\n    OperatorType[\"ArgumentDelimiter\"] = \",\";\n    OperatorType[\"ValueDelimiter\"] = \"-\";\n    OperatorType[\"PropertyDelimiter\"] = \":\";\n})(OperatorType || (OperatorType = {}));\n\nvar Chars$2;\n(function (Chars) {\n    /** `#` character */\n    Chars[Chars[\"Hash\"] = 35] = \"Hash\";\n    /** `$` character */\n    Chars[Chars[\"Dollar\"] = 36] = \"Dollar\";\n    /** `-` character */\n    Chars[Chars[\"Dash\"] = 45] = \"Dash\";\n    /** `.` character */\n    Chars[Chars[\"Dot\"] = 46] = \"Dot\";\n    /** `:` character */\n    Chars[Chars[\"Colon\"] = 58] = \"Colon\";\n    /** `,` character */\n    Chars[Chars[\"Comma\"] = 44] = \"Comma\";\n    /** `!` character */\n    Chars[Chars[\"Excl\"] = 33] = \"Excl\";\n    /** `@` character */\n    Chars[Chars[\"At\"] = 64] = \"At\";\n    /** `%` character */\n    Chars[Chars[\"Percent\"] = 37] = \"Percent\";\n    /** `_` character */\n    Chars[Chars[\"Underscore\"] = 95] = \"Underscore\";\n    /** `(` character */\n    Chars[Chars[\"RoundBracketOpen\"] = 40] = \"RoundBracketOpen\";\n    /** `)` character */\n    Chars[Chars[\"RoundBracketClose\"] = 41] = \"RoundBracketClose\";\n    /** `{` character */\n    Chars[Chars[\"CurlyBracketOpen\"] = 123] = \"CurlyBracketOpen\";\n    /** `}` character */\n    Chars[Chars[\"CurlyBracketClose\"] = 125] = \"CurlyBracketClose\";\n    /** `+` character */\n    Chars[Chars[\"Sibling\"] = 43] = \"Sibling\";\n    /** `'` character */\n    Chars[Chars[\"SingleQuote\"] = 39] = \"SingleQuote\";\n    /** `\"` character */\n    Chars[Chars[\"DoubleQuote\"] = 34] = \"DoubleQuote\";\n    /** `t` character */\n    Chars[Chars[\"Transparent\"] = 116] = \"Transparent\";\n    /** `/` character */\n    Chars[Chars[\"Slash\"] = 47] = \"Slash\";\n})(Chars$2 || (Chars$2 = {}));\n\nfunction tokenize(abbr, isValue) {\n    let brackets = 0;\n    let token;\n    const scanner = new Scanner(abbr);\n    const tokens = [];\n    while (!scanner.eof()) {\n        token = getToken(scanner, brackets === 0 && !isValue);\n        if (!token) {\n            throw scanner.error('Unexpected character');\n        }\n        if (token.type === 'Bracket') {\n            if (!brackets && token.open) {\n                mergeTokens(scanner, tokens);\n            }\n            brackets += token.open ? 1 : -1;\n            if (brackets < 0) {\n                throw scanner.error('Unexpected bracket', token.start);\n            }\n        }\n        tokens.push(token);\n        // Forcibly consume next operator after unit-less numeric value or color:\n        // next dash `-` must be used as value delimiter\n        if (shouldConsumeDashAfter(token) && (token = operator(scanner))) {\n            tokens.push(token);\n        }\n    }\n    return tokens;\n}\n/**\n * Returns next token from given scanner, if possible\n */\nfunction getToken(scanner, short) {\n    return field$1(scanner)\n        || customProperty(scanner)\n        || numberValue(scanner)\n        || colorValue(scanner)\n        || stringValue(scanner)\n        || bracket(scanner)\n        || operator(scanner)\n        || whiteSpace(scanner)\n        || literal$1(scanner, short);\n}\nfunction field$1(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(Chars$2.Dollar) && scanner.eat(Chars$2.CurlyBracketOpen)) {\n        scanner.start = scanner.pos;\n        let index;\n        let name = '';\n        if (scanner.eatWhile(isNumber$1)) {\n            // Its a field\n            index = Number(scanner.current());\n            name = scanner.eat(Chars$2.Colon) ? consumePlaceholder$1(scanner) : '';\n        }\n        else if (isAlpha$1(scanner.peek())) {\n            // Its a variable\n            name = consumePlaceholder$1(scanner);\n        }\n        if (scanner.eat(Chars$2.CurlyBracketClose)) {\n            return {\n                type: 'Field',\n                index, name,\n                start,\n                end: scanner.pos\n            };\n        }\n        throw scanner.error('Expecting }');\n    }\n    // If we reached here then theres no valid field here, revert\n    // back to starting position\n    scanner.pos = start;\n}\n/**\n * Consumes a placeholder: value right after `:` in field. Could be empty\n */\nfunction consumePlaceholder$1(stream) {\n    const stack = [];\n    stream.start = stream.pos;\n    while (!stream.eof()) {\n        if (stream.eat(Chars$2.CurlyBracketOpen)) {\n            stack.push(stream.pos);\n        }\n        else if (stream.eat(Chars$2.CurlyBracketClose)) {\n            if (!stack.length) {\n                stream.pos--;\n                break;\n            }\n            stack.pop();\n        }\n        else {\n            stream.pos++;\n        }\n    }\n    if (stack.length) {\n        stream.pos = stack.pop();\n        throw stream.error(`Expecting }`);\n    }\n    return stream.current();\n}\n/**\n * Consumes literal from given scanner\n * @param short Use short notation for consuming value.\n * The difference between short and full notation is that first one uses\n * alpha characters only and used for extracting keywords from abbreviation,\n * while full notation also supports numbers and dashes\n */\nfunction literal$1(scanner, short) {\n    const start = scanner.pos;\n    if (scanner.eat(isIdentPrefix)) {\n        // SCSS or LESS variable\n        // NB a bit dirty hack: if abbreviation starts with identifier prefix,\n        // consume alpha characters only to allow embedded variables\n        scanner.eatWhile(start ? isKeyword : isLiteral$1);\n    }\n    else if (scanner.eat(isAlphaWord)) {\n        scanner.eatWhile(short ? isLiteral$1 : isKeyword);\n    }\n    else {\n        // Allow dots only at the beginning of literal\n        scanner.eat(Chars$2.Dot);\n        scanner.eatWhile(isLiteral$1);\n    }\n    if (start !== scanner.pos) {\n        scanner.start = start;\n        return createLiteral(scanner, scanner.start = start);\n    }\n}\nfunction createLiteral(scanner, start = scanner.start, end = scanner.pos) {\n    return {\n        type: 'Literal',\n        value: scanner.substring(start, end),\n        start,\n        end\n    };\n}\n/**\n * Consumes numeric CSS value (number with optional unit) from current stream,\n * if possible\n */\nfunction numberValue(scanner) {\n    const start = scanner.pos;\n    if (consumeNumber(scanner)) {\n        scanner.start = start;\n        const rawValue = scanner.current();\n        // eat unit, which can be a % or alpha word\n        scanner.start = scanner.pos;\n        scanner.eat(Chars$2.Percent) || scanner.eatWhile(isAlphaWord);\n        return {\n            type: 'NumberValue',\n            value: Number(rawValue),\n            rawValue,\n            unit: scanner.current(),\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes quoted string value from given scanner\n */\nfunction stringValue(scanner) {\n    const ch = scanner.peek();\n    const start = scanner.pos;\n    let finished = false;\n    if (isQuote$2(ch)) {\n        scanner.pos++;\n        while (!scanner.eof()) {\n            // Do not throw error on malformed string\n            if (scanner.eat(ch)) {\n                finished = true;\n                break;\n            }\n            else {\n                scanner.pos++;\n            }\n        }\n        scanner.start = start;\n        return {\n            type: 'StringValue',\n            value: scanner.substring(start + 1, scanner.pos - (finished ? 1 : 0)),\n            quote: ch === Chars$2.SingleQuote ? 'single' : 'double',\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes a color token from given string\n */\nfunction colorValue(scanner) {\n    // supported color variations:\n    // #abc    #aabbccc\n    // #0      #000000\n    // #fff.5  rgba(255, 255, 255, 0.5)\n    // #t      transparent\n    const start = scanner.pos;\n    if (scanner.eat(Chars$2.Hash)) {\n        const valueStart = scanner.pos;\n        let color = '';\n        let alpha = '';\n        if (scanner.eatWhile(isHex)) {\n            color = scanner.substring(valueStart, scanner.pos);\n            alpha = colorAlpha(scanner);\n        }\n        else if (scanner.eat(Chars$2.Transparent)) {\n            color = '0';\n            alpha = colorAlpha(scanner) || '0';\n        }\n        else {\n            alpha = colorAlpha(scanner);\n        }\n        if (color || alpha || scanner.eof()) {\n            const { r, g, b, a } = parseColor(color, alpha);\n            return {\n                type: 'ColorValue',\n                r, g, b, a,\n                raw: scanner.substring(start + 1, scanner.pos),\n                start,\n                end: scanner.pos\n            };\n        }\n        else {\n            // Consumed # but no actual value: invalid color value, treat it as literal\n            return createLiteral(scanner, start);\n        }\n    }\n    scanner.pos = start;\n}\n/**\n * Consumes alpha value of color: `.1`\n */\nfunction colorAlpha(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(Chars$2.Dot)) {\n        scanner.start = start;\n        if (scanner.eatWhile(isNumber$1)) {\n            return scanner.current();\n        }\n        return '1';\n    }\n    return '';\n}\n/**\n * Consumes white space characters as string literal from given scanner\n */\nfunction whiteSpace(scanner) {\n    const start = scanner.pos;\n    if (scanner.eatWhile(isSpace)) {\n        return {\n            type: 'WhiteSpace',\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes custom CSS property: --foo-bar\n */\nfunction customProperty(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(Chars$2.Dash) && scanner.eat(Chars$2.Dash)) {\n        scanner.start = start;\n        scanner.eatWhile(isKeyword);\n        return {\n            type: 'CustomProperty',\n            value: scanner.current(),\n            start,\n            end: scanner.pos\n        };\n    }\n    scanner.pos = start;\n}\n/**\n * Consumes bracket from given scanner\n */\nfunction bracket(scanner) {\n    const ch = scanner.peek();\n    if (isBracket$1(ch)) {\n        return {\n            type: 'Bracket',\n            open: ch === Chars$2.RoundBracketOpen,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes operator from given scanner\n */\nfunction operator(scanner) {\n    const op = operatorType(scanner.peek());\n    if (op) {\n        return {\n            type: 'Operator',\n            operator: op,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Eats number value from given stream\n * @return Returns `true` if number was consumed\n */\nfunction consumeNumber(stream) {\n    const start = stream.pos;\n    stream.eat(Chars$2.Dash);\n    const afterNegative = stream.pos;\n    const hasDecimal = stream.eatWhile(isNumber$1);\n    const prevPos = stream.pos;\n    if (stream.eat(Chars$2.Dot)) {\n        // Its perfectly valid to have numbers like `1.`, which enforces\n        // value to float unit type\n        const hasFloat = stream.eatWhile(isNumber$1);\n        if (!hasDecimal && !hasFloat) {\n            // Lone dot\n            stream.pos = prevPos;\n        }\n    }\n    // Edge case: consumed dash only: not a number, bail-out\n    if (stream.pos === afterNegative) {\n        stream.pos = start;\n    }\n    return stream.pos !== start;\n}\nfunction isIdentPrefix(code) {\n    return code === Chars$2.At || code === Chars$2.Dollar;\n}\n/**\n * If given character is an operator, returns its type\n */\nfunction operatorType(ch) {\n    return (ch === Chars$2.Sibling && OperatorType.Sibling)\n        || (ch === Chars$2.Excl && OperatorType.Important)\n        || (ch === Chars$2.Comma && OperatorType.ArgumentDelimiter)\n        || (ch === Chars$2.Colon && OperatorType.PropertyDelimiter)\n        || (ch === Chars$2.Dash && OperatorType.ValueDelimiter)\n        || void 0;\n}\n/**\n * Check if given code is a hex value (/0-9a-f/)\n */\nfunction isHex(code) {\n    return isNumber$1(code) || isAlpha$1(code, 65, 70); // A-F\n}\nfunction isKeyword(code) {\n    return isAlphaNumericWord(code) || code === Chars$2.Dash;\n}\nfunction isBracket$1(code) {\n    return code === Chars$2.RoundBracketOpen || code === Chars$2.RoundBracketClose;\n}\nfunction isLiteral$1(code) {\n    return isAlphaWord(code) || code === Chars$2.Percent || code === Chars$2.Slash;\n}\n/**\n * Parses given color value from abbreviation into RGBA format\n */\nfunction parseColor(value, alpha) {\n    let r = '0';\n    let g = '0';\n    let b = '0';\n    let a = Number(alpha != null && alpha !== '' ? alpha : 1);\n    if (value === 't') {\n        a = 0;\n    }\n    else {\n        switch (value.length) {\n            case 0:\n                break;\n            case 1:\n                r = g = b = value + value;\n                break;\n            case 2:\n                r = g = b = value;\n                break;\n            case 3:\n                r = value[0] + value[0];\n                g = value[1] + value[1];\n                b = value[2] + value[2];\n                break;\n            default:\n                value += value;\n                r = value.slice(0, 2);\n                g = value.slice(2, 4);\n                b = value.slice(4, 6);\n        }\n    }\n    return {\n        r: parseInt(r, 16),\n        g: parseInt(g, 16),\n        b: parseInt(b, 16),\n        a\n    };\n}\n/**\n * Check if scanner reader must consume dash after given token.\n * Used in cases where user must explicitly separate numeric values\n */\nfunction shouldConsumeDashAfter(token) {\n    return token.type === 'ColorValue' || (token.type === 'NumberValue' && !token.unit);\n}\n/**\n * Merges last adjacent tokens into a single literal.\n * This function is used to overcome edge case when function name was parsed\n * as a list of separate tokens. For example, a `scale3d()` value will be\n * parsed as literal and number tokens (`scale` and `3d`) which is a perfectly\n * valid abbreviation but undesired result. This function will detect last adjacent\n * literal and number values and combine them into single literal\n */\nfunction mergeTokens(scanner, tokens) {\n    let start = 0;\n    let end = 0;\n    while (tokens.length) {\n        const token = last(tokens);\n        if (token.type === 'Literal' || token.type === 'NumberValue') {\n            start = token.start;\n            if (!end) {\n                end = token.end;\n            }\n            tokens.pop();\n        }\n        else {\n            break;\n        }\n    }\n    if (start !== end) {\n        tokens.push(createLiteral(scanner, start, end));\n    }\n}\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\n\nfunction tokenScanner(tokens) {\n    return {\n        tokens,\n        start: 0,\n        pos: 0,\n        size: tokens.length\n    };\n}\nfunction peek$2(scanner) {\n    return scanner.tokens[scanner.pos];\n}\nfunction readable(scanner) {\n    return scanner.pos < scanner.size;\n}\nfunction consume$1(scanner, test) {\n    if (test(peek$2(scanner))) {\n        scanner.pos++;\n        return true;\n    }\n    return false;\n}\nfunction error(scanner, message, token = peek$2(scanner)) {\n    if (token && token.start != null) {\n        message += ` at ${token.start}`;\n    }\n    const err = new Error(message);\n    err['pos'] = token && token.start;\n    return err;\n}\n\nfunction parser(tokens, options = {}) {\n    const scanner = tokenScanner(tokens);\n    const result = [];\n    let property;\n    while (readable(scanner)) {\n        if (property = consumeProperty(scanner, options)) {\n            result.push(property);\n        }\n        else if (!consume$1(scanner, isSiblingOperator)) {\n            throw error(scanner, 'Unexpected token');\n        }\n    }\n    return result;\n}\n/**\n * Consumes single CSS property\n */\nfunction consumeProperty(scanner, options) {\n    let name;\n    let important = false;\n    let valueFragment;\n    const value = [];\n    const token = peek$2(scanner);\n    const valueMode = !!options.value;\n    if (!valueMode && isLiteral(token) && !isFunctionStart(scanner)) {\n        scanner.pos++;\n        name = token.value;\n        // Consume any following value delimiter after property name\n        consume$1(scanner, isValueDelimiter);\n    }\n    // Skip whitespace right after property name, if any\n    if (valueMode) {\n        consume$1(scanner, isWhiteSpace$1);\n    }\n    while (readable(scanner)) {\n        if (consume$1(scanner, isImportant)) {\n            important = true;\n        }\n        else if (valueFragment = consumeValue(scanner, valueMode)) {\n            value.push(valueFragment);\n        }\n        else if (!consume$1(scanner, isFragmentDelimiter)) {\n            break;\n        }\n    }\n    if (name || value.length || important) {\n        return { name, value, important };\n    }\n}\n/**\n * Consumes single value fragment, e.g. all value tokens before comma\n */\nfunction consumeValue(scanner, inArgument) {\n    const result = [];\n    let token;\n    let args;\n    while (readable(scanner)) {\n        token = peek$2(scanner);\n        if (isValue(token)) {\n            scanner.pos++;\n            if (isLiteral(token) && (args = consumeArguments(scanner))) {\n                result.push({\n                    type: 'FunctionCall',\n                    name: token.value,\n                    arguments: args\n                });\n            }\n            else {\n                result.push(token);\n            }\n        }\n        else if (isValueDelimiter(token) || (inArgument && isWhiteSpace$1(token))) {\n            scanner.pos++;\n        }\n        else {\n            break;\n        }\n    }\n    return result.length\n        ? { type: 'CSSValue', value: result }\n        : void 0;\n}\nfunction consumeArguments(scanner) {\n    const start = scanner.pos;\n    if (consume$1(scanner, isOpenBracket$1)) {\n        const args = [];\n        let value;\n        while (readable(scanner) && !consume$1(scanner, isCloseBracket$1)) {\n            if (value = consumeValue(scanner, true)) {\n                args.push(value);\n            }\n            else if (!consume$1(scanner, isWhiteSpace$1) && !consume$1(scanner, isArgumentDelimiter)) {\n                throw error(scanner, 'Unexpected token');\n            }\n        }\n        scanner.start = start;\n        return args;\n    }\n}\nfunction isLiteral(token) {\n    return token && token.type === 'Literal';\n}\nfunction isBracket(token, open) {\n    return token && token.type === 'Bracket' && (open == null || token.open === open);\n}\nfunction isOpenBracket$1(token) {\n    return isBracket(token, true);\n}\nfunction isCloseBracket$1(token) {\n    return isBracket(token, false);\n}\nfunction isWhiteSpace$1(token) {\n    return token && token.type === 'WhiteSpace';\n}\nfunction isOperator(token, operator) {\n    return token && token.type === 'Operator' && (!operator || token.operator === operator);\n}\nfunction isSiblingOperator(token) {\n    return isOperator(token, OperatorType.Sibling);\n}\nfunction isArgumentDelimiter(token) {\n    return isOperator(token, OperatorType.ArgumentDelimiter);\n}\nfunction isFragmentDelimiter(token) {\n    return isArgumentDelimiter(token);\n}\nfunction isImportant(token) {\n    return isOperator(token, OperatorType.Important);\n}\nfunction isValue(token) {\n    return token.type === 'StringValue'\n        || token.type === 'ColorValue'\n        || token.type === 'NumberValue'\n        || token.type === 'Literal'\n        || token.type === 'Field'\n        || token.type === 'CustomProperty';\n}\nfunction isValueDelimiter(token) {\n    return isOperator(token, OperatorType.PropertyDelimiter)\n        || isOperator(token, OperatorType.ValueDelimiter);\n}\nfunction isFunctionStart(scanner) {\n    const t1 = scanner.tokens[scanner.pos];\n    const t2 = scanner.tokens[scanner.pos + 1];\n    return t1 && t2 && isLiteral(t1) && t2.type === 'Bracket';\n}\n\n/**\n * Parses given abbreviation into property set\n */\nfunction parse$2(abbr, options) {\n    try {\n        const tokens = typeof abbr === 'string' ? tokenize(abbr, options && options.value) : abbr;\n        return parser(tokens, options);\n    }\n    catch (err) {\n        if (err instanceof ScannerError && typeof abbr === 'string') {\n            err.message += `\\n${abbr}\\n${'-'.repeat(err.pos)}^`;\n        }\n        throw err;\n    }\n}\n\n/**\n * Merges attributes in current node: de-duplicates attributes with the same name\n * and merges class names\n */\nfunction mergeAttributes(node, config) {\n    if (!node.attributes) {\n        return;\n    }\n    const attributes = [];\n    const lookup = {};\n    for (const attr of node.attributes) {\n        if (attr.name) {\n            const attrName = attr.name;\n            if (attrName in lookup) {\n                const prev = lookup[attrName];\n                if (attrName === 'class') {\n                    prev.value = mergeValue(prev.value, attr.value, ' ');\n                }\n                else {\n                    mergeDeclarations(prev, attr, config);\n                }\n            }\n            else {\n                // Create new attribute instance so we can safely modify it later\n                attributes.push(lookup[attrName] = Object.assign({}, attr));\n            }\n        }\n        else {\n            attributes.push(attr);\n        }\n    }\n    node.attributes = attributes;\n}\n/**\n * Merges two token lists into single list. Adjacent strings are merged together\n */\nfunction mergeValue(prev, next, glue) {\n    if (prev && next) {\n        if (prev.length && glue) {\n            append(prev, glue);\n        }\n        for (const t of next) {\n            append(prev, t);\n        }\n        return prev;\n    }\n    const result = prev || next;\n    return result && result.slice();\n}\n/**\n * Merges data from `src` attribute into `dest` and returns it\n */\nfunction mergeDeclarations(dest, src, config) {\n    dest.name = src.name;\n    if (!config.options['output.reverseAttributes']) {\n        dest.value = src.value;\n    }\n    // Keep high-priority properties\n    if (!dest.implied) {\n        dest.implied = src.implied;\n    }\n    if (!dest.boolean) {\n        dest.boolean = src.boolean;\n    }\n    if (dest.valueType !== 'expression') {\n        dest.valueType = src.valueType;\n    }\n    return dest;\n}\nfunction append(tokens, value) {\n    const lastIx = tokens.length - 1;\n    if (typeof tokens[lastIx] === 'string' && typeof value === 'string') {\n        tokens[lastIx] += value;\n    }\n    else {\n        tokens.push(value);\n    }\n}\n\n/**\n * Walks over each child node of given markup abbreviation AST node (not including\n * given one) and invokes `fn` on each node.\n * The `fn` callback accepts context node, list of ancestor nodes and optional\n * state object\n */\nfunction walk$1(node, fn, state) {\n    const ancestors = [node];\n    const callback = (ctx) => {\n        fn(ctx, ancestors, state);\n        ancestors.push(ctx);\n        ctx.children.forEach(callback);\n        ancestors.pop();\n    };\n    node.children.forEach(callback);\n}\n/**\n * Finds first child node that matches given `callback`\n */\nfunction find$1(node, callback) {\n    for (let i = 0; i < node.children.length; i++) {\n        const child = node.children[i];\n        if (callback(child)) {\n            return child;\n        }\n        const result = find$1(child, callback);\n        if (result) {\n            return result;\n        }\n    }\n}\n/**\n * Finds node which is the deepest for in current node or node itself.\n */\nfunction findDeepest(node) {\n    let parent;\n    while (node.children.length) {\n        parent = node;\n        node = node.children[node.children.length - 1];\n    }\n    return { parent, node };\n}\nfunction isNode(node) {\n    return node.type === 'AbbreviationNode';\n}\n\n/**\n * Finds matching snippet from `registry` and resolves it into a parsed abbreviation.\n * Resolved node is then updated or replaced with matched abbreviation tree.\n *\n * A HTML registry basically contains aliases to another Emmet abbreviations,\n * e.g. a predefined set of name, attributes and so on, possibly a complex\n * abbreviation with multiple elements. So we have to get snippet, parse it\n * and recursively resolve it.\n */\nfunction resolveSnippets(abbr, config) {\n    const stack = [];\n    const reversed = config.options['output.reverseAttributes'];\n    const { warn } = config;\n    const resolve = (child) => {\n        const snippet = child.name && config.snippets[child.name];\n        // A snippet in stack means circular reference.\n        // It can be either a user error or a perfectly valid snippet like\n        // \"img\": \"img[src alt]/\", e.g. an element with predefined shape.\n        // In any case, simply stop parsing and keep element as is\n        if (!snippet || stack.includes(snippet)) {\n            return null;\n        }\n        let snippetAbbr;\n        try {\n            // User may add invlid snippet. In this case, silently bail out\n            snippetAbbr = parseAbbreviation(snippet, config);\n        }\n        catch (err) {\n            warn === null || warn === void 0 ? void 0 : warn(`Unable to parse \"${snippet}\" snippet`, err);\n            return null;\n        }\n        stack.push(snippet);\n        walkResolve(snippetAbbr, resolve);\n        stack.pop();\n        // Add attributes from current node into every top-level node of parsed abbreviation\n        for (const topNode of snippetAbbr.children) {\n            if (child.attributes) {\n                const from = topNode.attributes || [];\n                const to = child.attributes || [];\n                topNode.attributes = reversed ? to.concat(from) : from.concat(to);\n            }\n            mergeNodes(child, topNode);\n        }\n        return snippetAbbr;\n    };\n    walkResolve(abbr, resolve);\n    return abbr;\n}\nfunction walkResolve(node, resolve, config) {\n    let children = [];\n    for (const child of node.children) {\n        const resolved = resolve(child);\n        if (resolved) {\n            children = children.concat(resolved.children);\n            const deepest = findDeepest(resolved);\n            if (isNode(deepest.node)) {\n                deepest.node.children = deepest.node.children.concat(walkResolve(child, resolve));\n            }\n        }\n        else {\n            children.push(child);\n            child.children = walkResolve(child, resolve);\n        }\n    }\n    return node.children = children;\n}\n/**\n * Adds data from first node into second node\n */\nfunction mergeNodes(from, to) {\n    if (from.selfClosing) {\n        to.selfClosing = true;\n    }\n    if (from.value != null) {\n        to.value = from.value;\n    }\n    if (from.repeat) {\n        to.repeat = from.repeat;\n    }\n}\n\nconst expressionStart = '{';\nconst expressionEnd = '}';\nfunction createOutputStream(options, level = 0) {\n    return {\n        options,\n        value: '',\n        level,\n        offset: 0,\n        line: 0,\n        column: 0\n    };\n}\n/**\n * Pushes plain string into output stream without newline processing\n */\nfunction push(stream, text) {\n    const processText = stream.options['output.text'];\n    _push(stream, processText(text, stream.offset, stream.line, stream.column));\n}\n/**\n * Pushes given string with possible newline formatting into output\n */\nfunction pushString(stream, value) {\n    // If given value contains newlines, we should push content line-by-line and\n    // use `pushNewline()` to maintain proper line/column state\n    const lines = splitByLines$1(value);\n    for (let i = 0, il = lines.length - 1; i <= il; i++) {\n        push(stream, lines[i]);\n        if (i !== il) {\n            pushNewline(stream, true);\n        }\n    }\n}\n/**\n * Pushes new line into given output stream\n */\nfunction pushNewline(stream, indent) {\n    const baseIndent = stream.options['output.baseIndent'];\n    const newline = stream.options['output.newline'];\n    push(stream, newline + baseIndent);\n    stream.line++;\n    stream.column = baseIndent.length;\n    if (indent) {\n        pushIndent(stream, indent === true ? stream.level : indent);\n    }\n}\n/**\n * Adds indentation of `size` to current output stream\n */\nfunction pushIndent(stream, size = stream.level) {\n    const indent = stream.options['output.indent'];\n    push(stream, indent.repeat(Math.max(size, 0)));\n}\n/**\n * Pushes field/tabstop into output stream\n */\nfunction pushField(stream, index, placeholder) {\n    const field = stream.options['output.field'];\n    // NB: use `_push` instead of `push` to skip text processing\n    _push(stream, field(index, placeholder, stream.offset, stream.line, stream.column));\n}\n/**\n * Returns given tag name formatted according to given config\n */\nfunction tagName(name, config) {\n    return strCase(name, config.options['output.tagCase']);\n}\n/**\n * Returns given attribute name formatted according to given config\n */\nfunction attrName(name, config) {\n    return strCase(name, config.options['output.attributeCase']);\n}\n/**\n * Returns character for quoting value of given attribute\n */\nfunction attrQuote(attr, config, isOpen) {\n    if (attr.valueType === 'expression') {\n        return isOpen ? expressionStart : expressionEnd;\n    }\n    return config.options['output.attributeQuotes'] === 'single' ? '\\'' : '\"';\n}\n/**\n * Check if given attribute is boolean\n */\nfunction isBooleanAttribute(attr, config) {\n    return attr.boolean\n        || config.options['output.booleanAttributes'].includes((attr.name || '').toLowerCase());\n}\n/**\n * Returns a token for self-closing tag, depending on current options\n */\nfunction selfClose(config) {\n    switch (config.options['output.selfClosingStyle']) {\n        case 'xhtml': return ' /';\n        case 'xml': return '/';\n        default: return '';\n    }\n}\n/**\n * Check if given tag name belongs to inline-level element\n * @param node Parsed node or tag name\n */\nfunction isInline(node, config) {\n    if (typeof node === 'string') {\n        return config.options.inlineElements.includes(node.toLowerCase());\n    }\n    // inline node is a node either with inline-level name or text-only node\n    return node.name ? isInline(node.name, config) : Boolean(node.value && !node.attributes);\n}\n/**\n * Splits given text by lines\n */\nfunction splitByLines$1(text) {\n    return text.split(/\\r\\n|\\r|\\n/g);\n}\n/**\n * Pushes raw string into output stream without any processing\n */\nfunction _push(stream, text) {\n    stream.value += text;\n    stream.offset += text.length;\n    stream.column += text.length;\n}\nfunction strCase(str, type) {\n    if (type) {\n        return type === 'upper' ? str.toUpperCase() : str.toLowerCase();\n    }\n    return str;\n}\n\nconst elementMap = {\n    p: 'span',\n    ul: 'li',\n    ol: 'li',\n    table: 'tr',\n    tr: 'td',\n    tbody: 'tr',\n    thead: 'tr',\n    tfoot: 'tr',\n    colgroup: 'col',\n    select: 'option',\n    optgroup: 'option',\n    audio: 'source',\n    video: 'source',\n    object: 'param',\n    map: 'area'\n};\nfunction implicitTag(node, ancestors, config) {\n    if (!node.name && node.attributes) {\n        resolveImplicitTag(node, ancestors, config);\n    }\n}\nfunction resolveImplicitTag(node, ancestors, config) {\n    const parent = getParentElement(ancestors);\n    const contextName = config.context ? config.context.name : '';\n    const parentName = lowercase(parent ? parent.name : contextName);\n    node.name = elementMap[parentName]\n        || (isInline(parentName, config) ? 'span' : 'div');\n}\nfunction lowercase(str) {\n    return (str || '').toLowerCase();\n}\n/**\n * Returns closest element node from given ancestors list\n */\nfunction getParentElement(ancestors) {\n    for (let i = ancestors.length - 1; i >= 0; i--) {\n        const elem = ancestors[i];\n        if (isNode(elem)) {\n            return elem;\n        }\n    }\n}\n\nvar latin = {\n\t\"common\": [\"lorem\", \"ipsum\", \"dolor\", \"sit\", \"amet\", \"consectetur\", \"adipisicing\", \"elit\"],\n\t\"words\": [\"exercitationem\", \"perferendis\", \"perspiciatis\", \"laborum\", \"eveniet\",\n\t\t\"sunt\", \"iure\", \"nam\", \"nobis\", \"eum\", \"cum\", \"officiis\", \"excepturi\",\n\t\t\"odio\", \"consectetur\", \"quasi\", \"aut\", \"quisquam\", \"vel\", \"eligendi\",\n\t\t\"itaque\", \"non\", \"odit\", \"tempore\", \"quaerat\", \"dignissimos\",\n\t\t\"facilis\", \"neque\", \"nihil\", \"expedita\", \"vitae\", \"vero\", \"ipsum\",\n\t\t\"nisi\", \"animi\", \"cumque\", \"pariatur\", \"velit\", \"modi\", \"natus\",\n\t\t\"iusto\", \"eaque\", \"sequi\", \"illo\", \"sed\", \"ex\", \"et\", \"voluptatibus\",\n\t\t\"tempora\", \"veritatis\", \"ratione\", \"assumenda\", \"incidunt\", \"nostrum\",\n\t\t\"placeat\", \"aliquid\", \"fuga\", \"provident\", \"praesentium\", \"rem\",\n\t\t\"necessitatibus\", \"suscipit\", \"adipisci\", \"quidem\", \"possimus\",\n\t\t\"voluptas\", \"debitis\", \"sint\", \"accusantium\", \"unde\", \"sapiente\",\n\t\t\"voluptate\", \"qui\", \"aspernatur\", \"laudantium\", \"soluta\", \"amet\",\n\t\t\"quo\", \"aliquam\", \"saepe\", \"culpa\", \"libero\", \"ipsa\", \"dicta\",\n\t\t\"reiciendis\", \"nesciunt\", \"doloribus\", \"autem\", \"impedit\", \"minima\",\n\t\t\"maiores\", \"repudiandae\", \"ipsam\", \"obcaecati\", \"ullam\", \"enim\",\n\t\t\"totam\", \"delectus\", \"ducimus\", \"quis\", \"voluptates\", \"dolores\",\n\t\t\"molestiae\", \"harum\", \"dolorem\", \"quia\", \"voluptatem\", \"molestias\",\n\t\t\"magni\", \"distinctio\", \"omnis\", \"illum\", \"dolorum\", \"voluptatum\", \"ea\",\n\t\t\"quas\", \"quam\", \"corporis\", \"quae\", \"blanditiis\", \"atque\", \"deserunt\",\n\t\t\"laboriosam\", \"earum\", \"consequuntur\", \"hic\", \"cupiditate\",\n\t\t\"quibusdam\", \"accusamus\", \"ut\", \"rerum\", \"error\", \"minus\", \"eius\",\n\t\t\"ab\", \"ad\", \"nemo\", \"fugit\", \"officia\", \"at\", \"in\", \"id\", \"quos\",\n\t\t\"reprehenderit\", \"numquam\", \"iste\", \"fugiat\", \"sit\", \"inventore\",\n\t\t\"beatae\", \"repellendus\", \"magnam\", \"recusandae\", \"quod\", \"explicabo\",\n\t\t\"doloremque\", \"aperiam\", \"consequatur\", \"asperiores\", \"commodi\",\n\t\t\"optio\", \"dolor\", \"labore\", \"temporibus\", \"repellat\", \"veniam\",\n\t\t\"architecto\", \"est\", \"esse\", \"mollitia\", \"nulla\", \"a\", \"similique\",\n\t\t\"eos\", \"alias\", \"dolore\", \"tenetur\", \"deleniti\", \"porro\", \"facere\",\n\t\t\"maxime\", \"corrupti\"]\n};\n\nvar ru = {\n\t\"common\": [\"-\", \"\", \"\", \"\", \" \", \"\", \" \", \"\", \"\", \"\"],\n\t\"words\": [\"\", \" \", \"\", \"\", \"\", \" \", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \" \", \"\", \"\",\"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\",\"\", \"\", \"\", \"lorem\", \"ipsum\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\",  \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"]\n};\n\nvar sp = {\n\t\"common\": [\"mujer\", \"uno\", \"dolor\", \"ms\", \"de\", \"poder\", \"mismo\", \"si\"],\n\t\"words\": [\"ejercicio\", \"preferencia\", \"perspicacia\", \"laboral\", \"pao\",\n\t\t\"suntuoso\", \"molde\", \"namibia\", \"planeador\", \"mirar\", \"dems\", \"oficinista\", \"excepcin\",\n\t\t\"odio\", \"consecuencia\", \"casi\", \"auto\", \"chicharra\", \"velo\", \"elixir\",\n\t\t\"ataque\", \"no\", \"odio\", \"temporal\", \"curum\", \"dignsimo\",\n\t\t\"facilismo\", \"letra\", \"nihilista\", \"expedicin\", \"alma\", \"alveolar\", \"aparte\",\n\t\t\"len\", \"animal\", \"como\", \"paria\", \"belleza\", \"modo\", \"natividad\",\n\t\t\"justo\", \"ataque\", \"squito\", \"pillo\", \"sed\", \"ex\", \"y\", \"voluminoso\",\n\t\t\"temporalidad\", \"verdades\", \"racional\", \"asuncin\", \"incidente\", \"marejada\",\n\t\t\"placenta\", \"amanecer\", \"fuga\", \"previsor\", \"presentacin\", \"lejos\",\n\t\t\"necesariamente\", \"sospechoso\", \"adiposidad\", \"quindo\", \"pcima\",\n\t\t\"voluble\", \"dbito\", \"sinti\", \"accesorio\", \"falda\", \"sapiencia\",\n\t\t\"volutas\", \"queso\", \"permacultura\", \"laudo\", \"soluciones\", \"entero\",\n\t\t\"pan\", \"litro\", \"tonelada\", \"culpa\", \"libertario\", \"mosca\", \"dictado\",\n\t\t\"reincidente\", \"nascimiento\", \"dolor\", \"escolar\", \"impedimento\", \"mnima\",\n\t\t\"mayores\", \"repugnante\", \"dulce\", \"obcecado\", \"montaa\", \"enigma\",\n\t\t\"total\", \"deletreo\", \"dcima\", \"cbala\", \"fotografa\", \"dolores\",\n\t\t\"molesto\", \"olvido\", \"paciencia\", \"resiliencia\", \"voluntad\", \"molestias\",\n\t\t\"magnfico\", \"distincin\", \"ovni\", \"marejada\", \"cerro\", \"torre\", \"y\",\n\t\t\"abogada\", \"manantial\", \"corporal\", \"agua\", \"crepsculo\", \"ataque\", \"desierto\",\n\t\t\"laboriosamente\", \"angustia\", \"afortunado\", \"alma\", \"encefalograma\",\n\t\t\"materialidad\", \"cosas\", \"o\", \"renuncia\", \"error\", \"menos\", \"conejo\",\n\t\t\"abada\", \"analfabeto\", \"remo\", \"fugacidad\", \"oficio\", \"en\", \"almcigo\", \"vos\", \"pan\",\n\t\t\"represin\", \"nmeros\", \"triste\", \"refugiado\", \"trote\", \"inventor\",\n\t\t\"corchea\", \"repelente\", \"magma\", \"recusado\", \"patrn\", \"explcito\",\n\t\t\"paloma\", \"sndrome\", \"inmune\", \"autoinmune\", \"comodidad\",\n\t\t\"ley\", \"vietnamita\", \"demonio\", \"tasmania\", \"repeler\", \"apndice\",\n\t\t\"arquitecto\", \"columna\", \"yugo\", \"computador\", \"mula\", \"a\", \"propsito\",\n\t\t\"fantasa\", \"alias\", \"rayo\", \"tenedor\", \"deleznable\", \"ventana\", \"cara\",\n\t\t\"anemia\", \"corrupto\"]\n};\n\nconst vocabularies = { ru, sp, latin };\nconst reLorem = /^lorem([a-z]*)(\\d*)(-\\d*)?$/i;\nfunction lorem(node, ancestors, config) {\n    let m;\n    if (node.name && (m = node.name.match(reLorem))) {\n        const db = vocabularies[m[1]] || vocabularies.latin;\n        const minWordCount = m[2] ? Math.max(1, Number(m[2])) : 30;\n        const maxWordCount = m[3] ? Math.max(minWordCount, Number(m[3].slice(1))) : minWordCount;\n        const wordCount = rand(minWordCount, maxWordCount);\n        const repeat = node.repeat || findRepeater(ancestors);\n        node.name = node.attributes = void 0;\n        node.value = [paragraph(db, wordCount, !repeat || repeat.value === 0)];\n        if (node.repeat && ancestors.length > 1) {\n            resolveImplicitTag(node, ancestors, config);\n        }\n    }\n}\n/**\n * Returns random integer between <code>from</code> and <code>to</code> values\n */\nfunction rand(from, to) {\n    return Math.floor(Math.random() * (to - from) + from);\n}\nfunction sample(arr, count) {\n    const len = arr.length;\n    const iterations = Math.min(len, count);\n    const result = [];\n    while (result.length < iterations) {\n        const str = arr[rand(0, len)];\n        if (!result.includes(str)) {\n            result.push(str);\n        }\n    }\n    return result;\n}\nfunction choice(val) {\n    return val[rand(0, val.length - 1)];\n}\nfunction sentence(words, end) {\n    if (words.length) {\n        words = [capitalize(words[0])].concat(words.slice(1));\n    }\n    return words.join(' ') + (end || choice('?!...')); // more dots than question marks\n}\nfunction capitalize(word) {\n    return word[0].toUpperCase() + word.slice(1);\n}\n/**\n * Insert commas at randomly selected words. This function modifies values\n * inside `words` array\n */\nfunction insertCommas(words) {\n    if (words.length < 2) {\n        return words;\n    }\n    words = words.slice();\n    const len = words.length;\n    const hasComma = /,$/;\n    let totalCommas = 0;\n    if (len > 3 && len <= 6) {\n        totalCommas = rand(0, 1);\n    }\n    else if (len > 6 && len <= 12) {\n        totalCommas = rand(0, 2);\n    }\n    else {\n        totalCommas = rand(1, 4);\n    }\n    for (let i = 0, pos; i < totalCommas; i++) {\n        pos = rand(0, len - 2);\n        if (!hasComma.test(words[pos])) {\n            words[pos] += ',';\n        }\n    }\n    return words;\n}\n/**\n * Generate a paragraph of \"Lorem ipsum\" text\n * @param dict Words dictionary\n * @param wordCount Words count in paragraph\n * @param startWithCommon Should paragraph start with common \"lorem ipsum\" sentence.\n */\nfunction paragraph(dict, wordCount, startWithCommon) {\n    const result = [];\n    let totalWords = 0;\n    let words;\n    if (startWithCommon && dict.common) {\n        words = dict.common.slice(0, wordCount);\n        totalWords += words.length;\n        result.push(sentence(insertCommas(words), '.'));\n    }\n    while (totalWords < wordCount) {\n        words = sample(dict.words, Math.min(rand(2, 30), wordCount - totalWords));\n        totalWords += words.length;\n        result.push(sentence(insertCommas(words)));\n    }\n    return result.join(' ');\n}\nfunction findRepeater(ancestors) {\n    for (let i = ancestors.length - 1; i >= 0; i--) {\n        const element = ancestors[i];\n        if (element.type === 'AbbreviationNode' && element.repeat) {\n            return element.repeat;\n        }\n    }\n}\n\n/**\n * XSL transformer: removes `select` attributes from certain nodes that contain\n * children\n */\nfunction xsl(node) {\n    if (matchesName(node.name) && node.attributes && (node.children.length || node.value)) {\n        node.attributes = node.attributes.filter(isAllowed);\n    }\n}\nfunction isAllowed(attr) {\n    return attr.name !== 'select';\n}\nfunction matchesName(name) {\n    return name === 'xsl:variable' || name === 'xsl:with-param';\n}\n\nconst reElement = /^(-+)([a-z0-9]+[a-z0-9-]*)/i;\nconst reModifier = /^(_+)([a-z0-9]+[a-z0-9-_]*)/i;\nconst blockCandidates1 = (className) => /^[a-z]\\-/i.test(className);\nconst blockCandidates2 = (className) => /^[a-z]/i.test(className);\nfunction bem(node, ancestors, config) {\n    expandClassNames(node);\n    expandShortNotation(node, ancestors, config);\n}\n/**\n * Expands existing class names in BEM notation in given `node`.\n * For example, if node contains `b__el_mod` class name, this method ensures\n * that element contains `b__el` class as well\n */\nfunction expandClassNames(node) {\n    const data = getBEMData(node);\n    const classNames = [];\n    for (const cl of data.classNames) {\n        // remove all modifiers and element prefixes from class name to get a base element name\n        const ix = cl.indexOf('_');\n        if (ix > 0 && !cl.startsWith('-')) {\n            classNames.push(cl.slice(0, ix));\n            classNames.push(cl.slice(ix));\n        }\n        else {\n            classNames.push(cl);\n        }\n    }\n    if (classNames.length) {\n        data.classNames = classNames.filter(uniqueClass);\n        data.block = findBlockName(data.classNames);\n        updateClass(node, data.classNames.join(' '));\n    }\n}\n/**\n * Expands short BEM notation, e.g. `-element` and `_modifier`\n */\nfunction expandShortNotation(node, ancestors, config) {\n    const data = getBEMData(node);\n    const classNames = [];\n    const { options } = config;\n    const path = ancestors.slice(1).concat(node);\n    for (let cl of data.classNames) {\n        let prefix = '';\n        let m;\n        const originalClass = cl;\n        // parse element definition (could be only one)\n        if (m = cl.match(reElement)) {\n            prefix = getBlockName(path, m[1].length, config.context) + options['bem.element'] + m[2];\n            classNames.push(prefix);\n            cl = cl.slice(m[0].length);\n        }\n        // parse modifiers definitions\n        if (m = cl.match(reModifier)) {\n            if (!prefix) {\n                prefix = getBlockName(path, m[1].length);\n                classNames.push(prefix);\n            }\n            classNames.push(`${prefix}${options['bem.modifier']}${m[2]}`);\n            cl = cl.slice(m[0].length);\n        }\n        if (cl === originalClass) {\n            // class name wasnt modified: its not a BEM-specific class,\n            // add it as-is into output\n            classNames.push(originalClass);\n        }\n    }\n    const arrClassNames = classNames.filter(uniqueClass);\n    if (arrClassNames.length) {\n        updateClass(node, arrClassNames.join(' '));\n    }\n}\n/**\n * Returns BEM data from given abbreviation node\n */\nfunction getBEMData(node) {\n    if (!node._bem) {\n        let classValue = '';\n        if (node.attributes) {\n            for (const attr of node.attributes) {\n                if (attr.name === 'class' && attr.value) {\n                    classValue = stringifyValue(attr.value);\n                    break;\n                }\n            }\n        }\n        node._bem = parseBEM(classValue);\n    }\n    return node._bem;\n}\nfunction getBEMDataFromContext(context) {\n    if (!context._bem) {\n        context._bem = parseBEM(context.attributes && context.attributes.class || '');\n    }\n    return context._bem;\n}\n/**\n * Parses BEM data from given class name\n */\nfunction parseBEM(classValue) {\n    const classNames = classValue ? classValue.split(/\\s+/) : [];\n    return {\n        classNames,\n        block: findBlockName(classNames)\n    };\n}\n/**\n * Returns block name for given `node` by `prefix`, which tells the depth of\n * of parent node lookup\n */\nfunction getBlockName(ancestors, depth = 0, context) {\n    const maxParentIx = 0;\n    let parentIx = Math.max(ancestors.length - depth, maxParentIx);\n    do {\n        const parent = ancestors[parentIx];\n        if (parent) {\n            const data = getBEMData(parent);\n            if (data.block) {\n                return data.block;\n            }\n        }\n    } while (maxParentIx < parentIx--);\n    if (context) {\n        const data = getBEMDataFromContext(context);\n        if (data.block) {\n            return data.block;\n        }\n    }\n    return '';\n}\nfunction findBlockName(classNames) {\n    return find(classNames, blockCandidates1)\n        || find(classNames, blockCandidates2)\n        || void 0;\n}\n/**\n * Finds class name from given list which may be used as block name\n */\nfunction find(classNames, filter) {\n    for (const cl of classNames) {\n        if (reElement.test(cl) || reModifier.test(cl)) {\n            break;\n        }\n        if (filter(cl)) {\n            return cl;\n        }\n    }\n}\nfunction updateClass(node, value) {\n    for (const attr of node.attributes) {\n        if (attr.name === 'class') {\n            attr.value = [value];\n            break;\n        }\n    }\n}\nfunction stringifyValue(value) {\n    let result = '';\n    for (const t of value) {\n        result += typeof t === 'string' ? t : t.name;\n    }\n    return result;\n}\nfunction uniqueClass(item, ix, arr) {\n    return !!item && arr.indexOf(item) === ix;\n}\n\n/**\n * Preprocessor of `<label>` element: if it contains `<input>`, remove `for` attribute\n * and `id` from input\n */\nfunction label(node) {\n    if (node.name === 'label') {\n        const input = find$1(node, n => (n.name === 'input' || n.name === 'textarea'));\n        if (input) {\n            // Remove empty `for` attribute\n            if (node.attributes) {\n                node.attributes = node.attributes.filter(attr => {\n                    return !(attr.name === 'for' && isEmptyAttribute(attr));\n                });\n            }\n            // Remove empty `id` attribute\n            if (input.attributes) {\n                input.attributes = input.attributes.filter(attr => {\n                    return !(attr.name === 'id' && isEmptyAttribute(attr));\n                });\n            }\n        }\n    }\n}\nfunction isEmptyAttribute(attr) {\n    if (!attr.value) {\n        return true;\n    }\n    if (attr.value.length === 1) {\n        const token = attr.value[0];\n        if (token && typeof token !== 'string' && !token.name) {\n            // Attribute contains field\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction walk(abbr, visitor, state) {\n    const callback = (ctx, index, items) => {\n        const { parent, current } = state;\n        state.parent = current;\n        state.current = ctx;\n        visitor(ctx, index, items, state, next);\n        state.current = current;\n        state.parent = parent;\n    };\n    const next = (node, index, items) => {\n        state.ancestors.push(state.current);\n        callback(node, index, items);\n        state.ancestors.pop();\n    };\n    abbr.children.forEach(callback);\n}\nfunction createWalkState(config) {\n    return {\n        // @ts-ignore: Will set value in iterator\n        current: null,\n        parent: void 0,\n        ancestors: [],\n        config,\n        field: 1,\n        out: createOutputStream(config.options)\n    };\n}\n\nconst caret = [{ type: 'Field', index: 0, name: '' }];\n/**\n * Check if given node is a snippet: a node without name and attributes\n */\nfunction isSnippet(node) {\n    return node ? !node.name && !node.attributes : false;\n}\n/**\n * Check if given node is inline-level element, e.g. element with explicitly\n * defined node name\n */\nfunction isInlineElement(node, config) {\n    return node ? isInline(node, config) : false;\n}\n/**\n * Check if given value token is a field\n */\nfunction isField(token) {\n    return typeof token === 'object' && token.type === 'Field';\n}\nfunction pushTokens(tokens, state) {\n    const { out } = state;\n    let largestIndex = -1;\n    for (const t of tokens) {\n        if (typeof t === 'string') {\n            pushString(out, t);\n        }\n        else {\n            pushField(out, state.field + t.index, t.name);\n            if (t.index > largestIndex) {\n                largestIndex = t.index;\n            }\n        }\n    }\n    if (largestIndex !== -1) {\n        state.field += largestIndex + 1;\n    }\n}\n/**\n * Splits given value token by lines: returns array where each entry is a token list\n * for a single line\n */\nfunction splitByLines(tokens) {\n    const result = [];\n    let line = [];\n    for (const t of tokens) {\n        if (typeof t === 'string') {\n            const lines = t.split(/\\r\\n?|\\n/g);\n            line.push(lines.shift() || '');\n            while (lines.length) {\n                result.push(line);\n                line = [lines.shift() || ''];\n            }\n        }\n        else {\n            line.push(t);\n        }\n    }\n    line.length && result.push(line);\n    return result;\n}\n/**\n * Check if given attribute should be outputted\n */\nfunction shouldOutputAttribute(attr) {\n    // In case if attribute is implied, check if it has a defined value:\n    // either non-empty value or quoted empty value\n    return !attr.implied || attr.valueType !== 'raw' || (!!attr.value && attr.value.length > 0);\n}\n\nvar TemplateChars;\n(function (TemplateChars) {\n    /** `[` character */\n    TemplateChars[TemplateChars[\"Start\"] = 91] = \"Start\";\n    /** `]` character */\n    TemplateChars[TemplateChars[\"End\"] = 93] = \"End\";\n    /* `_` character */\n    TemplateChars[TemplateChars[\"Underscore\"] = 95] = \"Underscore\";\n    /* `-` character */\n    TemplateChars[TemplateChars[\"Dash\"] = 45] = \"Dash\";\n})(TemplateChars || (TemplateChars = {}));\n/**\n * Splits given string into template tokens.\n * Template is a string which contains placeholders which are uppercase names\n * between `[` and `]`, for example: `[PLACEHOLDER]`.\n * Unlike other templates, a placeholder may contain extra characters before and\n * after name: `[%PLACEHOLDER.]`. If data for `PLACEHOLDER` is defined, it will\n * be outputted with with these extra character, otherwise will be completely omitted.\n */\nfunction template(text) {\n    const tokens = [];\n    const scanner = { pos: 0, text };\n    let placeholder;\n    let offset = scanner.pos;\n    let pos = scanner.pos;\n    while (scanner.pos < scanner.text.length) {\n        pos = scanner.pos;\n        if (placeholder = consumePlaceholder(scanner)) {\n            if (offset !== scanner.pos) {\n                tokens.push(text.slice(offset, pos));\n            }\n            tokens.push(placeholder);\n            offset = scanner.pos;\n        }\n        else {\n            scanner.pos++;\n        }\n    }\n    if (offset !== scanner.pos) {\n        tokens.push(text.slice(offset));\n    }\n    return tokens;\n}\n/**\n * Consumes placeholder like `[#ID]` from given scanner\n */\nfunction consumePlaceholder(scanner) {\n    if (peek$1(scanner) === TemplateChars.Start) {\n        const start = ++scanner.pos;\n        let namePos = start;\n        let afterPos = start;\n        let stack = 1;\n        while (scanner.pos < scanner.text.length) {\n            const code = peek$1(scanner);\n            if (isTokenStart(code)) {\n                namePos = scanner.pos;\n                while (isToken(peek$1(scanner))) {\n                    scanner.pos++;\n                }\n                afterPos = scanner.pos;\n            }\n            else {\n                if (code === TemplateChars.Start) {\n                    stack++;\n                }\n                else if (code === TemplateChars.End) {\n                    if (--stack === 0) {\n                        return {\n                            before: scanner.text.slice(start, namePos),\n                            after: scanner.text.slice(afterPos, scanner.pos++),\n                            name: scanner.text.slice(namePos, afterPos)\n                        };\n                    }\n                }\n                scanner.pos++;\n            }\n        }\n    }\n}\nfunction peek$1(scanner, pos = scanner.pos) {\n    return scanner.text.charCodeAt(pos);\n}\nfunction isTokenStart(code) {\n    return code >= 65 && code <= 90; // A-Z\n}\nfunction isToken(code) {\n    return isTokenStart(code)\n        || (code > 47 && code < 58) /* 0-9 */\n        || code === TemplateChars.Underscore\n        || code === TemplateChars.Dash;\n}\n\nfunction createCommentState(config) {\n    const { options } = config;\n    return {\n        enabled: options['comment.enabled'],\n        trigger: options['comment.trigger'],\n        before: options['comment.before'] ? template(options['comment.before']) : void 0,\n        after: options['comment.after'] ? template(options['comment.after']) : void 0\n    };\n}\n/**\n * Adds comment prefix for given node, if required\n */\nfunction commentNodeBefore(node, state) {\n    if (shouldComment(node, state) && state.comment.before) {\n        output(node, state.comment.before, state);\n    }\n}\n/**\n * Adds comment suffix for given node, if required\n */\nfunction commentNodeAfter(node, state) {\n    if (shouldComment(node, state) && state.comment.after) {\n        output(node, state.comment.after, state);\n    }\n}\n/**\n * Check if given node should be commented\n */\nfunction shouldComment(node, state) {\n    const { comment } = state;\n    if (!comment.enabled || !comment.trigger || !node.name || !node.attributes) {\n        return false;\n    }\n    for (const attr of node.attributes) {\n        if (attr.name && comment.trigger.includes(attr.name)) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Pushes given template tokens into output stream\n */\nfunction output(node, tokens, state) {\n    const attrs = {};\n    const { out } = state;\n    // Collect attributes payload\n    for (const attr of node.attributes) {\n        if (attr.name && attr.value) {\n            attrs[attr.name.toUpperCase()] = attr.value;\n        }\n    }\n    // Output parsed tokens\n    for (const token of tokens) {\n        if (typeof token === 'string') {\n            pushString(out, token);\n        }\n        else if (attrs[token.name]) {\n            pushString(out, token.before);\n            pushTokens(attrs[token.name], state);\n            pushString(out, token.after);\n        }\n    }\n}\n\nconst htmlTagRegex = /^<([\\w\\-:]+)[\\s>]/;\nconst reservedKeywords = new Set([\n    'for', 'while', 'of', 'async', 'await', 'const', 'let', 'var', 'continue',\n    'break', 'debugger', 'do', 'export', 'import', 'in', 'instanceof', 'new', 'return',\n    'switch', 'this', 'throw', 'try', 'catch', 'typeof', 'void', 'with', 'yield'\n]);\nfunction html(abbr, config) {\n    const state = createWalkState(config);\n    state.comment = createCommentState(config);\n    walk(abbr, element$1, state);\n    return state.out.value;\n}\n/**\n * Outputs `node` content to output stream of `state`\n * @param node Context node\n * @param index Index of `node` in `items`\n * @param items List of `node`s siblings\n * @param state Current walk state\n */\nfunction element$1(node, index, items, state, next) {\n    const { out, config } = state;\n    const format = shouldFormat$1(node, index, items, state);\n    // Pick offset level for current node\n    const level = getIndent(state);\n    out.level += level;\n    format && pushNewline(out, true);\n    if (node.name) {\n        const name = tagName(node.name, config);\n        commentNodeBefore(node, state);\n        pushString(out, `<${name}`);\n        if (node.attributes) {\n            for (const attr of node.attributes) {\n                if (shouldOutputAttribute(attr)) {\n                    pushAttribute(attr, state);\n                }\n            }\n        }\n        if (node.selfClosing && !node.children.length && !node.value) {\n            pushString(out, `${selfClose(config)}>`);\n        }\n        else {\n            pushString(out, '>');\n            if (!pushSnippet(node, state, next)) {\n                if (node.value) {\n                    const innerFormat = node.value.some(hasNewline) || startsWithBlockTag(node.value, config);\n                    innerFormat && pushNewline(state.out, ++out.level);\n                    pushTokens(node.value, state);\n                    innerFormat && pushNewline(state.out, --out.level);\n                }\n                node.children.forEach(next);\n                if (!node.value && !node.children.length) {\n                    const innerFormat = config.options['output.formatLeafNode']\n                        || config.options['output.formatForce'].includes(node.name);\n                    innerFormat && pushNewline(state.out, ++out.level);\n                    pushTokens(caret, state);\n                    innerFormat && pushNewline(state.out, --out.level);\n                }\n            }\n            pushString(out, `</${name}>`);\n            commentNodeAfter(node, state);\n        }\n    }\n    else if (!pushSnippet(node, state, next) && node.value) {\n        // A text-only node (snippet)\n        pushTokens(node.value, state);\n        node.children.forEach(next);\n    }\n    if (format && index === items.length - 1 && state.parent) {\n        const offset = isSnippet(state.parent) ? 0 : 1;\n        pushNewline(out, out.level - offset);\n    }\n    out.level -= level;\n}\n/**\n * Outputs given attributes content into output stream\n */\nfunction pushAttribute(attr, state) {\n    const { out, config } = state;\n    if (attr.name) {\n        const attributes = config.options['markup.attributes'];\n        const valuePrefix = config.options['markup.valuePrefix'];\n        let { name, value } = attr;\n        let lQuote = attrQuote(attr, config, true);\n        let rQuote = attrQuote(attr, config);\n        if (attributes) {\n            name = getMultiValue(name, attributes, attr.multiple) || name;\n        }\n        name = attrName(name, config);\n        if (config.options['jsx.enabled'] && attr.multiple) {\n            lQuote = expressionStart;\n            rQuote = expressionEnd;\n        }\n        const prefix = valuePrefix\n            ? getMultiValue(attr.name, valuePrefix, attr.multiple)\n            : null;\n        if (prefix && (value === null || value === void 0 ? void 0 : value.length) === 1 && typeof value[0] === 'string') {\n            // Add given prefix in object notation\n            const val = value[0];\n            value = [isPropKey(val) ? `${prefix}.${val}` : `${prefix}['${val}']`];\n            if (config.options['jsx.enabled']) {\n                lQuote = expressionStart;\n                rQuote = expressionEnd;\n            }\n        }\n        if (isBooleanAttribute(attr, config) && !value) {\n            // If attribute value is omitted and its a boolean value, check for\n            // `compactBoolean` option: if its disabled, set value to attribute name\n            // (XML style)\n            if (!config.options['output.compactBoolean']) {\n                value = [name];\n            }\n        }\n        else if (!value) {\n            value = caret;\n        }\n        pushString(out, ' ' + name);\n        if (value) {\n            pushString(out, '=' + lQuote);\n            pushTokens(value, state);\n            pushString(out, rQuote);\n        }\n        else if (config.options['output.selfClosingStyle'] !== 'html') {\n            pushString(out, '=' + lQuote + rQuote);\n        }\n    }\n}\nfunction pushSnippet(node, state, next) {\n    if (node.value && node.children.length) {\n        // We have a value and child nodes. In case if value contains fields,\n        // we should output children as a content of first field\n        const fieldIx = node.value.findIndex(isField);\n        if (fieldIx !== -1) {\n            pushTokens(node.value.slice(0, fieldIx), state);\n            const line = state.out.line;\n            let pos = fieldIx + 1;\n            node.children.forEach(next);\n            // If there was a line change, trim leading whitespace for better result\n            if (state.out.line !== line && typeof node.value[pos] === 'string') {\n                pushString(state.out, node.value[pos++].trimLeft());\n            }\n            pushTokens(node.value.slice(pos), state);\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Check if given node should be formatted in its parent context\n */\nfunction shouldFormat$1(node, index, items, state) {\n    const { config, parent } = state;\n    if (!config.options['output.format']) {\n        return false;\n    }\n    if (index === 0 && !parent) {\n        // Do not format very first node\n        return false;\n    }\n    // Do not format single child of snippet\n    if (parent && isSnippet(parent) && items.length === 1) {\n        return false;\n    }\n    /**\n     * Adjacent text-only/snippet nodes\n     */\n    if (isSnippet(node)) {\n        // Adjacent text-only/snippet nodes\n        const format = isSnippet(items[index - 1]) || isSnippet(items[index + 1])\n            // Has newlines: looks like wrapping code fragment\n            || node.value.some(hasNewline)\n            // Format as wrapper: contains children which will be outputted as field content\n            || (node.value.some(isField) && node.children.length);\n        if (format) {\n            return true;\n        }\n    }\n    if (isInline(node, config)) {\n        // Check if inline node is the next sibling of block-level node\n        if (index === 0) {\n            // First node in parent: format if its followed by a block-level element\n            for (let i = 0; i < items.length; i++) {\n                if (!isInline(items[i], config)) {\n                    return true;\n                }\n            }\n        }\n        else if (!isInline(items[index - 1], config)) {\n            // Node is right after block-level element\n            return true;\n        }\n        if (config.options['output.inlineBreak']) {\n            // check for adjacent inline elements before and after current element\n            let adjacentInline = 1;\n            let before = index;\n            let after = index;\n            while (isInlineElement(items[--before], config)) {\n                adjacentInline++;\n            }\n            while (isInlineElement(items[++after], config)) {\n                adjacentInline++;\n            }\n            if (adjacentInline >= config.options['output.inlineBreak']) {\n                return true;\n            }\n        }\n        // Edge case: inline node contains node that should receive formatting\n        for (let i = 0, il = node.children.length; i < il; i++) {\n            if (shouldFormat$1(node.children[i], i, node.children, state)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    return true;\n}\n/**\n * Returns indentation offset for given node\n */\nfunction getIndent(state) {\n    const { config, parent } = state;\n    if (!parent || isSnippet(parent) || (parent.name && config.options['output.formatSkip'].includes(parent.name))) {\n        return 0;\n    }\n    return 1;\n}\n/**\n * Check if given node value contains newlines\n */\nfunction hasNewline(value) {\n    return typeof value === 'string' && /\\r|\\n/.test(value);\n}\n/**\n * Check if given node value starts with block-level tag\n */\nfunction startsWithBlockTag(value, config) {\n    if (value.length && typeof value[0] === 'string') {\n        const matches = htmlTagRegex.exec(value[0]);\n        if ((matches === null || matches === void 0 ? void 0 : matches.length) && !config.options['inlineElements'].includes(matches[1].toLowerCase())) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction getMultiValue(key, data, multiple) {\n    return (multiple && data[`${key}*`]) || data[key];\n}\nfunction isPropKey(name) {\n    return !reservedKeywords.has(name) && /^[a-zA-Z_$][\\w_$]*$/.test(name);\n}\n\nfunction indentFormat(abbr, config, options) {\n    const state = createWalkState(config);\n    state.options = options || {};\n    walk(abbr, element, state);\n    return state.out.value;\n}\n/**\n * Outputs `node` content to output stream of `state`\n * @param node Context node\n * @param index Index of `node` in `items`\n * @param items List of `node`s siblings\n * @param state Current walk state\n */\nfunction element(node, index, items, state, next) {\n    const { out, options } = state;\n    const { primary, secondary } = collectAttributes(node);\n    // Pick offset level for current node\n    const level = state.parent ? 1 : 0;\n    out.level += level;\n    // Do not indent top-level elements\n    if (shouldFormat(node, index, items, state)) {\n        pushNewline(out, true);\n    }\n    if (node.name && (node.name !== 'div' || !primary.length)) {\n        pushString(out, (options.beforeName || '') + node.name + (options.afterName || ''));\n    }\n    pushPrimaryAttributes(primary, state);\n    pushSecondaryAttributes(secondary.filter(shouldOutputAttribute), state);\n    if (node.selfClosing && !node.value && !node.children.length) {\n        if (state.options.selfClose) {\n            pushString(out, state.options.selfClose);\n        }\n    }\n    else {\n        pushValue(node, state);\n        node.children.forEach(next);\n    }\n    out.level -= level;\n}\n/**\n * From given node, collects all attributes as `primary` (id, class) and\n * `secondary` (all the rest) lists. In most indent-based syntaxes, primary attribute\n * has special syntax\n */\nfunction collectAttributes(node) {\n    const primary = [];\n    const secondary = [];\n    if (node.attributes) {\n        for (const attr of node.attributes) {\n            if (isPrimaryAttribute(attr)) {\n                primary.push(attr);\n            }\n            else {\n                secondary.push(attr);\n            }\n        }\n    }\n    return { primary, secondary };\n}\n/**\n * Outputs given attributes as primary into output stream\n */\nfunction pushPrimaryAttributes(attrs, state) {\n    for (const attr of attrs) {\n        if (attr.value) {\n            if (attr.name === 'class') {\n                pushString(state.out, '.');\n                // All whitespace characters must be replaced with dots in class names\n                const tokens = attr.value.map(t => typeof t === 'string' ? t.replace(/\\s+/g, '.') : t);\n                pushTokens(tokens, state);\n            }\n            else {\n                // ID attribute\n                pushString(state.out, '#');\n                pushTokens(attr.value, state);\n            }\n        }\n    }\n}\n/**\n * Outputs given attributes as secondary into output stream\n */\nfunction pushSecondaryAttributes(attrs, state) {\n    if (attrs.length) {\n        const { out, config, options } = state;\n        options.beforeAttribute && pushString(out, options.beforeAttribute);\n        for (let i = 0; i < attrs.length; i++) {\n            const attr = attrs[i];\n            pushString(out, attrName(attr.name || '', config));\n            if (isBooleanAttribute(attr, config) && !attr.value) {\n                if (!config.options['output.compactBoolean'] && options.booleanValue) {\n                    pushString(out, '=' + options.booleanValue);\n                }\n            }\n            else {\n                pushString(out, '=' + attrQuote(attr, config, true));\n                pushTokens(attr.value || caret, state);\n                pushString(out, attrQuote(attr, config));\n            }\n            if (i !== attrs.length - 1 && options.glueAttribute) {\n                pushString(out, options.glueAttribute);\n            }\n        }\n        options.afterAttribute && pushString(out, options.afterAttribute);\n    }\n}\n/**\n * Outputs given node value into state output stream\n */\nfunction pushValue(node, state) {\n    // We should either output value or add caret but for leaf nodes only (no children)\n    if (!node.value && node.children.length) {\n        return;\n    }\n    const value = node.value || caret;\n    const lines = splitByLines(value);\n    const { out, options } = state;\n    if (lines.length === 1) {\n        if (node.name || node.attributes) {\n            push(out, ' ');\n        }\n        pushTokens(value, state);\n    }\n    else {\n        // We should format multi-line value with terminating `|` character\n        // and same line length\n        const lineLengths = [];\n        let maxLength = 0;\n        // Calculate lengths of all lines and max line length\n        for (const line of lines) {\n            const len = valueLength(line);\n            lineLengths.push(len);\n            if (len > maxLength) {\n                maxLength = len;\n            }\n        }\n        // Output each line, padded to max length\n        out.level++;\n        for (let i = 0; i < lines.length; i++) {\n            pushNewline(out, true);\n            options.beforeTextLine && push(out, options.beforeTextLine);\n            pushTokens(lines[i], state);\n            if (options.afterTextLine) {\n                push(out, ' '.repeat(maxLength - lineLengths[i]));\n                push(out, options.afterTextLine);\n            }\n        }\n        out.level--;\n    }\n}\nfunction isPrimaryAttribute(attr) {\n    return attr.name === 'class' || attr.name === 'id';\n}\n/**\n * Calculates string length from given tokens\n */\nfunction valueLength(tokens) {\n    let len = 0;\n    for (const token of tokens) {\n        len += typeof token === 'string' ? token.length : token.name.length;\n    }\n    return len;\n}\nfunction shouldFormat(node, index, items, state) {\n    // Do not format first top-level element or snippets\n    if (!state.parent && index === 0) {\n        return false;\n    }\n    return !isSnippet(node);\n}\n\nfunction haml(abbr, config) {\n    return indentFormat(abbr, config, {\n        beforeName: '%',\n        beforeAttribute: '(',\n        afterAttribute: ')',\n        glueAttribute: ' ',\n        afterTextLine: ' |',\n        booleanValue: 'true',\n        selfClose: '/'\n    });\n}\n\nfunction slim(abbr, config) {\n    return indentFormat(abbr, config, {\n        beforeAttribute: ' ',\n        glueAttribute: ' ',\n        beforeTextLine: '| ',\n        selfClose: '/'\n    });\n}\n\nfunction pug(abbr, config) {\n    return indentFormat(abbr, config, {\n        beforeAttribute: '(',\n        afterAttribute: ')',\n        glueAttribute: ', ',\n        beforeTextLine: '| ',\n        selfClose: config.options['output.selfClosingStyle'] === 'xml' ? '/' : ''\n    });\n}\n\nconst formatters = { html, haml, slim, pug };\n/**\n * Parses given Emmet abbreviation into a final abbreviation tree with all\n * required transformations applied\n */\nfunction parse$1(abbr, config) {\n    let oldTextValue;\n    if (typeof abbr === 'string') {\n        const parseOpt = Object.assign({}, config);\n        if (config.options['jsx.enabled']) {\n            parseOpt.jsx = true;\n        }\n        if (config.options['markup.href']) {\n            parseOpt.href = true;\n        }\n        abbr = parseAbbreviation(abbr, parseOpt);\n        // remove text field before snippets(abbr, config) call\n        // as abbreviation(abbr, parseOpt) already handled it\n        oldTextValue = config.text;\n        config.text = undefined;\n    }\n    // Run abbreviation resolve in two passes:\n    // 1. Map each node to snippets, which are abbreviations as well. A single snippet\n    // may produce multiple nodes\n    // 2. Transform every resolved node\n    abbr = resolveSnippets(abbr, config);\n    walk$1(abbr, transform, config);\n    config.text = oldTextValue !== null && oldTextValue !== void 0 ? oldTextValue : config.text;\n    return abbr;\n}\n/**\n * Converts given abbreviation to string according to provided `config`\n */\nfunction stringify(abbr, config) {\n    const formatter = formatters[config.syntax] || html;\n    return formatter(abbr, config);\n}\n/**\n * Modifies given node and prepares it for output\n */\nfunction transform(node, ancestors, config) {\n    implicitTag(node, ancestors, config);\n    mergeAttributes(node, config);\n    lorem(node, ancestors, config);\n    if (config.syntax === 'xsl') {\n        xsl(node);\n    }\n    if (config.type === 'markup') {\n        label(node);\n    }\n    if (config.options['bem.enabled']) {\n        bem(node, ancestors, config);\n    }\n}\n\nvar CSSSnippetType;\n(function (CSSSnippetType) {\n    CSSSnippetType[\"Raw\"] = \"Raw\";\n    CSSSnippetType[\"Property\"] = \"Property\";\n})(CSSSnippetType || (CSSSnippetType = {}));\nconst reProperty = /^([a-z-]+)(?:\\s*:\\s*([^\\n\\r;]+?);*)?$/;\nconst opt = { value: true };\n/**\n * Creates structure for holding resolved CSS snippet\n */\nfunction createSnippet(key, value) {\n    // A snippet could be a raw text snippet (e.g. arbitrary text string) or a\n    // CSS property with possible values separated by `|`.\n    // In latter case, we have to parse snippet as CSS abbreviation\n    const m = value.match(reProperty);\n    if (m) {\n        const keywords = {};\n        const parsed = m[2] ? m[2].split('|').map(parseValue) : [];\n        for (const item of parsed) {\n            for (const cssVal of item) {\n                collectKeywords(cssVal, keywords);\n            }\n        }\n        return {\n            type: CSSSnippetType.Property,\n            key,\n            property: m[1],\n            value: parsed,\n            keywords,\n            dependencies: []\n        };\n    }\n    return { type: CSSSnippetType.Raw, key, value };\n}\n/**\n * Nests more specific CSS properties into shorthand ones, e.g.\n * `background-position-x` -> `background-position` -> `background`\n */\nfunction nest(snippets) {\n    snippets = snippets.slice().sort(snippetsSort);\n    const stack = [];\n    let prev;\n    // For sorted list of CSS properties, create dependency graph where each\n    // shorthand property contains its more specific one, e.g.\n    // background -> background-position -> background-position-x\n    for (const cur of snippets.filter(isProperty)) {\n        // Check if current property belongs to one from parent stack.\n        // Since `snippets` array is sorted, items are perfectly aligned\n        // from shorthands to more specific variants\n        while (stack.length) {\n            prev = stack[stack.length - 1];\n            if (cur.property.startsWith(prev.property)\n                && cur.property.charCodeAt(prev.property.length) === 45 /* - */) {\n                prev.dependencies.push(cur);\n                stack.push(cur);\n                break;\n            }\n            stack.pop();\n        }\n        if (!stack.length) {\n            stack.push(cur);\n        }\n    }\n    return snippets;\n}\n/**\n * A sorting function for array of snippets\n */\nfunction snippetsSort(a, b) {\n    if (a.key === b.key) {\n        return 0;\n    }\n    return a.key < b.key ? -1 : 1;\n}\nfunction parseValue(value) {\n    return parse$2(value.trim(), opt)[0].value;\n}\nfunction isProperty(snippet) {\n    return snippet.type === CSSSnippetType.Property;\n}\nfunction collectKeywords(cssVal, dest) {\n    for (const v of cssVal.value) {\n        if (v.type === 'Literal') {\n            dest[v.value] = v;\n        }\n        else if (v.type === 'FunctionCall') {\n            dest[v.name] = v;\n        }\n        else if (v.type === 'Field') {\n            // Create literal from field, if available\n            const value = v.name.trim();\n            if (value) {\n                dest[value] = { type: 'Literal', value };\n            }\n        }\n    }\n}\n\n/**\n * Calculates how close `str1` matches `str2` using fuzzy match.\n * How matching works:\n *  first characters of both `str1` and `str2` *must* match\n *  `str1` length larger than `str2` length is allowed only when `unmatched` is true\n *  ideal match is when `str1` equals to `str2` (score: 1)\n *  next best match is `str2` starts with `str1` (score: 1  percent of matched characters)\n *  other scores depend on how close characters of `str1` to the beginning of `str2`\n * @param partialMatch Allow length `str1` to be greater than `str2` length\n */\nfunction scoreMatch(str1, str2, partialMatch = false) {\n    str1 = str1.toLowerCase();\n    str2 = str2.toLowerCase();\n    if (str1 === str2) {\n        return 1;\n    }\n    // Both strings MUST start with the same character\n    if (!str1 || !str2 || str1.charCodeAt(0) !== str2.charCodeAt(0)) {\n        return 0;\n    }\n    const str1Len = str1.length;\n    const str2Len = str2.length;\n    if (!partialMatch && str1Len > str2Len) {\n        return 0;\n    }\n    // Characters from `str1` which are closer to the beginning of a `str2` should\n    // have higher score.\n    // For example, if `str2` is `abcde`, its max score is:\n    // 5 + 4 + 3 + 2 + 1 = 15 (sum of character positions in reverse order)\n    // Matching `abd` against `abcde` should produce:\n    // 5 + 4 + 2 = 11\n    // Acronym bonus for match right after `-`. Matching `abd` against `abc-de`\n    // should produce:\n    // 6 + 5 + 4 (use `d` position in `abd`, not in abc-de`)\n    const minLength = Math.min(str1Len, str2Len);\n    const maxLength = Math.max(str1Len, str2Len);\n    let i = 1;\n    let j = 1;\n    let score = maxLength;\n    let ch1 = 0;\n    let ch2 = 0;\n    let found = false;\n    let acronym = false;\n    while (i < str1Len) {\n        ch1 = str1.charCodeAt(i);\n        found = false;\n        acronym = false;\n        while (j < str2Len) {\n            ch2 = str2.charCodeAt(j);\n            if (ch1 === ch2) {\n                found = true;\n                score += maxLength - (acronym ? i : j);\n                break;\n            }\n            // add acronym bonus for exactly next match after unmatched `-`\n            acronym = ch2 === 45 /* - */;\n            j++;\n        }\n        if (!found) {\n            if (!partialMatch) {\n                return 0;\n            }\n            break;\n        }\n        i++;\n    }\n    const matchRatio = i / maxLength;\n    const delta = maxLength - minLength;\n    const maxScore = sum(maxLength) - sum(delta);\n    return (score * matchRatio) / maxScore;\n}\n/**\n * Calculates sum of first `n` numbers, e.g. 1+2+3+...n\n */\nfunction sum(n) {\n    return n * (n + 1) / 2;\n}\n\nfunction color(token, shortHex) {\n    if (!token.r && !token.g && !token.b && !token.a) {\n        return 'transparent';\n    }\n    else if (token.a === 1) {\n        return asHex(token, shortHex);\n    }\n    return asRGB(token);\n}\n/**\n * Output given color as hex value\n * @param short Produce short value (e.g. #fff instead of #ffffff), if possible\n */\nfunction asHex(token, short) {\n    const fn = (short && isShortHex(token.r) && isShortHex(token.g) && isShortHex(token.b))\n        ? toShortHex : toHex;\n    return '#' + fn(token.r) + fn(token.g) + fn(token.b);\n}\n/**\n * Output current color as `rgba?(...)` CSS color\n */\nfunction asRGB(token) {\n    const values = [token.r, token.g, token.b];\n    if (token.a !== 1) {\n        values.push(frac(token.a, 8));\n    }\n    return `${values.length === 3 ? 'rgb' : 'rgba'}(${values.join(', ')})`;\n}\nfunction frac(num, digits = 4) {\n    return num.toFixed(digits).replace(/\\.?0+$/, '');\n}\nfunction isShortHex(hex) {\n    return !(hex % 17);\n}\nfunction toShortHex(num) {\n    return (num >> 4).toString(16);\n}\nfunction toHex(num) {\n    return pad(num.toString(16), 2);\n}\nfunction pad(value, len) {\n    while (value.length < len) {\n        value = '0' + value;\n    }\n    return value;\n}\n\nconst CSSAbbreviationScope = {\n    /** Include all possible snippets in match */\n    Global: '@@global',\n    /** Include raw snippets only (e.g. no properties) in abbreviation match */\n    Section: '@@section',\n    /** Include properties only in abbreviation match */\n    Property: '@@property',\n    /** Resolve abbreviation in context of CSS property value */\n    Value: '@@value',\n};\nfunction css(abbr, config) {\n    var _a;\n    const out = createOutputStream(config.options);\n    const format = config.options['output.format'];\n    if (((_a = config.context) === null || _a === void 0 ? void 0 : _a.name) === CSSAbbreviationScope.Section) {\n        // For section context, filter out unmatched snippets\n        abbr = abbr.filter(node => node.snippet);\n    }\n    for (let i = 0; i < abbr.length; i++) {\n        if (format && i !== 0) {\n            pushNewline(out, true);\n        }\n        property(abbr[i], out, config);\n    }\n    return out.value;\n}\n/**\n * Outputs given abbreviation node into output stream\n */\nfunction property(node, out, config) {\n    const isJSON = config.options['stylesheet.json'];\n    if (node.name) {\n        // Its a CSS property\n        const name = isJSON ? toCamelCase(node.name) : node.name;\n        pushString(out, name + config.options['stylesheet.between']);\n        if (node.value.length) {\n            propertyValue(node, out, config);\n        }\n        else {\n            pushField(out, 0, '');\n        }\n        if (isJSON) {\n            // For CSS-in-JS, always finalize property with comma\n            // NB: seems like `important` is not available in CSS-in-JS syntaxes\n            push(out, ',');\n        }\n        else {\n            outputImportant(node, out, true);\n            push(out, config.options['stylesheet.after']);\n        }\n    }\n    else {\n        // Its a regular snippet, output plain tokens without any additional formatting\n        for (const cssVal of node.value) {\n            for (const v of cssVal.value) {\n                outputToken(v, out, config);\n            }\n        }\n        outputImportant(node, out, node.value.length > 0);\n    }\n}\nfunction propertyValue(node, out, config) {\n    const isJSON = config.options['stylesheet.json'];\n    const num = isJSON ? getSingleNumeric(node) : null;\n    if (num && (!num.unit || num.unit === 'px')) {\n        // For CSS-in-JS, if property contains single numeric value, output it\n        // as JS number\n        push(out, String(num.value));\n    }\n    else {\n        const quote = getQuote(config);\n        isJSON && push(out, quote);\n        for (let i = 0; i < node.value.length; i++) {\n            if (i !== 0) {\n                push(out, ', ');\n            }\n            outputValue(node.value[i], out, config);\n        }\n        isJSON && push(out, quote);\n    }\n}\nfunction outputImportant(node, out, separator) {\n    if (node.important) {\n        if (separator) {\n            push(out, ' ');\n        }\n        push(out, '!important');\n    }\n}\nfunction outputValue(value, out, config) {\n    for (let i = 0, prevEnd = -1; i < value.value.length; i++) {\n        const token = value.value[i];\n        // Handle edge case: a field is written close to previous token like this: `foo${bar}`.\n        // We should not add delimiter here\n        if (i !== 0 && (token.type !== 'Field' || token.start !== prevEnd)) {\n            push(out, ' ');\n        }\n        outputToken(token, out, config);\n        prevEnd = token['end'];\n    }\n}\nfunction outputToken(token, out, config) {\n    if (token.type === 'ColorValue') {\n        push(out, color(token, config.options['stylesheet.shortHex']));\n    }\n    else if (token.type === 'Literal' || token.type === 'CustomProperty') {\n        pushString(out, token.value);\n    }\n    else if (token.type === 'NumberValue') {\n        pushString(out, frac(token.value, 4) + token.unit);\n    }\n    else if (token.type === 'StringValue') {\n        const quote = token.quote === 'double' ? '\"' : '\\'';\n        pushString(out, quote + token.value + quote);\n    }\n    else if (token.type === 'Field') {\n        pushField(out, token.index, token.name);\n    }\n    else if (token.type === 'FunctionCall') {\n        push(out, token.name + '(');\n        for (let i = 0; i < token.arguments.length; i++) {\n            if (i) {\n                push(out, ', ');\n            }\n            outputValue(token.arguments[i], out, config);\n        }\n        push(out, ')');\n    }\n}\n/**\n * If value of given property is a single numeric value, returns this token\n */\nfunction getSingleNumeric(node) {\n    if (node.value.length === 1) {\n        const cssVal = node.value[0];\n        if (cssVal.value.length === 1 && cssVal.value[0].type === 'NumberValue') {\n            return cssVal.value[0];\n        }\n    }\n}\n/**\n * Converts kebab-case string to camelCase\n */\nfunction toCamelCase(str) {\n    return str.replace(/\\-(\\w)/g, (_, letter) => letter.toUpperCase());\n}\nfunction getQuote(config) {\n    return config.options['stylesheet.jsonDoubleQuotes'] ? '\"' : '\\'';\n}\n\nconst gradientName = 'lg';\n/**\n * Parses given Emmet abbreviation into a final abbreviation tree with all\n * required transformations applied\n */\nfunction parse(abbr, config) {\n    var _a;\n    const snippets = ((_a = config.cache) === null || _a === void 0 ? void 0 : _a.stylesheetSnippets) || convertSnippets(config.snippets);\n    const result = [];\n    if (config.cache) {\n        config.cache.stylesheetSnippets = snippets;\n    }\n    if (typeof abbr === 'string') {\n        abbr = parse$2(abbr, { value: isValueScope(config) });\n    }\n    const filteredSnippets = getSnippetsForScope(snippets, config);\n    for (const node of abbr) {\n        const resolved = resolveNode(node, filteredSnippets, config);\n        if (resolved) {\n            result.push(resolved);\n        }\n    }\n    return result;\n}\n/**\n * Converts given raw snippets into internal snippets representation\n */\nfunction convertSnippets(snippets) {\n    const result = [];\n    for (const key of Object.keys(snippets)) {\n        result.push(createSnippet(key, snippets[key]));\n    }\n    return nest(result);\n}\n/**\n * Resolves given node: finds matched CSS snippets using fuzzy match and resolves\n * keyword aliases from node value\n */\nfunction resolveNode(node, snippets, config) {\n    if (!resolveGradient(node, config)) {\n        const score = config.options['stylesheet.fuzzySearchMinScore'];\n        if (isValueScope(config)) {\n            // Resolve as value of given CSS property\n            const propName = config.context.name;\n            const snippet = snippets.find(s => s.type === CSSSnippetType.Property && s.property === propName);\n            resolveValueKeywords(node, config, snippet, score);\n            node.snippet = snippet;\n        }\n        else if (node.name) {\n            const snippet = findBestMatch(node.name, snippets, score, true);\n            node.snippet = snippet;\n            if (snippet) {\n                const resolved = snippet.type === CSSSnippetType.Property\n                    ? resolveAsProperty(node, snippet, config)\n                    : resolveAsSnippet(node, snippet);\n                if (resolved) {\n                    node = resolved;\n                }\n                else if (config.options['stylesheet.strictMatch']) {\n                    return null;\n                }\n            }\n        }\n    }\n    if (node.name || config.context) {\n        // Resolve numeric values for CSS properties only\n        resolveNumericValue(node, config);\n    }\n    return node;\n}\n/**\n * Resolves CSS gradient shortcut from given property, if possible\n */\nfunction resolveGradient(node, config) {\n    let gradientFn = null;\n    const cssVal = node.value.length === 1 ? node.value[0] : null;\n    if (cssVal && cssVal.value.length === 1) {\n        const v = cssVal.value[0];\n        if (v.type === 'FunctionCall' && v.name === gradientName) {\n            gradientFn = v;\n        }\n    }\n    if (gradientFn || node.name === gradientName) {\n        if (!gradientFn) {\n            gradientFn = {\n                type: 'FunctionCall',\n                name: 'linear-gradient',\n                arguments: [cssValue(field(0, ''))]\n            };\n        }\n        else {\n            gradientFn = Object.assign(Object.assign({}, gradientFn), { name: 'linear-gradient' });\n        }\n        if (!config.context) {\n            node.name = 'background-image';\n        }\n        node.value = [cssValue(gradientFn)];\n        return true;\n    }\n    return false;\n}\n/**\n * Resolves given parsed abbreviation node as CSS property\n */\nfunction resolveAsProperty(node, snippet, config) {\n    const abbr = node.name;\n    // Check for unmatched part of abbreviation\n    // For example, in `dib` abbreviation the matched part is `d` and `ib` should\n    // be considered as inline value. If unmatched fragment exists, we should check\n    // if it matches actual value of snippet. If either explicit value is specified\n    // or unmatched fragment did not resolve to to a keyword, we should consider\n    // matched snippet as invalid\n    const inlineValue = getUnmatchedPart(abbr, snippet.key);\n    if (inlineValue) {\n        if (node.value.length) {\n            // Already have value: unmatched part indicates matched snippet is invalid\n            return null;\n        }\n        const kw = resolveKeyword(inlineValue, config, snippet);\n        if (!kw) {\n            return null;\n        }\n        node.value.push(cssValue(kw));\n    }\n    node.name = snippet.property;\n    if (node.value.length) {\n        // Replace keyword alias from current abbreviation node with matched keyword\n        resolveValueKeywords(node, config, snippet);\n    }\n    else if (snippet.value.length) {\n        const defaultValue = snippet.value[0];\n        // https://github.com/emmetio/emmet/issues/558\n        // We should auto-select inserted value only if theres multiple value\n        // choice\n        node.value = snippet.value.length === 1 || defaultValue.some(hasField)\n            ? defaultValue\n            : defaultValue.map(n => wrapWithField(n, config));\n    }\n    return node;\n}\nfunction resolveValueKeywords(node, config, snippet, minScore) {\n    for (const cssVal of node.value) {\n        const value = [];\n        for (const token of cssVal.value) {\n            if (token.type === 'Literal') {\n                value.push(resolveKeyword(token.value, config, snippet, minScore) || token);\n            }\n            else if (token.type === 'FunctionCall') {\n                // For function calls, we should find matching function call\n                // and merge arguments\n                const match = resolveKeyword(token.name, config, snippet, minScore);\n                if (match && match.type === 'FunctionCall') {\n                    value.push(Object.assign(Object.assign({}, match), { arguments: token.arguments.concat(match.arguments.slice(token.arguments.length)) }));\n                }\n                else {\n                    value.push(token);\n                }\n            }\n            else {\n                value.push(token);\n            }\n        }\n        cssVal.value = value;\n    }\n}\n/**\n * Resolves given parsed abbreviation node as a snippet: a plain code chunk\n */\nfunction resolveAsSnippet(node, snippet) {\n    // When resolving snippets, we have to do the following:\n    // 1. Replace field placeholders with actual field tokens.\n    // 2. If input values given, put them instead of fields\n    let offset = 0;\n    let m;\n    const reField = /\\$\\{(\\d+)(:[^}]+)?\\}/g;\n    const inputValue = node.value[0];\n    const outputValue = [];\n    while (m = reField.exec(snippet.value)) {\n        if (offset !== m.index) {\n            outputValue.push(literal(snippet.value.slice(offset, m.index)));\n        }\n        offset = m.index + m[0].length;\n        if (inputValue && inputValue.value.length) {\n            outputValue.push(inputValue.value.shift());\n        }\n        else {\n            outputValue.push(field(Number(m[1]), m[2] ? m[2].slice(1) : ''));\n        }\n    }\n    const tail = snippet.value.slice(offset);\n    if (tail) {\n        outputValue.push(literal(tail));\n    }\n    node.name = void 0;\n    node.value = [cssValue(...outputValue)];\n    return node;\n}\n/**\n * Finds best matching item from `items` array\n * @param abbr  Abbreviation to match\n * @param items List of items for match\n * @param minScore The minimum score the best matched item should have to be a valid match.\n */\nfunction findBestMatch(abbr, items, minScore = 0, partialMatch = false) {\n    let matchedItem = null;\n    let maxScore = 0;\n    for (const item of items) {\n        const score = scoreMatch(abbr, getScoringPart(item), partialMatch);\n        if (score === 1) {\n            // direct hit, no need to look further\n            return item;\n        }\n        if (score && score >= maxScore) {\n            maxScore = score;\n            matchedItem = item;\n        }\n    }\n    return maxScore >= minScore ? matchedItem : null;\n}\nfunction getScoringPart(item) {\n    return typeof item === 'string' ? item : item.key;\n}\n/**\n * Returns a part of `abbr` that wasnt directly matched against `str`.\n * For example, if abbreviation `poas` is matched against `position`,\n * the unmatched part will be `as` since `a` wasnt found in string stream\n */\nfunction getUnmatchedPart(abbr, str) {\n    for (let i = 0, lastPos = 0; i < abbr.length; i++) {\n        lastPos = str.indexOf(abbr[i], lastPos);\n        if (lastPos === -1) {\n            return abbr.slice(i);\n        }\n        lastPos++;\n    }\n    return '';\n}\n/**\n * Resolves given keyword shorthand into matched snippet keyword or global keyword,\n * if possible\n */\nfunction resolveKeyword(kw, config, snippet, minScore) {\n    let ref;\n    if (snippet) {\n        if (ref = findBestMatch(kw, Object.keys(snippet.keywords), minScore)) {\n            return snippet.keywords[ref];\n        }\n        for (const dep of snippet.dependencies) {\n            if (ref = findBestMatch(kw, Object.keys(dep.keywords), minScore)) {\n                return dep.keywords[ref];\n            }\n        }\n    }\n    if (ref = findBestMatch(kw, config.options['stylesheet.keywords'], minScore)) {\n        return literal(ref);\n    }\n    return null;\n}\n/**\n * Resolves numeric values in given abbreviation node\n */\nfunction resolveNumericValue(node, config) {\n    const aliases = config.options['stylesheet.unitAliases'];\n    const unitless = config.options['stylesheet.unitless'];\n    for (const v of node.value) {\n        for (const t of v.value) {\n            if (t.type === 'NumberValue') {\n                if (t.unit) {\n                    t.unit = aliases[t.unit] || t.unit;\n                }\n                else if (t.value !== 0 && !unitless.includes(node.name)) {\n                    t.unit = t.rawValue.includes('.')\n                        ? config.options['stylesheet.floatUnit']\n                        : config.options['stylesheet.intUnit'];\n                }\n            }\n        }\n    }\n}\n/**\n * Constructs CSS value token\n */\nfunction cssValue(...args) {\n    return {\n        type: 'CSSValue',\n        value: args\n    };\n}\n/**\n * Constructs literal token\n */\nfunction literal(value) {\n    return { type: 'Literal', value };\n}\n/**\n * Constructs field token\n */\nfunction field(index, name) {\n    return { type: 'Field', index, name };\n}\n/**\n * Check if given value contains fields\n */\nfunction hasField(value) {\n    for (const v of value.value) {\n        if (v.type === 'Field' || (v.type === 'FunctionCall' && v.arguments.some(hasField))) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Wraps tokens of given abbreviation with fields\n */\nfunction wrapWithField(node, config, state = { index: 1 }) {\n    let value = [];\n    for (const v of node.value) {\n        switch (v.type) {\n            case 'ColorValue':\n                value.push(field(state.index++, color(v, config.options['stylesheet.shortHex'])));\n                break;\n            case 'Literal':\n                value.push(field(state.index++, v.value));\n                break;\n            case 'NumberValue':\n                value.push(field(state.index++, `${v.value}${v.unit}`));\n                break;\n            case 'StringValue':\n                const q = v.quote === 'single' ? '\\'' : '\"';\n                value.push(field(state.index++, q + v.value + q));\n                break;\n            case 'FunctionCall':\n                value.push(field(state.index++, v.name), literal('('));\n                for (let i = 0, il = v.arguments.length; i < il; i++) {\n                    value = value.concat(wrapWithField(v.arguments[i], config, state).value);\n                    if (i !== il - 1) {\n                        value.push(literal(', '));\n                    }\n                }\n                value.push(literal(')'));\n                break;\n            default:\n                value.push(v);\n        }\n    }\n    return Object.assign(Object.assign({}, node), { value });\n}\n/**\n * Check if abbreviation should be expanded in CSS value context\n */\nfunction isValueScope(config) {\n    if (config.context) {\n        return config.context.name === CSSAbbreviationScope.Value || !config.context.name.startsWith('@@');\n    }\n    return false;\n}\n/**\n * Returns snippets for given scope\n */\nfunction getSnippetsForScope(snippets, config) {\n    if (config.context) {\n        if (config.context.name === CSSAbbreviationScope.Section) {\n            return snippets.filter(s => s.type === CSSSnippetType.Raw);\n        }\n        if (config.context.name === CSSAbbreviationScope.Property) {\n            return snippets.filter(s => s.type === CSSSnippetType.Property);\n        }\n    }\n    return snippets;\n}\n\nvar markupSnippets = {\n\t\"a\": \"a[href]\",\n\t\"a:blank\": \"a[href='http://${0}' target='_blank' rel='noopener noreferrer']\",\n\t\"a:link\": \"a[href='http://${0}']\",\n\t\"a:mail\": \"a[href='mailto:${0}']\",\n\t\"a:tel\": \"a[href='tel:+${0}']\",\n\t\"abbr\": \"abbr[title]\",\n\t\"acr|acronym\": \"acronym[title]\",\n\t\"base\": \"base[href]/\",\n\t\"basefont\": \"basefont/\",\n\t\"br\": \"br/\",\n\t\"frame\": \"frame/\",\n\t\"hr\": \"hr/\",\n\t\"bdo\": \"bdo[dir]\",\n\t\"bdo:r\": \"bdo[dir=rtl]\",\n\t\"bdo:l\": \"bdo[dir=ltr]\",\n\t\"col\": \"col/\",\n\t\"link\": \"link[rel=stylesheet href]/\",\n\t\"link:css\": \"link[href='${1:style}.css']\",\n\t\"link:print\": \"link[href='${1:print}.css' media=print]\",\n\t\"link:favicon\": \"link[rel='shortcut icon' type=image/x-icon href='${1:favicon.ico}']\",\n\t\"link:mf|link:manifest\": \"link[rel='manifest' href='${1:manifest.json}']\",\n\t\"link:touch\": \"link[rel=apple-touch-icon href='${1:favicon.png}']\",\n\t\"link:rss\": \"link[rel=alternate type=application/rss+xml title=RSS href='${1:rss.xml}']\",\n\t\"link:atom\": \"link[rel=alternate type=application/atom+xml title=Atom href='${1:atom.xml}']\",\n\t\"link:im|link:import\": \"link[rel=import href='${1:component}.html']\",\n\t\"meta\": \"meta/\",\n\t\"meta:utf\": \"meta[http-equiv=Content-Type content='text/html;charset=UTF-8']\",\n\t\"meta:vp\": \"meta[name=viewport content='width=${1:device-width}, initial-scale=${2:1.0}']\",\n\t\"meta:compat\": \"meta[http-equiv=X-UA-Compatible content='${1:IE=7}']\",\n\t\"meta:edge\": \"meta:compat[content='${1:ie=edge}']\",\n\t\"meta:redirect\": \"meta[http-equiv=refresh content='0; url=${1:http://example.com}']\",\n\t\"meta:refresh\": \"meta[http-equiv=refresh content='${1:5}']\",\n\t\"meta:kw\": \"meta[name=keywords content]\",\n\t\"meta:desc\": \"meta[name=description content]\",\n\t\"style\": \"style\",\n\t\"script\": \"script\",\n\t\"script:src\": \"script[src]\",\n\t\"script:module\": \"script[type=module src]\",\n\t\"img\": \"img[src alt]/\",\n\t\"img:s|img:srcset\": \"img[srcset src alt]\",\n\t\"img:z|img:sizes\": \"img[sizes srcset src alt]\",\n\t\"picture\": \"picture\",\n\t\"src|source\": \"source/\",\n\t\"src:sc|source:src\": \"source[src type]\",\n\t\"src:s|source:srcset\": \"source[srcset]\",\n\t\"src:t|source:type\": \"source[srcset type='${1:image/}']\",\n\t\"src:z|source:sizes\": \"source[sizes srcset]\",\n\t\"src:m|source:media\": \"source[media='(${1:min-width: })' srcset]\",\n\t\"src:mt|source:media:type\": \"source:media[type='${2:image/}']\",\n\t\"src:mz|source:media:sizes\": \"source:media[sizes srcset]\",\n\t\"src:zt|source:sizes:type\": \"source[sizes srcset type='${1:image/}']\",\n\t\"iframe\": \"iframe[src frameborder=0]\",\n\t\"embed\": \"embed[src type]/\",\n\t\"object\": \"object[data type]\",\n\t\"param\": \"param[name value]/\",\n\t\"map\": \"map[name]\",\n\t\"area\": \"area[shape coords href alt]/\",\n\t\"area:d\": \"area[shape=default]\",\n\t\"area:c\": \"area[shape=circle]\",\n\t\"area:r\": \"area[shape=rect]\",\n\t\"area:p\": \"area[shape=poly]\",\n\t\"form\": \"form[action]\",\n\t\"form:get\": \"form[method=get]\",\n\t\"form:post\": \"form[method=post]\",\n\t\"label\": \"label[for]\",\n\t\"input\": \"input[type=${1:text}]/\",\n\t\"inp\": \"input[name=${1} id=${1}]\",\n\t\"input:h|input:hidden\": \"input[type=hidden name]\",\n\t\"input:t|input:text\": \"inp[type=text]\",\n\t\"input:search\": \"inp[type=search]\",\n\t\"input:email\": \"inp[type=email]\",\n\t\"input:url\": \"inp[type=url]\",\n\t\"input:p|input:password\": \"inp[type=password]\",\n\t\"input:datetime\": \"inp[type=datetime]\",\n\t\"input:date\": \"inp[type=date]\",\n\t\"input:datetime-local\": \"inp[type=datetime-local]\",\n\t\"input:month\": \"inp[type=month]\",\n\t\"input:week\": \"inp[type=week]\",\n\t\"input:time\": \"inp[type=time]\",\n\t\"input:tel\": \"inp[type=tel]\",\n\t\"input:number\": \"inp[type=number]\",\n\t\"input:color\": \"inp[type=color]\",\n\t\"input:c|input:checkbox\": \"inp[type=checkbox]\",\n\t\"input:r|input:radio\": \"inp[type=radio]\",\n\t\"input:range\": \"inp[type=range]\",\n\t\"input:f|input:file\": \"inp[type=file]\",\n\t\"input:s|input:submit\": \"input[type=submit value]\",\n\t\"input:i|input:image\": \"input[type=image src alt]\",\n\t\"input:b|input:btn|input:button\": \"input[type=button value]\",\n\t\"input:reset\": \"input:button[type=reset]\",\n\t\"isindex\": \"isindex/\",\n\t\"select\": \"select[name=${1} id=${1}]\",\n\t\"select:d|select:disabled\": \"select[disabled.]\",\n\t\"opt|option\": \"option[value]\",\n\t\"textarea\": \"textarea[name=${1} id=${1}]\",\n\t\"tarea:c|textarea:cols\":\"textarea[name=${1} id=${1} cols=${2:30}]\",\n\t\"tarea:r|textarea:rows\":\"textarea[name=${1} id=${1} rows=${3:10}]\",\n\t\"tarea:cr|textarea:cols:rows\":\"textarea[name=${1} id=${1} cols=${2:30} rows=${3:10}]\",\n\t\"marquee\": \"marquee[behavior direction]\",\n\t\"menu:c|menu:context\": \"menu[type=context]\",\n\t\"menu:t|menu:toolbar\": \"menu[type=toolbar]\",\n\t\"video\": \"video[src]\",\n\t\"audio\": \"audio[src]\",\n\t\"html:xml\": \"html[xmlns=http://www.w3.org/1999/xhtml]\",\n\t\"keygen\": \"keygen/\",\n\t\"command\": \"command/\",\n\t\"btn:s|button:s|button:submit\" : \"button[type=submit]\",\n\t\"btn:r|button:r|button:reset\" : \"button[type=reset]\",\n\t\"btn:b|button:b|button:button\" : \"button[type=button]\",\n\t\"btn:d|button:d|button:disabled\" : \"button[disabled.]\",\n\t\"fst:d|fset:d|fieldset:d|fieldset:disabled\" : \"fieldset[disabled.]\",\n\n\t\"bq\": \"blockquote\",\n\t\"fig\": \"figure\",\n\t\"figc\": \"figcaption\",\n\t\"pic\": \"picture\",\n\t\"ifr\": \"iframe\",\n\t\"emb\": \"embed\",\n\t\"obj\": \"object\",\n\t\"cap\": \"caption\",\n\t\"colg\": \"colgroup\",\n\t\"fst\": \"fieldset\",\n\t\"btn\": \"button\",\n\t\"optg\": \"optgroup\",\n\t\"tarea\": \"textarea\",\n\t\"leg\": \"legend\",\n\t\"sect\": \"section\",\n\t\"art\": \"article\",\n\t\"hdr\": \"header\",\n\t\"ftr\": \"footer\",\n\t\"adr\": \"address\",\n\t\"dlg\": \"dialog\",\n\t\"str\": \"strong\",\n\t\"prog\": \"progress\",\n\t\"mn\": \"main\",\n\t\"tem\": \"template\",\n\t\"fset\": \"fieldset\",\n\t\"datal\": \"datalist\",\n\t\"kg\": \"keygen\",\n\t\"out\": \"output\",\n\t\"det\": \"details\",\n\t\"sum\": \"summary\",\n\t\"cmd\": \"command\",\n\t\"data\": \"data[value]\",\n\t\"meter\": \"meter[value]\",\n\t\"time\": \"time[datetime]\",\n\n\t\"ri:d|ri:dpr\": \"img:s\",\n\t\"ri:v|ri:viewport\": \"img:z\",\n\t\"ri:a|ri:art\": \"pic>src:m+img\",\n\t\"ri:t|ri:type\": \"pic>src:t+img\",\n\n\t\"!!!\": \"{<!DOCTYPE html>}\",\n\t\"doc\": \"html[lang=${lang}]>(head>meta[charset=${charset}]+meta:vp+title{${1:Document}})+body\",\n\t\"!|html:5\": \"!!!+doc\",\n\n\t\"c\": \"{<!-- ${0} -->}\",\n\t\"cc:ie\": \"{<!--[if IE]>${0}<![endif]-->}\",\n\t\"cc:noie\": \"{<!--[if !IE]><!-->${0}<!--<![endif]-->}\"\n};\n\nvar stylesheetSnippets = {\n\t\"@f\": \"@font-face {\\n\\tfont-family: ${1};\\n\\tsrc: url(${2});\\n}\",\n\t\"@ff\": \"@font-face {\\n\\tfont-family: '${1:FontName}';\\n\\tsrc: url('${2:FileName}.eot');\\n\\tsrc: url('${2:FileName}.eot?#iefix') format('embedded-opentype'),\\n\\t\\t url('${2:FileName}.woff') format('woff'),\\n\\t\\t url('${2:FileName}.ttf') format('truetype'),\\n\\t\\t url('${2:FileName}.svg#${1:FontName}') format('svg');\\n\\tfont-style: ${3:normal};\\n\\tfont-weight: ${4:normal};\\n}\",\n\t\"@i|@import\": \"@import url(${0});\",\n\t\"@kf\": \"@keyframes ${1:identifier} {\\n\\t${2}\\n}\",\n\t\"@m|@media\": \"@media ${1:screen} {\\n\\t${0}\\n}\",\n\t\"ac\": \"align-content:start|end|flex-start|flex-end|center|space-between|space-around|stretch|space-evenly\",\n\t\"ai\": \"align-items:start|end|flex-start|flex-end|center|baseline|stretch\",\n\t\"anim\": \"animation:${1:name} ${2:duration} ${3:timing-function} ${4:delay} ${5:iteration-count} ${6:direction} ${7:fill-mode}\",\n\t\"animdel\": \"animation-delay:time\",\n\t\"animdir\": \"animation-direction:normal|reverse|alternate|alternate-reverse\",\n\t\"animdur\": \"animation-duration:${1:0}s\",\n\t\"animfm\": \"animation-fill-mode:both|forwards|backwards\",\n\t\"animic\": \"animation-iteration-count:1|infinite\",\n\t\"animn\": \"animation-name\",\n\t\"animps\": \"animation-play-state:running|paused\",\n\t\"animtf\": \"animation-timing-function:linear|ease|ease-in|ease-out|ease-in-out|cubic-bezier(${1:0.1}, ${2:0.7}, ${3:1.0}, ${3:0.1})\",\n\t\"ap\": \"appearance:none\",\n\t\"as\": \"align-self:start|end|auto|flex-start|flex-end|center|baseline|stretch\",\n\t\"b\": \"bottom\",\n\t\"bd\": \"border:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdb\": \"border-bottom:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdbc\": \"border-bottom-color:${1:#000}\",\n\t\"bdbi\": \"border-bottom-image:url(${0})\",\n\t\"bdbk\": \"border-break:close\",\n\t\"bdbli\": \"border-bottom-left-image:url(${0})|continue\",\n\t\"bdblrs\": \"border-bottom-left-radius\",\n\t\"bdbri\": \"border-bottom-right-image:url(${0})|continue\",\n\t\"bdbrrs\": \"border-bottom-right-radius\",\n\t\"bdbs\": \"border-bottom-style\",\n\t\"bdbw\": \"border-bottom-width\",\n\t\"bdc\": \"border-color:${1:#000}\",\n\t\"bdci\": \"border-corner-image:url(${0})|continue\",\n\t\"bdcl\": \"border-collapse:collapse|separate\",\n\t\"bdf\": \"border-fit:repeat|clip|scale|stretch|overwrite|overflow|space\",\n\t\"bdi\": \"border-image:url(${0})\",\n\t\"bdl\": \"border-left:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdlc\": \"border-left-color:${1:#000}\",\n\t\"bdlen\": \"border-length\",\n\t\"bdli\": \"border-left-image:url(${0})\",\n\t\"bdls\": \"border-left-style\",\n\t\"bdlw\": \"border-left-width\",\n\t\"bdr\": \"border-right:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdrc\": \"border-right-color:${1:#000}\",\n\t\"bdri\": \"border-right-image:url(${0})\",\n\t\"bdrs\": \"border-radius\",\n\t\"bdrst\": \"border-right-style\",\n\t\"bdrw\": \"border-right-width\",\n\t\"bds\": \"border-style:none|hidden|dotted|dashed|solid|double|dot-dash|dot-dot-dash|wave|groove|ridge|inset|outset\",\n\t\"bdsp\": \"border-spacing\",\n\t\"bdt\": \"border-top:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdtc\": \"border-top-color:${1:#000}\",\n\t\"bdti\": \"border-top-image:url(${0})\",\n\t\"bdtli\": \"border-top-left-image:url(${0})|continue\",\n\t\"bdtlrs\": \"border-top-left-radius\",\n\t\"bdtri\": \"border-top-right-image:url(${0})|continue\",\n\t\"bdtrrs\": \"border-top-right-radius\",\n\t\"bdts\": \"border-top-style\",\n\t\"bdtw\": \"border-top-width\",\n\t\"bdw\": \"border-width\",\n  \"bbs\": \"border-block-start\",\n  \"bbe\": \"border-block-end\",\n  \"bis\": \"border-inline-start\",\n  \"bie\": \"border-inline-end\",\n\t\"bfv\": \"backface-visibility:hidden|visible\",\n\t\"bg\": \"background:${1:#000}\",\n\t\"bg:n\": \"background: none\",\n\t\"bga\": \"background-attachment:fixed|scroll\",\n\t\"bgbk\": \"background-break:bounding-box|each-box|continuous\",\n\t\"bgc\": \"background-color:${1:#fff}\",\n\t\"bgcp\": \"background-clip:padding-box|border-box|content-box|no-clip\",\n\t\"bgi\": \"background-image:url(${0})\",\n\t\"bgo\": \"background-origin:padding-box|border-box|content-box\",\n\t\"bgp\": \"background-position:${1:0} ${2:0}\",\n\t\"bgpx\": \"background-position-x\",\n\t\"bgpy\": \"background-position-y\",\n\t\"bgr\": \"background-repeat:no-repeat|repeat-x|repeat-y|space|round\",\n\t\"bgsz\": \"background-size:contain|cover\",\n  \"bs\": \"block-size\",\n\t\"bxsh\": \"box-shadow:${1:inset }${2:hoff} ${3:voff} ${4:blur} ${5:#000}|none\",\n\t\"bxsz\": \"box-sizing:border-box|content-box|border-box\",\n\t\"c\": \"color:${1:#000}\",\n  \"cg\": \"column-gap\",\n\t\"cr\": \"color:rgb(${1:0}, ${2:0}, ${3:0})\",\n\t\"cra\": \"color:rgba(${1:0}, ${2:0}, ${3:0}, ${4:.5})\",\n\t\"cl\": \"clear:both|left|right|none\",\n\t\"cm\": \"/* ${0} */\",\n\t\"cnt\": \"content:'${0}'|normal|open-quote|no-open-quote|close-quote|no-close-quote|attr(${0})|counter(${0})|counters(${0})\",\n\t\"coi\": \"counter-increment\",\n\t\"colm\": \"columns\",\n\t\"colmc\": \"column-count\",\n\t\"colmf\": \"column-fill\",\n\t\"colmg\": \"column-gap\",\n\t\"colmr\": \"column-rule\",\n\t\"colmrc\": \"column-rule-color\",\n\t\"colmrs\": \"column-rule-style\",\n\t\"colmrw\": \"column-rule-width\",\n\t\"colms\": \"column-span\",\n\t\"colmw\": \"column-width\",\n\t\"cor\": \"counter-reset\",\n\t\"cp\": \"clip:auto|rect(${1:top} ${2:right} ${3:bottom} ${4:left})\",\n\t\"cps\": \"caption-side:top|bottom\",\n\t\"cur\": \"cursor:pointer|auto|default|crosshair|hand|help|move|pointer|text\",\n\t\"d\": \"display:block|none|flex|inline-flex|inline|inline-block|grid|inline-grid|subgrid|list-item|run-in|contents|table|inline-table|table-caption|table-column|table-column-group|table-header-group|table-footer-group|table-row|table-row-group|table-cell|ruby|ruby-base|ruby-base-group|ruby-text|ruby-text-group\",\n\t\"ec\": \"empty-cells:show|hide\",\n\t\"f\": \"font:${1:1em} ${2:sans-serif}\",\n\t\"fd\": \"font-display:auto|block|swap|fallback|optional\",\n\t\"fef\": \"font-effect:none|engrave|emboss|outline\",\n\t\"fem\": \"font-emphasize\",\n\t\"femp\": \"font-emphasize-position:before|after\",\n\t\"fems\": \"font-emphasize-style:none|accent|dot|circle|disc\",\n\t\"ff\": \"font-family:serif|sans-serif|cursive|fantasy|monospace\",\n\t\"fft\": \"font-family:\\\"Times New Roman\\\", Times, Baskerville, Georgia, serif\",\n\t\"ffa\": \"font-family:Arial, \\\"Helvetica Neue\\\", Helvetica, sans-serif\",\n\t\"ffv\": \"font-family:Verdana, Geneva, sans-serif\",\n\t\"fl\": \"float:left|right|none\",\n\t\"fs\": \"font-style:italic|normal|oblique\",\n\t\"fsm\": \"font-smoothing:antialiased|subpixel-antialiased|none\",\n\t\"fst\": \"font-stretch:normal|ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded\",\n\t\"fv\": \"font-variant:normal|small-caps\",\n\t\"fvs\": \"font-variation-settings:normal|inherit|initial|unset\",\n\t\"fw\": \"font-weight:normal|bold|bolder|lighter\",\n\t\"fx\": \"flex\",\n\t\"fxb\": \"flex-basis:fill|max-content|min-content|fit-content|content\",\n\t\"fxd\": \"flex-direction:row|row-reverse|column|column-reverse\",\n\t\"fxf\": \"flex-flow\",\n\t\"fxg\": \"flex-grow\",\n\t\"fxsh\": \"flex-shrink\",\n\t\"fxw\": \"flex-wrap:nowrap|wrap|wrap-reverse\",\n\t\"fsz\": \"font-size\",\n\t\"fsza\": \"font-size-adjust\",\n\t\"g\": \"gap\",\n\t\"gtc\": \"grid-template-columns:repeat(${0})|minmax()\",\n\t\"gtr\": \"grid-template-rows:repeat(${0})|minmax()\",\n\t\"gta\": \"grid-template-areas\",\n\t\"gt\": \"grid-template\",\n\t\"gg\": \"grid-gap\",\n\t\"gcg\": \"grid-column-gap\",\n\t\"grg\": \"grid-row-gap\",\n\t\"gac\": \"grid-auto-columns:auto|minmax()\",\n\t\"gar\": \"grid-auto-rows:auto|minmax()\",\n\t\"gaf\": \"grid-auto-flow:row|column|dense|inherit|initial|unset\",\n\t\"gd\": \"grid\",\n\t\"gc\": \"grid-column\",\n\t\"gcs\": \"grid-column-start\",\n\t\"gce\": \"grid-column-end\",\n\t\"gr\": \"grid-row\",\n\t\"grs\": \"grid-row-start\",\n\t\"gre\": \"grid-row-end\",\n\t\"ga\": \"grid-area\",\n\t\"h\": \"height\",\n  \"is\": \"inline-size\",\n\t\"jc\": \"justify-content:start|end|stretch|flex-start|flex-end|center|space-between|space-around|space-evenly\",\n\t\"ji\": \"justify-items:start|end|center|stretch\",\n\t\"js\": \"justify-self:start|end|center|stretch\",\n\t\"l\": \"left\",\n\t\"lg\": \"background-image:linear-gradient(${1})\",\n\t\"lh\": \"line-height\",\n\t\"lis\": \"list-style\",\n\t\"lisi\": \"list-style-image\",\n\t\"lisp\": \"list-style-position:inside|outside\",\n\t\"list\": \"list-style-type:disc|circle|square|decimal|decimal-leading-zero|lower-roman|upper-roman\",\n\t\"lts\": \"letter-spacing:normal\",\n\t\"m\": \"margin\",\n\t\"mah\": \"max-height\",\n\t\"mar\": \"max-resolution\",\n\t\"maw\": \"max-width\",\n\t\"mb\": \"margin-bottom\",\n\t\"mih\": \"min-height\",\n\t\"mir\": \"min-resolution\",\n\t\"miw\": \"min-width\",\n\t\"ml\": \"margin-left\",\n\t\"mr\": \"margin-right\",\n\t\"mt\": \"margin-top\",\n  \"mbs\": \"margin-block-start\",\n  \"mbe\": \"margin-block-end\",\n  \"mis\": \"margin-inline-start\",\n  \"mie\": \"margin-inline-end\",\n\t\"ol\": \"outline\",\n\t\"olc\": \"outline-color:${1:#000}|invert\",\n\t\"olo\": \"outline-offset\",\n\t\"ols\": \"outline-style:none|dotted|dashed|solid|double|groove|ridge|inset|outset\",\n\t\"olw\": \"outline-width:thin|medium|thick\",\n\t\"op|opa\": \"opacity\",\n\t\"ord\": \"order\",\n\t\"ori\": \"orientation:landscape|portrait\",\n\t\"orp\": \"orphans\",\n\t\"ov\": \"overflow:hidden|visible|hidden|scroll|auto\",\n\t\"ovs\": \"overflow-style:scrollbar|auto|scrollbar|panner|move|marquee\",\n\t\"ovx\": \"overflow-x:hidden|visible|hidden|scroll|auto\",\n\t\"ovy\": \"overflow-y:hidden|visible|hidden|scroll|auto\",\n\t\"p\": \"padding\",\n\t\"pb\": \"padding-bottom\",\n\t\"pgba\": \"page-break-after:auto|always|left|right\",\n\t\"pgbb\": \"page-break-before:auto|always|left|right\",\n\t\"pgbi\": \"page-break-inside:auto|avoid\",\n\t\"pl\": \"padding-left\",\n\t\"pos\": \"position:relative|absolute|relative|fixed|static\",\n\t\"pr\": \"padding-right\",\n\t\"pt\": \"padding-top\",\n  \"pbs\": \"padding-block-start\",\n  \"pbe\": \"padding-block-end\",\n  \"pis\": \"padding-inline-start\",\n  \"pie\": \"padding-inline-end\",\n  \"spbs\": \"scroll-padding-block-start\",\n  \"spbe\": \"scroll-padding-block-end\",\n  \"spis\": \"scroll-padding-inline-start\",\n  \"spie\": \"scroll-padding-inline-end\",\n\t\"q\": \"quotes\",\n\t\"qen\": \"quotes:'\\\\201C' '\\\\201D' '\\\\2018' '\\\\2019'\",\n\t\"qru\": \"quotes:'\\\\00AB' '\\\\00BB' '\\\\201E' '\\\\201C'\",\n\t\"r\": \"right\",\n  \"rg\": \"row-gap\",\n\t\"rsz\": \"resize:none|both|horizontal|vertical\",\n\t\"t\": \"top\",\n\t\"ta\": \"text-align:left|center|right|justify\",\n\t\"tal\": \"text-align-last:left|center|right\",\n\t\"tbl\": \"table-layout:fixed\",\n\t\"td\": \"text-decoration:none|underline|overline|line-through\",\n\t\"te\": \"text-emphasis:none|accent|dot|circle|disc|before|after\",\n\t\"th\": \"text-height:auto|font-size|text-size|max-size\",\n\t\"ti\": \"text-indent\",\n\t\"tj\": \"text-justify:auto|inter-word|inter-ideograph|inter-cluster|distribute|kashida|tibetan\",\n\t\"to\": \"text-outline:${1:0} ${2:0} ${3:#000}\",\n\t\"tov\": \"text-overflow:ellipsis|clip\",\n\t\"tr\": \"text-replace\",\n\t\"trf\": \"transform:${1}|skewX(${1:angle})|skewY(${1:angle})|scale(${1:x}, ${2:y})|scaleX(${1:x})|scaleY(${1:y})|scaleZ(${1:z})|scale3d(${1:x}, ${2:y}, ${3:z})|rotate(${1:angle})|rotateX(${1:angle})|rotateY(${1:angle})|rotateZ(${1:angle})|translate(${1:x}, ${2:y})|translateX(${1:x})|translateY(${1:y})|translateZ(${1:z})|translate3d(${1:tx}, ${2:ty}, ${3:tz})\",\n\t\"trfo\": \"transform-origin\",\n\t\"trfs\": \"transform-style:preserve-3d\",\n\t\"trs\": \"transition:${1:prop} ${2:time}\",\n\t\"trsde\": \"transition-delay:${1:time}\",\n\t\"trsdu\": \"transition-duration:${1:time}\",\n\t\"trsp\": \"transition-property:${1:prop}\",\n\t\"trstf\": \"transition-timing-function:${1:fn}\",\n\t\"tsh\": \"text-shadow:${1:hoff} ${2:voff} ${3:blur} ${4:#000}\",\n\t\"tt\": \"text-transform:uppercase|lowercase|capitalize|none\",\n\t\"tw\": \"text-wrap:none|normal|unrestricted|suppress\",\n\t\"us\": \"user-select:none\",\n\t\"v\": \"visibility:hidden|visible|collapse\",\n\t\"va\": \"vertical-align:top|super|text-top|middle|baseline|bottom|text-bottom|sub\",\n\t\"w|wid\": \"width\",\n\t\"whs\": \"white-space:nowrap|pre|pre-wrap|pre-line|normal\",\n\t\"whsc\": \"white-space-collapse:normal|keep-all|loose|break-strict|break-all\",\n\t\"wido\": \"widows\",\n\t\"wm\": \"writing-mode:lr-tb|lr-tb|lr-bt|rl-tb|rl-bt|tb-rl|tb-lr|bt-lr|bt-rl\",\n\t\"wob\": \"word-break:normal|keep-all|break-all\",\n\t\"wos\": \"word-spacing\",\n\t\"wow\": \"word-wrap:none|unrestricted|suppress|break-word|normal\",\n\t\"z\": \"z-index\",\n\t\"zom\": \"zoom:1\"\n};\n\nvar xslSnippets = {\n    \"tm|tmatch\": \"xsl:template[match mode]\",\n    \"tn|tname\": \"xsl:template[name]\",\n    \"call\": \"xsl:call-template[name]\",\n    \"ap\": \"xsl:apply-templates[select mode]\",\n    \"api\": \"xsl:apply-imports\",\n    \"imp\": \"xsl:import[href]\",\n    \"inc\": \"xsl:include[href]\",\n    \"ch\": \"xsl:choose\",\n    \"wh|xsl:when\": \"xsl:when[test]\",\n    \"ot\": \"xsl:otherwise\",\n    \"if\": \"xsl:if[test]\",\n    \"par\": \"xsl:param[name]\",\n    \"pare\": \"xsl:param[name select]\",\n    \"var\": \"xsl:variable[name]\",\n    \"vare\": \"xsl:variable[name select]\",\n    \"wp\": \"xsl:with-param[name select]\",\n    \"key\": \"xsl:key[name match use]\",\n    \"elem\": \"xsl:element[name]\",\n    \"attr\": \"xsl:attribute[name]\",\n    \"attrs\": \"xsl:attribute-set[name]\",\n    \"cp\": \"xsl:copy[select]\",\n    \"co\": \"xsl:copy-of[select]\",\n    \"val\": \"xsl:value-of[select]\",\n    \"for|each\": \"xsl:for-each[select]\",\n    \"tex\": \"xsl:text\",\n    \"com\": \"xsl:comment\",\n    \"msg\": \"xsl:message[terminate=no]\",\n    \"fall\": \"xsl:fallback\",\n    \"num\": \"xsl:number[value]\",\n    \"nam\": \"namespace-alias[stylesheet-prefix result-prefix]\",\n    \"pres\": \"xsl:preserve-space[elements]\",\n    \"strip\": \"xsl:strip-space[elements]\",\n    \"proc\": \"xsl:processing-instruction[name]\",\n    \"sort\": \"xsl:sort[select order]\",\n    \"choose\": \"xsl:choose>xsl:when+xsl:otherwise\",\n    \"xsl\": \"!!!+xsl:stylesheet[version=1.0 xmlns:xsl=http://www.w3.org/1999/XSL/Transform]>{\\n|}\",\n    \"!!!\": \"{<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>}\"\n};\n\nvar pugSnippets = {\n\t\"!!!\": \"{doctype html}\"\n};\n\nvar variables = {\n\t\"lang\": \"en\",\n\t\"locale\": \"en-US\",\n\t\"charset\": \"UTF-8\",\n\t\"indentation\": \"\\t\",\n\t\"newline\": \"\\n\"\n};\n\n/**\n * Default syntaxes for abbreviation types\n */\nconst defaultSyntaxes = {\n    markup: 'html',\n    stylesheet: 'css'\n};\nconst defaultOptions$1 = {\n    'inlineElements': [\n        'a', 'abbr', 'acronym', 'applet', 'b', 'basefont', 'bdo',\n        'big', 'br', 'button', 'cite', 'code', 'del', 'dfn', 'em', 'font', 'i',\n        'iframe', 'img', 'input', 'ins', 'kbd', 'label', 'map', 'object', 'q',\n        's', 'samp', 'select', 'small', 'span', 'strike', 'strong', 'sub', 'sup',\n        'textarea', 'tt', 'u', 'var'\n    ],\n    'output.indent': '\\t',\n    'output.baseIndent': '',\n    'output.newline': '\\n',\n    'output.tagCase': '',\n    'output.attributeCase': '',\n    'output.attributeQuotes': 'double',\n    'output.format': true,\n    'output.formatLeafNode': false,\n    'output.formatSkip': ['html'],\n    'output.formatForce': ['body'],\n    'output.inlineBreak': 3,\n    'output.compactBoolean': false,\n    'output.booleanAttributes': [\n        'contenteditable', 'seamless', 'async', 'autofocus',\n        'autoplay', 'checked', 'controls', 'defer', 'disabled', 'formnovalidate',\n        'hidden', 'ismap', 'loop', 'multiple', 'muted', 'novalidate', 'readonly',\n        'required', 'reversed', 'selected', 'typemustmatch'\n    ],\n    'output.reverseAttributes': false,\n    'output.selfClosingStyle': 'html',\n    'output.field': (index, placeholder) => placeholder,\n    'output.text': text => text,\n    'markup.href': true,\n    'comment.enabled': false,\n    'comment.trigger': ['id', 'class'],\n    'comment.before': '',\n    'comment.after': '\\n<!-- /[#ID][.CLASS] -->',\n    'bem.enabled': false,\n    'bem.element': '__',\n    'bem.modifier': '_',\n    'jsx.enabled': false,\n    'stylesheet.keywords': ['auto', 'inherit', 'unset', 'none'],\n    'stylesheet.unitless': ['z-index', 'line-height', 'opacity', 'font-weight', 'zoom', 'flex', 'flex-grow', 'flex-shrink'],\n    'stylesheet.shortHex': true,\n    'stylesheet.between': ': ',\n    'stylesheet.after': ';',\n    'stylesheet.intUnit': 'px',\n    'stylesheet.floatUnit': 'em',\n    'stylesheet.unitAliases': { e: 'em', p: '%', x: 'ex', r: 'rem' },\n    'stylesheet.json': false,\n    'stylesheet.jsonDoubleQuotes': false,\n    'stylesheet.fuzzySearchMinScore': 0,\n    'stylesheet.strictMatch': false\n};\nconst defaultConfig = {\n    type: 'markup',\n    syntax: 'html',\n    variables,\n    snippets: {},\n    options: defaultOptions$1\n};\n/**\n * Default per-syntax config\n */\nconst syntaxConfig = {\n    markup: {\n        snippets: parseSnippets(markupSnippets),\n    },\n    xhtml: {\n        options: {\n            'output.selfClosingStyle': 'xhtml'\n        }\n    },\n    xml: {\n        options: {\n            'output.selfClosingStyle': 'xml'\n        }\n    },\n    xsl: {\n        snippets: parseSnippets(xslSnippets),\n        options: {\n            'output.selfClosingStyle': 'xml'\n        }\n    },\n    jsx: {\n        options: {\n            'jsx.enabled': true,\n            'markup.attributes': {\n                'class': 'className',\n                'class*': 'styleName',\n                'for': 'htmlFor'\n            },\n            'markup.valuePrefix': {\n                'class*': 'styles'\n            }\n        }\n    },\n    vue: {\n        options: {\n            'markup.attributes': {\n                'class*': ':class',\n            }\n        }\n    },\n    svelte: {\n        options: {\n            'jsx.enabled': true\n        }\n    },\n    pug: {\n        snippets: parseSnippets(pugSnippets)\n    },\n    stylesheet: {\n        snippets: parseSnippets(stylesheetSnippets)\n    },\n    sass: {\n        options: {\n            'stylesheet.after': ''\n        }\n    },\n    stylus: {\n        options: {\n            'stylesheet.between': ' ',\n            'stylesheet.after': '',\n        }\n    }\n};\n/**\n * Parses raw snippets definitions with possibly multiple keys into a plan\n * snippet map\n */\nfunction parseSnippets(snippets) {\n    const result = {};\n    Object.keys(snippets).forEach(k => {\n        for (const name of k.split('|')) {\n            result[name] = snippets[k];\n        }\n    });\n    return result;\n}\nfunction resolveConfig(config = {}, globals = {}) {\n    const type = config.type || 'markup';\n    const syntax = config.syntax || defaultSyntaxes[type];\n    return Object.assign(Object.assign(Object.assign({}, defaultConfig), config), { type,\n        syntax, variables: mergedData(type, syntax, 'variables', config, globals), snippets: mergedData(type, syntax, 'snippets', config, globals), options: mergedData(type, syntax, 'options', config, globals) });\n}\nfunction mergedData(type, syntax, key, config, globals = {}) {\n    const typeDefaults = syntaxConfig[type];\n    const typeOverride = globals[type];\n    const syntaxDefaults = syntaxConfig[syntax];\n    const syntaxOverride = globals[syntax];\n    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, defaultConfig[key]), (typeDefaults && typeDefaults[key])), (syntaxDefaults && syntaxDefaults[key])), (typeOverride && typeOverride[key])), (syntaxOverride && syntaxOverride[key])), config[key]);\n}\n\n/**\n * Creates structure for scanning given string in backward direction\n */\nfunction backwardScanner(text, start = 0) {\n    return { text, start, pos: text.length };\n}\n/**\n * Check if given scanner position is at start of scanned text\n */\nfunction sol(scanner) {\n    return scanner.pos === scanner.start;\n}\n/**\n * Peeks character code an current scanner location without advancing it\n */\nfunction peek(scanner, offset = 0) {\n    return scanner.text.charCodeAt(scanner.pos - 1 + offset);\n}\n/**\n * Returns current character code and moves character location one symbol back\n */\nfunction previous(scanner) {\n    if (!sol(scanner)) {\n        return scanner.text.charCodeAt(--scanner.pos);\n    }\n}\n/**\n * Consumes current character code if it matches given `match` code or function\n */\nfunction consume(scanner, match) {\n    if (sol(scanner)) {\n        return false;\n    }\n    const ok = typeof match === 'function'\n        ? match(peek(scanner))\n        : match === peek(scanner);\n    if (ok) {\n        scanner.pos--;\n    }\n    return !!ok;\n}\nfunction consumeWhile(scanner, match) {\n    const start = scanner.pos;\n    while (consume(scanner, match)) {\n        // empty\n    }\n    return scanner.pos < start;\n}\n\nvar Chars$1;\n(function (Chars) {\n    Chars[Chars[\"SingleQuote\"] = 39] = \"SingleQuote\";\n    Chars[Chars[\"DoubleQuote\"] = 34] = \"DoubleQuote\";\n    Chars[Chars[\"Escape\"] = 92] = \"Escape\";\n})(Chars$1 || (Chars$1 = {}));\n/**\n * Check if given character code is a quote\n */\nfunction isQuote(c) {\n    return c === Chars$1.SingleQuote || c === Chars$1.DoubleQuote;\n}\n/**\n * Consumes quoted value, if possible\n * @return Returns `true` is value was consumed\n */\nfunction consumeQuoted(scanner) {\n    const start = scanner.pos;\n    const quote = previous(scanner);\n    if (isQuote(quote)) {\n        while (!sol(scanner)) {\n            if (previous(scanner) === quote && peek(scanner) !== Chars$1.Escape) {\n                return true;\n            }\n        }\n    }\n    scanner.pos = start;\n    return false;\n}\n\nvar Brackets;\n(function (Brackets) {\n    Brackets[Brackets[\"SquareL\"] = 91] = \"SquareL\";\n    Brackets[Brackets[\"SquareR\"] = 93] = \"SquareR\";\n    Brackets[Brackets[\"RoundL\"] = 40] = \"RoundL\";\n    Brackets[Brackets[\"RoundR\"] = 41] = \"RoundR\";\n    Brackets[Brackets[\"CurlyL\"] = 123] = \"CurlyL\";\n    Brackets[Brackets[\"CurlyR\"] = 125] = \"CurlyR\";\n})(Brackets || (Brackets = {}));\nconst bracePairs = {\n    [Brackets.SquareL]: Brackets.SquareR,\n    [Brackets.RoundL]: Brackets.RoundR,\n    [Brackets.CurlyL]: Brackets.CurlyR,\n};\n\nvar Chars;\n(function (Chars) {\n    Chars[Chars[\"Tab\"] = 9] = \"Tab\";\n    Chars[Chars[\"Space\"] = 32] = \"Space\";\n    /** `-` character */\n    Chars[Chars[\"Dash\"] = 45] = \"Dash\";\n    /** `/` character */\n    Chars[Chars[\"Slash\"] = 47] = \"Slash\";\n    /** `:` character */\n    Chars[Chars[\"Colon\"] = 58] = \"Colon\";\n    /** `=` character */\n    Chars[Chars[\"Equals\"] = 61] = \"Equals\";\n    /** `<` character */\n    Chars[Chars[\"AngleLeft\"] = 60] = \"AngleLeft\";\n    /** `>` character */\n    Chars[Chars[\"AngleRight\"] = 62] = \"AngleRight\";\n})(Chars || (Chars = {}));\n/**\n * Check if given readers current position points at the end of HTML tag\n */\nfunction isHtml(scanner) {\n    const start = scanner.pos;\n    if (!consume(scanner, Chars.AngleRight)) {\n        return false;\n    }\n    let ok = false;\n    consume(scanner, Chars.Slash); // possibly self-closed element\n    while (!sol(scanner)) {\n        consumeWhile(scanner, isWhiteSpace);\n        if (consumeIdent(scanner)) {\n            // ate identifier: could be a tag name, boolean attribute or unquoted\n            // attribute value\n            if (consume(scanner, Chars.Slash)) {\n                // either closing tag or invalid tag\n                ok = consume(scanner, Chars.AngleLeft);\n                break;\n            }\n            else if (consume(scanner, Chars.AngleLeft)) {\n                // opening tag\n                ok = true;\n                break;\n            }\n            else if (consume(scanner, isWhiteSpace)) {\n                // boolean attribute\n                continue;\n            }\n            else if (consume(scanner, Chars.Equals)) {\n                // simple unquoted value or invalid attribute\n                if (consumeIdent(scanner)) {\n                    continue;\n                }\n                break;\n            }\n            else if (consumeAttributeWithUnquotedValue(scanner)) {\n                // identifier was a part of unquoted value\n                ok = true;\n                break;\n            }\n            // invalid tag\n            break;\n        }\n        if (consumeAttribute(scanner)) {\n            continue;\n        }\n        break;\n    }\n    scanner.pos = start;\n    return ok;\n}\n/**\n * Consumes HTML attribute from given string.\n * @return `true` if attribute was consumed.\n */\nfunction consumeAttribute(scanner) {\n    return consumeAttributeWithQuotedValue(scanner) || consumeAttributeWithUnquotedValue(scanner);\n}\nfunction consumeAttributeWithQuotedValue(scanner) {\n    const start = scanner.pos;\n    if (consumeQuoted(scanner) && consume(scanner, Chars.Equals) && consumeIdent(scanner)) {\n        return true;\n    }\n    scanner.pos = start;\n    return false;\n}\nfunction consumeAttributeWithUnquotedValue(scanner) {\n    const start = scanner.pos;\n    const stack = [];\n    while (!sol(scanner)) {\n        const ch = peek(scanner);\n        if (isCloseBracket(ch)) {\n            stack.push(ch);\n        }\n        else if (isOpenBracket(ch)) {\n            if (stack.pop() !== bracePairs[ch]) {\n                // Unexpected open bracket\n                break;\n            }\n        }\n        else if (!isUnquotedValue(ch)) {\n            break;\n        }\n        scanner.pos--;\n    }\n    if (start !== scanner.pos && consume(scanner, Chars.Equals) && consumeIdent(scanner)) {\n        return true;\n    }\n    scanner.pos = start;\n    return false;\n}\n/**\n * Consumes HTML identifier from stream\n */\nfunction consumeIdent(scanner) {\n    return consumeWhile(scanner, isIdent);\n}\n/**\n * Check if given character code belongs to HTML identifier\n */\nfunction isIdent(ch) {\n    return ch === Chars.Colon || ch === Chars.Dash || isAlpha(ch) || isNumber(ch);\n}\n/**\n * Check if given character code is alpha code (letter though A to Z)\n */\nfunction isAlpha(ch) {\n    ch &= ~32; // quick hack to convert any char code to uppercase char code\n    return ch >= 65 && ch <= 90; // A-Z\n}\n/**\n * Check if given code is a number\n */\nfunction isNumber(ch) {\n    return ch > 47 && ch < 58;\n}\n/**\n * Check if given code is a whitespace\n */\nfunction isWhiteSpace(ch) {\n    return ch === Chars.Space || ch === Chars.Tab;\n}\n/**\n * Check if given code may belong to unquoted attribute value\n */\nfunction isUnquotedValue(ch) {\n    return !isNaN(ch) && ch !== Chars.Equals && !isWhiteSpace(ch) && !isQuote(ch);\n}\nfunction isOpenBracket(ch) {\n    return ch === Brackets.CurlyL || ch === Brackets.RoundL || ch === Brackets.SquareL;\n}\nfunction isCloseBracket(ch) {\n    return ch === Brackets.CurlyR || ch === Brackets.RoundR || ch === Brackets.SquareR;\n}\n\nconst code = (ch) => ch.charCodeAt(0);\nconst specialChars = '#.*:$-_!@%^+>/'.split('').map(code);\nconst defaultOptions = {\n    type: 'markup',\n    lookAhead: true,\n    prefix: ''\n};\n/**\n * Extracts Emmet abbreviation from given string.\n * The goal of this module is to extract abbreviation from current editors line,\n * e.g. like this: `<span>.foo[title=bar|]</span>` -> `.foo[title=bar]`, where\n * `|` is a current caret position.\n * @param line A text line where abbreviation should be expanded\n * @param pos Caret position in line. If not given, uses end of line\n * @param options Extracting options\n */\nfunction extractAbbreviation(line, pos = line.length, options = {}) {\n    // make sure `pos` is within line range\n    const opt = Object.assign(Object.assign({}, defaultOptions), options);\n    pos = Math.min(line.length, Math.max(0, pos == null ? line.length : pos));\n    if (opt.lookAhead) {\n        pos = offsetPastAutoClosed(line, pos, opt);\n    }\n    let ch;\n    const start = getStartOffset(line, pos, opt.prefix || '');\n    if (start === -1) {\n        return void 0;\n    }\n    const scanner = backwardScanner(line, start);\n    scanner.pos = pos;\n    const stack = [];\n    while (!sol(scanner)) {\n        ch = peek(scanner);\n        if (stack.includes(Brackets.CurlyR)) {\n            if (ch === Brackets.CurlyR) {\n                stack.push(ch);\n                scanner.pos--;\n                continue;\n            }\n            if (ch !== Brackets.CurlyL) {\n                scanner.pos--;\n                continue;\n            }\n        }\n        if (isCloseBrace(ch, opt.type)) {\n            stack.push(ch);\n        }\n        else if (isOpenBrace(ch, opt.type)) {\n            if (stack.pop() !== bracePairs[ch]) {\n                // unexpected brace\n                break;\n            }\n        }\n        else if (stack.includes(Brackets.SquareR) || stack.includes(Brackets.CurlyR)) {\n            // respect all characters inside attribute sets or text nodes\n            scanner.pos--;\n            continue;\n        }\n        else if (isHtml(scanner) || !isAbbreviation(ch)) {\n            break;\n        }\n        scanner.pos--;\n    }\n    if (!stack.length && scanner.pos !== pos) {\n        // Found something, remove some invalid symbols from the\n        // beginning and return abbreviation\n        const abbreviation = line.slice(scanner.pos, pos).replace(/^[*+>^]+/, '');\n        return {\n            abbreviation,\n            location: pos - abbreviation.length,\n            start: options.prefix\n                ? start - options.prefix.length\n                : pos - abbreviation.length,\n            end: pos\n        };\n    }\n}\n/**\n * Returns new `line` index which is right after characters beyound `pos` that\n * editor will likely automatically close, e.g. }, ], and quotes\n */\nfunction offsetPastAutoClosed(line, pos, options) {\n    // closing quote is allowed only as a next character\n    if (isQuote(line.charCodeAt(pos))) {\n        pos++;\n    }\n    // offset pointer until non-autoclosed character is found\n    while (isCloseBrace(line.charCodeAt(pos), options.type)) {\n        pos++;\n    }\n    return pos;\n}\n/**\n * Returns start offset (left limit) in `line` where we should stop looking for\n * abbreviation: its nearest to `pos` location of `prefix` token\n */\nfunction getStartOffset(line, pos, prefix) {\n    if (!prefix) {\n        return 0;\n    }\n    const scanner = backwardScanner(line);\n    const compiledPrefix = prefix.split('').map(code);\n    scanner.pos = pos;\n    let result;\n    while (!sol(scanner)) {\n        if (consumePair(scanner, Brackets.SquareR, Brackets.SquareL) || consumePair(scanner, Brackets.CurlyR, Brackets.CurlyL)) {\n            continue;\n        }\n        result = scanner.pos;\n        if (consumeArray(scanner, compiledPrefix)) {\n            return result;\n        }\n        scanner.pos--;\n    }\n    return -1;\n}\n/**\n * Consumes full character pair, if possible\n */\nfunction consumePair(scanner, close, open) {\n    const start = scanner.pos;\n    if (consume(scanner, close)) {\n        while (!sol(scanner)) {\n            if (consume(scanner, open)) {\n                return true;\n            }\n            scanner.pos--;\n        }\n    }\n    scanner.pos = start;\n    return false;\n}\n/**\n * Consumes all character codes from given array, right-to-left, if possible\n */\nfunction consumeArray(scanner, arr) {\n    const start = scanner.pos;\n    let consumed = false;\n    for (let i = arr.length - 1; i >= 0 && !sol(scanner); i--) {\n        if (!consume(scanner, arr[i])) {\n            break;\n        }\n        consumed = i === 0;\n    }\n    if (!consumed) {\n        scanner.pos = start;\n    }\n    return consumed;\n}\nfunction isAbbreviation(ch) {\n    return (ch > 64 && ch < 91) // uppercase letter\n        || (ch > 96 && ch < 123) // lowercase letter\n        || (ch > 47 && ch < 58) // number\n        || specialChars.includes(ch); // special character\n}\nfunction isOpenBrace(ch, syntax) {\n    return ch === Brackets.RoundL || (syntax === 'markup' && (ch === Brackets.SquareL || ch === Brackets.CurlyL));\n}\nfunction isCloseBrace(ch, syntax) {\n    return ch === Brackets.RoundR || (syntax === 'markup' && (ch === Brackets.SquareR || ch === Brackets.CurlyR));\n}\n\nfunction expandAbbreviation(abbr, config) {\n    const resolvedConfig = resolveConfig(config);\n    return resolvedConfig.type === 'stylesheet'\n        ? stylesheet(abbr, resolvedConfig)\n        : markup(abbr, resolvedConfig);\n}\n/**\n * Expands given *markup* abbreviation (e.g. regular Emmet abbreviation that\n * produces structured output like HTML) and outputs it according to options\n * provided in config\n */\nfunction markup(abbr, config) {\n    return stringify(parse$1(abbr, config), config);\n}\n/**\n * Expands given *stylesheet* abbreviation (a special Emmet abbreviation designed for\n * stylesheet languages like CSS, SASS etc.) and outputs it according to options\n * provided in config\n */\nfunction stylesheet(abbr, config) {\n    return css(parse(abbr, config), config);\n}\n\nexport { CSSAbbreviationScope, expandAbbreviation as default, extractAbbreviation as extract, markup, parseAbbreviation as markupAbbreviation, parse$1 as parseMarkup, parse as parseStylesheet, convertSnippets as parseStylesheetSnippets, resolveConfig, stringify as stringifyMarkup, css as stringifyStylesheet, stylesheet, parse$2 as stylesheetAbbreviation };\n//# sourceMappingURL=emmet.es.js.map\n"],"file":"emmet.es.js"}