{"version":3,"sources":["thirdparty/acorn/dist/walk.js"],"names":["global","factory","exports","module","define","amd","globalThis","self","acorn","walk","this","simple","node","visitors","baseVisitor","state","override","base","c","st","type","ancestor","ancestors","isNew","length","push","pop","recursive","funcs","visitor","make","undefined","makeTest","test","Found","full","callback","last","fullAncestor","findNodeAt","start","end","e","findNodeAround","pos","findNodeAfter","findNodeBefore","max","Object","create","skipThrough","ignore","_node","_st","_c","Program","BlockStatement","StaticBlock","i","list","body","stmt","Statement","EmptyStatement","ExpressionStatement","ParenthesizedExpression","ChainExpression","expression","IfStatement","consequent","alternate","LabeledStatement","BreakStatement","ContinueStatement","WithStatement","object","SwitchStatement","discriminant","cases","cs","SwitchCase","cons","ReturnStatement","YieldExpression","AwaitExpression","argument","ThrowStatement","SpreadElement","TryStatement","block","handler","finalizer","CatchClause","param","WhileStatement","DoWhileStatement","ForStatement","init","update","ForInStatement","ForOfStatement","left","right","ForInit","DebuggerStatement","FunctionDeclaration","VariableDeclaration","declarations","decl","VariableDeclarator","id","Function","params","Pattern","VariablePattern","MemberPattern","RestElement","ArrayPattern","elements","elt","ObjectPattern","properties","prop","computed","key","value","Expression","ThisExpression","Super","MetaProperty","ArrayExpression","ObjectExpression","FunctionExpression","ArrowFunctionExpression","SequenceExpression","expressions","expr","TemplateLiteral","quasis","quasi","i$1","list$1","TemplateElement","UnaryExpression","UpdateExpression","BinaryExpression","LogicalExpression","AssignmentExpression","AssignmentPattern","ConditionalExpression","NewExpression","CallExpression","callee","arguments","arg","MemberExpression","property","ExportNamedDeclaration","ExportDefaultDeclaration","declaration","source","ExportAllDeclaration","exported","ImportDeclaration","specifiers","spec","ImportExpression","ImportSpecifier","ImportDefaultSpecifier","ImportNamespaceSpecifier","Identifier","PrivateIdentifier","Literal","TaggedTemplateExpression","tag","ClassDeclaration","ClassExpression","Class","superClass","ClassBody","MethodDefinition","PropertyDefinition","Property"],"mappings":"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","sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.acorn = global.acorn || {}, global.acorn.walk = {})));\n})(this, (function (exports) { 'use strict';\n\n  // AST walker module for ESTree compatible trees\n\n  // A simple walk is one where you simply specify callbacks to be\n  // called on specific nodes. The last two arguments are optional. A\n  // simple use would be\n  //\n  //     walk.simple(myTree, {\n  //         Expression: function(node) { ... }\n  //     });\n  //\n  // to do something with all expressions. All ESTree node types\n  // can be used to identify node types, as well as Expression and\n  // Statement, which denote categories of nodes.\n  //\n  // The base argument can be used to pass a custom (recursive)\n  // walker, and state can be used to give this walked an initial\n  // state.\n\n  function simple(node, visitors, baseVisitor, state, override) {\n    if (!baseVisitor) { baseVisitor = base\n    ; }(function c(node, st, override) {\n      var type = override || node.type;\n      baseVisitor[type](node, st, c);\n      if (visitors[type]) { visitors[type](node, st); }\n    })(node, state, override);\n  }\n\n  // An ancestor walk keeps an array of ancestor nodes (including the\n  // current node) and passes them to the callback as third parameter\n  // (and also as state parameter when no other state is present).\n  function ancestor(node, visitors, baseVisitor, state, override) {\n    var ancestors = [];\n    if (!baseVisitor) { baseVisitor = base\n    ; }(function c(node, st, override) {\n      var type = override || node.type;\n      var isNew = node !== ancestors[ancestors.length - 1];\n      if (isNew) { ancestors.push(node); }\n      baseVisitor[type](node, st, c);\n      if (visitors[type]) { visitors[type](node, st || ancestors, ancestors); }\n      if (isNew) { ancestors.pop(); }\n    })(node, state, override);\n  }\n\n  // A recursive walk is one where your functions override the default\n  // walkers. They can modify and replace the state parameter that's\n  // threaded through the walk, and can opt how and whether to walk\n  // their child nodes (by calling their third argument on these\n  // nodes).\n  function recursive(node, state, funcs, baseVisitor, override) {\n    var visitor = funcs ? make(funcs, baseVisitor || undefined) : baseVisitor\n    ;(function c(node, st, override) {\n      visitor[override || node.type](node, st, c);\n    })(node, state, override);\n  }\n\n  function makeTest(test) {\n    if (typeof test === \"string\")\n      { return function (type) { return type === test; } }\n    else if (!test)\n      { return function () { return true; } }\n    else\n      { return test }\n  }\n\n  var Found = function Found(node, state) { this.node = node; this.state = state; };\n\n  // A full walk triggers the callback on each node\n  function full(node, callback, baseVisitor, state, override) {\n    if (!baseVisitor) { baseVisitor = base; }\n    var last\n    ;(function c(node, st, override) {\n      var type = override || node.type;\n      baseVisitor[type](node, st, c);\n      if (last !== node) {\n        callback(node, st, type);\n        last = node;\n      }\n    })(node, state, override);\n  }\n\n  // An fullAncestor walk is like an ancestor walk, but triggers\n  // the callback on each node\n  function fullAncestor(node, callback, baseVisitor, state) {\n    if (!baseVisitor) { baseVisitor = base; }\n    var ancestors = [], last\n    ;(function c(node, st, override) {\n      var type = override || node.type;\n      var isNew = node !== ancestors[ancestors.length - 1];\n      if (isNew) { ancestors.push(node); }\n      baseVisitor[type](node, st, c);\n      if (last !== node) {\n        callback(node, st || ancestors, ancestors, type);\n        last = node;\n      }\n      if (isNew) { ancestors.pop(); }\n    })(node, state);\n  }\n\n  // Find a node with a given start, end, and type (all are optional,\n  // null can be used as wildcard). Returns a {node, state} object, or\n  // undefined when it doesn't find a matching node.\n  function findNodeAt(node, start, end, test, baseVisitor, state) {\n    if (!baseVisitor) { baseVisitor = base; }\n    test = makeTest(test);\n    try {\n      (function c(node, st, override) {\n        var type = override || node.type;\n        if ((start == null || node.start <= start) &&\n            (end == null || node.end >= end))\n          { baseVisitor[type](node, st, c); }\n        if ((start == null || node.start === start) &&\n            (end == null || node.end === end) &&\n            test(type, node))\n          { throw new Found(node, st) }\n      })(node, state);\n    } catch (e) {\n      if (e instanceof Found) { return e }\n      throw e\n    }\n  }\n\n  // Find the innermost node of a given type that contains the given\n  // position. Interface similar to findNodeAt.\n  function findNodeAround(node, pos, test, baseVisitor, state) {\n    test = makeTest(test);\n    if (!baseVisitor) { baseVisitor = base; }\n    try {\n      (function c(node, st, override) {\n        var type = override || node.type;\n        if (node.start > pos || node.end < pos) { return }\n        baseVisitor[type](node, st, c);\n        if (test(type, node)) { throw new Found(node, st) }\n      })(node, state);\n    } catch (e) {\n      if (e instanceof Found) { return e }\n      throw e\n    }\n  }\n\n  // Find the outermost matching node after a given position.\n  function findNodeAfter(node, pos, test, baseVisitor, state) {\n    test = makeTest(test);\n    if (!baseVisitor) { baseVisitor = base; }\n    try {\n      (function c(node, st, override) {\n        if (node.end < pos) { return }\n        var type = override || node.type;\n        if (node.start >= pos && test(type, node)) { throw new Found(node, st) }\n        baseVisitor[type](node, st, c);\n      })(node, state);\n    } catch (e) {\n      if (e instanceof Found) { return e }\n      throw e\n    }\n  }\n\n  // Find the outermost matching node before a given position.\n  function findNodeBefore(node, pos, test, baseVisitor, state) {\n    test = makeTest(test);\n    if (!baseVisitor) { baseVisitor = base; }\n    var max\n    ;(function c(node, st, override) {\n      if (node.start > pos) { return }\n      var type = override || node.type;\n      if (node.end <= pos && (!max || max.node.end < node.end) && test(type, node))\n        { max = new Found(node, st); }\n      baseVisitor[type](node, st, c);\n    })(node, state);\n    return max\n  }\n\n  // Used to create a custom walker. Will fill in all missing node\n  // type properties with the defaults.\n  function make(funcs, baseVisitor) {\n    var visitor = Object.create(baseVisitor || base);\n    for (var type in funcs) { visitor[type] = funcs[type]; }\n    return visitor\n  }\n\n  function skipThrough(node, st, c) { c(node, st); }\n  function ignore(_node, _st, _c) {}\n\n  // Node walkers.\n\n  var base = {};\n\n  base.Program = base.BlockStatement = base.StaticBlock = function (node, st, c) {\n    for (var i = 0, list = node.body; i < list.length; i += 1)\n      {\n      var stmt = list[i];\n\n      c(stmt, st, \"Statement\");\n    }\n  };\n  base.Statement = skipThrough;\n  base.EmptyStatement = ignore;\n  base.ExpressionStatement = base.ParenthesizedExpression = base.ChainExpression =\n    function (node, st, c) { return c(node.expression, st, \"Expression\"); };\n  base.IfStatement = function (node, st, c) {\n    c(node.test, st, \"Expression\");\n    c(node.consequent, st, \"Statement\");\n    if (node.alternate) { c(node.alternate, st, \"Statement\"); }\n  };\n  base.LabeledStatement = function (node, st, c) { return c(node.body, st, \"Statement\"); };\n  base.BreakStatement = base.ContinueStatement = ignore;\n  base.WithStatement = function (node, st, c) {\n    c(node.object, st, \"Expression\");\n    c(node.body, st, \"Statement\");\n  };\n  base.SwitchStatement = function (node, st, c) {\n    c(node.discriminant, st, \"Expression\");\n    for (var i = 0, list = node.cases; i < list.length; i += 1) {\n      var cs = list[i];\n\n      c(cs, st);\n    }\n  };\n  base.SwitchCase = function (node, st, c) {\n    if (node.test) { c(node.test, st, \"Expression\"); }\n    for (var i = 0, list = node.consequent; i < list.length; i += 1)\n      {\n      var cons = list[i];\n\n      c(cons, st, \"Statement\");\n    }\n  };\n  base.ReturnStatement = base.YieldExpression = base.AwaitExpression = function (node, st, c) {\n    if (node.argument) { c(node.argument, st, \"Expression\"); }\n  };\n  base.ThrowStatement = base.SpreadElement =\n    function (node, st, c) { return c(node.argument, st, \"Expression\"); };\n  base.TryStatement = function (node, st, c) {\n    c(node.block, st, \"Statement\");\n    if (node.handler) { c(node.handler, st); }\n    if (node.finalizer) { c(node.finalizer, st, \"Statement\"); }\n  };\n  base.CatchClause = function (node, st, c) {\n    if (node.param) { c(node.param, st, \"Pattern\"); }\n    c(node.body, st, \"Statement\");\n  };\n  base.WhileStatement = base.DoWhileStatement = function (node, st, c) {\n    c(node.test, st, \"Expression\");\n    c(node.body, st, \"Statement\");\n  };\n  base.ForStatement = function (node, st, c) {\n    if (node.init) { c(node.init, st, \"ForInit\"); }\n    if (node.test) { c(node.test, st, \"Expression\"); }\n    if (node.update) { c(node.update, st, \"Expression\"); }\n    c(node.body, st, \"Statement\");\n  };\n  base.ForInStatement = base.ForOfStatement = function (node, st, c) {\n    c(node.left, st, \"ForInit\");\n    c(node.right, st, \"Expression\");\n    c(node.body, st, \"Statement\");\n  };\n  base.ForInit = function (node, st, c) {\n    if (node.type === \"VariableDeclaration\") { c(node, st); }\n    else { c(node, st, \"Expression\"); }\n  };\n  base.DebuggerStatement = ignore;\n\n  base.FunctionDeclaration = function (node, st, c) { return c(node, st, \"Function\"); };\n  base.VariableDeclaration = function (node, st, c) {\n    for (var i = 0, list = node.declarations; i < list.length; i += 1)\n      {\n      var decl = list[i];\n\n      c(decl, st);\n    }\n  };\n  base.VariableDeclarator = function (node, st, c) {\n    c(node.id, st, \"Pattern\");\n    if (node.init) { c(node.init, st, \"Expression\"); }\n  };\n\n  base.Function = function (node, st, c) {\n    if (node.id) { c(node.id, st, \"Pattern\"); }\n    for (var i = 0, list = node.params; i < list.length; i += 1)\n      {\n      var param = list[i];\n\n      c(param, st, \"Pattern\");\n    }\n    c(node.body, st, node.expression ? \"Expression\" : \"Statement\");\n  };\n\n  base.Pattern = function (node, st, c) {\n    if (node.type === \"Identifier\")\n      { c(node, st, \"VariablePattern\"); }\n    else if (node.type === \"MemberExpression\")\n      { c(node, st, \"MemberPattern\"); }\n    else\n      { c(node, st); }\n  };\n  base.VariablePattern = ignore;\n  base.MemberPattern = skipThrough;\n  base.RestElement = function (node, st, c) { return c(node.argument, st, \"Pattern\"); };\n  base.ArrayPattern = function (node, st, c) {\n    for (var i = 0, list = node.elements; i < list.length; i += 1) {\n      var elt = list[i];\n\n      if (elt) { c(elt, st, \"Pattern\"); }\n    }\n  };\n  base.ObjectPattern = function (node, st, c) {\n    for (var i = 0, list = node.properties; i < list.length; i += 1) {\n      var prop = list[i];\n\n      if (prop.type === \"Property\") {\n        if (prop.computed) { c(prop.key, st, \"Expression\"); }\n        c(prop.value, st, \"Pattern\");\n      } else if (prop.type === \"RestElement\") {\n        c(prop.argument, st, \"Pattern\");\n      }\n    }\n  };\n\n  base.Expression = skipThrough;\n  base.ThisExpression = base.Super = base.MetaProperty = ignore;\n  base.ArrayExpression = function (node, st, c) {\n    for (var i = 0, list = node.elements; i < list.length; i += 1) {\n      var elt = list[i];\n\n      if (elt) { c(elt, st, \"Expression\"); }\n    }\n  };\n  base.ObjectExpression = function (node, st, c) {\n    for (var i = 0, list = node.properties; i < list.length; i += 1)\n      {\n      var prop = list[i];\n\n      c(prop, st);\n    }\n  };\n  base.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;\n  base.SequenceExpression = function (node, st, c) {\n    for (var i = 0, list = node.expressions; i < list.length; i += 1)\n      {\n      var expr = list[i];\n\n      c(expr, st, \"Expression\");\n    }\n  };\n  base.TemplateLiteral = function (node, st, c) {\n    for (var i = 0, list = node.quasis; i < list.length; i += 1)\n      {\n      var quasi = list[i];\n\n      c(quasi, st);\n    }\n\n    for (var i$1 = 0, list$1 = node.expressions; i$1 < list$1.length; i$1 += 1)\n      {\n      var expr = list$1[i$1];\n\n      c(expr, st, \"Expression\");\n    }\n  };\n  base.TemplateElement = ignore;\n  base.UnaryExpression = base.UpdateExpression = function (node, st, c) {\n    c(node.argument, st, \"Expression\");\n  };\n  base.BinaryExpression = base.LogicalExpression = function (node, st, c) {\n    c(node.left, st, \"Expression\");\n    c(node.right, st, \"Expression\");\n  };\n  base.AssignmentExpression = base.AssignmentPattern = function (node, st, c) {\n    c(node.left, st, \"Pattern\");\n    c(node.right, st, \"Expression\");\n  };\n  base.ConditionalExpression = function (node, st, c) {\n    c(node.test, st, \"Expression\");\n    c(node.consequent, st, \"Expression\");\n    c(node.alternate, st, \"Expression\");\n  };\n  base.NewExpression = base.CallExpression = function (node, st, c) {\n    c(node.callee, st, \"Expression\");\n    if (node.arguments)\n      { for (var i = 0, list = node.arguments; i < list.length; i += 1)\n        {\n          var arg = list[i];\n\n          c(arg, st, \"Expression\");\n        } }\n  };\n  base.MemberExpression = function (node, st, c) {\n    c(node.object, st, \"Expression\");\n    if (node.computed) { c(node.property, st, \"Expression\"); }\n  };\n  base.ExportNamedDeclaration = base.ExportDefaultDeclaration = function (node, st, c) {\n    if (node.declaration)\n      { c(node.declaration, st, node.type === \"ExportNamedDeclaration\" || node.declaration.id ? \"Statement\" : \"Expression\"); }\n    if (node.source) { c(node.source, st, \"Expression\"); }\n  };\n  base.ExportAllDeclaration = function (node, st, c) {\n    if (node.exported)\n      { c(node.exported, st); }\n    c(node.source, st, \"Expression\");\n  };\n  base.ImportDeclaration = function (node, st, c) {\n    for (var i = 0, list = node.specifiers; i < list.length; i += 1)\n      {\n      var spec = list[i];\n\n      c(spec, st);\n    }\n    c(node.source, st, \"Expression\");\n  };\n  base.ImportExpression = function (node, st, c) {\n    c(node.source, st, \"Expression\");\n  };\n  base.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.PrivateIdentifier = base.Literal = ignore;\n\n  base.TaggedTemplateExpression = function (node, st, c) {\n    c(node.tag, st, \"Expression\");\n    c(node.quasi, st, \"Expression\");\n  };\n  base.ClassDeclaration = base.ClassExpression = function (node, st, c) { return c(node, st, \"Class\"); };\n  base.Class = function (node, st, c) {\n    if (node.id) { c(node.id, st, \"Pattern\"); }\n    if (node.superClass) { c(node.superClass, st, \"Expression\"); }\n    c(node.body, st);\n  };\n  base.ClassBody = function (node, st, c) {\n    for (var i = 0, list = node.body; i < list.length; i += 1)\n      {\n      var elt = list[i];\n\n      c(elt, st);\n    }\n  };\n  base.MethodDefinition = base.PropertyDefinition = base.Property = function (node, st, c) {\n    if (node.computed) { c(node.key, st, \"Expression\"); }\n    if (node.value) { c(node.value, st, \"Expression\"); }\n  };\n\n  exports.ancestor = ancestor;\n  exports.base = base;\n  exports.findNodeAfter = findNodeAfter;\n  exports.findNodeAround = findNodeAround;\n  exports.findNodeAt = findNodeAt;\n  exports.findNodeBefore = findNodeBefore;\n  exports.full = full;\n  exports.fullAncestor = fullAncestor;\n  exports.make = make;\n  exports.recursive = recursive;\n  exports.simple = simple;\n\n}));\n"],"file":"walk.js"}