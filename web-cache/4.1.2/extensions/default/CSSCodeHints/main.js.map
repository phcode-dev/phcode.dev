{"version":3,"sources":["extensions/default/CSSCodeHints/main.js"],"names":["define","require","exports","module","AppInit","brackets","getModule","CodeHintManager","EditorManager","CSSUtils","PreferencesManager","TokenUtils","StringMatch","ColorUtils","Strings","KeyEvent","LiveDevelopment","Metrics","CSSProperties","properties","JSON","parse","expandAbbr","Phoenix","libs","Emmet","expand","enabled","BOOSTED_PROPERTIES","MAX_CSS_HINTS","cssWideKeywords","computedProperties","computedPropertyKeys","mdnPropertiesUrls","lastContext","CssPropHints","this","primaryTriggerKeys","secondaryTriggerKeys","exclusion","isAlphanumeric","char","test","isValidColor","text","colorMatch","colorIndex","index","previousChar","charAt","endIndex","length","nextChar","updateColorList","colorList","color","lineNumber","existingColor","find","item","count","lines","includes","push","getAllColorsInFile","editor","getActiveEditor","nLen","lineCount","i","lineText","getLine","matches","matchAll","COLOR_REGEX","match","token","getToken","line","ch","state","htmlState","context","tagName","type","vendorPrefixesAndGenericToEnd","hints","nonDashHints","dashHints","forEach","hint","label","startsWith","concat","formatHints","isColorSwatch","splice","map","$hintObj","$","value","addClass","stringRanges","matched","append","formatColorHint","MDN_URL","$mdn","DOCS_MORE_LINK_MDN_TITLE","attr","uniqueMerge","arr1","arr2","_computeProperties","blacklistedValues","none","auto","propertyKey","Object","keys","property","values","_isEmmetExpandable","needle","expandedAbbr","_isEmmetAbbrNumeric","definePreference","description","DESCRIPTION_CSS_PROP_HINTS","prototype","updateExclusion","propNameOnly","textAfterCursor","info","PROP_NAME","name","substr","offset","PROP_VALUE","hasValidExclusion","hasHints","implicitChar","cursor","getCursorPos","getInfoAtPos","indexOf","getHints","valueNeedle","valueArray","result","selectInitial","previouslyUsedColors","isNewItem","trim","injectedCSSDefaults","sort","a","b","COLOR_NAMES","pvalue","codeHintsSort","limit","boostPrefixList","onlyContiguous","resultItem","sourceIndex","pushedHints","syntax","split","$icon","$emmetHintObj","range","getAttribute","unshift","e","handleWideResults","HISTORY_PREFIX","hintSessionId","isInLiveHighlightSession","preferenceChanged","get","onClose","restoreHistoryPoint","onHighlight","$highlightedEl","_$descriptionElem","reason","console","error","currentLivePreviewDetails","getLivePreviewDetails","liveDocument","currentlyEditedFile","document","file","fullPath","livePreviewedFile","doc","isRelatedFile","isRelated","source","SELECTION_REASON","SESSION_START","createHistoryRestorePoint","KEYBOARD_NAV","event","keyCode","DOM_VK_UP","DOM_VK_DOWN","DOM_VK_PAGE_UP","DOM_VK_PAGE_DOWN","countEvent","EVENT_TYPE","LIVE_PREVIEW","$hintItem","highligtedValue","data","is","_dontDismissPopupOnScroll","insertHint","isLiveHighlight","start","end","keepHints","adjustCursor","newCursor","ctx","jquery","CODE_HINTS","getInitialContext","_codeMirror","string","moveNextToken","moveSkippingWhitespace","endsWith","parenMatch","hasSelection","setSelection","replaceSelection","replaceRange","setCursorPos","cursorPos","getCharacterAtPosition","appReady","cssPropHints","registerHintProvider","on","cssPropHintProvider"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*jslint regexp: true */\n\ndefine(function (require, exports, module) {\n\n\n    var AppInit = brackets.getModule(\"utils/AppInit\"),\n        CodeHintManager = brackets.getModule(\"editor/CodeHintManager\"),\n        EditorManager = brackets.getModule(\"editor/EditorManager\"),\n        CSSUtils = brackets.getModule(\"language/CSSUtils\"),\n        PreferencesManager = brackets.getModule(\"preferences/PreferencesManager\"),\n        TokenUtils = brackets.getModule(\"utils/TokenUtils\"),\n        StringMatch = brackets.getModule(\"utils/StringMatch\"),\n        ColorUtils = brackets.getModule(\"utils/ColorUtils\"),\n        Strings = brackets.getModule(\"strings\"),\n        KeyEvent = brackets.getModule(\"utils/KeyEvent\"),\n        LiveDevelopment = brackets.getModule(\"LiveDevelopment/main\"),\n        Metrics = brackets.getModule(\"utils/Metrics\"),\n        CSSProperties = require(\"text!CSSProperties.json\"),\n        properties = JSON.parse(CSSProperties);\n\n    /**\n     * Emmet API:\n     * This provides a function to expand abbreviations into full CSS properties.\n     */\n    const expandAbbr = Phoenix.libs.Emmet.expand;\n    let enabled = true; // whether Emmet is enabled or not in preferences\n\n    require(\"./css-lint\");\n\n    const BOOSTED_PROPERTIES = [\n        \"display\", \"position\",\n        \"margin\", \"margin-bottom\", \"margin-left\", \"margin-right\", \"margin-top\",\n        \"padding\", \"padding-bottom\", \"padding-left\", \"padding-right\", \"padding-top\",\n        \"width\", \"height\",\n        \"background-color\", \"background\", \"color\",\n        \"font-size\", \"font-family\",\n        \"text-align\",\n        \"line-height\",\n        \"border\", \"border-radius\", \"box-shadow\",\n        \"transition\", \"animation\", \"transform\",\n        \"overflow\",\n        \"cursor\",\n        \"z-index\",\n        \"flex\", \"grid\"\n    ];\n    const MAX_CSS_HINTS = 50;\n    const cssWideKeywords = ['initial', 'inherit', 'unset', 'var()', 'calc()'];\n    let computedProperties, computedPropertyKeys;\n\n    // Stores a list of all CSS properties along with their corresponding MDN URLs.\n    // This is used by Emmet code hints to ensure users can still access MDN documentation.\n    // the Emmet icon serves as a clickable link that redirects to the MDN page for the property (if available).\n    // This object follows the structure:\n    // { PROPERTY_NAME: MDN_URL }\n    const mdnPropertiesUrls = {};\n\n    PreferencesManager.definePreference(\"codehint.CssPropHints\", \"boolean\", true, {\n        description: Strings.DESCRIPTION_CSS_PROP_HINTS\n    });\n\n    // Context of the last request for hints: either CSSUtils.PROP_NAME,\n    // CSSUtils.PROP_VALUE or null.\n    var lastContext;\n\n    /**\n     * @constructor\n     */\n    function CssPropHints() {\n        this.primaryTriggerKeys = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-()\";\n        this.secondaryTriggerKeys = \":\";\n        this.exclusion = null;\n    }\n\n    function isAlphanumeric(char) {\n        return /^[a-z0-9-@$]$/i.test(char);\n    }\n\n    function isValidColor(text, colorMatch) {\n        const colorIndex = colorMatch.index;\n        const previousChar = colorIndex === 0 ? \"\" : text.charAt(colorIndex - 1);\n        const endIndex = colorIndex + colorMatch[0].length;\n        const nextChar = endIndex === text.length ? \"\" : text.charAt(endIndex);\n        return !isAlphanumeric(previousChar) && !isAlphanumeric(nextChar);\n    }\n\n    function updateColorList(colorList, color, lineNumber) {\n        const existingColor = colorList.find(item => item.color === color);\n        if (existingColor) {\n            existingColor.count++;\n            if (!existingColor.lines.includes(lineNumber)) {\n                existingColor.lines.push(lineNumber);\n            }\n        } else {\n            colorList.push({\n                color: color,\n                lines: [lineNumber],\n                count: 1\n            });\n        }\n    }\n\n    function getAllColorsInFile() {\n        const editor = EditorManager.getActiveEditor();\n        const nLen = editor.lineCount();\n\n        const colorList = [];\n\n        for (let i = 0; i < nLen; i++) {\n            const lineText = editor.getLine(i);\n\n            if (!lineText || lineText.length > 1000) {\n                continue;\n            }\n\n            const matches = [...lineText.matchAll(ColorUtils.COLOR_REGEX)];\n\n            for (const match of matches) {\n                if (isValidColor(lineText, match)) {\n                    const token = editor.getToken({ line: i, ch: match.index });\n\n                    // this check is added to filter out non-required colors. For ex:\n                    // the color should not be inside a commented line\n                    // the color should not be written as a plain text (in html files)\n                    // like <p>Red is bad.</p>, we need to ignore this Red\n                    if (\n                        token &&\n                        (\n                            // If we're in an HTML file (token.state.htmlState exists),\n                            // then only process if inside a <style> tag.\n                            (token.state && token.state.htmlState ? token.state.htmlState.context.tagName === \"style\" : true)\n                        ) &&\n                        token.type !== \"comment\"\n                    ) {\n                        updateColorList(colorList, match[0], i);\n                    }\n                }\n            }\n        }\n\n        return colorList;\n    }\n\n    /**\n     * Check whether the exclusion is still the same as text after the cursor.\n     * If not, reset it to null.\n     *\n     * @param {boolean} propNameOnly\n     * true to indicate that we update the exclusion only if the cursor is inside property name context.\n     * Otherwise, we also update exclusion for property value context.\n     */\n    CssPropHints.prototype.updateExclusion = function (propNameOnly) {\n        var textAfterCursor;\n        if (this.exclusion && this.info) {\n            if (this.info.context === CSSUtils.PROP_NAME) {\n                textAfterCursor = this.info.name.substr(this.info.offset);\n            } else if (!propNameOnly && this.info.context === CSSUtils.PROP_VALUE) {\n                textAfterCursor = this.info.value.substr(this.info.offset);\n            }\n            if (!CodeHintManager.hasValidExclusion(this.exclusion, textAfterCursor)) {\n                this.exclusion = null;\n            }\n        }\n    };\n\n    /**\n     * Determines whether CSS propertyname or -name hints are available in the current editor\n     * context.\n     *\n     * @param {Editor} editor\n     * A non-null editor object for the active window.\n     *\n     * @param {String} implicitChar\n     * Either null, if the hinting request was explicit, or a single character\n     * that represents the last insertion and that indicates an implicit\n     * hinting request.\n     *\n     * @return {Boolean}\n     * Determines whether the current provider is able to provide hints for\n     * the given editor context and, in case implicitChar is non- null,\n     * whether it is appropriate to do so.\n     */\n    CssPropHints.prototype.hasHints = function (editor, implicitChar) {\n        this.editor = editor;\n        var cursor = this.editor.getCursorPos();\n\n        lastContext = null;\n        this.info = CSSUtils.getInfoAtPos(editor, cursor);\n\n        if (this.info.context !== CSSUtils.PROP_NAME && this.info.context !== CSSUtils.PROP_VALUE) {\n            return false;\n        }\n\n        if (implicitChar) {\n            this.updateExclusion(false);\n            if (this.info.context === CSSUtils.PROP_NAME) {\n                // Check if implicitChar is the first character typed before an existing property name.\n                if (!this.exclusion && this.info.offset === 1 && implicitChar === this.info.name[0]) {\n                    this.exclusion = this.info.name.substr(this.info.offset);\n                }\n            }\n\n            return (this.primaryTriggerKeys.indexOf(implicitChar) !== -1) ||\n                (this.secondaryTriggerKeys.indexOf(implicitChar) !== -1);\n        } else if (this.info.context === CSSUtils.PROP_NAME) {\n            if (this.info.offset === 0) {\n                this.exclusion = this.info.name;\n            } else {\n                this.updateExclusion(true);\n            }\n        }\n\n        return true;\n    };\n\n    function vendorPrefixesAndGenericToEnd(hints) {\n        // Two arrays to hold strings: one for non-dash strings, one for dash-starting strings\n        const nonDashHints = [];\n        const dashHints = [];\n\n        // Iterate through the array and partition the strings into the two arrays based on the starting character\n        hints.forEach(hint => {\n            if (hint.label.startsWith('-') || cssWideKeywords.includes(hint.label)) {\n                dashHints.push(hint);\n            } else {\n                nonDashHints.push(hint);\n            }\n        });\n\n        // Concatenate the non-dash array with the dash array to form the final sorted array\n        return nonDashHints.concat(dashHints);\n    }\n\n\n    /**\n     * Returns a sorted and formatted list of hints with the query substring\n     * highlighted.\n     *\n     * @param {Array.<Object>} hints - the list of hints to format\n     * @param isColorSwatch\n     * @return {Array.jQuery} sorted Array of jQuery DOM elements to insert\n     */\n    function formatHints(hints, isColorSwatch) {\n        hints = vendorPrefixesAndGenericToEnd(hints);\n        if (hints.length > MAX_CSS_HINTS) {\n            hints = hints.splice(0, MAX_CSS_HINTS);\n        }\n        return hints.map(function (token) {\n            var $hintObj = $(`<span data-val='${token.label || token.value || token.text}'></span>`).addClass(\"brackets-css-hints brackets-hints\");\n\n            // highlight the matched portion of each hint\n            if (token.stringRanges) {\n                token.stringRanges.forEach(function (item) {\n                    if (item.matched) {\n                        $hintObj.append($(`<span>`)\n                            .text(item.text)\n                            .addClass(\"matched-hint\"));\n                    } else {\n                        $hintObj.append(item.text);\n                    }\n                });\n            } else {\n                $hintObj.text(token.label || token.value);\n            }\n\n            if (isColorSwatch) {\n                $hintObj = ColorUtils.formatColorHint($hintObj, token.color || token.label || token.value);\n            }\n            if (token.MDN_URL) {\n                const $mdn = $(`<a class=\"css-code-hint-info\" style=\"text-decoration: none;\"\n                href=\"${token.MDN_URL}\" title=\"${Strings.DOCS_MORE_LINK_MDN_TITLE}\">\n                <i class=\"fa-solid fa-circle-info\"></i></a>`);\n                $hintObj = $(`<span data-val='${token.label || token.value}'></span>`).append($hintObj).append($mdn);\n            }\n\n            $hintObj.attr(\"data-val\", token.value);\n\n            return $hintObj;\n        });\n    }\n\n    function uniqueMerge(arr1, arr2) {\n        arr2.forEach(item => {\n            if (!arr1.includes(item)) {\n                arr1.push(item);\n            }\n        });\n        return arr1;\n    }\n\n    function _computeProperties() {\n        const blacklistedValues = {\n            none: true,\n            auto: true\n        };\n        computedProperties = {};\n        for (let propertyKey of Object.keys(properties)) {\n            const property = properties[propertyKey];\n            if (property.type === \"color\" || !property.values || !property.values.length\n                || propertyKey === \"font-family\") {\n                computedProperties[propertyKey] = propertyKey;\n                continue;\n            }\n            computedProperties[propertyKey] = propertyKey;\n            for (let value of property.values) {\n                if (!blacklistedValues[value]) {\n                    computedProperties[`${propertyKey}: ${value};`] = propertyKey;\n                }\n            }\n        }\n        computedPropertyKeys = Object.keys(computedProperties);\n    }\n\n    /**\n     * Returns a list of available CSS property name or -value hints if possible for the current\n     * editor context.\n     *\n     * @param {Editor} implicitChar\n     * Either null, if the hinting request was explicit, or a single character\n     * that represents the last insertion and that indicates an implicit\n     * hinting request.\n     *\n     * @return {jQuery.Deferred|{\n     *              hints: Array.<string|jQueryObject>,\n     *              match: string,\n     *              selectInitial: boolean,\n     *              handleWideResults: boolean}}\n     * Null if the provider wishes to end the hinting session. Otherwise, a\n     * response object that provides:\n     * 1. a sorted array hints that consists of strings\n     * 2. a string match that is used by the manager to emphasize matching\n     *    substrings when rendering the hint list\n     * 3. a boolean that indicates whether the first result, if one exists,\n     *    should be selected by default in the hint list window.\n     * 4. handleWideResults, a boolean (or undefined) that indicates whether\n     *    to allow result string to stretch width of display.\n     */\n    CssPropHints.prototype.getHints = function (implicitChar) {\n        this.cursor = this.editor.getCursorPos();\n        this.info = CSSUtils.getInfoAtPos(this.editor, this.cursor);\n\n        let needle = this.info.name,\n            valueNeedle = \"\",\n            context = this.info.context,\n            valueArray,\n            type,\n            result,\n            selectInitial = false;\n\n        let previouslyUsedColors = [];\n\n\n\n        // Clear the exclusion if the user moves the cursor with left/right arrow key.\n        this.updateExclusion(true);\n\n        if (context === CSSUtils.PROP_VALUE) {\n\n            // Always select initial value\n            selectInitial = true;\n\n            // We need to end the session and begin a new session if the ( char is typed to\n            // get arguments into the list when typing too fast\n            if (implicitChar === \"(\") {\n                return true;\n            }\n\n            // When switching from a NAME to a VALUE context, restart the session\n            // to give other more specialized providers a chance to intervene.\n            if (lastContext === CSSUtils.PROP_NAME) {\n                return true;\n            }\n            lastContext = CSSUtils.PROP_VALUE;\n\n\n            if (!properties[needle]) {\n                return null;\n            }\n\n            // Cursor is in an existing property value or partially typed value\n            if (!this.info.isNewItem && this.info.index !== -1) {\n                valueNeedle = this.info.values[this.info.index].trim();\n                valueNeedle = valueNeedle.substr(0, this.info.offset);\n            }\n\n            if (!properties[needle].injectedCSSDefaults) {\n                uniqueMerge(properties[needle].values, cssWideKeywords);\n                properties[needle].injectedCSSDefaults = true;\n            }\n            valueArray = properties[needle].values;\n            type = properties[needle].type;\n            let isColorSwatch = false;\n            if (type === \"color\") {\n                isColorSwatch = true;\n\n\n                const colorList = getAllColorsInFile();\n\n                // Convert COLOR_LIST to previouslyUsedColors format and sort by count\n                previouslyUsedColors = colorList\n                    .sort((a, b) => b.count - a.count) // Sort in descending order by count\n                    .map(item => item.color); // Extract only the colors\n\n                // Combine default hex, rgb colors with existing color names\n                valueArray = previouslyUsedColors.concat(\n                    ColorUtils.COLOR_NAMES.map(function (color) {\n                        return { text: color, color: color };\n                    })\n                );\n\n                valueArray.push(\"transparent\", \"currentColor\");\n            }\n\n            valueArray = $.map(valueArray, function (pvalue) {\n                return pvalue.text || pvalue;\n            });\n\n            result = StringMatch.codeHintsSort(valueNeedle, valueArray, {\n                limit: MAX_CSS_HINTS,\n                boostPrefixList: previouslyUsedColors, // for named colors to make them appear before other color hints\n                onlyContiguous: isColorSwatch // for color swatches, when searching for `ora` we should\n                // only hint <ora>nge and not <o>lived<ra>b (green shade)\n            });\n\n            return {\n                hints: formatHints(result, isColorSwatch),\n                match: null, // the CodeHintManager should not format the results\n                selectInitial: selectInitial\n            };\n        } else if (context === CSSUtils.PROP_NAME) {\n\n            // Select initial property if anything has been typed\n            if (this.primaryTriggerKeys.indexOf(implicitChar) !== -1 || needle !== \"\") {\n                selectInitial = true;\n            }\n\n            if (lastContext === CSSUtils.PROP_VALUE) {\n                // close the session if we're coming from a property value\n                // see https://github.com/adobe/brackets/issues/9496\n                return null;\n            }\n\n            lastContext = CSSUtils.PROP_NAME;\n            needle = needle.substr(0, this.info.offset);\n            if (!computedProperties) {\n                _computeProperties();\n            }\n\n\n            result = StringMatch.codeHintsSort(needle, computedPropertyKeys, {\n                limit: MAX_CSS_HINTS,\n                boostPrefixList: BOOSTED_PROPERTIES\n            });\n\n            for (let resultItem of result) {\n                const propertyKey = computedPropertyKeys[resultItem.sourceIndex];\n                if (properties[propertyKey] && properties[propertyKey].MDN_URL) {\n                    resultItem.MDN_URL = properties[propertyKey].MDN_URL;\n                    mdnPropertiesUrls[propertyKey] = resultItem.MDN_URL;\n                }\n            }\n\n            // pushedHints stores all the hints that will be displayed to the user\n            let pushedHints = formatHints(result);\n\n            // make sure that emmet feature is on in preferences\n            if (enabled) {\n\n                // needle gives the current word before cursor, make sure that it exists\n                // also needle shouldn't contain `-`, because for example if user typed:\n                // `box-siz` then in that case it is very obvious that user wants to type `box-sizing`\n                // but emmet expands it `box: siz;`. So we prevent calling emmet when needle has `-`.\n                if (needle && !needle.includes('-')) {\n\n                    // wrapped in try catch block because EXPAND_ABBR might throw error when it gets unexpected\n                    // characters such as `, =, etc\n                    try {\n                        let expandedAbbr = expandAbbr(needle, { syntax: \"css\", type: \"stylesheet\" });\n                        if (expandedAbbr && _isEmmetExpandable(needle, expandedAbbr)) {\n\n                            // if the expandedAbbr doesn't have any numbers, we should split the expandedAbbr to,\n                            // get its first word before `:`.\n                            // For instance, `m` expands to `margin: ;`. Here the `: ;` is unnecessary.\n                            // Also, `bgc` expands to `background-color: #fff;`. Here we don't need the `: #fff;`\n                            // as we have cssIntelligence to display hints based on the property\n                            if (!_isEmmetAbbrNumeric(expandedAbbr)) {\n                                expandedAbbr = expandedAbbr.split(':')[0];\n                            }\n\n                            // token is required for highlighting the matched part. It gives access to\n                            // stringRanges property. Refer to `formatHints()` function in this file for more detail\n                            const [token] = StringMatch.codeHintsSort(needle, [expandedAbbr]);\n\n                            // this displays an emmet icon at the side of the hint\n                            // this gives an idea to the user that the hint is coming from Emmet\n                            let $icon = $(`<a class=\"emmet-css-code-hint\" style=\"text-decoration: none\">Emmet</a>`);\n\n                            // if MDN_URL is available for the property, add the href attribute to redirect to mdn\n                            if (mdnPropertiesUrls[expandedAbbr]) {\n                                $icon.attr(\"href\", mdnPropertiesUrls[expandedAbbr]);\n                                $icon.attr(\"title\", Strings.DOCS_MORE_LINK_MDN_TITLE);\n                            }\n\n                            const $emmetHintObj = $(\"<span>\")\n                                .addClass(\"brackets-css-hints brackets-hints\")\n                                .attr(\"data-val\", expandedAbbr)\n                                .attr(\"data-isEmmet\", true);\n\n                            // for highlighting the already-typed characters\n                            if (token.stringRanges) {\n                                token.stringRanges.forEach(function (range) {\n                                    if (range.matched) {\n                                        $emmetHintObj.append($(\"<span>\")\n                                            .text(range.text)\n                                            .addClass(\"matched-hint\"));\n                                    } else {\n                                        $emmetHintObj.append(range.text);\n                                    }\n                                });\n                            } else {\n                                // fallback\n                                $emmetHintObj.text(expandedAbbr);\n                            }\n\n                            // add the emmet icon to the final hint object\n                            $emmetHintObj.append($icon);\n\n                            if (pushedHints) {\n\n                                // to remove duplicate hints. one comes from emmet and other from default css hints.\n                                // we remove the default css hints and push emmet hint at the beginning.\n                                for (let i = 0; i < pushedHints.length; i++) {\n                                    if (pushedHints[i][0].getAttribute('data-val') === expandedAbbr) {\n                                        pushedHints.splice(i, 1);\n                                        break;\n                                    }\n                                }\n                                pushedHints.unshift($emmetHintObj);\n                            } else {\n                                pushedHints = $emmetHintObj;\n                            }\n                        }\n                    } catch (e) {\n                        // pass\n                    }\n                }\n            }\n\n            return {\n                hints: pushedHints,\n                match: null, // the CodeHintManager should not format the results\n                selectInitial: selectInitial,\n                handleWideResults: false\n            };\n        }\n        return null;\n    };\n\n    /**\n     * Checks whether the emmet abbr should be expanded or not.\n     * For instance: EXPAND_ABBR function always expands a value passed to it.\n     * if we pass 'xyz', then there's no CSS property matching to it, but it still expands this to `xyz: ;`.\n     * So, make sure that `needle + ': ;'` doesn't add to expandedAbbr\n     *\n     * @param {String} needle the word before the cursor\n     * @param {String} expandedAbbr the expanded abbr returned by EXPAND_ABBR emmet api\n     * @returns {boolean} true if emmet should be expanded, otherwise false\n     */\n    function _isEmmetExpandable(needle, expandedAbbr) {\n        return needle + ': ;' !== expandedAbbr;\n    }\n\n    /**\n     * Checks whether the expandedAbbr has any number.\n     * For instance: `m0` expands to `margin: 0;`, so we need to display the whole thing in the code hint\n     * Here, we also make sure that abbreviations which has `#`, `,` should not be included, because\n     * `color` expands to `color: #000;` or `color: rgb(0, 0, 0)`.\n     * So this actually has numbers, but we don't want to display this.\n     *\n     * @param {String} expandedAbbr the expanded abbr returned by EXPAND_ABBR emmet api\n     * @returns {boolean} true if expandedAbbr has numbers (and doesn't include '#') otherwise false.\n     */\n    function _isEmmetAbbrNumeric(expandedAbbr) {\n        return expandedAbbr.match(/\\d/) !== null && !expandedAbbr.includes('#') && !expandedAbbr.includes(',');\n    }\n\n\n    const HISTORY_PREFIX = \"Live_hint_\";\n    let hintSessionId = 0, isInLiveHighlightSession = false;\n\n    CssPropHints.prototype.onClose = function () {\n        if (isInLiveHighlightSession) {\n            this.editor.restoreHistoryPoint(`${HISTORY_PREFIX}${hintSessionId}`);\n            isInLiveHighlightSession = false;\n        }\n        hintSessionId++;\n    };\n\n    CssPropHints.prototype.onHighlight = function ($highlightedEl, _$descriptionElem, reason) {\n        if (!reason) {\n            console.error(\"OnHighlight called without reason, should never happen!\");\n            hintSessionId++;\n            return;\n        }\n        const currentLivePreviewDetails = LiveDevelopment.getLivePreviewDetails();\n        if (!(currentLivePreviewDetails && currentLivePreviewDetails.liveDocument)) {\n            // css live hints only for live previewed page and related files\n            return;\n        }\n        const currentlyEditedFile = this.editor.document.file.fullPath;\n        const livePreviewedFile = currentLivePreviewDetails.liveDocument.doc.file.fullPath;\n        if (currentlyEditedFile !== livePreviewedFile) {\n            const isRelatedFile = currentLivePreviewDetails.liveDocument.isRelated &&\n                currentLivePreviewDetails.liveDocument.isRelated(currentlyEditedFile);\n            if (!isRelatedFile) {\n                // file is neither current html file being live previewed, or any of its\n                // related file. we dont show hints in the case\n                return;\n            }\n        }\n        if (reason.source === CodeHintManager.SELECTION_REASON.SESSION_START) {\n            hintSessionId++;\n            this.editor.createHistoryRestorePoint(`${HISTORY_PREFIX}${hintSessionId}`);\n            return;\n        }\n        if (reason.source !== CodeHintManager.SELECTION_REASON.KEYBOARD_NAV) {\n            return;\n        }\n        const event = reason.event;\n        if (!(event.keyCode === KeyEvent.DOM_VK_UP ||\n            event.keyCode === KeyEvent.DOM_VK_DOWN ||\n            event.keyCode === KeyEvent.DOM_VK_PAGE_UP ||\n            event.keyCode === KeyEvent.DOM_VK_PAGE_DOWN)) {\n            return;\n        }\n        Metrics.countEvent(Metrics.EVENT_TYPE.LIVE_PREVIEW, \"cssHint\", \"preview\");\n        const $hintItem = $highlightedEl.find(\".brackets-css-hints\");\n        const highligtedValue = $highlightedEl.find(\".brackets-css-hints\").data(\"val\");\n        if (!highligtedValue || !$hintItem.is(\":visible\")) {\n            return;\n        }\n        isInLiveHighlightSession = true;\n        this.editor._dontDismissPopupOnScroll();\n        this.editor.restoreHistoryPoint(`${HISTORY_PREFIX}${hintSessionId}`);\n        this.insertHint($highlightedEl.find(\".brackets-css-hints\"), true);\n    };\n\n    /**\n     * Inserts a given CSS protertyname or -value hint into the current editor context.\n     *\n     * @param {String} hint\n     * The hint to be inserted into the editor context.\n     *\n     * @return {Boolean}\n     * Indicates whether the manager should follow hint insertion with an\n     * additional explicit hint request.\n     */\n    CssPropHints.prototype.insertHint = function (hint, isLiveHighlight) {\n        var offset = this.info.offset,\n            cursor = this.editor.getCursorPos(),\n            start = { line: -1, ch: -1 },\n            end = { line: -1, ch: -1 },\n            keepHints = false,\n            adjustCursor = false,\n            newCursor,\n            ctx;\n\n        if (hint.jquery) {\n            hint.data(\"isEmmet\") && Metrics.countEvent(Metrics.EVENT_TYPE.CODE_HINTS, \"emmet\", \"cssInsert\");\n            hint = hint.data(\"val\") + \"\"; // font-weight: 400, 400 is returned as number so,\n        }\n\n        if (this.info.context !== CSSUtils.PROP_NAME && this.info.context !== CSSUtils.PROP_VALUE) {\n            return false;\n        }\n\n        start.line = end.line = cursor.line;\n        start.ch = cursor.ch - offset;\n\n        if (this.info.context === CSSUtils.PROP_NAME) {\n            keepHints = true;\n            var textAfterCursor = this.info.name.substr(this.info.offset);\n            if (this.info.name.length === 0 || CodeHintManager.hasValidExclusion(this.exclusion, textAfterCursor)) {\n                // It's a new insertion, so append a colon and set keepHints\n                // to show property value hints.\n                hint += \": \";\n                end.ch = start.ch;\n                end.ch += offset;\n\n                if (this.exclusion) {\n                    // Append a space to the end of hint to insert and then adjust\n                    // the cursor before that space.\n                    hint += \" \";\n                    adjustCursor = true;\n                    newCursor = {\n                        line: cursor.line,\n                        ch: start.ch + hint.length - 1\n                    };\n                    this.exclusion = null;\n                }\n            } else {\n                // It's a replacement of an existing one or just typed in property.\n                // So we need to check whether there is an existing colon following\n                // the current property name. If a colon already exists, then we also\n                // adjust the cursor position and show code hints for property values.\n                end.ch = start.ch + this.info.name.length;\n                ctx = TokenUtils.getInitialContext(this.editor._codeMirror, cursor);\n                if (ctx.token.string.length > 0 && !/\\S/.test(ctx.token.string)) {\n                    // We're at the very beginning of a property name. So skip it\n                    // before we locate the colon following it.\n                    TokenUtils.moveNextToken(ctx);\n                }\n                if (TokenUtils.moveSkippingWhitespace(TokenUtils.moveNextToken, ctx) && ctx.token.string === \":\") {\n                    adjustCursor = true;\n                    newCursor = {\n                        line: cursor.line,\n                        ch: cursor.ch + (hint.length - this.info.name.length)\n                    };\n                    // Adjust cursor to the position after any whitespace that follows the colon, if there is any.\n                    if (TokenUtils.moveNextToken(ctx) && ctx.token.string.length > 0 && !/\\S/.test(ctx.token.string)) {\n                        newCursor.ch += ctx.token.string.length;\n                    }\n                } else if (!hint.endsWith(\";\")) {\n                    hint += \": \";\n                }\n            }\n        } else {\n            if (!this.info.isNewItem && this.info.index !== -1) {\n                // Replacing an existing property value or partially typed value\n                end.ch = start.ch + this.info.values[this.info.index].length;\n            } else {\n                // Inserting a new property value\n                end.ch = start.ch;\n            }\n\n            var parenMatch = hint.match(/\\(.*?\\)/);\n            if (parenMatch) {\n                // Only adjust cursor for non-color values\n                if (!hint.startsWith('rgb') &&\n                    !hint.startsWith('rgba') &&\n                    !hint.startsWith('hsl') &&\n                    !hint.startsWith('hsla')) {\n                    // value has (...), so place cursor inside opening paren\n                    // and keep hints open\n                    adjustCursor = true;\n                    newCursor = {\n                        line: cursor.line,\n                        ch: start.ch + parenMatch.index + 1\n                    };\n                    keepHints = true;\n                }\n            }\n        }\n\n        if (isLiveHighlight) {\n            // this is via user press up and down arrows when code hints is visible\n            if (this.info.context !== CSSUtils.PROP_VALUE && !hint.endsWith(\";\")) {\n                // we only do live hints for css property values. else UX is jarring.\n                // property full statements hints like \"display: flex;\" will be live previewed tho\n                return keepHints;\n            }\n            if (!this.editor.hasSelection()) {\n                this.editor.setSelection(start, end);\n            }\n            this.editor.replaceSelection(hint, 'around', \"liveHints\");\n            return keepHints;\n        }\n\n        // this is commit flow\n        if (isInLiveHighlightSession) {\n            // end previous highlight session.\n            isInLiveHighlightSession = false;\n            hintSessionId++;\n        }\n\n        if (this.editor.hasSelection()) {\n            // this is when user commits\n            this.editor.replaceSelection(hint, 'end');\n            return keepHints;\n        }\n\n        // HACK (tracking adobe/brackets#1688): We talk to the private CodeMirror instance\n        // directly to replace the range instead of using the Document, as we should. The\n        // reason is due to a flaw in our current document synchronization architecture when\n        // inline editors are open.\n        this.editor._codeMirror.replaceRange(hint, start, end);\n\n        if (adjustCursor) {\n            this.editor.setCursorPos(newCursor);\n        }\n\n        // If the cursor is just after a semicolon that means that,\n        // the CSS property is fully specified,\n        // so we don't need to continue showing hints for its value.\n        const cursorPos = this.editor.getCursorPos();\n        if (this.editor.getCharacterAtPosition({ line: cursorPos.line, ch: cursorPos.ch - 1 }) === ';') {\n            keepHints = false;\n        }\n\n        return keepHints;\n    };\n\n    /**\n     * Checks for preference changes, to enable/disable Emmet\n     */\n    function preferenceChanged() {\n        enabled = PreferencesManager.get(\"emmet\");\n    }\n\n\n    AppInit.appReady(function () {\n        var cssPropHints = new CssPropHints();\n        CodeHintManager.registerHintProvider(cssPropHints, [\"css\", \"scss\", \"less\"], 1);\n\n        PreferencesManager.on(\"change\", \"emmet\", preferenceChanged);\n        preferenceChanged();\n\n        // For unit testing\n        exports.cssPropHintProvider = cssPropHints;\n    });\n});\n"],"file":"main.js"}