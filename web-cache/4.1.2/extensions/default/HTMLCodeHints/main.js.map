{"version":3,"sources":["extensions/default/HTMLCodeHints/main.js"],"names":["define","require","exports","module","AppInit","brackets","getModule","CodeHintManager","HTMLUtils","PreferencesManager","Strings","NewFileContentManager","CSSUtils","StringMatch","LiveDevelopment","KeyEvent","Metrics","HTMLTags","HTMLAttributes","HTMLTemplate","XHTMLTemplate","markupSnippets","htmlTags","positiveSymbols","negativeSymbols","expandAbbr","Phoenix","libs","Emmet","expand","markupSnippetsList","Object","keys","enabled","tags","attributes","EmmetMarkupHints","formatEmmetHint","abbr","$hint","$","addClass","$textContent","text","$icon","append","_isEmmetChar","char","insideBraces","validPattern","specialChars","Set","test","has","_findAbbreviationStart","line","cursorCh","start","charAt","getWordBeforeCursor","editor","pos","getCursorPos","lineText","document","getLine","abbreviationStart","ch","abbreviationEnd","word","substring","end","getLineIndentation","position","match","addIndentation","expandedText","baseIndent","lines","split","result","isFirstLine","i","length","trim","findCursorPosition","indentedAbbr","startPos","totalLines","j","pair","endsWith","includes","tempLine","trimmedTempLine","startsWith","openingTagLine","indentMatch","extraIndent","_updateAbbrInEditor","wordObj","expandedAbbr","charsNext","replaceRange","cursorPos","setCursorPos","_isExpandable","some","symbol","toLowerCase","syntax","type","error","nextChar","modifiedWord","innerError","TagHints","this","exclusion","AttrHints","globalAttributes","readGlobalAttrHints","cachedHints","definePreference","description","DESCRIPTION_HTML_TAG_HINTS","DESCRIPTION_ATTR_HINTS","prototype","hasHints","implicitChar","getHints","formattedHint","hints","selectInitial","defaultDescriptionWidth","handleWideResults","insertHint","countEvent","EVENT_TYPE","CODE_HINTS","updateExclusion","textAfterCursor","tagInfo","tagName","substr","offset","hasValidExclusion","getTagInfo","tokenType","TAG_NAME","query","slice","map","value","key","indexOf","sort","completion","cursor","charCount","global","MAX_CLASS_HINTS","formatHints","basicMatchSort","splice","token","$hintObj","label","stringRanges","forEach","item","matched","attr","_getAllClassHints","queryStr","segments","deferred","Deferred","getAllCssSelectorsInProject","includeClasses","scanCurrentHtml","then","pvalue","stringMatch","preferPrefixMatches","validHints","alreadyMatched","resolve","catch","console","_getValueHintsForAttr","attrName","tagPlusAttr","attrInfo","attribOption","attrNameOnly","ATTR_NAME","name","ATTR_VALUE","HISTORY_PREFIX","hintSessionId","isInLiveHighlightSession","NewDocContentProvider","CONTENT_PROVIDER_NAME","preferenceChanged","get","onClose","restoreHistoryPoint","onHighlight","$highlightedEl","_$descriptionElem","reason","currentLivePreviewDetails","getLivePreviewDetails","liveDocument","currentlyEditedFile","file","fullPath","livePreviewedFile","doc","source","SELECTION_REASON","SESSION_START","createHistoryRestorePoint","KEYBOARD_NAV","event","keyCode","DOM_VK_UP","DOM_VK_DOWN","DOM_VK_PAGE_UP","DOM_VK_PAGE_DOWN","LIVE_PREVIEW","$hintItem","find","highligtedValue","data","is","_dontDismissPopupOnScroll","Array","foundPrefix","tag","usedAttr","getTagAttributes","filter","unfiltered","concat","grep","inArray","assert","hasOwnProperty","done","asyncHints","resolveWith","isLiveHighlight","insertedName","replaceExistingOne","valueAssigned","endQuote","shouldReplace","positionWithinAttributeVal","textBeforeCursor","lastSegment","hasEndQuote","quoteChar","hasSelection","initialOffset","firstSegment","setSelection","replaceSelection","getContent","fileName","Promise","reject","appReady","JSON","parse","tagHints","attrHints","newDocContentProvider","registerHintProvider","registerContentProvider","on","emmetMarkupHints","emmetHintProvider","tagHintProvider","attrHintProvider"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\ndefine(function (require, exports, module) {\n\n    require(\"HTMLJumpToDef\");\n\n    // Load dependent modules\n    const AppInit             = brackets.getModule(\"utils/AppInit\"),\n        CodeHintManager     = brackets.getModule(\"editor/CodeHintManager\"),\n        HTMLUtils           = brackets.getModule(\"language/HTMLUtils\"),\n        PreferencesManager  = brackets.getModule(\"preferences/PreferencesManager\"),\n        Strings             = brackets.getModule(\"strings\"),\n        NewFileContentManager = brackets.getModule(\"features/NewFileContentManager\"),\n        CSSUtils            = brackets.getModule(\"language/CSSUtils\"),\n        StringMatch         = brackets.getModule(\"utils/StringMatch\"),\n        LiveDevelopment     = brackets.getModule(\"LiveDevelopment/main\"),\n        KeyEvent            = brackets.getModule(\"utils/KeyEvent\"),\n        Metrics             = brackets.getModule(\"utils/Metrics\"),\n        HTMLTags            = require(\"text!HtmlTags.json\"),\n        HTMLAttributes      = require(\"text!HtmlAttributes.json\"),\n        HTMLTemplate        = require(\"text!template.html\"),\n        XHTMLTemplate       = require(\"text!template.xhtml\");\n\n    require(\"./html-lint\");\n\n    const {\n        markupSnippets,\n        htmlTags,\n        positiveSymbols,\n        negativeSymbols\n    } = require('./emmet-snippets');\n\n    /**\n     * The Emmet api's\n     */\n    const expandAbbr = Phoenix.libs.Emmet.expand;\n\n    /**\n     * A list of all the markup snippets that can be expanded.\n     * For ex: 'link:css', 'iframe'\n     * They expand differently as compared to normal tags.\n     * Refer to `./emmet-snippets.js` file for more info.\n     */\n    const markupSnippetsList = Object.keys(markupSnippets);\n    let enabled = true; // whether Emmet is enabled or not in preferences\n\n\n    let tags,\n        attributes;\n\n    PreferencesManager.definePreference(\"codehint.TagHints\", \"boolean\", true, {\n        description: Strings.DESCRIPTION_HTML_TAG_HINTS\n    });\n\n    PreferencesManager.definePreference(\"codehint.AttrHints\", \"boolean\", true, {\n        description: Strings.DESCRIPTION_ATTR_HINTS\n    });\n\n    /**\n     * @constructor\n     */\n    function EmmetMarkupHints() {\n    }\n\n\n    /**\n     * Checks whether hints are available for the current word where cursor is present.\n     *\n     * @param {Editor} editor - the editor instance\n     * @param {String} implicitChar - unused param [didn't remove, as we might need it in future]\n     * @returns {Boolean} - true if the abbr can be expanded otherwise false.\n     */\n    EmmetMarkupHints.prototype.hasHints = function (editor, implicitChar) {\n        if (enabled) {\n            this.editor = editor;\n\n            const wordObj = getWordBeforeCursor(editor);\n            // make sure we donot have empty spaces\n            if (wordObj.word.trim()) {\n\n                const expandedAbbr = _isExpandable(editor, wordObj.word);\n                if (expandedAbbr) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    };\n\n\n    /**\n     * Returns the Emmet hint for the current word before the cursor.\n     * The hint element will have an appended \"Emmet\" icon at bottom-rigth to indicate it's an Emmet abbreviation.\n     *\n     * @param {String} implicitChar - unused param [didn't remove, as we might need it in future]\n     */\n    EmmetMarkupHints.prototype.getHints = function (implicitChar) {\n        const wordObj = getWordBeforeCursor(this.editor);\n\n        // Check if the abbreviation is expandable\n        const expandedAbbr = _isExpandable(this.editor, wordObj.word);\n        if (!expandedAbbr) {\n            return null;\n        }\n\n        // Create the formatted hint element with an appended Emmet icon\n        const formattedHint = formatEmmetHint(wordObj.word);\n\n        return {\n            hints: [formattedHint],\n            match: null,\n            selectInitial: true,\n            defaultDescriptionWidth: true,\n            handleWideResults: false\n        };\n    };\n\n\n    /**\n     * Formats an Emmet abbreviation hint by appending an icon.\n     *\n     * @param {string} abbr - The Emmet abbreviation.\n     * @returns {jQuery} - A jQuery element representing the formatted hint.\n     */\n    function formatEmmetHint(abbr) {\n        // Create the main container for the hint\n        var $hint = $(\"<span>\")\n            .addClass(\"emmet-hint\");\n\n        // Create a wrapper for the text content\n        var $textContent = $(\"<span>\")\n            .addClass(\"emmet-text-content\")\n            .text(abbr);\n\n        // style in brackets_patterns_override.less file\n        let $icon = $(`<span class=\"emmet-code-hint\">Emmet</span>`);\n\n        // Append both text content and icon to the main container\n        $hint.append($textContent);\n        $hint.append($icon);\n\n        return $hint;\n    }\n\n\n    /**\n     * Responsible for updating the abbr with the expanded text in the editor.\n     * This function calls helper functions for this as there are,\n     * lot of complex cases that should be taken care of.\n     */\n    EmmetMarkupHints.prototype.insertHint = function () {\n        const wordObj = getWordBeforeCursor(this.editor);\n        const expandedAbbr = _isExpandable(this.editor, wordObj.word);\n        _updateAbbrInEditor(this.editor, wordObj, expandedAbbr);\n        Metrics.countEvent(Metrics.EVENT_TYPE.CODE_HINTS, \"emmet\", \"htmlInsert\");\n        return false;\n    };\n\n\n    /**\n     * Determines whether a given character is allowed as part of an Emmet abbreviation\n     *\n     * @param {String} char - The character to test\n     * @param {Boolean} insideBraces - Flag indicating if we are inside braces (e.g. {} or [])\n     * @returns True if the character is valid for an abbreviation\n     */\n    function _isEmmetChar(char, insideBraces) {\n        // Valid abbreviation characters: letters, digits, and some punctuation\n        // Adjust this regex or the list as needed for your implementation\n        const validPattern = /[a-zA-Z0-9:+*<>()/!$\\-@#}{]/;\n        const specialChars = new Set(['.', '#', '[', ']', '\"', '=', ':', ',', '-']);\n        return validPattern.test(char) || specialChars.has(char) || (insideBraces && char === ' ');\n    }\n\n\n    /**\n     * Scans backwards from the given cursor position on a line to locate the start of the Emmet abbreviation\n     *\n     * @param {String} line - The full text of the current line\n     * @param {Number} cursorCh - The cursor's character (column) position on that line\n     * @returns The index (column) where the abbreviation starts\n     */\n    function _findAbbreviationStart(line, cursorCh) {\n        let start = cursorCh;\n        let insideBraces = false;\n\n        // If the cursor is right before a closing brace, adjust it to be \"inside\" the braces\n        if (line.charAt(start) === '}' || line.charAt(start) === ']') {\n            start--;\n            insideBraces = true;\n        }\n\n        // Walk backwards from the cursor to find the boundary of the abbreviation\n        while (start > 0) {\n            const char = line.charAt(start - 1);\n\n            // Update our \"inside braces\" state based on the character\n            if (char === '}' || char === ']') {\n                insideBraces = true;\n            } else if (char === '{' || char === '[') {\n                insideBraces = false;\n            }\n\n            // If the character is valid as part of an Emmet abbreviation, continue scanning backwards\n            if (_isEmmetChar(char, insideBraces)) {\n                start--;\n            } else {\n                break;\n            }\n        }\n        return start;\n    }\n\n\n    /**\n     * Retrieves the Emmet abbreviation (i.e. the word before the cursor) from the current editor state\n     *\n     * @param {Editor} editor - The editor instance\n     * @returns An object with the abbreviation and its start/end positions\n     *\n     * Format:\n     * {\n     *   word: string,             // the extracted abbreviation\n     *   start: { line: number, ch: number },\n     *   end: { line: number, ch: number }\n     * }\n     */\n    function getWordBeforeCursor(editor) {\n        const pos = editor.getCursorPos();\n        const lineText = editor.document.getLine(pos.line);\n\n        // to determine where the abbreviation starts on the line\n        const abbreviationStart = _findAbbreviationStart(lineText, pos.ch);\n\n        // Optionally, adjust the end position if the cursor is immediately before a closing brace.\n        let abbreviationEnd = pos.ch;\n        if (lineText.charAt(abbreviationEnd) === '}' || lineText.charAt(abbreviationEnd) === ']') {\n            abbreviationEnd++;\n        }\n\n        const word = lineText.substring(abbreviationStart, abbreviationEnd);\n\n        return {\n            word: word,\n            start: { line: pos.line, ch: abbreviationStart },\n            end: { line: pos.line, ch: abbreviationEnd }\n        };\n    }\n\n\n    /**\n     * Calculate the indentation level for the current line\n     *\n     * @param {Editor} editor - the editor instance\n     * @param {Object} position - position object with line number\n     * @returns {String} - the indentation string\n     */\n    function getLineIndentation(editor, position) {\n        const line = editor.document.getLine(position.line);\n        const match = line.match(/^\\s*/);\n        return match ? match[0] : '';\n    }\n\n\n    /**\n     * Adds proper indentation to multiline Emmet expansion\n     *\n     * @param {String} expandedText - the expanded Emmet abbreviation\n     * @param {String} baseIndent - the base indentation string\n     * @returns {String} - properly indented text\n     */\n    function addIndentation(expandedText, baseIndent) {\n        // Split into lines, preserve empty lines\n        const lines = expandedText.split(/(\\r\\n|\\n)/g);\n\n        // Process each line\n        let result = '';\n        let isFirstLine = true;\n\n        for (let i = 0; i < lines.length; i++) {\n            const line = lines[i];\n\n            // If it's a newline character, just add it\n            if (line === '\\n' || line === '\\r\\n') {\n                result += line;\n                continue;\n            }\n\n            // Skip indenting empty lines\n            if (line.trim() === '') {\n                result += line;\n                continue;\n            }\n\n            // Don't indent the first line as it inherits the current indent\n            if (isFirstLine) {\n                result += line;\n                isFirstLine = false;\n            } else {\n                // Add base indent plus the existing indent in the expanded text\n                result += baseIndent + line;\n            }\n        }\n\n        return result;\n    }\n\n\n\n    /**\n     * Find the position where cursor should be placed after expansion\n     * Looks for patterns like '><', '\"\"', ''\n     *\n     * @param {Editor} editor - The editor instance\n     * @param {String} indentedAbbr - the indented abbreviation\n     * @param {Object} startPos - Starting position {line, ch} of the expansion\n     * @returns {Object | false} - Cursor position {line, ch} or false if no pattern found\n     */\n    function findCursorPosition(editor, indentedAbbr, startPos) {\n        const totalLines = startPos.line + indentedAbbr.split('\\n').length;\n\n        for (let i = startPos.line; i < totalLines; i++) {\n            const line = editor.document.getLine(i);\n\n            for (let j = 0; j < line.length - 1; j++) {\n                const pair = line[j] + line[j + 1];\n\n                if (pair === '\"\"' || pair === \"''\") {\n                    return { line: i, ch: j + 1 };\n                }\n            }\n            for (let j = 0; j < line.length - 1; j++) {\n                const pair = line[j] + line[j + 1];\n\n                if (pair === '><') {\n                    return { line: i, ch: j + 1 };\n                }\n            }\n        }\n\n        // Look for opening and closing tag pairs with empty line in between\n        // <body>\n        //      |\n        // </body>\n        // here in such scenarios, we want the cursor to be placed in between\n        // Look for opening and closing tag pairs with empty line in between\n        for (let i = startPos.line; i < totalLines; i++) {\n            const line = editor.document.getLine(i).trim();\n            if (line.endsWith('>') && line.includes('<') && !line.includes('</')) {\n                if (editor.document.getLine(i + 1) && !editor.document.getLine(i + 1).trim()) {\n                    const tempLine = editor.document.getLine(i + 2);\n                    if (tempLine) {\n                        const trimmedTempLine = tempLine.trim();\n                        if (trimmedTempLine.includes('</') && trimmedTempLine.startsWith('<')) {\n                            // Get the current line's indentation by counting spaces/tabs\n                            const openingTagLine = editor.document.getLine(i);\n                            const indentMatch = openingTagLine.match(/^[\\s\\t]*/)[0];\n                            // Add 4 more spaces (or equivalent tab) for inner content\n                            const extraIndent = '    ';  // 4 spaces for additional indentation\n\n                            return {\n                                line: i + 1,\n                                ch: indentMatch.length + extraIndent.length\n                            };\n                        }\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n\n\n    /**\n     * This function is responsible to replace the abbreviation in the editor,\n     * with its expanded version\n     *\n     * @param {Editor} editor - the editor instance\n     * @param {Object} wordObj -  an object in the format :\n     * {\n     *      word: \"\",   // the word before the cursor\n     *      start: {line: Number, ch: Number},\n     *      end: {line: Number, ch: Number}\n     * }\n     * @param {String} expandedAbbr - the expanded version of abbr that will replace the abbr\n     */\n    function _updateAbbrInEditor(editor, wordObj, expandedAbbr) {\n        // Get the current line's indentation\n        const baseIndent = getLineIndentation(editor, wordObj.start);\n\n        // Add proper indentation to the expanded abbreviation\n        const indentedAbbr = addIndentation(expandedAbbr, baseIndent);\n\n        // Handle the special case for braces\n        // this check is added because in some situations such as\n        // `ul>li{Hello}` and the cursor is before the closing braces right after 'o',\n        // then when this is expanded it results in an extra closing braces at the end.\n        // so we remove the extra closing brace from the end\n        if (wordObj.word.includes('{') || wordObj.word.includes('[')) {\n            const pos = editor.getCursorPos();\n            const line = editor.document.getLine(pos.line);\n            const char = line.charAt(wordObj.end.ch);\n            const charsNext = line.charAt(wordObj.end.ch + 1);\n\n            if (char === '}' || char === ']') {\n                wordObj.end.ch += 1;\n            }\n\n            // sometimes at the end we get `\"]` as extra with some abbreviations.\n            if (char === '\"' && charsNext && charsNext === ']') {\n                wordObj.end.ch += 2;\n            }\n\n        }\n\n        // Replace the abbreviation\n        editor.document.replaceRange(\n            indentedAbbr,\n            wordObj.start,\n            wordObj.end\n        );\n\n        // Calculate and set the new cursor position\n        const cursorPos = findCursorPosition(editor, indentedAbbr, wordObj.start);\n        if (cursorPos) {\n            editor.setCursorPos(cursorPos.line, cursorPos.ch);\n        }\n    }\n\n\n    /**\n     * This function checks whether the abbreviation can be expanded or not.\n     * There are a lot of cases to check:\n     * There should not be any negative symbols\n     * The abbr should be either in htmlTags or in markupSnippetsList\n     * For other cases such as 'ul>li', we will check if there is any,\n     * positive word. This is done to handle complex abbreviations such as,\n     * 'ul>li' or 'li*3{Hello}'. So we check if the word includes any positive symbols.\n     *\n     * @param {Editor} editor - the editor instance\n     * @param {String} word - the abbr\n     * @returns {String | null} - returns the expanded abbr, and if cannot be expanded, returns null\n     */\n    function _isExpandable(editor, word) {\n        const pos = editor.getCursorPos();\n        const line = editor.document.getLine(pos.line);\n\n        // to prevent hints from appearing in <!DOCTYPE html> line. Also to prevent hints from appearing in comments\n        if(line.includes('<!')) {\n            return null;\n        }\n\n        // not to show emmet hint when either a single or three exclamation mark(s) is present\n        if (line.includes('!!') && !line.includes('!!!')) {\n            return null;\n        }\n\n        // if more than three, then don't show emmet hint\n        if(line.includes('!!!!')) {\n            return null;\n        }\n\n        // make sure that word doesn't contain any negativeSymbols\n        if (negativeSymbols.some(symbol => word.includes(symbol))) {\n            return null;\n        }\n\n        // the word must be either in markupSnippetsList, htmlList or it must have a positive symbol or lorem text\n        // convert to lowercase only for `htmlTags` because HTML tag names are case-insensitive,\n        // but `markupSnippetsList` expands abbreviations in a non-tag manner,\n        // where the expanded abbreviation is already in lowercase.\n        if (markupSnippetsList.includes(word) ||\n            htmlTags.includes(word.toLowerCase()) ||\n            positiveSymbols.some(symbol => word.includes(symbol)) ||\n            word.toLowerCase().includes('lorem')\n        ) {\n\n            try {\n                return  expandAbbr(word, { syntax: \"html\", type: \"markup\" }); // expanded\n            } catch (error) {\n\n                // emmet api throws an error when abbr contains unclosed quotes, handling that case\n                const nextChar = line.charAt(pos.ch);\n\n                if (nextChar) {\n                    // If the next character is a quote, add quote to abbr\n                    if (nextChar === '\"' || nextChar === \"'\") {\n                        const modifiedWord = word + nextChar;\n\n                        try {\n                            return expandAbbr(modifiedWord, { syntax: \"html\", type: \"markup\" }); //expandedModified\n                        } catch (innerError) {\n                            // If it still fails, return false\n                            return null;\n                        }\n                    }\n                }\n\n                // If no quote is found or expansion fails, return false\n                return null;\n            }\n        }\n\n        return null;\n    }\n\n\n    /**\n     * @constructor\n     */\n    function TagHints() {\n        this.exclusion = null;\n    }\n\n    /**\n     * Check whether the exclusion is still the same as text after the cursor.\n     * If not, reset it to null.\n     */\n    TagHints.prototype.updateExclusion = function () {\n        var textAfterCursor;\n        if (this.exclusion && this.tagInfo) {\n            textAfterCursor = this.tagInfo.tagName.substr(this.tagInfo.position.offset);\n            if (!CodeHintManager.hasValidExclusion(this.exclusion, textAfterCursor)) {\n                this.exclusion = null;\n            }\n        }\n    };\n\n    /**\n     * Determines whether HTML tag hints are available in the current editor\n     * context.\n     *\n     * @param {Editor} editor\n     * A non-null editor object for the active window.\n     *\n     * @param {string} implicitChar\n     * Either null, if the hinting request was explicit, or a single character\n     * that represents the last insertion and that indicates an implicit\n     * hinting request.\n     *\n     * @return {boolean}\n     * Determines whether the current provider is able to provide hints for\n     * the given editor context and, in case implicitChar is non- null,\n     * whether it is appropriate to do so.\n     */\n    TagHints.prototype.hasHints = function (editor, implicitChar) {\n        var pos = editor.getCursorPos();\n\n        this.tagInfo = HTMLUtils.getTagInfo(editor, pos);\n        this.editor = editor;\n        if (implicitChar === null) {\n            if (this.tagInfo.position.tokenType === HTMLUtils.TAG_NAME) {\n                if (this.tagInfo.position.offset >= 0) {\n                    if (this.tagInfo.position.offset === 0) {\n                        this.exclusion = this.tagInfo.tagName;\n                    } else {\n                        this.updateExclusion();\n                    }\n                    return true;\n                }\n            }\n            return false;\n        }\n        if (implicitChar === \"<\") {\n            this.exclusion = this.tagInfo.tagName;\n            return true;\n        }\n        return false;\n\n    };\n\n    /**\n     * Returns a list of availble HTML tag hints if possible for the current\n     * editor context.\n     *\n     * @return {jQuery.Deferred|{\n     *              hints: Array.<string|jQueryObject>,\n     *              match: string,\n     *              selectInitial: boolean,\n     *              handleWideResults: boolean}}\n     * Null if the provider wishes to end the hinting session. Otherwise, a\n     * response object that provides:\n     * 1. a sorted array hints that consists of strings\n     * 2. a string match that is used by the manager to emphasize matching\n     *    substrings when rendering the hint list\n     * 3. a boolean that indicates whether the first result, if one exists,\n     *    should be selected by default in the hint list window.\n     * 4. handleWideResults, a boolean (or undefined) that indicates whether\n     *    to allow result string to stretch width of display.\n     */\n    TagHints.prototype.getHints = function (implicitChar) {\n        var query,\n            result;\n\n        this.tagInfo = HTMLUtils.getTagInfo(this.editor, this.editor.getCursorPos());\n        if (this.tagInfo.position.tokenType === HTMLUtils.TAG_NAME) {\n            if (this.tagInfo.position.offset >= 0) {\n                this.updateExclusion();\n                query = this.tagInfo.tagName.slice(0, this.tagInfo.position.offset);\n                result = $.map(tags, function (value, key) {\n                    if (key.indexOf(query) === 0) {\n                        return key;\n                    }\n                }).sort();\n\n                return {\n                    hints: result,\n                    match: query,\n                    selectInitial: true,\n                    handleWideResults: false\n                };\n            }\n        }\n\n        return null;\n    };\n\n    /**\n     * Inserts a given HTML tag hint into the current editor context.\n     *\n     * @param {string} hint\n     * The hint to be inserted into the editor context.\n     *\n     * @return {boolean}\n     * Indicates whether the manager should follow hint insertion with an\n     * additional explicit hint request.\n     */\n    TagHints.prototype.insertHint = function (completion) {\n        var start = {line: -1, ch: -1},\n            end = {line: -1, ch: -1},\n            cursor = this.editor.getCursorPos(),\n            charCount = 0;\n\n        if (this.tagInfo.position.tokenType === HTMLUtils.TAG_NAME) {\n            var textAfterCursor = this.tagInfo.tagName.substr(this.tagInfo.position.offset);\n            if (CodeHintManager.hasValidExclusion(this.exclusion, textAfterCursor)) {\n                charCount = this.tagInfo.position.offset;\n            } else {\n                charCount = this.tagInfo.tagName.length;\n            }\n        }\n\n        end.line = start.line = cursor.line;\n        start.ch = cursor.ch - this.tagInfo.position.offset;\n        end.ch = start.ch + charCount;\n\n        if (this.exclusion || completion !== this.tagInfo.tagName) {\n            if (start.ch !== end.ch) {\n                this.editor.document.replaceRange(completion, start, end);\n            } else {\n                this.editor.document.replaceRange(completion, start);\n            }\n            this.exclusion = null;\n        }\n\n        return false;\n    };\n\n    /**\n     * @constructor\n     */\n    function AttrHints() {\n        this.globalAttributes = this.readGlobalAttrHints();\n        this.cachedHints = null;\n        this.exclusion = \"\";\n    }\n\n    /**\n     * @private\n     * Parse the code hints from JSON data and extract all hints from property names.\n     * @return {!Array.<string>} An array of code hints read from the JSON data source.\n     */\n    AttrHints.prototype.readGlobalAttrHints = function () {\n        return $.map(attributes, function (value, key) {\n            if (value.global === \"true\") {\n                return key;\n            }\n        });\n    };\n\n    const MAX_CLASS_HINTS = 250;\n    function formatHints(hints) {\n        StringMatch.basicMatchSort(hints);\n        if(hints.length > MAX_CLASS_HINTS) {\n            hints = hints.splice(0, MAX_CLASS_HINTS);\n        }\n        return hints.map(function (token) {\n            let $hintObj = $(`<span data-val='${token.label || token.value || token.text}'></span>`).addClass(\"brackets-html-hints brackets-hints\");\n\n            // highlight the matched portion of each hint\n            if (token.stringRanges) {\n                token.stringRanges.forEach(function (item) {\n                    if (item.matched) {\n                        $hintObj.append($(\"<span>\")\n                            .text(item.text)\n                            .addClass(\"matched-hint\"));\n                    } else {\n                        $hintObj.append(item.text);\n                    }\n                });\n            } else {\n                $hintObj.text(token.label);\n            }\n            $hintObj.attr(\"data-val\", token.label);\n            return $hintObj;\n        });\n    }\n\n    function _getAllClassHints(query) {\n        let queryStr = query.queryStr;\n        // \"class1 class2\" have multiple classes. the last part is the query to hint\n        const segments = queryStr.split(\" \");\n        queryStr = segments[segments.length-1];\n        const deferred = $.Deferred();\n        CSSUtils.getAllCssSelectorsInProject({includeClasses: true, scanCurrentHtml: true}).then(hints=>{\n            const result = $.map(hints, function (pvalue) {\n                pvalue = pvalue.slice(1); // remove.\n                if(!pvalue || pvalue.includes(\"#\") || pvalue.includes(\"\\\\\") || pvalue.includes(\"/\")){\n                    return null;\n                }\n                return  StringMatch.stringMatch(pvalue, queryStr, { preferPrefixMatches: true });\n            });\n            const validHints = formatHints(result);\n            validHints.alreadyMatched = true;\n            deferred.resolve(validHints);\n        }).catch(console.error);\n        return deferred;\n    }\n\n    /**\n     * Helper function that determines the possible value hints for a given html tag/attribute name pair\n     *\n     * @param {{queryStr: string}} query\n     * The current query\n     *\n     * @param {string} tagName\n     * HTML tag name\n     *\n     * @param {string} attrName\n     * HTML attribute name\n     *\n     * @return {!Array.<string>|$.Deferred}\n     * The (possibly deferred) hints.\n     */\n    AttrHints.prototype._getValueHintsForAttr = function (query, tagName, attrName) {\n        // We look up attribute values with tagName plus a slash and attrName first.\n        // If the lookup fails, then we fall back to look up with attrName only. Most\n        // of the attributes in JSON are using attribute name only as their properties,\n        // but in some cases like \"type\" attribute, we have different properties like\n        // \"script/type\", \"link/type\" and \"button/type\".\n        var hints = [];\n\n        if(attrName === \"class\") {\n            return _getAllClassHints(query);\n        }\n\n        var tagPlusAttr = tagName + \"/\" + attrName,\n            attrInfo = attributes[tagPlusAttr] || attributes[attrName];\n\n        if (attrInfo) {\n            if (attrInfo.type === \"boolean\") {\n                hints = [\"false\", \"true\"];\n            } else if (attrInfo.attribOption) {\n                hints = attrInfo.attribOption;\n            }\n        }\n\n        return hints;\n    };\n\n    /**\n     * Check whether the exclusion is still the same as text after the cursor.\n     * If not, reset it to null.\n     *\n     * @param {boolean} attrNameOnly\n     * true to indicate that we update the exclusion only if the cursor is inside an attribute name context.\n     * Otherwise, we also update exclusion for attribute value context.\n     */\n    AttrHints.prototype.updateExclusion = function (attrNameOnly) {\n        if (this.exclusion && this.tagInfo) {\n            var tokenType = this.tagInfo.position.tokenType,\n                offset = this.tagInfo.position.offset,\n                textAfterCursor;\n\n            if (tokenType === HTMLUtils.ATTR_NAME) {\n                textAfterCursor = this.tagInfo.attr.name.substr(offset);\n            } else if (!attrNameOnly && tokenType === HTMLUtils.ATTR_VALUE) {\n                textAfterCursor = this.tagInfo.attr.value.substr(offset);\n            }\n            if (!CodeHintManager.hasValidExclusion(this.exclusion, textAfterCursor)) {\n                this.exclusion = null;\n            }\n        }\n    };\n\n    const HISTORY_PREFIX = \"Live_hint_CSS\";\n    let hintSessionId = 0, isInLiveHighlightSession = false;\n\n    AttrHints.prototype.onClose = function () {\n        if(isInLiveHighlightSession) {\n            this.editor.restoreHistoryPoint(`${HISTORY_PREFIX}${hintSessionId}`);\n            isInLiveHighlightSession = false;\n        }\n        hintSessionId++;\n    };\n\n    AttrHints.prototype.onHighlight = function ($highlightedEl, _$descriptionElem, reason) {\n        if(!reason){\n            console.error(\"OnHighlight called without reason, should never happen!\");\n            hintSessionId++;\n            return;\n        }\n        const tokenType = this.tagInfo.position.tokenType;\n        const currentLivePreviewDetails = LiveDevelopment.getLivePreviewDetails();\n        if(!(currentLivePreviewDetails && currentLivePreviewDetails.liveDocument)\n            || !(tokenType === HTMLUtils.ATTR_VALUE && this.tagInfo.attr.name === \"class\")) {\n            // live hints only for live previewed page on class attribute values\n            return;\n        }\n        const currentlyEditedFile = this.editor.document.file.fullPath;\n        const livePreviewedFile = currentLivePreviewDetails.liveDocument.doc.file.fullPath;\n        if(currentlyEditedFile !== livePreviewedFile) {\n            // file is not current html file being live previewed. we dont show hints in the case\n            return;\n        }\n        if(reason.source === CodeHintManager.SELECTION_REASON.SESSION_START){\n            hintSessionId++;\n            this.editor.createHistoryRestorePoint(`${HISTORY_PREFIX}${hintSessionId}`);\n            return;\n        }\n        if(reason.source !== CodeHintManager.SELECTION_REASON.KEYBOARD_NAV){\n            return;\n        }\n        const event = reason.event;\n        if(!(event.keyCode === KeyEvent.DOM_VK_UP ||\n            event.keyCode === KeyEvent.DOM_VK_DOWN ||\n            event.keyCode === KeyEvent.DOM_VK_PAGE_UP ||\n            event.keyCode === KeyEvent.DOM_VK_PAGE_DOWN)){\n            return;\n        }\n        Metrics.countEvent(Metrics.EVENT_TYPE.LIVE_PREVIEW, \"htmlClassHint\", \"preview\");\n        const $hintItem = $highlightedEl.find(\".brackets-html-hints\");\n        const highligtedValue = $highlightedEl.find(\".brackets-html-hints\").data(\"val\");\n        if(!highligtedValue || !$hintItem.is(\":visible\")){\n            return;\n        }\n        isInLiveHighlightSession = true;\n        this.editor._dontDismissPopupOnScroll();\n        this.editor.restoreHistoryPoint(`${HISTORY_PREFIX}${hintSessionId}`);\n        this.insertHint($highlightedEl.find(\".brackets-html-hints\"), true);\n    };\n\n    /**\n     * Determines whether HTML attribute hints are available in the current\n     * editor context.\n     *\n     * @param {Editor} editor\n     * A non-null editor object for the active window.\n     *\n     * @param {string} implicitChar\n     * Either null, if the hinting request was explicit, or a single character\n     * that represents the last insertion and that indicates an implicit\n     * hinting request.\n     *\n     * @return {boolean}\n     * Determines whether the current provider is able to provide hints for\n     * the given editor context and, in case implicitChar is non-null,\n     * whether it is appropriate to do so.\n     */\n    AttrHints.prototype.hasHints = function (editor, implicitChar) {\n        var pos = editor.getCursorPos(),\n            tokenType,\n            offset,\n            query;\n\n        this.editor = editor;\n        this.tagInfo = HTMLUtils.getTagInfo(editor, pos);\n        tokenType = this.tagInfo.position.tokenType;\n        offset = this.tagInfo.position.offset;\n        if (implicitChar === null) {\n            query = null;\n\n            if (tokenType === HTMLUtils.ATTR_NAME) {\n                if (offset >= 0) {\n                    query = this.tagInfo.attr.name.slice(0, offset);\n                }\n            } else if (tokenType === HTMLUtils.ATTR_VALUE) {\n                if (this.tagInfo.position.offset >= 0) {\n                    query = this.tagInfo.attr.value.slice(0, offset);\n                } else {\n                    // We get negative offset for a quoted attribute value with some leading whitespaces\n                    // as in <a rel= \"rtl\" where the cursor is just to the right of the \"=\".\n                    // So just set the queryStr to an empty string.\n                    query = \"\";\n                }\n\n                // If we're at an attribute value, check if it's an attribute name that has hintable values.\n                const attrName = this.tagInfo.attr.name;\n                if (attrName && attrName !== \"class\") { // class hints are always computed later\n                    let hints = this._getValueHintsForAttr({queryStr: query},\n                        this.tagInfo.tagName, attrName);\n                    if (hints instanceof Array) {\n                        // If we got synchronous hints, check if we have something we'll actually use\n                        var i, foundPrefix = false;\n                        for (i = 0; i < hints.length; i++) {\n                            if (hints[i].indexOf(query) === 0) {\n                                foundPrefix = true;\n                                break;\n                            }\n                        }\n                        if (!foundPrefix) {\n                            query = null;\n                        }\n                    }\n                }\n            }\n\n            if (offset >= 0) {\n                if (tokenType === HTMLUtils.ATTR_NAME && offset === 0) {\n                    this.exclusion = this.tagInfo.attr.name;\n                } else {\n                    this.updateExclusion(false);\n                }\n            }\n\n            return query !== null;\n        }\n        if (implicitChar === \" \" || implicitChar === \"'\" ||\n                    implicitChar === \"\\\"\" || implicitChar === \"=\") {\n            if (tokenType === HTMLUtils.ATTR_NAME) {\n                this.exclusion = this.tagInfo.attr.name;\n            }\n            return true;\n        }\n        return false;\n\n    };\n\n    /**\n     * Returns a list of availble HTML attribute hints if possible for the\n     * current editor context.\n     *\n     * @return {jQuery.Deferred|{\n     *              hints: Array.<string|jQueryObject>,\n     *              match: string,\n     *              selectInitial: boolean,\n     *              handleWideResults: boolean}}\n     * Null if the provider wishes to end the hinting session. Otherwise, a\n     * response object that provides:\n     * 1. a sorted array hints that consists of strings\n     * 2. a string match that is used by the manager to emphasize matching\n     *    substrings when rendering the hint list\n     * 3. a boolean that indicates whether the first result, if one exists,\n     *    should be selected by default in the hint list window.\n     * 4. handleWideResults, a boolean (or undefined) that indicates whether\n     *    to allow result string to stretch width of display.\n     */\n    AttrHints.prototype.getHints = function (implicitChar) {\n        var cursor = this.editor.getCursorPos(),\n            query = {queryStr: null},\n            tokenType,\n            offset,\n            result = [];\n\n        this.tagInfo = HTMLUtils.getTagInfo(this.editor, cursor);\n        tokenType = this.tagInfo.position.tokenType;\n        offset = this.tagInfo.position.offset;\n        if (tokenType === HTMLUtils.ATTR_NAME || tokenType === HTMLUtils.ATTR_VALUE) {\n            query.tag = this.tagInfo.tagName;\n\n            if (offset >= 0) {\n                if (tokenType === HTMLUtils.ATTR_NAME) {\n                    query.queryStr = this.tagInfo.attr.name.slice(0, offset);\n                } else {\n                    query.queryStr = this.tagInfo.attr.value.slice(0, offset);\n                    query.attrName = this.tagInfo.attr.name;\n                }\n                this.updateExclusion(false);\n            } else if (tokenType === HTMLUtils.ATTR_VALUE) {\n                // We get negative offset for a quoted attribute value with some leading whitespaces\n                // as in <a rel= \"rtl\" where the cursor is just to the right of the \"=\".\n                // So just set the queryStr to an empty string.\n                query.queryStr = \"\";\n                query.attrName = this.tagInfo.attr.name;\n            }\n\n            query.usedAttr = HTMLUtils.getTagAttributes(this.editor, cursor);\n        }\n\n        if (query.tag && query.queryStr !== null) {\n            var tagName = query.tag,\n                attrName = query.attrName,\n                filter = query.queryStr,\n                unfiltered = [],\n                hints;\n\n            if (attrName) {\n                hints = this._getValueHintsForAttr(query, tagName, attrName);\n            } else if (tags && tags[tagName] && tags[tagName].attributes) {\n                unfiltered = tags[tagName].attributes.concat(this.globalAttributes);\n                hints = $.grep(unfiltered, function (attr, i) {\n                    return $.inArray(attr, query.usedAttr) < 0;\n                });\n            }\n\n            if (hints instanceof Array && hints.length) {\n                console.assert(!result.length);\n                result = $.map(hints, function (item) {\n                    if (item.indexOf(filter) === 0) {\n                        return item;\n                    }\n                }).sort();\n                return {\n                    hints: result,\n                    match: query.queryStr,\n                    selectInitial: true,\n                    handleWideResults: false\n                };\n            } else if (hints instanceof Object && hints.hasOwnProperty(\"done\")) { // Deferred hints\n                var deferred = $.Deferred();\n                hints.done(function (asyncHints) {\n                    deferred.resolveWith(this, [{\n                        hints: asyncHints,\n                        match: asyncHints.alreadyMatched? null: query.queryStr,\n                        selectInitial: true,\n                        handleWideResults: false\n                    }]);\n                });\n                return deferred;\n            }\n            return null;\n\n        }\n\n\n    };\n\n    /**\n     * Inserts a given HTML attribute hint into the current editor context.\n     *\n     * @param {string} completion\n     * The hint to be inserted into the editor context.\n     *\n     * @return {boolean}\n     * Indicates whether the manager should follow hint insertion with an\n     * additional explicit hint request.\n     */\n    AttrHints.prototype.insertHint = function (completion, isLiveHighlight) {\n        var cursor = this.editor.getCursorPos(),\n            start = {line: -1, ch: -1},\n            end = {line: -1, ch: -1},\n            tokenType = this.tagInfo.position.tokenType,\n            offset = this.tagInfo.position.offset,\n            charCount = 0,\n            insertedName = false,\n            replaceExistingOne = this.tagInfo.attr.valueAssigned,\n            endQuote = \"\",\n            shouldReplace = true,\n            positionWithinAttributeVal = false,\n            textAfterCursor;\n\n        if (tokenType === HTMLUtils.ATTR_NAME) {\n            textAfterCursor = this.tagInfo.attr.name.substr(offset);\n            if (CodeHintManager.hasValidExclusion(this.exclusion, textAfterCursor)) {\n                charCount = offset;\n                replaceExistingOne = false;\n            } else {\n                charCount = this.tagInfo.attr.name.length;\n            }\n            // Append an equal sign and two double quotes if the current attr is not an empty attr\n            // and then adjust cursor location before the last quote that we just inserted.\n            if (!replaceExistingOne && attributes && attributes[completion] &&\n                    attributes[completion].type !== \"flag\") {\n                completion += \"=\\\"\\\"\";\n                insertedName = true;\n            } else if (completion === this.tagInfo.attr.name) {\n                shouldReplace = false;\n            }\n        } else if (tokenType === HTMLUtils.ATTR_VALUE) {\n            textAfterCursor = this.tagInfo.attr.value.substr(offset);\n            if (CodeHintManager.hasValidExclusion(this.exclusion, textAfterCursor)) {\n                charCount = offset;\n                // Set exclusion to null only after attribute value insertion,\n                // not after attribute name insertion since we need to keep it\n                // for attribute value insertion.\n                this.exclusion = null;\n            } else {\n                charCount = this.tagInfo.attr.value.length;\n            }\n\n            if(this.tagInfo.attr.name === \"class\") {\n                // css class hints\n                completion = completion.data(\"val\");\n                // \"anotherClass class<cursor>name\" . completion = classics , we have to match a prefix after space\n                const textBeforeCursor = this.tagInfo.attr.value.slice(0, offset);\n                let lastSegment = textBeforeCursor.split(\" \");\n                lastSegment = lastSegment[lastSegment.length-1];\n                offset = lastSegment.length;\n                charCount = offset;\n                positionWithinAttributeVal = true;\n            }\n\n            if (!this.tagInfo.attr.hasEndQuote) {\n                endQuote = this.tagInfo.attr.quoteChar;\n                if (endQuote) {\n                    completion += endQuote;\n                } else if (offset === 0) {\n                    completion = \"\\\"\" + completion + \"\\\"\";\n                }\n            } else if (completion === this.tagInfo.attr.value) {\n                shouldReplace = false;\n            }\n        }\n\n        end.line = start.line = cursor.line;\n        start.ch = cursor.ch - offset;\n        end.ch = start.ch + charCount;\n\n        if(isLiveHighlight) {\n            // this is via user press up and down arrows when code hints is visible\n            if(!this.editor.hasSelection()){\n                const initialOffset = this.tagInfo.position.offset;\n                textAfterCursor = this.tagInfo.attr.value.substr(initialOffset);\n                let firstSegment = textAfterCursor.split(\" \");\n                firstSegment = firstSegment[0]; // \"name\"\n                end.ch = end.ch + firstSegment.length;\n                this.editor.setSelection(start, end);\n            }\n            this.editor.replaceSelection(completion, 'around', \"liveHints\");\n            return true;\n        }\n\n        // this is commit flow\n        if(isInLiveHighlightSession) {\n            // end previous highlight session.\n            isInLiveHighlightSession = false;\n            hintSessionId++;\n        }\n\n        if(this.editor.hasSelection()){\n            // this is when user commits in a live selection\n            this.editor.replaceSelection(completion, 'end');\n            return true;\n        }\n\n        if (shouldReplace) {\n            if (start.ch !== end.ch) {\n                this.editor.document.replaceRange(completion, start, end);\n            } else {\n                this.editor.document.replaceRange(completion, start);\n            }\n        }\n\n        if(positionWithinAttributeVal){\n            this.editor.setCursorPos(start.line, start.ch + completion.length);\n            // we're now inside the double-quotes we just inserted\n        } else if (insertedName) {\n            this.editor.setCursorPos(start.line, start.ch + completion.length - 1);\n\n            // Since we're now inside the double-quotes we just inserted,\n            // immediately pop up the attribute value hint.\n            return true;\n        } else if (tokenType === HTMLUtils.ATTR_VALUE && this.tagInfo.attr.hasEndQuote) {\n            // Move the cursor to the right of the existing end quote after value insertion.\n            this.editor.setCursorPos(start.line, start.ch + completion.length + 1);\n        }\n\n        return false;\n    };\n\n    /**\n     * @constructor\n     */\n    function NewDocContentProvider() {\n        this.CONTENT_PROVIDER_NAME = \"HTMLCodeHints\";\n    }\n\n    NewDocContentProvider.prototype.getContent = function(fileName) {\n        return new Promise((resolve, reject)=>{\n            if(fileName.endsWith(\".xhtml\")){\n                resolve(XHTMLTemplate);\n                return;\n            }\n            resolve(HTMLTemplate);\n        });\n    };\n\n    /**\n     * Checks for preference changes, to enable/disable Emmet\n     */\n    function preferenceChanged() {\n        enabled = PreferencesManager.get(\"emmet\");\n    }\n\n\n    AppInit.appReady(function () {\n        // Parse JSON files\n        tags = JSON.parse(HTMLTags);\n        attributes = JSON.parse(HTMLAttributes);\n\n        // Register code hint providers\n        let tagHints = new TagHints();\n        let attrHints = new AttrHints();\n        let newDocContentProvider = new NewDocContentProvider();\n        CodeHintManager.registerHintProvider(tagHints, [\"html\"], 0);\n        CodeHintManager.registerHintProvider(attrHints, [\"html\"], 0);\n        NewFileContentManager.registerContentProvider(newDocContentProvider, [\"html\"], 0);\n\n        PreferencesManager.on(\"change\", \"emmet\", preferenceChanged);\n        preferenceChanged();\n\n        var emmetMarkupHints = new EmmetMarkupHints();\n        CodeHintManager.registerHintProvider(emmetMarkupHints, [\"html\", \"php\"], 0);\n\n        // For unit testing\n        exports.emmetHintProvider = emmetMarkupHints;\n        exports.tagHintProvider = tagHints;\n        exports.attrHintProvider = attrHints;\n    });\n});\n"],"file":"main.js"}