{"version":3,"sources":["extensions/default/Git/src/GutterManager.js"],"names":["define","require","exports","_","brackets","getModule","CommandManager","DocumentManager","EditorManager","ScrollTrackMarkers","MainViewManager","ErrorHandler","Events","EventEmitter","Git","Preferences","Strings","GIT_SCROLL_MARKS","gitAvailable","gutterName","editorsWithGutters","openWidgets","_addDummyGutterMarkerIfNotExist","cm","line","lineInfo","gutters","gutterEnabled","getOption","slice","indexOf","gutterMarkers","existingMarker","dummy","document","createElement","className","setGutterMarker","_cursorActivity","_evt","editor","hasSelection","_codeMirror","getCursorPos","clearWidgets","lines","map","mark","w","lineWidget","visible","widget","clear","clearOld","io","splice","clearGutter","setOption","off","gutterClick","gitGutters","prepareGutter","unshift","on","push","prepareGutters","editors","forEach","idx","length","_showGutters","_results","sortBy","openBefore","obj","$marker","$","addClass","type","html","lineIndex","gutterId","find","o","parentMark","element","$btn","text","doc","getCurrentDocument","replaceRange","content","ch","execute","refresh","attr","append","appendTo","addLineWidget","coverGutter","noHScroll","above","showIfHidden","getEditorFromPane","paneId","currentPath","getCurrentlyViewedPath","getOpenDocumentForPath","_masterEditor","hasVerticalScrollbar","scrollEl","getScrollerElement","scrollHeight","clientHeight","_markScrollbar","allChanges","added","filter","item","removed","modified","trackers","arr","css","tracker","posArray","addTickmarks","trackStyle","TRACK_STYLES","ON_LEFT","name","cssColorClass","processDiffResults","diff","changesets","split","str","shift","m","match","s1","s2","lineRemovedFrom","lineFrom","parseInt","lineCount","isNaN","l","substring","join","isModifiedMark","firstAddedMark","i","lineTo","lineNo","pop","concat","get","currentGitRoot","compact","getPaneIdList","currentFilePath","file","fullPath","filename","diffFile","then","catch","err","contains","showError","ERROR_REFRESH_GUTTER","goToPrev","activeEditor","getActiveEditor","results","searched","currentPos","goToMark","setCursorPos","goToNext","init","event","newEditor","oldEditor","GIT_ENABLED","GIT_DISABLED","BRACKETS_CURRENT_DOCUMENT_CHANGE","alreadyOpened","GIT_COMMITED","BRACKETS_FILE_CHANGED"],"mappings":"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","sourcesContent":["// this file was composed with a big help from @MiguelCastillo extension Brackets-InteractiveLinter\n// @see https://github.com/MiguelCastillo/Brackets-InteractiveLinter\n\ndefine(function (require, exports) {\n\n    // Brackets modules\n    var _               = brackets.getModule(\"thirdparty/lodash\"),\n        CommandManager  = brackets.getModule(\"command/CommandManager\"),\n        DocumentManager = brackets.getModule(\"document/DocumentManager\"),\n        EditorManager   = brackets.getModule(\"editor/EditorManager\"),\n        ScrollTrackMarkers  = brackets.getModule(\"search/ScrollTrackMarkers\"),\n        MainViewManager = brackets.getModule(\"view/MainViewManager\"),\n        ErrorHandler    = require(\"src/ErrorHandler\"),\n        Events          = require(\"src/Events\"),\n        EventEmitter    = require(\"src/EventEmitter\"),\n        Git             = require(\"src/git/Git\"),\n        Preferences     = require(\"./Preferences\"),\n        Strings             = brackets.getModule(\"strings\");\n\n    const GIT_SCROLL_MARKS = \"git_marks\";\n\n    var gitAvailable = false,\n        gutterName = \"brackets-git-gutter\",\n        editorsWithGutters = [],\n        openWidgets = [];\n\n    /**\n     * Checks if there's already a gutter marker on the given line;\n     * if not, inserts a blank <div> to prevent an empty gutter spot.\n     */\n    function _addDummyGutterMarkerIfNotExist(cm, line) {\n        var lineInfo = cm.lineInfo(line);\n        if (!lineInfo) {\n            return; // If line is out of range or doc is empty\n        }\n        var gutters = cm.getOption(\"gutters\").slice(0),\n            gutterEnabled = gutters.indexOf(gutterName);\n        if(gutterEnabled === -1){\n            return;\n        }\n        var gutterMarkers = lineInfo.gutterMarkers;\n        var existingMarker = gutterMarkers && gutterMarkers[gutterName];\n        if (!existingMarker) {\n            var dummy = document.createElement(\"div\");\n            dummy.className = \"CodeMirror-gitGutter-none\";\n            cm.setGutterMarker(line, gutterName, dummy);\n        }\n    }\n\n    function _cursorActivity(_evt, editor){\n        // this is to prevent a gutter gap in the active line if there is no color on this line.\n        if (editor.hasSelection()){\n            // we dont show the gutter gap color when there is a selection. also adding dummy gutter is expensive\n            // and make test selection with cursor choppy\n            return;\n        }\n        _addDummyGutterMarkerIfNotExist(editor._codeMirror, editor.getCursorPos().line);\n    }\n\n    EditorManager.on(\"activeEditorChange\", function (event, newEditor, oldEditor) {\n        if(newEditor){\n            newEditor.off(\"cursorActivity.gitGutter\");\n            newEditor.on(\"cursorActivity.gitGutter\", _cursorActivity);\n            _cursorActivity(null, newEditor);\n        }\n        if(oldEditor){\n            oldEditor.off(\"cursorActivity.gitGutter\");\n        }\n    });\n\n    function clearWidgets() {\n        var lines = openWidgets.map(function (mark) {\n            var w = mark.lineWidget;\n            if (w.visible) {\n                w.visible = false;\n                w.widget.clear();\n            }\n            return {\n                cm: mark.cm,\n                line: mark.line\n            };\n        });\n        openWidgets = [];\n        return lines;\n    }\n\n    function clearOld(editor) {\n        var cm = editor._codeMirror;\n        if (!cm) { return; }\n\n        var gutters = cm.getOption(\"gutters\").slice(0),\n            io = gutters.indexOf(gutterName);\n\n        if (io !== -1) {\n            gutters.splice(io, 1);\n            cm.clearGutter(gutterName);\n            cm.setOption(\"gutters\", gutters);\n            cm.off(\"gutterClick\", gutterClick);\n        }\n\n        delete cm.gitGutters;\n\n        clearWidgets();\n    }\n\n    function prepareGutter(editor) {\n        // add our gutter if its not already available\n        var cm = editor._codeMirror;\n\n        var gutters = cm.getOption(\"gutters\").slice(0);\n        if (gutters.indexOf(gutterName) === -1) {\n            gutters.unshift(gutterName);\n            cm.setOption(\"gutters\", gutters);\n            cm.on(\"gutterClick\", gutterClick);\n        }\n\n        if (editorsWithGutters.indexOf(editor) === -1) {\n            editorsWithGutters.push(editor);\n        }\n    }\n\n    function prepareGutters(editors) {\n        editors.forEach(function (editor) {\n            prepareGutter(editor);\n        });\n        // clear the rest\n        var idx = editorsWithGutters.length;\n        while (idx--) {\n            if (editors.indexOf(editorsWithGutters[idx]) === -1) {\n                clearOld(editorsWithGutters[idx]);\n                editorsWithGutters.splice(idx, 1);\n            }\n        }\n    }\n\n    function _showGutters(editor, _results) {\n        prepareGutter(editor);\n\n        var cm = editor._codeMirror;\n        cm.gitGutters = _.sortBy(_results, \"line\");\n\n        // get line numbers of currently opened widgets\n        var openBefore = clearWidgets();\n\n        cm.clearGutter(gutterName);\n        cm.gitGutters.forEach(function (obj) {\n            var $marker = $(\"<div>\")\n                .addClass(gutterName + \"-\" + obj.type + \" gitline-\" + (obj.line + 1))\n                .html(\"&nbsp;\");\n            cm.setGutterMarker(obj.line, gutterName, $marker[0]);\n        });\n        _cursorActivity(null, editor);\n        // reopen widgets that were opened before refresh\n        openBefore.forEach(function (obj) {\n            gutterClick(obj.cm, obj.line, gutterName);\n        });\n    }\n\n    function gutterClick(cm, lineIndex, gutterId) {\n        if (!cm) {\n            return;\n        }\n\n        if (gutterId !== gutterName && gutterId !== \"CodeMirror-linenumbers\") {\n            return;\n        }\n\n        var mark = _.find(cm.gitGutters, function (o) { return o.line === lineIndex; });\n        if (!mark || mark.type === \"added\") { return; }\n\n        // we need to be able to identify cm instance from any mark\n        mark.cm = cm;\n\n        if (mark.parentMark) { mark = mark.parentMark; }\n\n        if (!mark.lineWidget) {\n            mark.lineWidget = {\n                visible: false,\n                element: $(\"<div class='\" + gutterName + \"-deleted-lines'></div>\")\n            };\n            var $btn = $(\"<button/>\")\n                .addClass(\"brackets-git-gutter-copy-button\")\n                .text(\"R\")\n                .on(\"click\", function () {\n                    var doc = DocumentManager.getCurrentDocument();\n                    doc.replaceRange(mark.content + \"\\n\", {\n                        line: mark.line,\n                        ch: 0\n                    });\n                    CommandManager.execute(\"file.save\");\n                    refresh();\n                });\n            $(\"<pre/>\")\n                .attr(\"style\", \"tab-size:\" + cm.getOption(\"tabSize\"))\n                .text(mark.content || \" \")\n                .append($btn)\n                .appendTo(mark.lineWidget.element);\n        }\n\n        if (mark.lineWidget.visible !== true) {\n            mark.lineWidget.visible = true;\n            mark.lineWidget.widget = cm.addLineWidget(mark.line, mark.lineWidget.element[0], {\n                coverGutter: false,\n                noHScroll: false,\n                above: true,\n                showIfHidden: false\n            });\n            openWidgets.push(mark);\n        } else {\n            mark.lineWidget.visible = false;\n            mark.lineWidget.widget.clear();\n            var io = openWidgets.indexOf(mark);\n            if (io !== -1) {\n                openWidgets.splice(io, 1);\n            }\n        }\n    }\n\n    function getEditorFromPane(paneId) {\n        var currentPath = MainViewManager.getCurrentlyViewedPath(paneId),\n            doc = currentPath && DocumentManager.getOpenDocumentForPath(currentPath);\n        return doc && doc._masterEditor;\n    }\n\n    function hasVerticalScrollbar(editor) {\n        const cm = editor._codeMirror;\n        const scrollEl = cm.getScrollerElement();\n        return scrollEl.scrollHeight > scrollEl.clientHeight;\n    }\n\n\n    function _markScrollbar(editor, allChanges) {\n        ScrollTrackMarkers.clear(editor, GIT_SCROLL_MARKS);\n        if(!hasVerticalScrollbar(editor)){\n            return;\n        }\n        const added = allChanges\n            .filter(item => item.type === \"added\")\n            .map(({ line }) => ({ line, ch: 0 }));\n\n        const removed = allChanges\n            .filter(item => item.type === \"removed\")\n            .map(({ line }) => ({ line, ch: 0 }));\n\n        const modified = allChanges\n            .filter(item => item.type === \"modified\")\n            .map(({ line }) => ({ line, ch: 0 }));\n\n        const trackers = [\n            {arr: added, css: \"brackets-git-added\"},\n            {arr: removed, css: \"brackets-git-removed\"},\n            {arr: modified, css: \"brackets-git-modified\"}\n        ];\n        for(let tracker of trackers) {\n            if( !tracker.arr.length ){\n                continue;\n            }\n            let posArray = tracker.arr.map(item => ({ line: item.line, ch: 0 }));\n            ScrollTrackMarkers.addTickmarks(editor, posArray, {\n                trackStyle: ScrollTrackMarkers.TRACK_STYLES.ON_LEFT,\n                name: GIT_SCROLL_MARKS,\n                cssColorClass: tracker.css\n            });\n        }\n    }\n\n    function processDiffResults(editor, diff) {\n        var added = [],\n            removed = [],\n            modified = [],\n            changesets = diff.split(/\\n@@/).map(function (str) { return \"@@\" + str; });\n\n        // remove part before first\n        changesets.shift();\n\n        changesets.forEach(function (str) {\n            var m = str.match(/^@@ -([,0-9]+) \\+([,0-9]+) @@/);\n            var s1 = m[1].split(\",\");\n            var s2 = m[2].split(\",\");\n\n            // removed stuff\n            var lineRemovedFrom;\n            var lineFrom = parseInt(s2[0], 10);\n            var lineCount = parseInt(s1[1], 10);\n            if (isNaN(lineCount)) { lineCount = 1; }\n            if (lineCount > 0) {\n                lineRemovedFrom = lineFrom - 1;\n                removed.push({\n                    type: \"removed\",\n                    line: lineRemovedFrom,\n                    content: str.split(\"\\n\")\n                        .filter(function (l) { return l.indexOf(\"-\") === 0; })\n                        .map(function (l) { return l.substring(1); })\n                        .join(\"\\n\")\n                });\n            }\n\n            // added stuff\n            lineFrom = parseInt(s2[0], 10);\n            lineCount = parseInt(s2[1], 10);\n            if (isNaN(lineCount)) { lineCount = 1; }\n            var isModifiedMark = false;\n            var firstAddedMark = false;\n            for (var i = lineFrom, lineTo = lineFrom + lineCount; i < lineTo; i++) {\n                var lineNo = i - 1;\n                if (lineNo === lineRemovedFrom) {\n                    // modified\n                    var o = removed.pop();\n                    o.type = \"modified\";\n                    modified.push(o);\n                    isModifiedMark = o;\n                } else {\n                    var mark = {\n                        type: isModifiedMark ? \"modified\" : \"added\",\n                        line: lineNo,\n                        parentMark: isModifiedMark || firstAddedMark || null\n                    };\n                    if (!isModifiedMark && !firstAddedMark) {\n                        firstAddedMark = mark;\n                    }\n                    // added new\n                    added.push(mark);\n                }\n            }\n        });\n\n        // fix displaying of removed lines\n        removed.forEach(function (o) {\n            o.line = o.line + 1;\n        });\n\n        const allChanges = [].concat(added, removed, modified);\n        _showGutters(editor, allChanges);\n        _markScrollbar(editor, allChanges);\n    }\n\n    function refresh() {\n        if (!gitAvailable) {\n            return;\n        }\n\n        if (!Preferences.get(\"useGitGutter\")) {\n            return;\n        }\n\n        var currentGitRoot = Preferences.get(\"currentGitRoot\");\n\n        // we get a list of editors, which need to be refreshed\n        var editors = _.compact(_.map(MainViewManager.getPaneIdList(), function (paneId) {\n            return getEditorFromPane(paneId);\n        }));\n\n        // we create empty gutters in all of these editors, all other editors lose their gutters\n        prepareGutters(editors);\n\n        // now we launch a diff to fill the gutters in our editors\n        editors.forEach(function (editor) {\n\n            var currentFilePath = null;\n\n            if (editor.document && editor.document.file) {\n                currentFilePath = editor.document.file.fullPath;\n            }\n\n            if (currentFilePath.indexOf(currentGitRoot) !== 0) {\n                // file is not in the current project\n                return;\n            }\n\n            var filename = currentFilePath.substring(currentGitRoot.length);\n\n            Git.diffFile(filename).then(function (diff) {\n                processDiffResults(editor, diff);\n            }).catch(function (err) {\n                // if this is launched in a non-git repository, just ignore\n                if (ErrorHandler.contains(err, \"Not a git repository\")) {\n                    return;\n                }\n                // if this file was moved or deleted before this command could be executed, ignore\n                if (ErrorHandler.contains(err, \"No such file or directory\")) {\n                    return;\n                }\n                ErrorHandler.showError(err, Strings.ERROR_REFRESH_GUTTER);\n            });\n\n        });\n    }\n\n    function goToPrev() {\n        var activeEditor = EditorManager.getActiveEditor();\n        if (!activeEditor) { return; }\n\n        var results = activeEditor._codeMirror.gitGutters || [];\n        var searched = _.filter(results, function (i) { return !i.parentMark; });\n\n        var currentPos = activeEditor.getCursorPos();\n        var i = searched.length;\n        while (i--) {\n            if (searched[i].line < currentPos.line) {\n                break;\n            }\n        }\n        if (i > -1) {\n            var goToMark = searched[i];\n            activeEditor.setCursorPos(goToMark.line, currentPos.ch);\n        }\n    }\n\n    function goToNext() {\n        var activeEditor = EditorManager.getActiveEditor();\n        if (!activeEditor) { return; }\n\n        var results = activeEditor._codeMirror.gitGutters || [];\n        var searched = _.filter(results, function (i) { return !i.parentMark; });\n\n        var currentPos = activeEditor.getCursorPos();\n        for (var i = 0, l = searched.length; i < l; i++) {\n            if (searched[i].line > currentPos.line) {\n                break;\n            }\n        }\n        if (i < searched.length) {\n            var goToMark = searched[i];\n            activeEditor.setCursorPos(goToMark.line, currentPos.ch);\n        }\n    }\n\n    // Event handlers\n    EventEmitter.on(Events.GIT_ENABLED, function () {\n        gitAvailable = true;\n        refresh();\n    });\n    EventEmitter.on(Events.GIT_DISABLED, function () {\n        gitAvailable = false;\n        // calling this with an empty array will remove gutters from all editor instances\n        prepareGutters([]);\n    });\n    EventEmitter.on(Events.BRACKETS_CURRENT_DOCUMENT_CHANGE, function (file) {\n        // file will be null when switching to an empty pane\n        if (!file) { return; }\n\n        // document change gets launched even when switching panes,\n        // so we check if the file hasn't already got the gutters\n        var alreadyOpened = _.filter(editorsWithGutters, function (editor) {\n            return editor.document.file.fullPath === file.fullPath;\n        }).length > 0;\n\n        if (!alreadyOpened) {\n            // TODO: here we could sent a particular file to be refreshed only\n            refresh();\n        }\n    });\n    EventEmitter.on(Events.GIT_COMMITED, function () {\n        refresh();\n    });\n    EventEmitter.on(Events.BRACKETS_FILE_CHANGED, function (file) {\n        var alreadyOpened = _.filter(editorsWithGutters, function (editor) {\n            return editor.document.file.fullPath === file.fullPath;\n        }).length > 0;\n\n        if (alreadyOpened) {\n            // TODO: here we could sent a particular file to be refreshed only\n            refresh();\n        }\n    });\n\n    function init() {\n        const editor = EditorManager.getActiveEditor();\n        if(!editor){\n            return;\n        }\n        editor.off(\"cursorActivity.gitGutter\");\n        editor.on(\"cursorActivity.gitGutter\", _cursorActivity);\n        _cursorActivity(null, editor);\n    }\n\n    // API\n    exports.init = init;\n    exports.goToPrev = goToPrev;\n    exports.goToNext = goToNext;\n});\n"],"file":"GutterManager.js"}