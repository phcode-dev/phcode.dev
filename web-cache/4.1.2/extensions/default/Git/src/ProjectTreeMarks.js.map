{"version":3,"sources":["extensions/default/Git/src/ProjectTreeMarks.js"],"names":["define","require","_","brackets","getModule","FileSystem","ProjectManager","EventEmitter","Events","Git","Preferences","ignoreEntries","newPaths","modifiedPaths","get","addClassesProvider","data","fullPath","isIgnored","isNew","isModified","refreshOpenFiles","debounce","_refreshOpenFiles","on","BRACKETS_FILE_CHANGED","file","refreshIgnoreEntries","finally","GIT_STATUS_RESULTS","files","gitRoot","forEach","entry","status","indexOf","FILE_STATUS","UNTRACKED","ADDED","push","rerenderTree","GIT_ENABLED","attachEvents","GIT_DISABLED","detachEvents","loadIgnoreContents","Promise","resolve","excludeContents","gitignoreContents","finish","after","getFileForPath","read","err","content","regexEscape","str","replace","then","compact","map","split","line","type","leadingSlash","trailingSlash","regex","trim","slice","lastIndexOf","length","regexp","RegExp","path","ignored","test","$","find","each","$li","this","toggleClass","triggerHandler","off"],"mappings":"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","sourcesContent":["define(function (require) {\n\n    var _                 = brackets.getModule(\"thirdparty/lodash\"),\n        FileSystem        = brackets.getModule(\"filesystem/FileSystem\"),\n        ProjectManager    = brackets.getModule(\"project/ProjectManager\");\n\n    var EventEmitter      = require(\"src/EventEmitter\"),\n        Events            = require(\"src/Events\"),\n        Git               = require(\"src/git/Git\"),\n        Preferences       = require(\"src/Preferences\");\n\n    var ignoreEntries = [],\n        newPaths      = [],\n        modifiedPaths = [];\n\n    if (!Preferences.get(\"markModifiedInTree\")) {\n        // end here, no point in processing the code below\n        return;\n    }\n\n    function loadIgnoreContents() {\n        return new Promise((resolve)=>{\n            let gitRoot = Preferences.get(\"currentGitRoot\"),\n                excludeContents,\n                gitignoreContents;\n\n            const finish = _.after(2, function () {\n                resolve(excludeContents + \"\\n\" + gitignoreContents);\n            });\n\n            FileSystem.getFileForPath(gitRoot + \".git/info/exclude\").read(function (err, content) {\n                excludeContents = err ? \"\" : content;\n                finish();\n            });\n\n            FileSystem.getFileForPath(gitRoot + \".gitignore\").read(function (err, content) {\n                gitignoreContents = err ? \"\" : content;\n                finish();\n            });\n\n        });\n    }\n\n    function refreshIgnoreEntries() {\n        function regexEscape(str) {\n            // NOTE: We cannot use StringUtils.regexEscape() here because we don't wanna replace *\n            return str.replace(/([.?+\\^$\\\\(){}|])/g, \"\\\\$1\");\n        }\n\n        return loadIgnoreContents().then(function (content) {\n            var gitRoot = Preferences.get(\"currentGitRoot\");\n\n            ignoreEntries = _.compact(_.map(content.split(\"\\n\"), function (line) {\n                // Rules: http://git-scm.com/docs/gitignore\n                var type = \"deny\",\n                    leadingSlash,\n                    trailingSlash,\n                    regex;\n\n                line = line.trim();\n                if (!line || line.indexOf(\"#\") === 0) {\n                    return;\n                }\n\n                // handle explicitly allowed files/folders with a leading !\n                if (line.indexOf(\"!\") === 0) {\n                    line = line.slice(1);\n                    type = \"accept\";\n                }\n                // handle lines beginning with a backslash, which is used for escaping ! or #\n                if (line.indexOf(\"\\\\\") === 0) {\n                    line = line.slice(1);\n                }\n                // handle lines beginning with a slash, which only matches files/folders in the root dir\n                if (line.indexOf(\"/\") === 0) {\n                    line = line.slice(1);\n                    leadingSlash = true;\n                }\n                // handle lines ending with a slash, which only exludes dirs\n                if (line.lastIndexOf(\"/\") === line.length) {\n                    // a line ending with a slash ends with **\n                    line += \"**\";\n                    trailingSlash = true;\n                }\n\n                // NOTE: /(.{0,})/ is basically the same as /(.*)/, but we can't use it because the asterisk\n                // would be replaced later on\n\n                // create the intial regexp here. We need the absolute path 'cause it could be that there\n                // are external files with the same name as a project file\n                regex = regexEscape(gitRoot) + (leadingSlash ? \"\" : \"((.+)/)?\") + regexEscape(line) + (trailingSlash ? \"\" : \"(/.{0,})?\");\n                // replace all the possible asterisks\n                regex = regex.replace(/\\*\\*$/g, \"(.{0,})\").replace(/(\\*\\*|\\*$)/g, \"(.+)\").replace(/\\*/g, \"([^/]*)\");\n                regex = \"^\" + regex + \"$\";\n\n                return {\n                    regexp: new RegExp(regex),\n                    type: type\n                };\n            }));\n        });\n    }\n\n    function isIgnored(path) {\n        var ignored = false;\n        _.forEach(ignoreEntries, function (entry) {\n            if (entry.regexp.test(path)) {\n                ignored = (entry.type === \"deny\");\n            }\n        });\n        return ignored;\n    }\n\n    function isNew(fullPath) {\n        return newPaths.indexOf(fullPath) !== -1;\n    }\n\n    function isModified(fullPath) {\n        return modifiedPaths.indexOf(fullPath) !== -1;\n    }\n\n    ProjectManager.addClassesProvider(function (data) {\n        var fullPath = data.fullPath;\n        if (isIgnored(fullPath)) {\n            return \"git-ignored\";\n        } else if (isNew(fullPath)) {\n            return \"git-new\";\n        } else if (isModified(fullPath)) {\n            return \"git-modified\";\n        }\n    });\n\n    function _refreshOpenFiles() {\n        $(\"#working-set-list-container\").find(\"li\").each(function () {\n            var $li = $(this),\n                data = $li.data(\"file\");\n            if (data) {\n                var fullPath = data.fullPath;\n                $li.toggleClass(\"git-ignored\", isIgnored(fullPath))\n                   .toggleClass(\"git-new\", isNew(fullPath))\n                   .toggleClass(\"git-modified\", isModified(fullPath));\n            }\n        });\n    }\n\n    var refreshOpenFiles = _.debounce(function () {\n        _refreshOpenFiles();\n    }, 100);\n\n    function attachEvents() {\n        $(\"#working-set-list-container\").on(\"contentChanged\", refreshOpenFiles).triggerHandler(\"contentChanged\");\n    }\n\n    function detachEvents() {\n        $(\"#working-set-list-container\").off(\"contentChanged\", refreshOpenFiles);\n    }\n\n    // this will refresh ignore entries when .gitignore is modified\n    EventEmitter.on(Events.BRACKETS_FILE_CHANGED, function (file) {\n        if (file.fullPath === Preferences.get(\"currentGitRoot\") + \".gitignore\") {\n            refreshIgnoreEntries().finally(function () {\n                refreshOpenFiles();\n            });\n        }\n    });\n\n    // this will refresh new/modified paths on every status results\n    EventEmitter.on(Events.GIT_STATUS_RESULTS, function (files) {\n        var gitRoot = Preferences.get(\"currentGitRoot\");\n\n        newPaths = [];\n        modifiedPaths = [];\n\n        files.forEach(function (entry) {\n            var isNew = entry.status.indexOf(Git.FILE_STATUS.UNTRACKED) !== -1 ||\n                        entry.status.indexOf(Git.FILE_STATUS.ADDED) !== -1;\n\n            var fullPath = gitRoot + entry.file;\n            if (isNew) {\n                newPaths.push(fullPath);\n            } else {\n                modifiedPaths.push(fullPath);\n            }\n        });\n\n        ProjectManager.rerenderTree();\n        refreshOpenFiles();\n    });\n\n    // this will refresh ignore entries when git project is opened\n    EventEmitter.on(Events.GIT_ENABLED, function () {\n        refreshIgnoreEntries();\n        attachEvents();\n    });\n\n    // this will clear entries when non-git project is opened\n    EventEmitter.on(Events.GIT_DISABLED, function () {\n        ignoreEntries = [];\n        newPaths      = [];\n        modifiedPaths = [];\n        detachEvents();\n    });\n\n});\n"],"file":"ProjectTreeMarks.js"}