{"version":3,"sources":["extensions/default/DebugCommands/MacroRunner.js"],"names":["define","require","exports","module","FileViewController","brackets","getModule","CommandManager","EditorManager","KeyEvent","Commands","FileSystem","MainViewManager","FileUtils","PreferencesManager","Editor","Dialogs","_","ProjectManager","openFile","filePath","startsWith","jsPromise","openFileAndAddToWorkingSet","projectFilePath","path","join","getProjectRoot","fullPath","readTextFile","bypassCache","file","getFileForPath","readAsText","writeTextFile","text","allowBlindWrite","writeText","deletePath","Promise","resolve","reject","window","fs","unlink","err","setCursors","selections","activeEditor","getActiveEditor","Error","parsedSelections","map","selection","parts","split","length","line","ch","Number","isNaN","start","end","fromLine","fromCh","toLine","toCh","setSelections","computeCursors","editor","addQuotes","getSelections","cursor","expectCursorsToBe","expectedSelections","currentSelections","i","includes","raiseKeyEvent","key","event","element","options","doc","ownerDocument","view","defaultView","bubbles","cancelable","keyIdentifer","keyIdentifier","oEvent","KeyboardEvent","Object","defineProperty","get","this","keyCodeVal","keyCode","console","log","dispatchEvent","keydown","keysArray","modifiers","document","activeElement","typeAtCursor","origin","replaceRange","_toPos","posString","pos","validateText","from","to","selectedText","getTextBetween","_getMarkLocations","markType","whichAPI","marks","getAllMarks","marksLocations","mark","loc","find","push","validateAllMarks","validateEqual","obj1","obj2","message","isEqual","JSON","stringify","validateNotEqual","validateMarks","totalMarkCount","undefined","closeFile","execute","FILE_CLOSE","_forceClose","closeAll","FILE_CLOSE_ALL","execCommand","commandID","arg","undo","EDIT_UNDO","redo","EDIT_REDO","setPreference","value","set","getPreference","_getFullPath","EDITING","setEditorSpacing","useTabs","spaceOrTabCount","isAutoMode","getAutoTabSpaces","setAutoTabSpaces","_autoDetectTabSpaces","setUseTabChar","setTabSize","setSpaceUnits","splitVertical","CMD_SPLITVIEW_VERTICAL","splitHorizontal","CMD_SPLITVIEW_HORIZONTAL","splitNone","CMD_SPLITVIEW_NONE","getFirstPaneEditor","getCurrentlyViewedEditor","getSecondPaneEditor","isSplit","getPaneCount","openFileInFirstPane","addToWorkingSet","command","CMD_ADD_TO_WORKINGSET_AND_OPEN","FILE_OPEN","paneId","openFileInSecondPane","focusFirstPane","setActivePaneId","focusSecondPane","awaitsFor","pollFn","_timeoutMessageOrMessageFn","timeoutms","pollInterval","async","_getExpectMessage","e","stack","_timeoutPromise","promise","ms","timeout","setTimeout","race","startTime","Date","now","lapsedTime","pollingFn","result","prototype","toString","call","waitForModalDialog","dialogClass","friendlyName","$dlg","$","waitForModalDialogClosed","_clickDialogButtonWithSelector","selectorOrButtonID","isButtonID","$button","prop","click","clickDialogButtonID","buttonID","clickDialogButton","buttonSelector","saveActiveFile","FILE_SAVE","__PR","runMacro","macroText","errors","AsyncFunction","constructor","macroAsync","error","lineNo","errorCode","errorText","Phoenix","isTestWindow"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*global path, jsPromise*/\n\n/**\n *  Utilities functions for running macros.\n *  Eg:\n *  await __PR.openFile(\"a.html\");\n *   __PR.setCursors([\"17:28\", \"17:28-17:30\"])\n * __PR.expectCursorsToBe([\"17:28\", \"17:28-17:30\"])\n * __PR.keydown([\"BACK_SPACE\"])\n * __PR.typeAtCursor(\"hello\")\n * __PR.validateText(`a`, \"16:14-16:15\")\n * __PR.validateAllMarks(\"startTagSyncEdit\", [\"16:14-16:15\"]); // All marks of type startTagSyncEdit should be there\n * __PR.validateMarks(\"startTagSyncEdit\", [\"16:14-16:15\"], 1); // 1 is total marks of type startTagSyncEdit\n *\n *  This can be later extended to run macros. But since this uses eval, the\n *  security posture must be changed. One way is to:\n *  1. create an iframe that contains the macro panel and codemirror surface in a sandboxed or 3rd party context. This\n *     will create origin isolation in browser so that extensions cannot read or write to the ifrmae macro code.\n *  2. The iframe should be created in an extensions and once created, only that iframe should be tested to run evaled\n *     code. So the iframe will post message with code to eval and we will only eval that.\n *  3. The iframe can request to save data to eval which we need to carefully handle.\n *  4. Now this is a problem only when we securely sandbox extensions in the future, as for now an extension can run\n *     eval itself and pretty much all of this is no-op till we have extension sandbox. So this is not the security\n *     model now.\n */\ndefine(function (require, exports, module) {\n    const FileViewController = brackets.getModule(\"project/FileViewController\"),\n        CommandManager = brackets.getModule(\"command/CommandManager\"),\n        EditorManager = brackets.getModule(\"editor/EditorManager\"),\n        KeyEvent = brackets.getModule(\"utils/KeyEvent\"),\n        Commands = brackets.getModule(\"command/Commands\"),\n        FileSystem = brackets.getModule(\"filesystem/FileSystem\"),\n        MainViewManager = brackets.getModule(\"view/MainViewManager\"),\n        FileUtils   = brackets.getModule(\"file/FileUtils\"),\n        PreferencesManager  = brackets.getModule(\"preferences/PreferencesManager\"),\n        Editor = brackets.getModule(\"editor/Editor\"),\n        Dialogs = brackets.getModule(\"widgets/Dialogs\"),\n        _ = brackets.getModule(\"thirdparty/lodash\"),\n        ProjectManager = brackets.getModule(\"project/ProjectManager\");\n\n    /**\n     * Open a project relative file or absolute file path. if no leading slash, path is assumed to be project relative\n     * @param filePath\n     * @returns {Promise<null>}\n     */\n    function openFile(filePath) {\n        if(filePath.startsWith('/')) {\n            return jsPromise(FileViewController.openFileAndAddToWorkingSet(filePath));\n        }\n        const projectFilePath = path.join(ProjectManager.getProjectRoot().fullPath, filePath);\n        return jsPromise(FileViewController.openFileAndAddToWorkingSet(projectFilePath));\n    }\n\n    /**\n     * Reads a text file and returns a promise that resolves to the text\n     * @param filePath - project relative or full path\n     * @param {boolean?} bypassCache - an optional argument, if specified will read from disc instead of using cache.\n     * @returns {Promise<String>}\n     */\n    function readTextFile(filePath, bypassCache) {\n        if(!filePath.startsWith('/')) {\n            filePath = path.join(ProjectManager.getProjectRoot().fullPath, filePath);\n        }\n        const file = FileSystem.getFileForPath(filePath);\n        return jsPromise(FileUtils.readAsText(file, bypassCache));\n    }\n\n    /**\n     * Asynchronously writes a file as UTF-8 encoded text.\n     * @param filePath - project relative or full path\n     * @param {String} text\n     * @param {boolean} allowBlindWrite Indicates whether or not CONTENTS_MODIFIED\n     *      errors---which can be triggered if the actual file contents differ from\n     *      the FileSystem's last-known contents---should be ignored.\n     * @return {Promise<null>} promise that will be resolved when\n     * file writing completes, or rejected with a FileSystemError string constant.\n     */\n    function writeTextFile(filePath, text, allowBlindWrite) {\n        if(!filePath.startsWith('/')) {\n            filePath = path.join(ProjectManager.getProjectRoot().fullPath, filePath);\n        }\n        const file = FileSystem.getFileForPath(filePath);\n        return jsPromise(FileUtils.writeText(file, text, allowBlindWrite));\n    }\n\n    /**\n     * deletes a file or dir at given path\n     * @param filePath - project relative or full path\n     * @return {Promise<null>} promise that will be resolved when path removed\n     */\n    function deletePath(filePath) {\n        if(!filePath.startsWith('/')) {\n            filePath = path.join(ProjectManager.getProjectRoot().fullPath, filePath);\n        }\n        return new Promise((resolve, reject) => {\n            window.fs.unlink(filePath, (err)=>{\n                if (err) {\n                    reject(err);\n                    return;\n                }\n                resolve();\n            });\n        });\n    }\n\n\n    /**\n     * Set cursor positions or text selections in the active CodeMirror editor based on a specified format.\n     * The input should be an array of strings where each string can denote a cursor position (\"line:char\")\n     * or a text selection range (\"line:char-line:char\"). For a selection, the first part is the anchor and\n     * the second is the head of the selection.\n     *\n     * Example usage: [\"1:2\", \"2:2-3:4\"]\n     *\n     * @param {Array<string>} selections - An array of strings defining cursor positions or selection ranges.\n     * @throws {Error} Throws an error if no active editor is found or if there are parsing issues with the input.\n     */\n    function setCursors(selections) {\n        const activeEditor = EditorManager.getActiveEditor();\n        if(!activeEditor){\n            throw new Error(`No active editor found to set cursor at: ${selections}`);\n        }\n        // Parse the selection strings to CodeMirror positions\n        const parsedSelections = selections.map(selection => {\n            const parts = selection.split('-');\n            if (parts.length === 1) {\n                const [line, ch] = parts[0].split(':').map(Number);\n                if (isNaN(line) || isNaN(ch)) {\n                    throw new Error(`Invalid cursor format: ${parts[0]} for ${selections}`);\n                }\n                return {start: {line: line - 1, ch: ch - 1}, end: {line: line - 1, ch: ch - 1}};\n            } else if (parts.length === 2) {\n                const [fromLine, fromCh] = parts[0].split(':').map(Number);\n                const [toLine, toCh] = parts[1].split(':').map(Number);\n                if (isNaN(fromLine) || isNaN(fromCh) || isNaN(toLine) || isNaN(toCh)) {\n                    throw new Error(`Invalid selection range format: ${selection}`);\n                }\n                return {start: {line: fromLine - 1, ch: fromCh -1}, end: {line: toLine - 1, ch: toCh - 1}};\n            } else {\n                throw new Error(`Invalid format: ${selection}`);\n            }\n        });\n\n        // Set the selections in the editor\n        activeEditor.setSelections(parsedSelections);\n    }\n\n    /**\n     * gets cursor selections array that can be used in the setCursors API\n     * @param editor\n     * @returns {*}\n     */\n    function computeCursors(editor, addQuotes) {\n        const selections = editor.getSelections();\n        return selections.map(selection => {\n            const start = selection.start;\n            const end = selection.end;\n            let cursor;\n\n            // Check if the selection is a cursor (start and end are the same)\n            if (start.line === end.line && start.ch === end.ch) {\n                cursor = `${start.line + 1}:${start.ch + 1}`;\n            } else {\n                cursor = `${start.line + 1}:${start.ch + 1}-${end.line + 1}:${end.ch + 1}`;\n            }\n            return addQuotes ? `\"${cursor}\"` : cursor;\n        });\n    }\n\n    /**\n     * Validates the currently active editor has selections as given here\n     */\n    function expectCursorsToBe(expectedSelections) {\n        const activeEditor = EditorManager.getActiveEditor();\n        if(!activeEditor){\n            throw new Error(`No active editor found for expectCursorsToBe: ${expectedSelections}`);\n        }\n        const currentSelections = computeCursors(activeEditor);\n        if(currentSelections.length !== expectedSelections.length) {\n            throw new Error(`expectCursorsToBe: [${expectedSelections.join(\", \")}] `+\n             `but got [${currentSelections.join(\", \")}]`);\n        }\n        for(let i = 0; i < currentSelections.length; i++) {\n            if(!currentSelections.includes(`${expectedSelections[i]}`) ||\n                !expectedSelections.includes(currentSelections[i])){\n                throw new Error(`expectCursorsToBe: [${expectedSelections.join(\", \")}] `+\n                    `but got [${currentSelections.join(\", \")}]`);\n            }\n        }\n    }\n\n    /**\n     * Simulate a key event.\n     * @param {Number} key Key code available as One of the KeyEvent.DOM_VK_*\n     * @param {String} event Key event to simulate. one of keydown, keyup or keypress\n     * @param {HTMLElement} element Element to receive event\n     * @param {KeyboardEventInit} options Optional arguments for key event\n     */\n    function raiseKeyEvent(key, event, element, options) {\n        const doc = element.ownerDocument;\n\n        if(typeof options === 'undefined') {\n            options = {\n                view: doc.defaultView,\n                bubbles: true,\n                cancelable: true,\n                keyIdentifer: key\n            };\n        } else {\n            options.view = doc.defaultView;\n            options.bubbles = true;\n            options.cancelable = true;\n            options.keyIdentifier = key;\n        }\n        const oEvent = new KeyboardEvent(event, options);\n\n        if (event !== \"keydown\" && event !== \"keyup\" && event !== \"keypress\") {\n            console.log(\"SpecRunnerUtils.simulateKeyEvent() - unsupported keyevent: \" + event);\n            return;\n        }\n\n        // Chromium Hack: need to override the 'which' property.\n        // Note: this code is not designed to work in IE, Safari,\n        // or other browsers. Well, maybe with Firefox. YMMV.\n        Object.defineProperty(oEvent, 'keyCode', {\n            get: function () {\n                return this.keyCodeVal;\n            }\n        });\n        Object.defineProperty(oEvent, 'which', {\n            get: function () {\n                return this.keyCodeVal;\n            }\n        });\n        Object.defineProperty(oEvent, 'charCode', {\n            get: function () {\n                return this.keyCodeVal;\n            }\n        });\n\n        oEvent.keyCodeVal = key;\n        if (oEvent.keyCode !== key) {\n            console.log(\"SpecRunnerUtils.simulateKeyEvent() - keyCode mismatch: \" + oEvent.keyCode);\n        }\n\n        element.dispatchEvent(oEvent);\n    }\n\n    /**\n     * @param {Array<string>} keysArray An array of Key strings available as One of the KeyEvent.DOM_VK_* without the\n     *    `KeyEvent.DOM_VK_` prefix. Eg: use `[\"ESCAPE\"]` instead of fully specifying [`DOM_VK_ESCAPE`]\n     *    E.g: __PR.keydown([\"BACK_SPACE\"]) or __PR.keydown([\"BACK_SPACE\"], {ctrlKey: true})\n     * @param {object} modifiers to modify the key\n     * @param {boolean} modifiers.ctrlKey\n     * @param {boolean} modifiers.altKey\n     * @param {boolean} modifiers.shiftKey\n     * @param {boolean} modifiers.metaKey\n     * @param keysArray\n     */\n    function keydown(keysArray, modifiers) {\n        for(let key of keysArray) {\n            if(typeof key === \"string\"){\n                if(!key.startsWith(\"DOM_VK_\")){\n                    key = \"DOM_VK_\"+key;\n                }\n                key = KeyEvent[key];\n                if(!key){\n                    throw new Error(`Invalid key \"${key}\"`);\n                }\n            }\n            raiseKeyEvent(key, \"keydown\", document.activeElement, modifiers);\n        }\n    }\n\n    function typeAtCursor(text, origin) {\n        const activeEditor = EditorManager.getActiveEditor();\n        if(!activeEditor){\n            throw new Error(`No active editor found to typeAtCursor: ${text}`);\n        }\n        const selections = activeEditor.getSelections();\n        // Insert text at each cursor or the head of each selection.\n        // We perform the insertions in reverse order to avoid affecting the indices of subsequent insertions.\n        for (let selection of selections) {\n            activeEditor.replaceRange(text, selection.start, selection.end, origin);\n        }\n    }\n\n    // converts string of from \"ln:ch\" to pos object\n    function _toPos(posString) {\n        const pos = posString.split(\":\");\n        return {line: Number(pos[0]) - 1, ch: Number(pos[1]) - 1 };\n    }\n\n    /**\n     * Verify if the given text is same as what is in between the given selection.\n     * @param {string} text\n     * @param {string} selection of the form \"ln:ch-ln:ch\"\n     */\n    function validateText(text, selection) {\n        const activeEditor = EditorManager.getActiveEditor();\n        if(!activeEditor){\n            throw new Error(`No active editor found to validateText: ${text} at selection ${selection}`);\n        }\n        const from = selection.split(\"-\")[0], to = selection.split(\"-\")[1];\n        const selectedText = activeEditor.getTextBetween(_toPos(from), _toPos(to));\n        if(selectedText !== text){\n            throw new Error(`validateText: expected text at [${selection}] to be \"${text}\" but got \"${selectedText}\"`);\n        }\n    }\n\n    function _getMarkLocations(markType, whichAPI, selections) {\n        const activeEditor = EditorManager.getActiveEditor();\n        if(!activeEditor){\n            throw new Error(`No active editor found to ${whichAPI}: \"${markType}\" for selection \"${selections}\"`);\n        }\n        const marks = activeEditor.getAllMarks(markType);\n        const marksLocations = [];\n        for(let mark of marks){\n            const loc = mark.find();\n            marksLocations.push(`${loc.from.line+1}:${loc.from.ch+1}-${loc.to.line+1}:${loc.to.ch+1}`);\n        }\n        return marksLocations;\n    }\n\n    /**\n     * validates all marks of the given mark type\n     * @param {string} markType\n     * @param {Array<string>} selections - An array of strings defining cursor positions or selection ranges.\n     */\n    function validateAllMarks(markType, selections) {\n        const marksLocations = _getMarkLocations(markType, \"validateAllMarks\", selections);\n        if(!selections || marksLocations.length !== selections.length){\n            throw new Error(`validateAllMarks expected marks \"${markType}\" at: [${selections&&selections.join(\", \")}] `+\n                `but got marked locations [${marksLocations.join(\", \")}]`);\n        }\n        for(let i = 0; i < selections.length; i++) {\n            if(!selections.includes(`${marksLocations[i]}`) ||\n                !marksLocations.includes(selections[i])){\n                throw new Error(`validateAllMarks expected marks \"${markType}\" at: [${selections.join(\", \")}] `+\n                    `but got marked locations [${marksLocations.join(\", \")}]`);\n            }\n        }\n    }\n\n    function validateEqual(obj1, obj2, message = \"\") {\n        if(!_.isEqual(obj1, obj2)){\n            throw new Error(`validateEqual: ${ message ? message + \"\\n\" : \"\"\n            } expected ${JSON.stringify(obj1)} to equal ${JSON.stringify(obj2)}`);\n        }\n    }\n\n    function validateNotEqual(obj1, obj2) {\n        if(_.isEqual(obj1, obj2)){\n            throw new Error(`validateEqual: expected ${JSON.stringify(obj1)} to NOT equal ${JSON.stringify(obj2)}`);\n        }\n    }\n\n    /**\n     * validates if the given mark type is present in the specified selections\n     * @param {string} markType\n     * @param {Array<string>} selections - An array of strings defining cursor positions or selection ranges.\n     * @param {number} [totalMarkCount] optional to validate against the total number of expected marks of the type\n     */\n    function validateMarks(markType, selections, totalMarkCount) {\n        const marksLocations = _getMarkLocations(markType, \"validateMarks\", selections);\n        if(!selections){\n            return;\n        }\n        if(totalMarkCount !== undefined && marksLocations.length !== totalMarkCount){\n            throw new Error(`validateMarks expected mark count for \"${markType}\" to be: ${totalMarkCount} `+\n                `but got ${marksLocations.length}`);\n        }\n        for(let selection of selections) {\n            if(!marksLocations.includes(selection)){\n                throw new Error(`validateMarks expected marks \"${markType}\" to be at: [${selections.join(\", \")}] `+\n                    `but got marked locations [${marksLocations.join(\", \")}]`);\n            }\n        }\n    }\n\n    function closeFile() {\n        return jsPromise(CommandManager.execute(Commands.FILE_CLOSE, { _forceClose: true }));\n    }\n\n    function closeAll() {\n        return jsPromise(CommandManager.execute(Commands.FILE_CLOSE_ALL, { _forceClose: true }));\n    }\n\n    function execCommand(commandID, arg) {\n        return jsPromise(CommandManager.execute(commandID, arg));\n    }\n\n    function undo() {\n        return execCommand(Commands.EDIT_UNDO);\n    }\n\n    function redo() {\n        return execCommand(Commands.EDIT_REDO);\n    }\n\n    function setPreference(key, value){\n        PreferencesManager.set(key, value);\n    }\n\n    function getPreference(key){\n        return PreferencesManager.get(key);\n    }\n\n    // Helper function to get full path (reusing existing openFile logic)\n    function _getFullPath(filePath) {\n        if(filePath.startsWith('/')) {\n            return filePath;\n        }\n        return path.join(ProjectManager.getProjectRoot().fullPath, filePath);\n    }\n\n    const EDITING = {\n        setEditorSpacing: function (useTabs, spaceOrTabCount, isAutoMode) {\n            const activeEditor = EditorManager.getActiveEditor();\n            if(!activeEditor){\n                throw new Error(`No active editor found to setEditorSpacing`);\n            }\n            const fullPath = activeEditor.document.file.fullPath;\n            if(Editor.Editor.getAutoTabSpaces(fullPath) !== isAutoMode){\n                Editor.Editor.setAutoTabSpaces(isAutoMode, fullPath);\n                isAutoMode && Editor.Editor._autoDetectTabSpaces(activeEditor, true, true);\n            }\n            Editor.Editor.setUseTabChar(useTabs, fullPath);\n            if(useTabs) {\n                Editor.Editor.setTabSize(spaceOrTabCount, fullPath);\n            } else {\n                Editor.Editor.setSpaceUnits(spaceOrTabCount, fullPath);\n            }\n        },\n        /**\n         * Split the editor pane vertically\n         */\n        splitVertical: function() {\n            CommandManager.execute(Commands.CMD_SPLITVIEW_VERTICAL);\n        },\n\n        /**\n         * Split the editor pane horizontally\n         */\n        splitHorizontal: function() {\n            CommandManager.execute(Commands.CMD_SPLITVIEW_HORIZONTAL);\n        },\n\n        /**\n         * Remove split pane and return to single pane view\n         */\n        splitNone: function() {\n            CommandManager.execute(Commands.CMD_SPLITVIEW_NONE);\n        },\n        /**\n         * Gets the editor in the first pane (left/top)\n         * @return {?Editor} The editor in first pane or null if not available\n         */\n        getFirstPaneEditor: function() {\n            return MainViewManager.getCurrentlyViewedEditor(\"first-pane\");\n        },\n\n        /**\n         * Gets the editor in the second pane (right/bottom)\n         * @return {?Editor} The editor in second pane or null if not available\n         */\n        getSecondPaneEditor: function() {\n            return MainViewManager.getCurrentlyViewedEditor(\"second-pane\");\n        },\n\n        /**\n         * Checks if the view is currently split\n         * @return {boolean} True if view is split, false otherwise\n         */\n        isSplit: function() {\n            return MainViewManager.getPaneCount() > 1;\n        },\n        /**\n         * Opens a file in the first pane (left/top)\n         * @param {string} filePath - Project relative or absolute file path\n         * @param {boolean} [addToWorkingSet] - true to add to working set\n         * @returns {Promise} A promise that resolves when the file is opened\n         */\n        openFileInFirstPane: function(filePath, addToWorkingSet) {\n            const command = addToWorkingSet ? Commands.CMD_ADD_TO_WORKINGSET_AND_OPEN : Commands.FILE_OPEN;\n            return jsPromise(CommandManager.execute(command, {\n                fullPath: _getFullPath(filePath),\n                paneId: \"first-pane\"\n            }));\n        },\n\n        /**\n         * Opens a file in the second pane (right/bottom)\n         * @param {string} filePath - Project relative or absolute file path\n         * @param {boolean} addToWorkingSet - true to add to working set\n         * @returns {Promise} A promise that resolves when the file is opened\n         */\n        openFileInSecondPane: function(filePath, addToWorkingSet) {\n            const command = addToWorkingSet ? Commands.CMD_ADD_TO_WORKINGSET_AND_OPEN : Commands.FILE_OPEN;\n            return jsPromise(CommandManager.execute(command, {\n                fullPath: _getFullPath(filePath),\n                paneId: \"second-pane\"\n            }));\n        },\n        /**\n         * Focus the first pane (left/top)\n         */\n        focusFirstPane: function() {\n            MainViewManager.setActivePaneId(\"first-pane\");\n        },\n\n        /**\n         * Focus the second pane (right/bottom)\n         */\n        focusSecondPane: function() {\n            MainViewManager.setActivePaneId(\"second-pane\");\n        }\n    };\n\n    /**\n     * Waits for a polling function to succeed or until a timeout is reached.\n     * The polling function is periodically invoked to check for success, and\n     * the function rejects with a timeout message if the timeout duration elapses.\n     *\n     * @param {function} pollFn - A function that returns `true` or a promise resolving to `true`/`false`\n     *                            to indicate success and stop waiting.\n     *                            The function will be called repeatedly until it succeeds or times out.\n     * @param {string|function} _timeoutMessageOrMessageFn - A helpful string message or an async function\n     *                                                       that returns a string message to reject with in case of timeout.\n     *                                                       Example:\n     *                                                       - String: \"Condition not met within the allowed time.\"\n     *                                                       - Function: `async () => \"Timeout while waiting for the process to complete.\"`\n     * @param {number} [timeoutms=2000] - The maximum time to wait in milliseconds before timing out. Defaults to 2 seconds.\n     * @param {number} [pollInterval=10] - The interval in milliseconds at which `pollFn` is invoked. Defaults to 10ms.\n     * @returns {Promise<void>} A promise that resolves when `pollFn` succeeds or rejects with a timeout message.\n     *\n     * @throws {Error} If `timeoutms` or `pollInterval` is not a number.\n     *\n     * @example\n     * // Example 1: Using a string as the timeout message\n     * awaitsFor(\n     *   () => document.getElementById(\"element\") !== null,\n     *   \"Element did not appear within the allowed time.\",\n     *   5000,\n     *   100\n     * ).then(() => {\n     *   console.log(\"Element appeared!\");\n     * }).catch(err => {\n     *   console.error(err.message);\n     * });\n     *\n     * @example\n     * // Example 2: Using a function as the timeout message\n     * awaitsFor(\n     *  () => document.getElementById(\"element\") !== null,\n     *   async () => {\n     *     const el = document.getElementById(\"element\");\n     *     return `expected ${el} to be null`;\n     *   },\n     *   10000,\n     *   500\n     * ).then(() => {\n     *   console.log(\"Element appeared!\");\n     * }).catch(err => {\n     *   console.error(err.message);\n     * });\n     */\n    function awaitsFor(pollFn, _timeoutMessageOrMessageFn, timeoutms = 2000, pollInterval = 10){\n        if(typeof  _timeoutMessageOrMessageFn === \"number\"){\n            timeoutms = _timeoutMessageOrMessageFn;\n            pollInterval = timeoutms;\n        }\n        if(!(typeof  timeoutms === \"number\" && typeof  pollInterval === \"number\")){\n            throw new Error(\"awaitsFor: invalid parameters when awaiting for \" + _timeoutMessageOrMessageFn);\n        }\n\n        async function _getExpectMessage(_timeoutMessageOrMessageFn) {\n            try{\n                if(typeof _timeoutMessageOrMessageFn === \"function\") {\n                    _timeoutMessageOrMessageFn = _timeoutMessageOrMessageFn();\n                    if(_timeoutMessageOrMessageFn instanceof Promise){\n                        _timeoutMessageOrMessageFn = await _timeoutMessageOrMessageFn;\n                    }\n                }\n            } catch (e) {\n                _timeoutMessageOrMessageFn = \"Error executing expected message function:\" + e.stack;\n            }\n            return _timeoutMessageOrMessageFn;\n        }\n\n        function _timeoutPromise(promise, ms) {\n            const timeout = new Promise((_, reject) => {\n                setTimeout(async () => {\n                    _timeoutMessageOrMessageFn = await _getExpectMessage(_timeoutMessageOrMessageFn);\n                    reject(new Error(_timeoutMessageOrMessageFn || `Promise timed out after ${ms}ms`));\n                }, ms);\n            });\n\n            return Promise.race([promise, timeout]);\n        }\n\n        return new Promise((resolve, reject)=>{\n            let startTime = Date.now(),\n                lapsedTime;\n            async function pollingFn() {\n                try{\n                    let result = pollFn();\n\n                    // If pollFn returns a promise, await it\n                    if (Object.prototype.toString.call(result) === \"[object Promise]\") {\n                        // we cant simply check for result instanceof Promise as the Promise may be returned from\n                        // an iframe and iframe has a different instance of Promise than this js context.\n                        result = await _timeoutPromise(result, timeoutms);\n                    }\n\n                    if (result) {\n                        resolve();\n                        return;\n                    }\n                    lapsedTime = Date.now() - startTime;\n                    if(lapsedTime>timeoutms){\n                        _timeoutMessageOrMessageFn = await _getExpectMessage(_timeoutMessageOrMessageFn);\n                        reject(\"awaitsFor timed out waiting for - \" + _timeoutMessageOrMessageFn);\n                        return;\n                    }\n                    setTimeout(pollingFn, pollInterval);\n                } catch (e) {\n                    reject(e);\n                }\n            }\n            pollingFn();\n        });\n    }\n\n    async function waitForModalDialog(dialogClass, friendlyName, timeout = 2000) {\n        dialogClass = dialogClass || \"\";\n        friendlyName = friendlyName || dialogClass || \"Modal Dialog\";\n        await awaitsFor(()=>{\n            let $dlg = $(`.modal.instance${dialogClass}`);\n            return $dlg.length >= 1;\n        }, `Waiting for Modal Dialog to show ${friendlyName}`, timeout);\n    }\n\n    async function waitForModalDialogClosed(dialogClass, friendlyName, timeout = 2000) {\n        dialogClass = dialogClass || \"\";\n        friendlyName = friendlyName || dialogClass || \"Modal Dialog\";\n        await awaitsFor(()=>{\n            let $dlg = $(`.modal.instance${dialogClass}`);\n            return $dlg.length === 0;\n        }, `Waiting for Modal Dialog to not there ${friendlyName}`, timeout);\n    }\n\n    /** Clicks on a button within a specified dialog.\n     * This function identifies a dialog using its class and locates a button either by its selector or button ID.\n     * Validation to ensure the dialog and button exist and that the button is enabled before attempting to click.\n     *\n     * @param {string} selectorOrButtonID - The selector or button ID to identify the button to be clicked.\n     *                                       Example (as selector): \".my-button-class\".\n     *                                       Example (as button ID): \"ok\".\n     * @param {string} dialogClass - The class of the dialog (optional). If omitted, defaults to an empty string.\n     *                               Example: \"my-dialog-class\".\n     * @param {boolean} isButtonID - If `true`, `selectorOrButtonid` is treated as a button ID.\n     *                                If `false`, it is treated as a jQuery selector. Default is `false`.\n     *\n     * @throws {Error} Throws an error if:\n     *   - The specified dialog does not exist.\n     *   - Multiple buttons match the given selector or ID.\n     *   - No button matches the given selector or ID.\n     *   - The button is disabled and cannot be clicked.\n     *\n     */\n    function _clickDialogButtonWithSelector(selectorOrButtonID, dialogClass, isButtonID) {\n        dialogClass = dialogClass || \"\";\n        const $dlg = $(`.modal.instance${dialogClass}`);\n\n        if(!$dlg.length){\n            throw new Error(`No such dialog present: \"${dialogClass}\"`);\n        }\n\n        const $button = isButtonID ?\n            $dlg.find(\".dialog-button[data-button-id='\" + selectorOrButtonID + \"']\") :\n            $dlg.find(selectorOrButtonID);\n        if($button.length > 1){\n            throw new Error(`Multiple button in dialog \"${selectorOrButtonID}\"`);\n        } else if(!$button.length){\n            throw new Error(`No such button in dialog \"${selectorOrButtonID}\"`);\n        }\n\n        if($button.prop(\"disabled\")) {\n            throw new Error(`Cannot click, button is disabled. \"${selectorOrButtonID}\"`);\n        }\n\n        $button.click();\n    }\n\n    /**\n     * Clicks on a button within a specified dialog using its button ID.\n     *\n     * @param {string} buttonID - The unique ID of the button to be clicked. usually One of the\n     *                            __PR.Dialogs.DIALOG_BTN_* symbolic constants or a custom id. You can find the button\n     *                            id in the dialog by inspecting the button and checking its `data-button-id` attribute\n     *                            Example: __PR.Dialogs.DIALOG_BTN_OK.\n     * @param {string} [dialogClass] - The class of the dialog containing the button. Optional, if only one dialog\n     *                               is present, you can omit this.\n     *                               Example: \"my-dialog-class\".\n     * @throws {Error} Throws an error if:\n     *   - The specified dialog does not exist.\n     *   - No button matches the given button ID.\n     *   - Multiple buttons match the given button ID.\n     *   - The button is disabled and cannot be clicked.\n     *\n     * @example\n     * // Example: Click a button by its ID\n     * __PR.clickDialogButtonID(__PR.Dialogs.DIALOG_BTN_OK, \"my-dialog-class\");\n     * __PR.clickDialogButtonID(__PR.Dialogs.DIALOG_BTN_OK); // if only 1 dialog is present, can omit the dialog class\n     * __PR.clickDialogButtonID(\"customBtnID\", \"my-dialog-class\");\n     */\n    function clickDialogButtonID(buttonID, dialogClass) {\n        _clickDialogButtonWithSelector(buttonID, dialogClass, true);\n    }\n\n    /**\n     * Clicks on a button within a specified dialog using a selector.\n     *\n     * @param {string} buttonSelector - A jQuery selector to identify the button to be clicked.\n     *                                   Example: \".showImageBtn\".\n     * @param {string} [dialogClass] - The class of the dialog containing the button. Optional, if only one dialog\n     *                               is present, you can omit this.\n     *                               Example: \"my-dialog-class\".\n     * @throws {Error} Throws an error if:\n     *   - The specified dialog does not exist.\n     *   - No button matches the given selector.\n     *   - Multiple buttons match the given selector.\n     *   - The button is disabled and cannot be clicked.\n     *\n     * @example\n     * // Example: Click a button using a selector\n     * __PR.clickDialogButton(\".showImageBtn\", \"my-dialog-class\");\n     * __PR.clickDialogButton(\".showImageBtn\"); // if only 1 dialog is present, can omit the dialog class\n     */\n    function clickDialogButton(buttonSelector, dialogClass) {\n        _clickDialogButtonWithSelector(buttonSelector, dialogClass, false);\n    }\n\n    /**\n     * Saves the currently active file\n     * @returns {Promise<void>} A promise that resolves when file is saved to disc\n     */\n    function saveActiveFile() {\n        return jsPromise(CommandManager.execute(Commands.FILE_SAVE));\n    }\n\n    const __PR= {\n        readTextFile, writeTextFile, deletePath,\n        openFile, setCursors, expectCursorsToBe, keydown, typeAtCursor, validateText, validateAllMarks, validateMarks,\n        closeFile, closeAll, undo, redo, setPreference, getPreference, validateEqual, validateNotEqual, execCommand,\n        saveActiveFile,\n        awaitsFor, waitForModalDialog, waitForModalDialogClosed, clickDialogButtonID, clickDialogButton,\n        EDITING, // contains apis like splitVertical, openFileInFirstPane. focus pane etc...\n        $, Commands, Dialogs\n    };\n\n    async function runMacro(macroText) {\n        let errors = [];\n        try{\n            const AsyncFunction = async function () {}.constructor;\n            const macroAsync = new AsyncFunction(\"__PR\", \"KeyEvent\", macroText);\n            await macroAsync(__PR, KeyEvent);\n        } catch (e) {\n            console.error(\"Error executing macro: \", macroText, e);\n            errors.push({\n                lineNo: 0, line: '',\n                errorCode: `ERROR_EXEC`,\n                errorText: `${e}`\n            });\n        }\n        return errors;\n    }\n\n    if(Phoenix.isTestWindow) {\n        window.__PR = __PR;\n    }\n    exports.computeCursors = computeCursors;\n    exports.runMacro = runMacro;\n});\n"],"file":"MacroRunner.js"}