{"version":3,"sources":["services/UserNotifications.js"],"names":["define","require","exports","module","KernalModeTrust","window","Error","PreferencesManager","NotificationUI","PREF_NOTIFICATIONS_SHOWN_LIST","EntitlementsManager","LoginService","stateManager","definePreference","currentlyShownNotifications","Set","fetchFn","fetch","getShownNotifications","get","markNotificationAsShown","notificationID","shownNotifications","Date","now","set","delete","async","acknowledgeNotificationToServer","accountBaseURL","getAccountBaseURL","url","requestBody","fetchOptions","method","headers","Content-Type","Accept","body","JSON","stringify","Phoenix","isNativeApp","profile","getProfile","apiKey","validationCode","appSessionID","credentials","response","ok","result","json","isSuccess","console","log","warn","status","error","handleNotificationDismiss","shouldShowNotification","notification","validTill","has","displayNotification","title","htmlContent","options","add","toastOptions","dismissOnClick","undefined","toastStyle","NOTIFICATION_STYLES_CSS_CLASS","INFO","autoCloseTimeS","notificationInstance","createToastFromTemplate","done","cleanupStaleNotifications","remoteNotifications","length","remoteIDs","updatedShownNotifications","id","oldCount","Object","keys","newCount","processNotifications","notifications","getNotifications","Array","isArray","notificationsToShow","filter","forEach","init","loginService","on","EVENT_ENTITLEMENTS_CHANGED","isTestWindow","_test_user_notifications_exports","setFetchFn","fn"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU Affero General Public License as published by the Free\n * Software Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along\n * with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/**\n * User Notifications Service\n *\n * This module handles server-sent notifications from the entitlements API.\n * Notifications are displayed as toast messages and acknowledged back to the server.\n */\n\ndefine(function (require, exports, module) {\n    const KernalModeTrust = window.KernalModeTrust;\n    if(!KernalModeTrust){\n        throw new Error(\"UserNotifications should have access to KernalModeTrust. Cannot boot without trust ring\");\n    }\n\n    const PreferencesManager = require(\"preferences/PreferencesManager\"),\n        NotificationUI = require(\"widgets/NotificationUI\");\n\n    const PREF_NOTIFICATIONS_SHOWN_LIST = \"notificationsShownList\";\n    PreferencesManager.stateManager.definePreference(PREF_NOTIFICATIONS_SHOWN_LIST, \"object\", {});\n\n    let EntitlementsManager;\n    let LoginService;\n\n    // In-memory tracking to prevent duplicate notifications during rapid EVENT_ENTITLEMENTS_CHANGED events\n    const currentlyShownNotifications = new Set();\n\n    // Save a copy of window.fetch so that extensions won't tamper with it\n    let fetchFn = window.fetch;\n\n    /**\n     * Get the list of notification IDs that have been shown and acknowledged\n     * @returns {Object} Map of notificationID -> timestamp\n     */\n    function getShownNotifications() {\n        return PreferencesManager.stateManager.get(PREF_NOTIFICATIONS_SHOWN_LIST) || {};\n    }\n\n    /**\n     * Mark a notification as shown and acknowledged\n     * @param {string} notificationID - The notification ID to mark as shown\n     */\n    function markNotificationAsShown(notificationID) {\n        const shownNotifications = getShownNotifications();\n        shownNotifications[notificationID] = Date.now();\n        PreferencesManager.stateManager.set(PREF_NOTIFICATIONS_SHOWN_LIST, shownNotifications);\n        currentlyShownNotifications.delete(notificationID);\n    }\n\n    /**\n     * Call the server API to acknowledge a notification\n     * @param {string} notificationID - The notification ID to acknowledge\n     * @returns {Promise<boolean>} - True if successful, false otherwise\n     */\n    async function acknowledgeNotificationToServer(notificationID) {\n        try {\n            const accountBaseURL = LoginService.getAccountBaseURL();\n            let url = `${accountBaseURL}/notificationAcknowledged`;\n\n            const requestBody = {\n                notificationID: notificationID\n            };\n\n            let fetchOptions = {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Accept': 'application/json'\n                },\n                body: JSON.stringify(requestBody)\n            };\n\n            // Handle different authentication methods for browser vs desktop\n            if (Phoenix.isNativeApp) {\n                // Desktop app: use appSessionID and validationCode\n                const profile = LoginService.getProfile();\n                if (profile && profile.apiKey && profile.validationCode) {\n                    requestBody.appSessionID = profile.apiKey;\n                    requestBody.validationCode = profile.validationCode;\n                    fetchOptions.body = JSON.stringify(requestBody);\n                }\n            } else {\n                // Browser app: use session cookies\n                fetchOptions.credentials = 'include';\n            }\n\n            const response = await fetchFn(url, fetchOptions);\n\n            if (response.ok) {\n                const result = await response.json();\n                if (result.isSuccess) {\n                    console.log(`Notification ${notificationID} acknowledged successfully`);\n                    return true;\n                }\n            }\n\n            console.warn(`Failed to acknowledge notification ${notificationID}:`, response.status);\n            return false;\n        } catch (error) {\n            console.error(`Error acknowledging notification ${notificationID}:`, error);\n            return false;\n        }\n    }\n\n    /**\n     * Handle notification dismissal\n     * @param {string} notificationID - The notification ID that was dismissed\n     */\n    async function handleNotificationDismiss(notificationID) {\n        // Always mark as shown locally to prevent re-showing, even if API fails\n        markNotificationAsShown(notificationID);\n\n        // Call server API to acknowledge\n        return acknowledgeNotificationToServer(notificationID);\n    }\n\n    /**\n     * Check if a notification should be shown\n     * @param {Object} notification - The notification object from server\n     * @returns {boolean} - True if should be shown, false otherwise\n     */\n    function shouldShowNotification(notification) {\n        if (!notification || !notification.notificationID) {\n            return false;\n        }\n\n        // Check if expired\n        if (notification.validTill && Date.now() > notification.validTill) {\n            return false;\n        }\n\n        // Check if already shown (persistent storage)\n        const shownNotifications = getShownNotifications();\n        if (shownNotifications[notification.notificationID]) {\n            return false;\n        }\n\n        // Check if currently being shown (in-memory)\n        if (currentlyShownNotifications.has(notification.notificationID)) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Display a single notification\n     * @param {Object} notification - The notification object from server\n     */\n    function displayNotification(notification) {\n        const {\n            notificationID,\n            title,\n            htmlContent,\n            options = {}\n        } = notification;\n\n        // Mark as currently showing to prevent duplicates\n        currentlyShownNotifications.add(notificationID);\n\n        // Prepare options for NotificationUI\n        const toastOptions = {\n            dismissOnClick: options.dismissOnClick !== undefined ? options.dismissOnClick : true,\n            toastStyle: options.toastStyle || NotificationUI.NOTIFICATION_STYLES_CSS_CLASS.INFO\n        };\n\n        // Add autoCloseTimeS if provided\n        if (options.autoCloseTimeS) {\n            toastOptions.autoCloseTimeS = options.autoCloseTimeS;\n        }\n\n        // Create and show the toast notification\n        const notificationInstance = NotificationUI.createToastFromTemplate(\n            title,\n            htmlContent,\n            toastOptions\n        );\n\n        // Handle notification dismissal\n        notificationInstance.done(() => {\n            handleNotificationDismiss(notificationID);\n        });\n    }\n\n    /**\n     * Clean up stale notification IDs from state manager\n     * Removes notification IDs that are no longer in the remote notifications list\n     * @param {Array} remoteNotifications - The current notifications from server\n     */\n    function cleanupStaleNotifications(remoteNotifications) {\n        if (!remoteNotifications || remoteNotifications.length === 0) {\n            return;\n        }\n\n        // Build a set of remote notification IDs for quick lookup\n        const remoteIDs = new Set();\n        for (const notification of remoteNotifications) {\n            if (notification.notificationID) {\n                remoteIDs.add(notification.notificationID);\n            }\n        }\n\n        // Keep only notification IDs that are still in remote notifications\n        const shownNotifications = getShownNotifications();\n        const updatedShownNotifications = {};\n        for (const id in shownNotifications) {\n            if (remoteIDs.has(id)) {\n                updatedShownNotifications[id] = shownNotifications[id];\n            }\n        }\n\n        // Update state if we removed any stale IDs\n        const oldCount = Object.keys(shownNotifications).length;\n        const newCount = Object.keys(updatedShownNotifications).length;\n        if (newCount < oldCount) {\n            console.log(`Cleaning up ${oldCount - newCount} stale notification ID(s) from state`);\n            PreferencesManager.stateManager.set(PREF_NOTIFICATIONS_SHOWN_LIST, updatedShownNotifications);\n        }\n    }\n\n    /**\n     * Process notifications from entitlements\n     */\n    async function processNotifications() {\n        try {\n            const notifications = await EntitlementsManager.getNotifications();\n\n            if (!notifications || !Array.isArray(notifications)) {\n                return;\n            }\n\n            // Clean up stale notification IDs if we have at least 1 notification from server\n            if (notifications.length > 0) {\n                cleanupStaleNotifications(notifications);\n            }\n\n            // Filter and show new notifications\n            const notificationsToShow = notifications.filter(shouldShowNotification);\n\n            if (notificationsToShow.length > 0) {\n                console.log(`Showing ${notificationsToShow.length} new notification(s)`);\n                notificationsToShow.forEach(displayNotification);\n            }\n        } catch (error) {\n            console.error('Error processing notifications:', error);\n        }\n    }\n\n    /**\n     * Initialize the UserNotifications service\n     */\n    function init() {\n        EntitlementsManager = KernalModeTrust.EntitlementsManager;\n        LoginService = KernalModeTrust.loginService;\n\n        if (!EntitlementsManager || !LoginService) {\n            throw new Error(\"UserNotifications requires EntitlementsManager and LoginService in KernalModeTrust\");\n        }\n\n        // Listen for entitlements changes\n        EntitlementsManager.on(EntitlementsManager.EVENT_ENTITLEMENTS_CHANGED, processNotifications);\n\n        console.log('UserNotifications service initialized');\n    }\n\n    // Test-only exports for integration testing\n    if (Phoenix.isTestWindow) {\n        window._test_user_notifications_exports = {\n            getShownNotifications,\n            markNotificationAsShown,\n            shouldShowNotification,\n            acknowledgeNotificationToServer,\n            processNotifications,\n            cleanupStaleNotifications,\n            currentlyShownNotifications,\n            setFetchFn: function (fn) {\n                fetchFn = fn;\n            }\n        };\n    }\n\n    exports.init = init;\n    // no public exports to prevent extension tampering\n});\n"],"file":"UserNotifications.js"}