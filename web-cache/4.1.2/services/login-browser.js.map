{"version":3,"sources":["services/login-browser.js"],"names":["define","require","exports","module","LoginServiceDirectImport","PreferencesManager","Metrics","Dialogs","DefaultDialogs","Strings","StringUtils","ProfileMenu","Mustache","browserLoginWaitingTemplate","KernalModeTrust","window","Error","LoginService","loginService","userProfile","isLoggedInUser","PREF_USER_PROFILE_VERSION","isLoggedIn","getProfile","_getAccountBaseURL","location","hostname","Phoenix","config","account_url","replace","_getAccountWebURL","ERR_RETRY_LATER","ERR_INVALID","ERR_NOT_LOGGED_IN","fetchFn","fetch","async","_resolveBrowserSession","resolveURL","navigator","onLine","err","isTestWindow","response","method","credentials","headers","Accept","status","ok","userDetails","json","isSuccess","console","log","e","error","_resetBrowserLogin","setNotLoggedIn","stateManager","set","crypto","randomUUID","_verifyBrowserLogin","silentCheck","resolveResponse","setLoggedIn","profileIcon","initials","color","email","countEvent","EVENT_TYPE","AUTH","_handleLoginError","loginWaitingDialog","_showLoginWaitingDialog","dialogData","SIGN_IN_WAITING_TITLE","SIGN_IN_WAITING_MESSAGE","WAITING_FOR_LOGIN","CHECK_NOW","CANCEL","$template","$","render","showModalDialogUsingTemplate","on","$btn","this","originalText","text","prop","CHECKING","find","CHECKING_STATUS","_onLoginSuccess","NOT_SIGNED_IN_YET","close","onFocusCheck","off","done","_cancelLoginWaiting","getElement","welcomeBackMessage","isNativeApp","format","WELCOME_BACK_USER","firstName","WELCOME_BACK","css","setTimeout","signInToBrowser","showModalDialog","DIALOG_ID_ERROR","SIGNED_IN_OFFLINE_TITLE","SIGNED_IN_OFFLINE_MESSAGE","signInURL","newTab","open","SIGNED_IN_FAILED_TITLE","POPUP_BLOCKED","signOutBrowser","logoutURL","Content-Type","body","JSON","stringify","result","DIALOG_ID_INFO","SIGNED_OUT","SIGNED_OUT_MESSAGE_FRIENDLY","warn","dialog","SIGNED_OUT_FAILED_TITLE","SIGNED_OUT_FAILED_MESSAGE","init","catch","pref","definePreference","watchExternalChanges","signInToAccount","signOutAccount","_verifyLoginStatus","getAccountBaseURL","_test_login_browser_exports","setFetchFn","_setFetchFn","fn"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU Affero General Public License as published by the Free\n * Software Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*global logger*/\n\n/**\n * Phoenix Browser Login Service\n *\n * This module handles user authentication for Phoenix browser applications.\n * It integrates with the Phoenix login service to provide secure authentication\n * across the phcode.dev domain ecosystem.\n *\n * IMPORTANT: For detailed setup instructions, development workflows, and\n * troubleshooting guide, see: src/services/login-service-no_dist.md\n *\n * Key Features:\n * - Domain-wide session management using 'session' cookie at .phcode.dev level\n * - Proxy server support for localhost development (serve-proxy.js)\n * - Support for both production (account.phcode.dev) and custom login servers\n * - Automatic session validation and user profile management\n *\n * Development Notes:\n * - Production: Uses account.phcode.dev directly with domain-wide cookies\n * - Development: Uses /proxy/accounts route through serve-proxy.js for localhost:8000 to account.phcode.dev\n * - Session cookies must be manually copied from account.phcode.dev to localhost for testing\n *\n * @see src/services/login-service-no_dist.md for comprehensive documentation\n */\n\ndefine(function (require, exports, module) {\n    const LoginServiceDirectImport = require(\"./login-service\"); // after this, loginService will be in KernalModeTrust\n    const PreferencesManager  = require(\"preferences/PreferencesManager\"),\n        Metrics = require(\"utils/Metrics\"),\n        Dialogs = require(\"widgets/Dialogs\"),\n        DefaultDialogs = require(\"widgets/DefaultDialogs\"),\n        Strings = require(\"strings\"),\n        StringUtils = require(\"utils/StringUtils\"),\n        ProfileMenu  = require(\"./profile-menu\"),\n        Mustache = require(\"thirdparty/mustache/mustache\"),\n        browserLoginWaitingTemplate = require(\"text!./html/browser-login-waiting-dialog.html\");\n\n    const KernalModeTrust = window.KernalModeTrust;\n    if(!KernalModeTrust){\n        // integrated extensions will have access to kernal mode, but not external extensions\n        throw new Error(\"Browser Login service should have access to KernalModeTrust. Cannot boot without trust ring\");\n    }\n    const LoginService = KernalModeTrust.loginService;\n\n    // user profile structure: \"customerID\": \"uuid...\", \"firstName\":\"Aa\",\"lastName\":\"bb\",\n    // \"email\":\"aaaa@sss.com\", \"loginTime\":1750074393853, \"isSuccess\": true,\n    // \"profileIcon\":{\"color\":\"#14b8a6\",\"initials\":\"AB\"}\n    let userProfile = null;\n    let isLoggedInUser = false;\n\n    // just used as trigger to notify different windows about user profile changes\n    const PREF_USER_PROFILE_VERSION = \"userProfileVersion\";\n\n    function isLoggedIn() {\n        return isLoggedInUser;\n    }\n\n    function getProfile() {\n        return userProfile;\n    }\n\n    /**\n     * Get the base URL for account API calls\n     * Uses proxy routes for localhost, direct URL otherwise\n     */\n    function _getAccountBaseURL() {\n        if (location.hostname === 'localhost' || location.hostname === '127.0.0.1') {\n            return '/proxy/accounts';\n        }\n        return Phoenix.config.account_url.replace(/\\/$/, ''); // Remove trailing slash\n    }\n\n    /**\n     * Get the account website URL for opening browser tabs\n     */\n    function _getAccountWebURL() {\n        return Phoenix.config.account_url;\n    }\n\n    const ERR_RETRY_LATER = \"retry_later\";\n    const ERR_INVALID = \"invalid\";\n    const ERR_NOT_LOGGED_IN = \"not_logged_in\";\n\n    // save a copy of window.fetch so that extensions wont tamper with it.\n    let fetchFn = window.fetch;\n\n    /**\n     * Resolve browser session using cookies\n     * @return {Promise<Object>} A promise resolving to user profile or error object\n     */\n    async function _resolveBrowserSession() {\n        const resolveURL = `${_getAccountBaseURL()}/resolveBrowserSession`;\n        if (!navigator.onLine) {\n            return {err: ERR_RETRY_LATER};\n        }\n        try {\n            if(Phoenix.isTestWindow && fetchFn === fetch){\n                // so we never allow tests to hit the actual login service.\n                return {err: ERR_NOT_LOGGED_IN};\n            }\n            const response = await fetchFn(resolveURL, {\n                method: 'GET',\n                credentials: 'include', // Include cookies\n                headers: {\n                    'Accept': 'application/json'\n                }\n            });\n\n            if (response.status === 401 || response.status === 403 || response.status === 404) {\n                // Not logged in or session expired\n                return {err: ERR_NOT_LOGGED_IN};\n            } else if (response.status === 400) {\n                return {err: ERR_INVALID};\n            } else if (response.ok) {\n                const userDetails = await response.json();\n                if (userDetails.isSuccess) {\n                    return {userDetails};\n                } else {\n                    return {err: ERR_NOT_LOGGED_IN};\n                }\n            }\n            // Other errors like 500 are retriable\n            console.log('Browser session resolve error:', response.status);\n            return {err: ERR_RETRY_LATER};\n        } catch (e) {\n            console.error(e, \"Failed to call resolveBrowserSession endpoint\", resolveURL);\n            return {err: ERR_RETRY_LATER};\n        }\n    }\n\n    async function _resetBrowserLogin() {\n        isLoggedInUser = false;\n        userProfile = null;\n        ProfileMenu.setNotLoggedIn();\n        // bump the version so that in multi windows, the other window gets notified of the change\n        PreferencesManager.stateManager.set(PREF_USER_PROFILE_VERSION, crypto.randomUUID());\n    }\n\n    /**\n     * Calls remote resolveBrowserSession endpoint to verify login status. should not be used frequently.\n     * @param silentCheck\n     * @returns {Promise<void>}\n     * @private\n     */\n    async function _verifyBrowserLogin(silentCheck = false) {\n        console.log(\"Verifying browser login status...\");\n\n        const resolveResponse = await _resolveBrowserSession();\n        if(resolveResponse.userDetails) {\n            // User is logged in\n            userProfile = resolveResponse.userDetails;\n            isLoggedInUser = true;\n            ProfileMenu.setLoggedIn(userProfile.profileIcon.initials, userProfile.profileIcon.color);\n            console.log(\"Browser login verified for:\", userProfile.email);\n            Metrics.countEvent(Metrics.EVENT_TYPE.AUTH, \"browser\", \"OKLogin\");\n            return;\n        }\n\n        // User is not logged in or error occurred if here\n        if(resolveResponse.err === ERR_NOT_LOGGED_IN) {\n            console.log(\"No browser session found. Not logged in\");\n            Metrics.countEvent(Metrics.EVENT_TYPE.AUTH, \"browser\", \"NotLoggedIn\");\n            _handleLoginError(silentCheck);\n            return;\n        }\n\n        if (resolveResponse.err === ERR_INVALID) {\n            console.log(\"Invalid auth token, resetting login state\");\n            Metrics.countEvent(Metrics.EVENT_TYPE.AUTH, \"browser\", \"invalidLogin\");\n            _handleLoginError(silentCheck);\n            return;\n        }\n\n        // Other errors (network, retry later, etc.)\n        console.log(\"Browser login verification failed (temporary):\", resolveResponse.err);\n        Metrics.countEvent(Metrics.EVENT_TYPE.AUTH, \"browser\", \"RetryLogin\");\n        // Don't reset login state for temporary errors, regardless of silent check\n    }\n\n    function _handleLoginError(silentCheck) {\n        if (!silentCheck) {\n            _resetBrowserLogin();\n        } else {\n            // For silent checks, just update the internal state\n            isLoggedInUser = false;\n            userProfile = null;\n        }\n    }\n\n    let loginWaitingDialog = null;\n\n    /**\n     * Show waiting dialog with auto-detection and manual check options\n     */\n    function _showLoginWaitingDialog() {\n        if (loginWaitingDialog) {\n            return; // Already showing\n        }\n\n        // Prepare dialog data with fallback strings\n        const dialogData = {\n            Strings: {\n                SIGN_IN_WAITING_TITLE: Strings.SIGN_IN_WAITING_TITLE,\n                SIGN_IN_WAITING_MESSAGE: Strings.SIGN_IN_WAITING_MESSAGE,\n                WAITING_FOR_LOGIN: Strings.WAITING_FOR_LOGIN,\n                CHECK_NOW: Strings.CHECK_NOW,\n                CANCEL: Strings.CANCEL\n            }\n        };\n\n        const $template = $(Mustache.render(browserLoginWaitingTemplate, dialogData));\n        loginWaitingDialog = Dialogs.showModalDialogUsingTemplate($template);\n\n        // Handle Check Now button\n        $template.on('click', '[data-button-id=\"check\"]', async function() {\n            const $btn = $(this);\n            const originalText = $btn.text();\n            $btn.prop('disabled', true).text(Strings.CHECKING);\n            $template.find('#login-status').text(Strings.CHECKING_STATUS);\n\n            await _verifyBrowserLogin();\n\n            if (isLoggedInUser) {\n                _onLoginSuccess();\n            } else {\n                $template.find('#login-status').text(Strings.NOT_SIGNED_IN_YET);\n                $btn.prop('disabled', false).text(originalText);\n            }\n        });\n\n        // Handle Cancel button\n        $template.on('click', '[data-button-id=\"cancel\"]', function() {\n            loginWaitingDialog.close();\n        });\n\n        // Auto-check when page gains focus\n        const onFocusCheck = async () => {\n            if (loginWaitingDialog && !isLoggedInUser) {\n                $template.find('#login-status').text(Strings.CHECKING_STATUS);\n                await _verifyBrowserLogin();\n\n                if (isLoggedInUser) {\n                    _onLoginSuccess();\n                }\n            }\n        };\n\n        $(window).off('focus.loginWaiting');\n        $(window).on('focus.loginWaiting', onFocusCheck);\n\n        // Clean up when dialog closes\n        loginWaitingDialog.done(() => {\n            _cancelLoginWaiting();\n        });\n    }\n\n    function _onLoginSuccess() {\n        if (loginWaitingDialog) {\n            const $template = loginWaitingDialog.getElement();\n            const welcomeBackMessage = Phoenix.isNativeApp ?\n                StringUtils.format(Strings.WELCOME_BACK_USER, userProfile.firstName): Strings.WELCOME_BACK;\n            // in desktop app, the apis return full username so we can show `Welcome back, alice`, but in\n            // browser app, we only get name like `a***` due to security posture, so we show `Welcome back` in browser.\n            $template.find('#login-status')\n                .text(welcomeBackMessage)\n                .css('color', '#10b981');\n            setTimeout(() => {\n                _cancelLoginWaiting();\n                Metrics.countEvent(Metrics.EVENT_TYPE.AUTH, \"browserLogin\", \"browser\");\n            }, 1500);\n        }\n    }\n\n    function _cancelLoginWaiting() {\n        if (loginWaitingDialog) {\n            loginWaitingDialog.close();\n            loginWaitingDialog = null;\n        }\n        $(window).off('focus.loginWaiting');\n    }\n\n    /**\n     * Open browser-based sign-in in new tab\n     */\n    async function signInToBrowser() {\n        if (!navigator.onLine) {\n            Dialogs.showModalDialog(\n                DefaultDialogs.DIALOG_ID_ERROR,\n                Strings.SIGNED_IN_OFFLINE_TITLE,\n                Strings.SIGNED_IN_OFFLINE_MESSAGE\n            );\n            return;\n        }\n\n        const signInURL = _getAccountWebURL() + \"authorizeBrowserApp\";\n\n        // Open account URL in new tab\n        const newTab = window.open(signInURL, '_blank');\n\n        if (!newTab) {\n            Dialogs.showModalDialog(\n                DefaultDialogs.DIALOG_ID_ERROR,\n                Strings.SIGNED_IN_FAILED_TITLE,\n                StringUtils.format(Strings.POPUP_BLOCKED, _getAccountWebURL())\n            );\n            return;\n        }\n\n        // Show dialog with better UX - auto-detect when user returns\n        _showLoginWaitingDialog();\n\n        Metrics.countEvent(Metrics.EVENT_TYPE.AUTH, \"browserLoginAttempt\", \"browser\");\n    }\n\n    /**\n     * Sign out from browser session\n     */\n    async function signOutBrowser() {\n        const logoutURL = `${_getAccountBaseURL()}/signOut`;\n        try {\n            if(Phoenix.isTestWindow && fetchFn === fetch){\n                // so we never allow tests to hit the actual login service.\n                return;\n            }\n            const response = await fetchFn(logoutURL, {\n                method: 'POST',\n                credentials: 'include', // Include cookies\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({})\n            });\n\n            // Always reset local state regardless of server response\n            await _resetBrowserLogin();\n            await _verifyBrowserLogin();\n\n            if (response.ok) {\n                const result = await response.json();\n                if (result.isSuccess) {\n                    Dialogs.showModalDialog(\n                        DefaultDialogs.DIALOG_ID_INFO,\n                        Strings.SIGNED_OUT,\n                        Strings.SIGNED_OUT_MESSAGE_FRIENDLY\n                    );\n                    Metrics.countEvent(Metrics.EVENT_TYPE.AUTH, 'browserLogoutOK', 'browser');\n                    return;\n                }\n            }\n\n            // If we get here, there was some issue but we still signed out locally\n            console.warn('Logout may not have completed on server, but signed out locally');\n            const dialog = Dialogs.showModalDialog(\n                DefaultDialogs.DIALOG_ID_ERROR,\n                Strings.SIGNED_OUT_FAILED_TITLE,\n                Strings.SIGNED_OUT_FAILED_MESSAGE\n            );\n            dialog.done(() => {\n                window.open(_getAccountWebURL() + \"#advanced\", '_blank');\n            });\n            Metrics.countEvent(Metrics.EVENT_TYPE.AUTH, 'browserLogoutPartial', 'browser');\n\n        } catch (error) {\n            // Always reset local state even on network error\n            await _resetBrowserLogin();\n            await _verifyBrowserLogin();\n            console.error(\"Network error during logout:\", error);\n            const dialog = Dialogs.showModalDialog(\n                DefaultDialogs.DIALOG_ID_ERROR,\n                Strings.SIGNED_OUT_FAILED_TITLE,\n                Strings.SIGNED_OUT_FAILED_MESSAGE\n            );\n            dialog.done(() => {\n                window.open(_getAccountWebURL() + \"#advanced\", '_blank');\n            });\n            Metrics.countEvent(Metrics.EVENT_TYPE.AUTH, 'browserLogoutError', 'browser');\n        }\n    }\n\n    function init() {\n        if(Phoenix.isNativeApp){\n            console.log(\"Browser login service is not needed for native app\");\n            return;\n        }\n        ProfileMenu.init();\n        LoginServiceDirectImport.init();\n\n        // Always verify login on browser app start\n        _verifyBrowserLogin().catch(console.error);\n\n        // Watch for profile changes from other windows/tabs\n        const pref = PreferencesManager.stateManager.definePreference(PREF_USER_PROFILE_VERSION, 'string', '0');\n        pref.watchExternalChanges();\n        pref.on('change', ()=>{\n            _verifyBrowserLogin(true).catch(console.error);\n        });\n\n        // Note: We don't do automatic verification on page focus to avoid server overload.\n        // Automatic checks are only done during the login waiting dialog period.\n    }\n\n    // no sensitive apis or events should be triggered from the public exports of this module as extensions\n    // can read them. Always use KernalModeTrust.loginService for sensitive apis.\n\n    // Only set exports for browser apps to avoid conflict with desktop login\n    if (!Phoenix.isNativeApp) {\n        // kernal exports\n        // Add to existing KernalModeTrust.loginService from login-service.js\n        // isLoggedIn API shouldn't be used outside loginService, please use Entitlements.isLoggedIn API.\n        LoginService.isLoggedIn = isLoggedIn;\n        // signInToAccount API shouldn't be used outside loginService, please use Entitlements.loginToAccount API.\n        LoginService.signInToAccount = signInToBrowser;\n        LoginService.signOutAccount = signOutBrowser;\n        LoginService.getProfile = getProfile;\n        // verifyLoginStatus Calls remote resolveBrowserSession endpoint to verify. should not be used frequently.\n        // All users are required to use isLoggedIn API instead.\n        LoginService._verifyLoginStatus = () => _verifyBrowserLogin(false);\n        LoginService.getAccountBaseURL = _getAccountBaseURL;\n        init();\n    }\n\n    // Test-only exports for integration testing\n    if (Phoenix.isTestWindow) {\n        window._test_login_browser_exports = {\n            setFetchFn: function _setFetchFn(fn) {\n                fetchFn = fn;\n            }\n        };\n    }\n\n    // public exports\n    exports.isLoggedIn = isLoggedIn;\n\n});\n"],"file":"login-browser.js"}