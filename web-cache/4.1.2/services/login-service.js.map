{"version":3,"sources":["services/login-service.js"],"names":["define","require","exports","module","NodeUtils","PreferencesManager","Commands","CommandManager","EntitlementsDirectImport","Metrics","Strings","PREF_STATE_LICENSED_DEVICE_CHECK","stateManager","definePreference","MS_IN_DAY","TEN_MINUTES","FREE_PLAN_VALIDITY_DAYS","FALLBACK_SALT","currentSalt","CACHED_ENTITLEMENTS_FILE","path","join","Phoenix","app","getApplicationSupportDirectory","fetchFn","window","fetch","dateNowFn","Date","now","KernalModeTrust","Error","LoginService","loginService","EVENT_ENTITLEMENTS_CHANGED","cachedEntitlements","undefined","lastRecordedState","entitlementsChangedTimer","ENTITLEMENT_CHANGED_DEBOUNCE_WINDOW","isTestWindow","_debounceEntitlementsChanged","setTimeout","trigger","async","getSalt","isNativeApp","salt","getCredential","SIGNATURE_SALT_KEY","crypto","randomUUID","setCredential","error","console","countEvent","EVENT_TYPE","AUTH","_loadCachedEntitlements","fileData","VFS","readFileResolves","data","cachedData","JSON","parse","jsonData","sign","warn","_clearCachedEntitlements","isValidSignature","validateDataSignature","PRO","_saveCachedEntitlements","entitlements","stringify","signature","generateDataSignature","cacheData","writeFileAsync","log","unlinkResolves","deviceIDCached","getDeviceID","deviceID","e","logger","reportError","deviceLicensePrimed","licencedDeviceCredsAvailable","getEntitlements","forceRefresh","isLicensedDevice","isLoggedIn","navigator","onLine","_processDiscCachedEntitlement","diskCachedEntitlements","entitlementsChanged","accountBaseURL","getAccountBaseURL","language","brackets","getLocale","currentVersion","AppConfig","apiVersion","url","platform","fetchOptions","method","headers","Accept","profile","getProfile","apiKey","validationCode","encodeURIComponent","credentials","processedEntitlement","response","ok","result","json","isSuccess","status","clearEntitlements","startEffectiveEntitlementsMonitor","getEffectiveEntitlements","setInterval","freshEntitlements","expiredPlanName","LoginUtils","validTillExpired","hasChanged","haveEntitlementsChanged","_validateAndFilterEntitlements","currentDate","plan","validTill","isSubscriber","paidSubscriber","name","USER_FREE_PLAN_NAME_DO_NOT_TRANSLATE","fullName","featureEntitlements","featureName","feature","activated","upgradeToPlan","config","main_pro_plan","subscribeURL","purchase_url","serverEntitlements","trialDaysRemaining","getProTrialDaysRemaining","isInProTrial","liveEdit","addDeviceLicense","set","addDeviceLicenseSystemWide","removeDeviceLicense","removeDeviceLicenseSystemWide","isLicensedDeviceSystemWide","_isLicensedDeviceFlagForTest","userCheck","get","systemCheck","handleReinstallCreds","reinstallCreds","inited","init","register","REINSTALL_CREDS","_test_login_service_exports","setIsLicensedDevice","_isLicensedDevice","setFetchFn","fn","setDateNowFn"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU Affero General Public License as published by the Free\n * Software Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*global path, logger*/\n\n/**\n * Shared Login Service\n *\n * This module contains shared login service functionality used by both\n * browser and desktop login implementations, including entitlements management.\n */\n\ndefine(function (require, exports, module) {\n    require(\"./setup-login-service\"); // this adds loginService to KernalModeTrust\n    require(\"./promotions\");\n    require(\"./login-utils\");\n    const NodeUtils = require(\"utils/NodeUtils\"),\n        PreferencesManager = require(\"preferences/PreferencesManager\"),\n        Commands = require(\"command/Commands\"),\n        CommandManager = require(\"command/CommandManager\");\n    const EntitlementsDirectImport = require(\"./EntitlementsManager\"); // this adds Entitlements to KernalModeTrust\n\n    const Metrics = require(\"utils/Metrics\"),\n        Strings = require(\"strings\");\n\n    const PREF_STATE_LICENSED_DEVICE_CHECK = \"LICENSED_DEVICE_CHECK\";\n    PreferencesManager.stateManager.definePreference(PREF_STATE_LICENSED_DEVICE_CHECK, \"boolean\", false);\n\n    const MS_IN_DAY = 10 * 24 * 60 * 60 * 1000;\n    const TEN_MINUTES = 10 * 60 * 1000;\n    const FREE_PLAN_VALIDITY_DAYS = 10000;\n\n    // the fallback salt is always a constant as this will only fail in rare circumstatnces and it needs to\n    // be exactly same across versions of the app. Changing this will not affect the large majority of users and\n    // for the ones who are affected, the app will reset the signed data with new salt but will not grant ant trial\n    // when tampering is detected.\n    const FALLBACK_SALT = 'fallback-salt-2f309322-b32d-4d59-85b4-2baef666a9f4';\n    let currentSalt;\n\n    // Cache file path for desktop app entitlements\n    const CACHED_ENTITLEMENTS_FILE = path.join(Phoenix.app.getApplicationSupportDirectory(),\n        \"cached_entitlements.json\");\n\n    // save a copy of window.fetch so that extensions wont tamper with it.\n    let fetchFn = window.fetch;\n    let dateNowFn = Date.now;\n\n    const KernalModeTrust = window.KernalModeTrust;\n    if(!KernalModeTrust){\n        // integrated extensions will have access to kernal mode, but not external extensions\n        throw new Error(\"Login service should have access to KernalModeTrust. Cannot boot without trust ring\");\n    }\n\n    const LoginService = KernalModeTrust.loginService;\n\n    // Event constants\n    const EVENT_ENTITLEMENTS_CHANGED = \"entitlements_changed\";\n\n    // Cached entitlements data\n    let cachedEntitlements = undefined;\n\n    // Last recorded state for entitlements monitoring\n    let lastRecordedState = null;\n\n    // Debounced trigger for entitlements changed\n    let entitlementsChangedTimer = null;\n\n    const ENTITLEMENT_CHANGED_DEBOUNCE_WINDOW = Phoenix.isTestWindow ? 100 : 1000;\n\n    function _debounceEntitlementsChanged() {\n        if (entitlementsChangedTimer) {\n            // already scheduled, skip\n            return;\n        }\n\n        // atmost 1 entitlement changed event will be triggered in this window to prevent too many entitlment changed\n        // events firing.\n        entitlementsChangedTimer = setTimeout(() => {\n            LoginService.trigger(EVENT_ENTITLEMENTS_CHANGED);\n            entitlementsChangedTimer = null;\n        }, ENTITLEMENT_CHANGED_DEBOUNCE_WINDOW);\n    }\n\n\n    /**\n     * Get per-user salt for signature generation, creating and persisting one if it doesn't exist\n     * Used for signing cached data to prevent tampering\n     */\n    async function getSalt() {\n        // Fallback salt constant for rare circumstances where salt generation fails\n        if(currentSalt) {\n            return currentSalt;\n        }\n\n        try {\n            if (Phoenix.isNativeApp) {\n                // Native app: use KernalModeTrust credential store\n                let salt = await KernalModeTrust.getCredential(KernalModeTrust.SIGNATURE_SALT_KEY);\n                if (!salt) {\n                    // Generate and store new salt\n                    salt = crypto.randomUUID();\n                    await KernalModeTrust.setCredential(KernalModeTrust.SIGNATURE_SALT_KEY, salt);\n                }\n                currentSalt = salt;\n                return salt;\n            }\n            // In browser app, there is no way to securely store salt without extensions being able to\n            // read it. Return a static salt for basic integrity checking.\n            currentSalt = FALLBACK_SALT;\n            return FALLBACK_SALT;\n        } catch (error) {\n            console.error(\"Error getting signature salt:\", error);\n            // Return a fallback salt to prevent crashes\n            Metrics.countEvent(Metrics.EVENT_TYPE.AUTH, \"saltGet\", \"Err\");\n            currentSalt = FALLBACK_SALT;\n            return FALLBACK_SALT;\n        }\n    }\n\n    /**\n     * Load cached entitlements from disk with signature validation\n     * Returns null if no cache, invalid signature, or error\n     */\n    async function _loadCachedEntitlements() {\n        if (!Phoenix.isNativeApp) {\n            return null; // No caching for browser app\n        }\n\n        try {\n            const fileData = await Phoenix.VFS.readFileResolves(CACHED_ENTITLEMENTS_FILE, 'utf8');\n\n            if (fileData.error || !fileData.data) {\n                return null; // No cached file exists\n            }\n\n            const cachedData = JSON.parse(fileData.data);\n            if (!cachedData.jsonData || !cachedData.sign) {\n                console.warn(\"Invalid cached entitlements format - missing jsonData or sign\");\n                await _clearCachedEntitlements();\n                return null;\n            }\n\n            // Validate signature\n            const salt = await getSalt();\n            const isValidSignature = await KernalModeTrust.validateDataSignature(\n                cachedData.jsonData,\n                cachedData.sign,\n                salt\n            );\n\n            if (!isValidSignature) {\n                console.warn(\"Cached entitlements signature validation failed - possible tampering detected\");\n                Metrics.countEvent(Metrics.EVENT_TYPE.PRO, \"entCacheLD\", \"signInvalid\");\n                await _clearCachedEntitlements();\n                return null;\n            }\n\n            // Parse and return the entitlements\n            return JSON.parse(cachedData.jsonData);\n        } catch (error) {\n            console.error(\"Error loading cached entitlements:\", error);\n            Metrics.countEvent(Metrics.EVENT_TYPE.PRO, \"entCacheLD\", \"error\");\n            await _clearCachedEntitlements(); // Clear corrupted cache\n            return null;\n        }\n    }\n\n    /**\n     * Save entitlements to cache with signature\n     */\n    async function _saveCachedEntitlements(entitlements) {\n        if (!Phoenix.isNativeApp || !entitlements) {\n            return; // No caching for browser app\n        }\n\n        try {\n            const jsonData = JSON.stringify(entitlements);\n            const salt = await getSalt();\n            const signature = await KernalModeTrust.generateDataSignature(jsonData, salt);\n\n            const cacheData = {\n                jsonData: jsonData,\n                sign: signature\n            };\n\n            await Phoenix.VFS.writeFileAsync(CACHED_ENTITLEMENTS_FILE, JSON.stringify(cacheData), 'utf8');\n            console.log(\"Entitlements cached successfully\");\n        } catch (error) {\n            Metrics.countEvent(Metrics.EVENT_TYPE.PRO, \"entCacheSave\", \"err\");\n            console.error(\"Error saving cached entitlements:\", error);\n        }\n    }\n\n    /**\n     * Clear cached entitlements file\n     */\n    async function _clearCachedEntitlements() {\n        if (!Phoenix.isNativeApp) {\n            return; // No caching for browser app\n        }\n\n        try {\n            await Phoenix.VFS.unlinkResolves(CACHED_ENTITLEMENTS_FILE);\n            console.log(\"Cached entitlements cleared\");\n        } catch (error) {\n            console.log(\"Error clearing cached entitlements:\", error);\n        }\n    }\n\n    let deviceIDCached = undefined;\n    async function getDeviceID() {\n        if(!Phoenix.isNativeApp) {\n            // We only grant device licenses to desktop apps. Browsers cannot be uniquely device identified obviously.\n            return null;\n        }\n        if(deviceIDCached !== undefined) {\n            return deviceIDCached;\n        }\n        try {\n            const deviceID = await NodeUtils.getDeviceID();\n            if(!deviceID) {\n                deviceIDCached = null;\n                Metrics.countEvent(Metrics.EVENT_TYPE.AUTH, \"deviceID\", \"nullErr\");\n                return null;\n            }\n            deviceIDCached = KernalModeTrust.generateDataSignature(deviceID);\n        } catch (e) {\n            logger.reportError(e, \"failed to sign deviceID\");\n            Metrics.countEvent(Metrics.EVENT_TYPE.AUTH, \"deviceID\", \"SignErr\");\n            deviceIDCached = null;\n        }\n        return deviceIDCached;\n    }\n\n\n    let deviceLicensePrimed = false,\n        licencedDeviceCredsAvailable = false;\n\n    /**\n     * Get entitlements from API or disc cache.\n     * @param {string} forceRefresh If provided will always fetch from server and bypass cache. Use rarely like\n     *      when a user logs in/out/some other user activity/ account-related events.\n     * Returns null if the user is not logged in\n     */\n    async function getEntitlements(forceRefresh = false) {\n        if(!deviceLicensePrimed) {\n            deviceLicensePrimed = true;\n            // we cache this as device license is only checked at app start. As invoves some files in system loactions,\n            // we dont want file access errors to happen on every entitlement check.\n            licencedDeviceCredsAvailable = await isLicensedDevice();\n        }\n        // Return null if not logged in\n        if (!LoginService.isLoggedIn() && !licencedDeviceCredsAvailable) {\n            return null;\n        }\n\n        // Return cached data if available and not forcing refresh\n        if (cachedEntitlements !== undefined && !forceRefresh) {\n            return cachedEntitlements;\n        }\n\n        if (cachedEntitlements && !navigator.onLine) {\n            return cachedEntitlements;\n        }\n\n        async function _processDiscCachedEntitlement() {\n            const diskCachedEntitlements = await _loadCachedEntitlements();\n            if (diskCachedEntitlements) {\n                console.log(\"offline/network/server error: Using cached entitlements from disk\");\n                const entitlementsChanged =\n                    JSON.stringify(cachedEntitlements) !== JSON.stringify(diskCachedEntitlements);\n                cachedEntitlements = diskCachedEntitlements;\n                // Trigger event if entitlements changed\n                if (entitlementsChanged) {\n                    _debounceEntitlementsChanged();\n                }\n                return cachedEntitlements;\n            }\n            return null;\n        }\n\n        try {\n            const accountBaseURL = LoginService.getAccountBaseURL();\n            const language = brackets.getLocale();\n            const currentVersion = window.AppConfig.apiVersion || \"1.0.0\";\n            let url = `${accountBaseURL}/getAppEntitlements?lang=${language}&version=${currentVersion}`+\n                `&platform=${Phoenix.platform}&appType=${Phoenix.isNativeApp ? \"desktop\" : \"browser\"}`;\n            if(licencedDeviceCredsAvailable) {\n                url += `&deviceID=${await getDeviceID()}`;\n            }\n            let fetchOptions = {\n                method: 'GET',\n                headers: {\n                    'Accept': 'application/json'\n                }\n            };\n\n            // Handle different authentication methods for browser vs desktop\n            if (Phoenix.isNativeApp) {\n                // Desktop app: use appSessionID and validationCode\n                const profile = LoginService.getProfile();\n                if (profile && profile.apiKey && profile.validationCode) {\n                    url += `&appSessionID=${encodeURIComponent(profile.apiKey)}&validationCode=${encodeURIComponent(profile.validationCode)}`;\n                } else if(!licencedDeviceCredsAvailable){\n                    console.error('Missing appSessionID or validationCode for desktop app entitlements');\n                    return null;\n                }\n            } else {\n                // Browser app: use session cookies\n                fetchOptions.credentials = 'include';\n            }\n\n            // For desktop app, if offline, try to return disc cached entitlements\n            if (Phoenix.isNativeApp && !navigator.onLine) {\n                const processedEntitlement = await _processDiscCachedEntitlement();\n                if (processedEntitlement) {\n                    return processedEntitlement;\n                }\n            }\n\n            const response = await fetchFn(url, fetchOptions);\n\n            if (response.ok) {\n                const result = await response.json();\n                if (result.isSuccess) {\n                    // Check if entitlements actually changed\n                    const entitlementsChanged = JSON.stringify(cachedEntitlements) !== JSON.stringify(result);\n\n                    cachedEntitlements = result;\n\n                    // Save to disk cache for desktop app\n                    if (Phoenix.isNativeApp) {\n                        await _saveCachedEntitlements(result);\n                    }\n\n                    // Trigger event if entitlements changed\n                    if (entitlementsChanged) {\n                        _debounceEntitlementsChanged();\n                    }\n\n                    return cachedEntitlements;\n                }\n            } else if (response.status >= 500 && response.status < 600) {\n                // Handle 5xx errors by loading from cache.\n                if (Phoenix.isNativeApp) {\n                    console.warn('Fetch entitlements server error:', response.status);\n                    const processedEntitlement = await _processDiscCachedEntitlement();\n                    if (processedEntitlement) {\n                        return processedEntitlement;\n                    }\n                }\n            } else if (Phoenix.isNativeApp) {\n                // 4xx errors are genuine auth fail errors, so our cache is not good then\n                console.warn('Cearing entitlements, entitlements server error:', response.status);\n                await _clearCachedEntitlements();\n            }\n        } catch (error) {\n            console.error('Failed to fetch entitlements:', error);\n\n            // errors that happen during the fetch operation itself, which are typically not HTTP errors\n            // returned by the server, but rather issues at the network or browser level.\n            // For desktop app, fall back to cached entitlements if available\n            if (Phoenix.isNativeApp) {\n                const processedEntitlement = await _processDiscCachedEntitlement();\n                if (processedEntitlement) {\n                    return processedEntitlement;\n                }\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Clear cached entitlements and trigger change event\n     * Called when user logs out\n     */\n    async function clearEntitlements() {\n        if (cachedEntitlements) {\n            cachedEntitlements = undefined;\n            _debounceEntitlementsChanged();\n        }\n        // Reset device license state so it's re-evaluated on next entitlement check\n        deviceLicensePrimed = false;\n    }\n\n\n    /**\n     * Start the 10-minute interval timer for monitoring entitlements\n     */\n    function startEffectiveEntitlementsMonitor() {\n        // Reconcile effective entitlements from server. So the effective entitlements api injects trial\n        // entitlements data. but only the server fetch will trigger the entitlements change event.\n        // so in here, we observe the effective entitlements, and if the effective entitlements are changed,\n        // since the last triggered state, we trigger a change event. This only concerens with the effective\n        // entitlement changes. This will not logout the user if user logged out from the server admin panel,\n        // but his entitlements will be cleared by this call anyways.\n\n        // At app start we refresh entitlements, then only one each user action like user clicks on profile icon,\n        // or if some user hits some backend api, we will refresh entitlements. But here, we periodically refresh\n        // entitlements from the server every 10 minutes, but only trigger entitlement change events only if some\n        // effective entitlement(Eg. trial) data changed or any validity expired.\n        if(Phoenix.isTestWindow){\n            return;\n        }\n        setTimeout( async function() {\n            // prime the entitlement monitor with the current effective entitlements, after app start, the system would\n            // have resolved any existing login info by now and effective entitlements would be available if any.\n            lastRecordedState = await getEffectiveEntitlements(false);\n        }, 30000);\n        setInterval(async () => {\n            try {\n                // Get fresh effective entitlements\n                const freshEntitlements = await getEffectiveEntitlements(true);\n\n                // Check if we need to refresh\n                const expiredPlanName = KernalModeTrust.LoginUtils\n                    .validTillExpired(freshEntitlements, lastRecordedState);\n                const hasChanged = KernalModeTrust.LoginUtils\n                    .haveEntitlementsChanged(freshEntitlements, lastRecordedState);\n\n                if (expiredPlanName || hasChanged) {\n                    console.log(`Entitlements monitor detected changes, Expired: ${expiredPlanName},` +\n                        `changed: ${hasChanged} refreshing...`);\n                    Metrics.countEvent(Metrics.EVENT_TYPE.PRO, \"entRefresh\",\n                        expiredPlanName ? \"exp_\"+expiredPlanName : \"changed\");\n                    // if not logged in, the getEffectiveEntitlements will not trigger change even if some trial\n                    // entitlements changed. so we trigger a change anyway here. The debounce will take care of\n                    // multi fire and we are ok with multi fire 1 second apart.\n                    _debounceEntitlementsChanged();\n                }\n\n                // Update last recorded state\n                lastRecordedState = freshEntitlements;\n            } catch (error) {\n                console.error('Entitlements monitor error:', error);\n            }\n        }, TEN_MINUTES);\n\n        console.log('Entitlements monitor started (10-minute interval)');\n    }\n\n    function _validateAndFilterEntitlements(entitlements) {\n        if (!entitlements) {\n            return;\n        }\n\n        const currentDate = dateNowFn();\n\n        if(entitlements.plan && (!entitlements.plan.validTill || currentDate > entitlements.plan.validTill)) {\n            entitlements.plan = {\n                ...entitlements.plan,\n                isSubscriber: false,\n                paidSubscriber: false,\n                name: Strings.USER_FREE_PLAN_NAME_DO_NOT_TRANSLATE,\n                fullName: Strings.USER_FREE_PLAN_NAME_DO_NOT_TRANSLATE,\n                validTill: currentDate + (FREE_PLAN_VALIDITY_DAYS * MS_IN_DAY)\n            };\n        }\n\n        const featureEntitlements = entitlements.entitlements;\n        if (!featureEntitlements) {\n            return;\n        }\n\n        for(const featureName in featureEntitlements) {\n            const feature = featureEntitlements[featureName];\n            if(feature && (!feature.validTill || currentDate > feature.validTill)) {\n                feature.activated = false;\n                feature.upgradeToPlan = feature.upgradeToPlan || brackets.config.main_pro_plan;\n                feature.subscribeURL = feature.subscribeURL || brackets.config.purchase_url;\n                feature.validTill = feature.validTill || (currentDate - MS_IN_DAY);\n            }\n        }\n    }\n\n    /**\n     * Get effective entitlements for determining feature availability.\n     * This is for internal use only. All consumers in phoenix should use `KernalModeTrust.EntitlementsManager` APIs.\n     *\n     * @returns {Promise<Object|null>} Entitlements object or null if not logged in and no trial active\n     *\n     * @description Response shapes vary based on user state:\n     *\n     * **For non-logged-in users:**\n     * - Returns `null` if no trial is active\n     * - Returns synthetic entitlements if trial is active:\n     * ```javascript\n     * {\n     *   plan: {\n     *     isSubscriber: true,    // Always true for trial users\n     *     paidSubscriber: false, // if the user is a paid for the plan, or is it an unpaid promo\n     *     name: \"Phoenix Pro\"\n     *     fullName: \"Phoenix Pro\" // this can be deceptive name like \"Phoenix Pro For Education\" to use in\n     *                             // profile popup, not main branding\n     *   },\n     *   isInProTrial: true,        // Indicates this is a trial user\n     *   trialDaysRemaining: number, // Days left in trial\n     *   entitlements: {\n     *     liveEdit: {\n     *       activated: true        // Trial users get liveEdit access\n     *     }\n     *   }\n     * }\n     * ```\n     *\n     * **For logged-in trial users:**\n     * - If remote response has `plan.isSubscriber: false`, injects `isSubscriber: true`\n     * - Adds `isInProTrial: true` and `trialDaysRemaining`\n     * - Injects `entitlements.liveEdit.activated: true`\n     * - Note: Trial users may not be actual paid subscribers, but `isSubscriber: true` is set\n     *   so all Phoenix code treats them as subscribers. to check if they actually paid or not, use\n     *   `paidSubscriber` field.\n     *\n     * **For logged-in users (full remote response):**\n     * ```javascript\n     * {\n     *   isSuccess: boolean,\n     *   lang: string,\n     *   plan: {\n     *     name: \"Phoenix Pro\",\n     *     fullName: \"Phoenix Pro\" // this can be deceptive name like \"Phoenix Pro For Education\" to use in\n     *                            // profile popup, not main branding\n     *     isSubscriber: boolean,\n     *     paidSubscriber: boolean,\n     *     validTill: number        // Timestamp\n     *   },\n     *   profileview: {\n     *     quota: {\n     *       titleText: \"Ai Quota Used\",\n     *       usageText: \"100 / 200 credits\",\n     *       usedPercent: number\n     *     },\n     *     htmlMessage: string      // HTML alert message\n     *   },\n     *   entitlements: {\n     *     liveEdit: {\n     *       activated: boolean,\n     *       subscribeURL: string,  // URL to subscribe if not activated\n     *       upgradeToPlan: string, // Plan name that includes this entitlement\n     *       validTill: number      // Timestamp when entitlement expires\n     *     },\n     *     aiAgent: {\n     *       activated: boolean,\n     *       aiBrandName: string,\n     *       subscribeURL: string,\n     *       upgradeToPlan: string,\n     *       validTill: number,\n     *       upsellDialog: {\n     *           title: \"if activated is false, server can send a custom upsell dialog to show\",\n     *           message: \"this is the message to show\",\n     *           buyURL: \"if this url is present from server, this will be shown to as buy link\"\n     *       }\n     *     }\n     *   }\n     * }\n     * ```\n     *\n     * @example\n     * // Listen for entitlements changes\n     * const LoginService = window.KernelModeTrust.loginService;\n     * LoginService.on(LoginService.EVENT_ENTITLEMENTS_CHANGED, async() => {\n     *   const entitlements = await LoginService.getEffectiveEntitlements();\n     *   console.log('Entitlements changed:', entitlements);\n     *   // Update UI based on new entitlements\n     * });\n     *\n     * // Get current entitlements\n     * const entitlements = await LoginService.getEffectiveEntitlements();\n     * if (entitlements?.plan?.isSubscriber) {\n     *   // Enable pro features\n     * }\n     * if (entitlements?.entitlements?.liveEdit?.activated) {\n     *   // Enable live edit feature\n     * }\n     */\n    async function getEffectiveEntitlements(forceRefresh = false) {\n        // Get raw server entitlements\n        const serverEntitlements = await getEntitlements(forceRefresh);\n        _validateAndFilterEntitlements(serverEntitlements); // will prune invalid entitlements\n\n        // Get trial days remaining\n        const trialDaysRemaining = await LoginService.getProTrialDaysRemaining();\n\n        // If no trial is active, return server entitlements as-is\n        if (trialDaysRemaining <= 0) {\n            return serverEntitlements;\n        }\n\n        // now we need to grant trial, as user is entitled to trial if he is here.\n        // User has active server plan(either with login or device license)\n        if (serverEntitlements && serverEntitlements.plan) {\n            if (serverEntitlements.plan.isSubscriber) {\n                // Already a subscriber(or has device license), return as-is\n                // never inject trail data in this case.\n                return serverEntitlements;\n            }\n            // Enhance entitlements for trial user\n            // user in not a paid subscriber(nor he has device license), inject trial\n            return {\n                ...serverEntitlements,\n                plan: {\n                    ...serverEntitlements.plan,\n                    isSubscriber: true,\n                    paidSubscriber: serverEntitlements.plan.paidSubscriber || false,\n                    name: brackets.config.main_pro_plan,\n                    fullName: brackets.config.main_pro_plan,\n                    validTill: dateNowFn() + trialDaysRemaining * MS_IN_DAY\n                },\n                isInProTrial: true,\n                trialDaysRemaining: trialDaysRemaining,\n                entitlements: {\n                    ...serverEntitlements.entitlements,\n                    // below we only override things we grant in trial. AI which is not part of trial\n                    // is always server injected. the EntitlementsManager will resolve it appropriately.\n                    liveEdit: {\n                        activated: true,\n                        subscribeURL: brackets.config.purchase_url,\n                        upgradeToPlan: brackets.config.main_pro_plan,\n                        validTill: dateNowFn() + trialDaysRemaining * MS_IN_DAY\n                    }\n                }\n            };\n        }\n\n        // Non-logged-in, non licensed user with trial - return synthetic entitlements\n        return {\n            plan: {\n                isSubscriber: true,\n                paidSubscriber: false,\n                name: brackets.config.main_pro_plan,\n                fullName: brackets.config.main_pro_plan,\n                validTill: dateNowFn() + trialDaysRemaining * MS_IN_DAY\n            },\n            isInProTrial: true,\n            trialDaysRemaining: trialDaysRemaining,\n            entitlements: {\n                // below we only override things we grant in trial. AI which is not part of trial\n                // is always server injected. the EntitlementsManager will resolve it appropriately.\n                liveEdit: {\n                    activated: true,\n                    subscribeURL: brackets.config.purchase_url,\n                    upgradeToPlan: brackets.config.main_pro_plan,\n                    validTill: dateNowFn() + trialDaysRemaining * MS_IN_DAY\n                }\n            }\n        };\n    }\n\n    async function addDeviceLicense() {\n        deviceLicensePrimed = false;\n        PreferencesManager.stateManager.set(PREF_STATE_LICENSED_DEVICE_CHECK, true);\n        return NodeUtils.addDeviceLicenseSystemWide();\n    }\n\n    async function removeDeviceLicense() {\n        deviceLicensePrimed = false;\n        PreferencesManager.stateManager.set(PREF_STATE_LICENSED_DEVICE_CHECK, false);\n        return NodeUtils.removeDeviceLicenseSystemWide();\n    }\n\n    async function isLicensedDeviceSystemWide() {\n        return NodeUtils.isLicensedDeviceSystemWide();\n    }\n\n    let _isLicensedDeviceFlagForTest = false;\n\n    /**\n     * Checks if app is configured to check for device licenses at app start at system or user level.\n     *\n     * @returns {Promise<boolean>} - Resolves with `true` if the device is licensed, `false` otherwise.\n     */\n    async function isLicensedDevice() {\n        if(Phoenix.isTestWindow) {\n            return _isLicensedDeviceFlagForTest;\n        }\n        if(!Phoenix.isNativeApp) {\n            // browser app doesn't support device licence keys, obviously.\n            return false;\n        }\n        const userCheck = PreferencesManager.stateManager.get(PREF_STATE_LICENSED_DEVICE_CHECK);\n        const systemCheck = await isLicensedDeviceSystemWide();\n        return userCheck || systemCheck;\n    }\n\n    // Add functions to secure exports\n    LoginService.getEntitlements = getEntitlements;\n    LoginService.getEffectiveEntitlements = getEffectiveEntitlements;\n    LoginService.clearEntitlements = clearEntitlements;\n    LoginService.getSalt = getSalt;\n    LoginService.addDeviceLicense = addDeviceLicense;\n    LoginService.removeDeviceLicense = removeDeviceLicense;\n    LoginService.isLicensedDevice = isLicensedDevice;\n    LoginService.isLicensedDeviceSystemWide = isLicensedDeviceSystemWide;\n    LoginService.getDeviceID = getDeviceID;\n    LoginService.EVENT_ENTITLEMENTS_CHANGED = EVENT_ENTITLEMENTS_CHANGED;\n\n    async function handleReinstallCreds() {\n        if(!Phoenix.isNativeApp) {\n            throw new Error(\"Reinstall credentials is only available in native apps\");\n        }\n        try {\n            await KernalModeTrust.reinstallCreds();\n            console.log(\"Credentials reinstalled successfully\");\n        } catch (error) {\n            console.error(\"Error reinstalling credentials:\", error);\n            throw error;\n        }\n    }\n\n    let inited = false;\n    function init() {\n        if(inited){\n            return;\n        }\n        inited = true;\n        EntitlementsDirectImport.init();\n\n        // Register reinstall credentials command for native apps only\n        if(Phoenix.isNativeApp) {\n            CommandManager.register(\"Reinstall Credentials\", Commands.REINSTALL_CREDS, handleReinstallCreds);\n        }\n    }\n    // Test-only exports for integration testing\n    if (Phoenix.isTestWindow) {\n        window._test_login_service_exports = {\n            LoginService,\n            setIsLicensedDevice: function (_isLicensedDevice) {\n                _isLicensedDeviceFlagForTest = _isLicensedDevice;\n            },\n            setFetchFn: function (fn) {\n                fetchFn = fn;\n            },\n            setDateNowFn: function (fn) {\n                dateNowFn = fn;\n            },\n            _validateAndFilterEntitlements: _validateAndFilterEntitlements\n        };\n    }\n\n    // Start the entitlements monitor timer\n    startEffectiveEntitlementsMonitor();\n\n    exports.init = init;\n    // no public exports to prevent extension tampering\n});\n"],"file":"login-service.js"}