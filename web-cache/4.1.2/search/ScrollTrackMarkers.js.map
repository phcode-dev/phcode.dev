{"version":3,"sources":["search/ScrollTrackMarkers.js"],"names":["define","require","exports","module","_","EditorManager","WorkspaceManager","TRACK_STYLES","LINE","ON_LEFT","scrollbarTrackOffset","brackets","platform","MARKER_HEIGHT_LINE","MARKER_HEIGHT_LEFT","_getMarkerState","editor","_scrollTrackMarker","trackOffset","trackHt","marks","$currentTick","visible","resizeHandler","_getScrollbar","$","getRootElement","children","_calcScaling","markerState","$sb","trackHeight","offsetHeight","codeContainer","find","offsetTop","_getTop","pos","cm","_codeMirror","editorHt","getScrollerElement","scrollHeight","wrapping","getOption","cursorTop","singleLineH","defaultTextHeight","lineObj","getLineHandle","line","height","charCoords","top","heightAtLine","ratio","Math","round","_renderMarks","posArray","$track","markPositions","forEach","trackStyle","options","cssColorClass","isLineMarker","markerHeight","startPos","start","endPos","end","startY","_computeY","endY","topY","min","bottomY","max","push","bottom","isLine","sort","a","b","mergedLineMarks","mergedLeftMarks","mark","mergedMarks","length","last","html","map","m","join","cmPos","append","_showTrack","$scrollbar","$overlay","parent","debounce","empty","on","_hideTrack","remove","off","clear","markName","console","error","getActiveEditor","filter","name","clearAll","Error","setVisible","warn","_mergeMarks","markArray","ch","merged","current","addTickmarks","wasEmpty","newMarks","dontMerge","concat","_markCurrent","index","_getTickmarks","editorInstance"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated.\n * All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/**\n * Manages tickmarks shown along the scrollbar track.\n * NOT yet intended for use by anyone other than the internal modules.\n *\n * Modified to allow each Editor to store its own scroll track markers via\n * `editor._scrollTrackMarker`.\n *\n * Also modified so that the track visibility is managed automatically\n * based on whether there are tickmarks present. The `setVisible()` method\n * is now deprecated and should no longer be called directly.\n */\ndefine(function (require, exports, module) {\n\n    const _                 = require(\"thirdparty/lodash\"),\n        EditorManager     = require(\"editor/EditorManager\"),\n        WorkspaceManager  = require(\"view/WorkspaceManager\");\n\n    const TRACK_STYLES = {\n        LINE: \"line\",\n        ON_LEFT: \"left\"\n    };\n\n    /**\n     * Vertical space above/below the scrollbar (set per OS).\n     * This remains global but applies to all editors.\n     * @type {number}\n     */\n    let scrollbarTrackOffset;\n\n    // Initialize scrollbarTrackOffset based on platform\n    switch (brackets.platform) {\n    case \"win\": // Custom scrollbar CSS has no gap around the track\n        scrollbarTrackOffset = 0;\n        break;\n    case \"mac\": // Native scrollbar has padding around the track\n        scrollbarTrackOffset = 4;\n        break;\n    case \"linux\": // Custom scrollbar CSS has asymmetrical gap; approximate it\n        scrollbarTrackOffset = 2;\n        break;\n    }\n\n    /**\n     * The (fixed) height of each individual tickmark for \"line\" style.\n     * @const\n     */\n    const MARKER_HEIGHT_LINE = 2;\n\n    /**\n     * The (fixed) height of each individual tickmark for \"left\" style.\n     * @const\n     */\n    const MARKER_HEIGHT_LEFT = 5;\n\n\n    /**\n     * Helper: get or create the scrollTrackMarker state object for an editor.\n     * @param {!Editor} editor\n     * @return {Object} A state object stored in editor._scrollTrackMarker\n     */\n    function _getMarkerState(editor) {\n        if (!editor._scrollTrackMarker) {\n            editor._scrollTrackMarker = {\n                // Track geometry\n                trackOffset: 0,\n                trackHt: 0,\n\n                // All marker positions\n                marks: [],\n\n                // The \"current\" marked tick\n                $currentTick: null,\n\n                // Whether the track is currently visible\n                visible: false,\n\n                // Handler for resizing\n                resizeHandler: null\n            };\n        }\n        return editor._scrollTrackMarker;\n    }\n\n    /**\n     * Return the scrollbar element for the given editor.\n     * (Select only the direct descendant so we don't get nested inline editors).\n     * @param {!Editor} editor\n     * @return {jQueryObject}\n     */\n    function _getScrollbar(editor) {\n        return $(editor.getRootElement()).children(\".CodeMirror-vscrollbar\");\n    }\n\n    /**\n     * Measure and store the scrollbar track geometry in editor._scrollTrackMarker.\n     * @param {!Editor} editor\n     */\n    function _calcScaling(editor) {\n        const markerState = _getMarkerState(editor);\n        const $sb = _getScrollbar(editor);\n\n        const trackHeight = $sb[0].offsetHeight;\n        if (trackHeight > 0) {\n            markerState.trackOffset = scrollbarTrackOffset;\n            markerState.trackHt = trackHeight - markerState.trackOffset * 2;\n        } else {\n            // No scrollbar: use the height of the entire code content\n            const codeContainer = $(editor.getRootElement())\n                .find(\"> .CodeMirror-scroll > .CodeMirror-sizer > div > .CodeMirror-lines > div\")[0];\n            markerState.trackHt = codeContainer.offsetHeight;\n            markerState.trackOffset = codeContainer.offsetTop;\n        }\n    }\n\n    /**\n     * Compute the \"top\" position in the scrollbar track for a given text pos.\n     * @param {!Editor} editor\n     * @param {{line: number, ch: number}} pos\n     * @return {number} Y offset in scrollbar track\n     */\n    function _getTop(editor, pos) {\n        const cm = editor._codeMirror;\n        const markerState = _getMarkerState(editor);\n        const editorHt = cm.getScrollerElement().scrollHeight;\n        const wrapping = cm.getOption(\"lineWrapping\");\n\n        let cursorTop;\n        const singleLineH = wrapping && cm.defaultTextHeight() * 1.5;\n        const lineObj = cm.getLineHandle(pos.line);\n\n        if (wrapping && lineObj && lineObj.height > singleLineH) {\n            // For wrapped lines, measure the exact y-position of the character\n            cursorTop = cm.charCoords(pos, \"local\").top;\n        } else {\n            // For unwrapped lines or lines with default height\n            cursorTop = cm.heightAtLine(pos.line, \"local\");\n        }\n\n        const ratio = editorHt ? (cursorTop / editorHt) : 0;\n        // offset in the scrollbar track\n        return Math.round(ratio * markerState.trackHt) + markerState.trackOffset - 1;\n    }\n\n    /**\n     * Renders the given list of positions as merged tickmarks in the scrollbar track.\n     * @param {!Editor} editor\n     * @param {Array.<{line: number, ch: number}>} posArray\n     */\n    function _renderMarks(editor, posArray) {\n        const cm           = editor._codeMirror;\n        const markerState  = _getMarkerState(editor);\n        const $track       = $(\".tickmark-track\", editor.getRootElement());\n        const editorHt     = cm.getScrollerElement().scrollHeight;\n        const wrapping     = cm.getOption(\"lineWrapping\");\n\n        // We'll collect all the normalized (top, bottom) positions here\n        const markPositions = [];\n\n        posArray.forEach(function (pos) {\n            // Extract the style info\n            const trackStyle     = pos.options.trackStyle || TRACK_STYLES.LINE;\n            const cssColorClass  = pos.options.cssColorClass || \"\";\n\n            // Decide which marker height to use\n            const isLineMarker   = (trackStyle === TRACK_STYLES.LINE);\n            const markerHeight   = isLineMarker ? MARKER_HEIGHT_LINE : MARKER_HEIGHT_LEFT;\n\n            // We'll measure the 'start' of the range and the 'end' of the range\n            const startPos       = pos.start || pos;   // Fallback, in case it's single\n            const endPos         = pos.end   || pos;   // Fallback, in case it's single\n\n            // Compute the top offset for the start\n            const startY = _computeY(startPos);\n            // Compute the top offset for the end\n            const endY   = _computeY(endPos);\n\n            // Put them in ascending order\n            const topY    = Math.min(startY, endY);\n            const bottomY = Math.max(startY, endY) + markerHeight;\n\n            markPositions.push({\n                top: topY,\n                bottom: bottomY,\n                isLine: isLineMarker,\n                cssColorClass\n            });\n        });\n\n        // Merge/condense overlapping or adjacent segments, same as before\n        markPositions.sort(function (a, b) {\n            return a.top - b.top;\n        });\n\n        const mergedLineMarks = [];\n        const mergedLeftMarks = [];\n\n        markPositions.forEach(function (mark) {\n            const mergedMarks = mark.isLine ? mergedLineMarks : mergedLeftMarks;\n            if (mergedMarks.length > 0) {\n                const last = mergedMarks[mergedMarks.length - 1];\n                // If overlapping or adjacent, merge them\n                if (mark.top <= last.bottom + 1) {\n                    last.bottom = Math.max(last.bottom, mark.bottom);\n                    last.height = last.bottom - last.top;\n                    return;\n                }\n            }\n            mark.height = mark.bottom - mark.top;\n            mergedMarks.push(mark);\n        });\n\n        // Now render them into the DOM\n        // (1) For the \"line\" style\n        let html = mergedLineMarks.map(function (m) {\n            return `<div class='tickmark ${m.cssColorClass}'\n                     style='top: ${m.top}px; height: ${m.height}px;'></div>`;\n        }).join(\"\");\n        $track.append($(html));\n\n        // (2) For the \"left\" style\n        html = mergedLeftMarks.map(function (m) {\n            return `<div class='tickmark tickmark-side ${m.cssColorClass}'\n                     style='top: ${m.top}px; height: ${m.height}px;'></div>`;\n        }).join(\"\");\n        $track.append($(html));\n\n        /**\n         * Helper function to compute Y offset for a given {line, ch} position\n         */\n        function _computeY(cmPos) {\n            if (wrapping) {\n                // For wrapped lines, measure the exact Y-position in the editor\n                return cm.charCoords(cmPos, \"local\").top / editorHt * markerState.trackHt\n                    + markerState.trackOffset - 1;\n            }\n            // For unwrapped lines, we can do a simpler approach\n            const cursorTop = cm.heightAtLine(cmPos.line, \"local\");\n            const ratio     = editorHt ? (cursorTop / editorHt) : 0;\n            return Math.round(ratio * markerState.trackHt) + markerState.trackOffset - 1;\n        }\n    }\n\n\n    /**\n     * Private helper: Show the track if it's not already visible.\n     * @param {!Editor} editor\n     */\n    function _showTrack(editor) {\n        const markerState = _getMarkerState(editor);\n        if (markerState.visible) {\n            return; // Already visible\n        }\n        markerState.visible = true;\n\n        // Create the container track if not present\n        const $scrollbar = _getScrollbar(editor);\n        const $overlay   = $(\"<div class='tickmark-track'></div>\");\n        $scrollbar.parent().append($overlay);\n\n        // Calculate scaling\n        _calcScaling(editor);\n\n        // Resize handler (debounced)\n        markerState.resizeHandler = _.debounce(function () {\n            if (markerState.marks.length) {\n                _calcScaling(editor);\n                // Re-render\n                $(\".tickmark-track\", editor.getRootElement()).empty();\n                _renderMarks(editor, markerState.marks);\n            }\n        }, 300);\n\n        // Attach to workspace resizing\n        WorkspaceManager.on(\"workspaceUpdateLayout.ScrollTrackMarkers\", markerState.resizeHandler);\n    }\n\n    /**\n     * Private helper: Hide the track if it's visible, and remove all markup.\n     * @param {!Editor} editor\n     */\n    function _hideTrack(editor) {\n        const markerState = _getMarkerState(editor);\n        if (!markerState.visible) {\n            return; // Already hidden\n        }\n        markerState.visible = false;\n\n        // Remove the track markup\n        $(\".tickmark-track\", editor.getRootElement()).remove();\n\n        // Detach resizing\n        if (markerState.resizeHandler) {\n            WorkspaceManager.off(\"workspaceUpdateLayout.ScrollTrackMarkers\", markerState.resizeHandler);\n            markerState.resizeHandler = null;\n        }\n\n        // Clear marks data (since track is gone, no need to keep them)\n        markerState.marks = [];\n        if (markerState.$currentTick) {\n            markerState.$currentTick.remove();\n            markerState.$currentTick = null;\n        }\n    }\n\n    /**\n     * Clears tickmarks from the editor's tickmark track.\n     * - If `markName` is provided, only clears marks with that name.\n     * - If `markName` is omitted, clears **all unnamed marks** but leaves named marks.\n     * - To **clear all marks**, including named ones, use `clearAll()`.\n     * @param {!Editor} editor\n     * @param {string} [markName] Optional. If given, only clears marks with that name.\n     */\n    function clear(editor, markName) {\n        if (!editor) {\n            console.error(\"Calling ScrollTrackMarkers.clear without an editor instance is deprecated.\");\n            editor = EditorManager.getActiveEditor();\n        }\n        const markerState = editor && editor._scrollTrackMarker;\n        if (!markerState) {\n            return;\n        }\n\n        if (markName) {\n            // Filter out only the named marks that match the given `markName`\n            markerState.marks = markerState.marks.filter(mark => mark.options && mark.options.name !== markName);\n        } else {\n            // Remove only unnamed marks (marks where options.name is undefined or null)\n            markerState.marks = markerState.marks.filter(mark => mark.options && mark.options.name);\n        }\n\n        // After removing, either re-render or hide the track if no marks remain\n        if (markerState.marks.length === 0) {\n            _hideTrack(editor);\n        } else {\n            $(\".tickmark-track\", editor.getRootElement()).empty();\n            _renderMarks(editor, markerState.marks);\n        }\n\n        if (markerState.$currentTick && !markName) {\n            markerState.$currentTick.remove();\n            markerState.$currentTick = null;\n        }\n    }\n\n    /**\n     * Clears all tickmarks from the editor's tickmark track, including named and unnamed marks.\n     * @param {!Editor} editor\n     */\n    function clearAll(editor) {\n        if (!editor) {\n            throw new Error(\"Called ScrollTrackMarkers.clearAll without an editor!\");\n        }\n        const markerState = editor && editor._scrollTrackMarker;\n        if (!markerState) {\n            return;\n        }\n\n        // Completely remove all tickmarks\n        markerState.marks = [];\n        _hideTrack(editor);\n    }\n\n    /**\n     * DEPRECATED: Shows or hides the tickmark track for the given editor.\n     *\n     * The track is now automatically shown/hidden based on the presence of\n     * tickmarks. You generally no longer need to call this method.\n\n     * @deprecated\n     */\n    function setVisible() {\n        console.warn(\"DEPRECATED: ScrollTrackMarkers.setVisible() is no longer needed. \" +\n                     \"Track visibility is now managed automatically.\");\n    }\n\n    /**\n     * Merges an array of tickmark ranges if they are adjacent or overlapping in lines.\n     * All items are assumed to be in the shape:\n     *   {\n     *     start:  { line: number, ch: number },\n     *     end:    { line: number, ch: number },\n     *     options: Object\n     *   }\n     *\n     * @param {Array} markArray\n     * @return {Array} A new array with merged ranges.\n     */\n    function _mergeMarks(markArray) {\n        // 1) Sort by starting line (and ch if you want a finer sort)\n        markArray.sort((a, b) => {\n            if (a.start.line !== b.start.line) {\n                return a.start.line - b.start.line;\n            }\n            return a.start.ch - b.start.ch;\n        });\n\n        const merged = [];\n        let current  = null;\n\n        for (const mark of markArray) {\n            // If we're not currently building a merged range, start one\n            if (!current) {\n                current = {\n                    start: { ...mark.start },\n                    end: { ...mark.end   },\n                    options: mark.options\n                };\n            } else {\n                // Check if the new mark is adjacent or overlaps the current range\n                // i.e. if mark's start is <= current's end.line + 1\n                if (mark.start.line <= current.end.line + 1) {\n                    // Merge them by extending current.end if needed\n                    if (mark.end.line > current.end.line) {\n                        current.end.line = mark.end.line;\n                        current.end.ch   = mark.end.ch;\n                    } else if (mark.end.line === current.end.line && mark.end.ch > current.end.ch) {\n                        current.end.ch = mark.end.ch;\n                    }\n                    // If you need to unify other fields (like color classes),\n                    // decide how to handle current.options vs. mark.options here.\n                } else {\n                    // Not adjacent => push the old range and start a fresh one\n                    merged.push(current);\n                    current = {\n                        start: { ...mark.start },\n                        end: { ...mark.end   },\n                        options: mark.options\n                    };\n                }\n            }\n        }\n\n        // Flush any final in-progress range\n        if (current) {\n            merged.push(current);\n        }\n\n        return merged;\n    }\n\n    /**\n     * Adds tickmarks or range-markers for the given positions (or ranges) into the editor's tickmark track.\n     * If the track was not visible and new marks are added, it is automatically shown.\n     *\n     * @param {!Editor} editor\n     * @param {Array.<{line: number, ch: number} | {start: {line, ch}, end: {line, ch}}>} posArray\n     *     Each element can be:\n     *       (A) a single point: `{ line: number, ch: number }`, or\n     *       (B) a range: `{ start: { line, ch }, end: { line, ch } }`\n     * @param {Object} [options]\n     * @param {string} [options.name] Optionally assign a name to these marks and later selectively clear them.\n     * @param {string} [options.trackStyle] one of TRACK_STYLES.* (e.g., \"line\" or \"left\").\n     * @param {string} [options.cssColorClass] A CSS class that can override or extend styling.\n     * @param {string} [options.dontMerge] If set to true, will not merge nearby lines in posArray to single mark.\n     */\n    function addTickmarks(editor, posArray, options = {}) {\n        const markerState = _getMarkerState(editor);\n        if (!markerState) {\n            return;\n        }\n\n        // Keep track of whether the track was empty before adding marks\n        const wasEmpty = (markerState.marks.length === 0);\n\n        // Normalize each incoming item so that every mark has both {start, end} internally\n        const newMarks = posArray.map(pos => {\n            // If this looks like { start: {...}, end: {...} }, use it directly\n            if (pos.start && pos.end) {\n                return {\n                    start: pos.start,\n                    end: pos.end,\n                    options\n                };\n            }\n\n            // Otherwise assume it's a single point { line, ch }\n            // Treat it as a zero-length range\n            return {\n                start: pos,\n                end: pos,\n                options\n            };\n        });\n\n        const mergedMarks = options.dontMerge ? newMarks : _mergeMarks(newMarks);\n\n        // Concat the new marks onto the existing marks\n        markerState.marks = markerState.marks.concat(mergedMarks);\n\n        // If we were empty and now have marks, show the scroll track\n        if (wasEmpty && markerState.marks.length > 0) {\n            _showTrack(editor);\n        }\n\n        // If the track is visible, re-render everything\n        if (markerState.visible) {\n            $(\".tickmark-track\", editor.getRootElement()).empty();\n            _renderMarks(editor, markerState.marks);\n        }\n    }\n\n\n    /**\n     * Highlights the \"current\" tickmark at the given index (into the marks array provided to addTickmarks),\n     * or clears if `index === -1`.\n     * @param {number} index\n     * @param {!Editor} editor\n     * @private\n     */\n    function _markCurrent(index, editor) {\n        if (!editor) {\n            throw new Error(\n                \"Calling private API ScrollTrackMarkers._markCurrent without editor instance is deprecated.\");\n        }\n        const markerState = _getMarkerState(editor);\n\n        // Remove previous highlight\n        if (markerState.$currentTick) {\n            markerState.$currentTick.remove();\n            markerState.$currentTick = null;\n        }\n        if (index === -1 || !markerState.marks[index]) {\n            return;\n        }\n\n        // Position the highlight\n        const top = _getTop(editor, markerState.marks[index].start);\n        const $currentTick = $(\n            `<div class='tickmark tickmark-current' style='top: ${top}px; height: ${MARKER_HEIGHT_LINE}px;'></div>`\n        );\n\n        $(\".tickmark-track\", editor.getRootElement()).append($currentTick);\n        markerState.$currentTick = $currentTick;\n    }\n\n    /**\n     * Private helper for unit tests\n     * @param {!Editor} editorInstance\n     * @return {!Array.<{line: number, ch: number}>}\n     */\n    function _getTickmarks(editorInstance) {\n        const markerState = editorInstance && editorInstance._scrollTrackMarker;\n        return markerState ? markerState.marks : [];\n    }\n\n    // For unit tests\n    exports._getTickmarks  = _getTickmarks;\n\n    // private API\n    exports._markCurrent    = _markCurrent;\n\n    // deprecated public API\n    exports.setVisible     = setVisible; // Deprecated\n\n    // Public API\n    exports.addTickmarks   = addTickmarks;\n    exports.clear          = clear;\n    exports.clearAll       = clearAll;\n    exports.TRACK_STYLES   = TRACK_STYLES;\n});\n"],"file":"ScrollTrackMarkers.js"}