{"version":3,"sources":["document/DocumentCommandHandlers.js"],"names":["define","require","exports","module","AppInit","CommandManager","Commands","DeprecationWarning","EventDispatcher","ProjectManager","DocumentManager","MainViewManager","EditorManager","FileSystem","FileSystemError","FileUtils","FileViewController","InMemoryFile","StringUtils","Async","Metrics","Dialogs","DefaultDialogs","Strings","PopUpManager","PreferencesManager","PerfUtils","KeyEvent","Menus","UrlParams","StatusBar","WorkspaceManager","LanguageManager","NewFileContentManager","NodeConnector","NodeUtils","_","KernalModeTrust","window","Error","async","_resetTauriTrustRingBeforeRestart","dismantleKeyring","e","console","error","_$title","_$dirtydot","_$titleWrapper","_currentTitlePath","_osDash","brackets","platform","WINDOW_TITLE_STRING_NO_DOC","WINDOW_TITLE_STRING_DOC","_$titleContainerToolbar","_lastToolbarHeight","_nextUntitledIndexToUse","_isReloading","USER_CANCELED","userCanceled","definePreference","excludeFromHints","makeEventDispatcher","description","DESCRIPTION_EMMET","EMMET_COMMAND_ID","emmetCommand","register","CMD_TOGGLE_EMMET","toggleEmmet","set","get","setChecked","on","APP_QUIT_CANCELLED","_EVENT_OPEN_WITH_FILE_FROM_OS","_filesOpenedFromOsCount","handleFileSaveAs","DEFAULT_PROJECT_FILES","index.html","Newly_added_features.md","styles.css","script.js","METRIC_FILE_SAVE","METRIC_FILE_OPEN","METRIC_FILE_CLOSE","METRIC_FILE_OPEN_WS","_dpIfDefaultProjectEvent","eventCategory","filePath","projectRootPath","getProjectRoot","fullPath","startsWith","relativePath","path","relative","_fileOpened","addedToWorkingSet","encoding","language","getLanguageForPath","countEvent","EVENT_TYPE","EDITOR","_name","toLowerCase","_fileSavedMetrics","docToSave","fileType","file","_fileClosed","_path","size","stat","err","fileStat","valueOf","_sendData","fileSizeInKB","subType","fileSizeInMB","_updateTitle","currentDoc","getCurrentDocument","windowTitle","config","app_title","currentlyViewedFile","getCurrentlyViewedFile","ACTIVE_PANE","currentlyViewedPath","readOnlyString","readOnly","Phoenix","isNativeApp","text","attr","css","newWidth","width","newToolbarHeight","height","recomputeLayout","projectRoot","projectName","name","format","isDirty","app","setWindowTitle","_shortTitleForDocument","doc","isUntitled","substring","lastIndexOf","getDisplayPath","makeProjectRelativeIfPossible","handleCurrentFileChange","newFile","newDocument","getOpenDocumentForPath","handleDirtyChange","event","changedDoc","showFileOpenError","showModalDialog","DIALOG_ID_ERROR","ERROR_OPENING_FILE_TITLE","ERROR_OPENING_FILE","breakableUrl","getFileErrorString","_doOpen","silent","paneId","options","result","$","Deferred","getCurrentlyViewedPath","resolve","promise","_cleanup","fileError","fullFilePath","_removeView","getFileForPath","focusActivePane","reject","_showErrorAndCleanUp","done","perfTimerName","markStart","always","fileOpenTime","addMeasurement","valueEvent","PERFORMANCE","Number","_encoding","getViewState","STATE_PROJECT_CONTEXT","_open","fail","_defaultOpenDialogFullPath","_doOpenWithOptionalPath","showOpenDialog","OPEN_FILE","paths","length","filesToOpen","forEach","push","addListToWorkingSet","getDirectoryPath","then","_parseDecoratedPath","line","column","matchResult","exec","parseInt","handleFileOpen","commandData","fileInfo","noPaneActivate","setActivePaneId","getCurrentFullEditor","setCursorPos","handleDocumentOpen","handleFileAddToWorkingSetAndOpen","addToWorkingSet","index","forceRedraw","handleFileAddToWorkingSet","deprecationWarning","_getUntitledFileSuggestion","dir","baseFileName","isFolder","suggestedName","deferred","entry","getDirectoryForPath","exists","fileNewInProgress","_handleNewItemInProject","baseDirEntry","selected","getFileTreeContext","isFile","parentPath","UNTITLED","createWithSuggestedName","bind","undefined","createNewItem","fileOrStatus","getDocumentForPath","getInitialContentForFile","content","setText","forceFinishRename","handleFileNew","defaultExtension","createUntitledDocument","_edit","handleFileNewInProject","handleNewFolderInProject","_showSaveFileError","ERROR_SAVING_FILE_TITLE","ERROR_SAVING_FILE","alwaysOverwriteTillProjectSwitch","doSave","force","handleError","handleContentsModified","EXT_MODIFIED_TITLE","EXT_MODIFIED_WARNING","className","DIALOG_BTN_CLASS_LEFT","id","DIALOG_BTN_SAVE_AS","SAVE_AS","DIALOG_BTN_CLASS_NORMAL","DIALOG_BTN_CANCEL","CANCEL","ALWAYS_OVERWRITE","tooltip","EXT_ALWAYS_MODIFIED_BUTTON_TOOLTIP","DIALOG_BTN_CLASS_PRIMARY","DIALOG_BTN_OK","SAVE_AND_OVERWRITE","trySave","writeText","getText","notifySaved","CONTENTS_MODIFIED","isSaving","keepChangesTime","mtime","getTime","_doRevert","suppressError","readAsText","readTimestamp","refreshText","dispatchAppQuitCancelledEvent","trigger","_doSaveAs","settings","origPath","saveAsDefaultPath","defaultName","_doSaveAfterSaveDialog","_configureEditorAndResolve","editor","getActiveEditor","setSelections","selections","setScrollPos","scrollPos","x","y","openNewFile","fileOpenPromise","getFileSelectionFocus","PROJECT_MANAGER","setTimeout","openAndSelectDocument","info","findInAllWorkingSets","shift","setViewState","getBaseName","fileExtensions","getFileExtensions","showSaveDialog","SAVE_FILE_AS","selectedPath","handleFileSave","activeEditor","activeDoc","document","getSelections","getScrollPos","_saveFileList","fileList","filesAfterSave","doSequentially","savePromise","saveAll","getWorkingSet","ALL_PANES","handleFileSaveAll","closedFilesHistory","Map","_enableOrDisableReopenClosedCmd","FILE_REOPEN_CLOSED","setEnabled","_addToClosedFilesHistory","paneID","closeTime","Date","now","handleReopenClosed","leastRecentlyClosedPath","leastRecentlyClosedTime","paneToUse","closedFilePath","keys","currentScan","delete","getPaneCount","openFileAndAddToWorkingSet","handleFileClose","promptOnly","_forceClose","_spawnedRequest","activePaneID","getActivePaneId","doClose","_close","paneClosing","spawnedRequest","isExclusiveToPane","filename","DIALOG_ID_SAVE_CLOSE","SAVE_CLOSE_TITLE","SAVE_CLOSE_MESSAGE","DIALOG_BTN_DONTSAVE","DONT_SAVE","SAVE","_closeList","list","unsavedDocs","fileCloseArgs","message","SAVE_CLOSE_MULTI_MESSAGE","makeDialogFileList","map","listAfterSave","handleFileCloseAll","getAllOpenFiles","handleFileCloseList","_windowGoingAway","exitWaitPromises","_handleWindowGoingAway","postCloseHandler","failHandler","flushMetrics","execute","FILE_CLOSE_ALL","ex","handleAbortQuit","handleBeforeMenuPopup","handleFileCloseWindow","_forceQuitIfNeeded","closeSuccess","log","raceAgainstTime","PhStore","flushDB","finally","_safeNodeTerminate","closeWindow","newPhoenixWindow","cliArgsArray","cwd","innerWidth","innerHeight","openNewPhoenixEditorWindow","_fileExists","resolveAsync","_tryToOpenFile","absOrRelativePath","cwdIfRelativePath","fileToOpen","join","VFS","getTauriVirtualPath","jsPromise","warn","_openFilesPassedInFromCLI","args","cliArgs","getCommandLineArgs","openCount","i","fileArg","isOpened","PLATFORM","_safeCheckFileAndGetVirtualPath","relativeToDir","fileToCheck","fileExists","_singleInstanceHandler","isPrimary","isPrimaryDesktopPhoenixWindow","focusWindow","handleFileNewWindow","handleFileRename","getContext","renameItemInline","_addedNavKeyHandler","detectDocumentNavEnd","keyCode","DOM_VK_CONTROL","endTraversal","body","off","goNextPrevDoc","inc","listOrder","traverseToNextViewInListOrder","traverseToNextViewByMRU","beginTraversal","FILE_OPEN","keyup","handleGoNextDoc","handleGoPrevDoc","handleGoNextDocListOrder","handleGoPrevDocListOrder","handleShowInTree","activeFile","showInTree","_getDeleteMessageTemplate","canMoveToTrash","CONFIRM_FILE_DELETE_RECYCLE_BIN","CONFIRM_FOLDER_DELETE_RECYCLE_BIN","CONFIRM_FILE_DELETE_TRASH","CONFIRM_FOLDER_DELETE_TRASH","CONFIRM_FILE_DELETE","CONFIRM_FOLDER_DELETE","_getDeleteButtonString","MOVE_TO_RECYCLE_BIN","MOVE_TO_TRASH","DELETE","handleFileDelete","getSelectedItem","DIALOG_ID_EXT_DELETED","CONFIRM_DELETE_TITLE","getProjectRelativePath","moveToTrash","deleteItem","handleShowInOS","openPathInFileBrowser","catch","openDefaultTerminal","openNativeTerminal","openPowerShell","openDefaultApp","openInDefaultApp","timeout","timeoutPromise","Promise","_resolve","race","browserReload","href","getAllMenus","value","key","removeMenu","fragment","indexOf","substr","all","location","handleReload","loadWithoutExtensions","loadDevExtensionPath","params","_removeLoadDevExtensionPathParam","remove","logger","loggingOptions","LOCAL_STORAGE_KEYS","LOG_TO_CONSOLE_KEY","parse","put","isEmpty","toString","handleReloadWithoutExts","partial","attachBrowserUnloadHandler","onbeforeunload","closeFail","openDocs","getAllOpenDocuments","filter","WINDOW_UNLOAD_WARNING_WITH_UNSAVED_CHANGES","WINDOW_UNLOAD_WARNING","_safeFlushDB","nodeTerminateDueToShutdown","closeInProgress","terminateNode","nodeTerminationPromise","NODEJS","fs","forceUseNodeWSEndpoint","showErrorDialog","ERROR_NODE_JS_CRASH_TITLE","ERROR_NODE_JS_CRASH_MESSAGE","closeClickCounter","CLOSE_TIMER_RESET_INTERVAL","closeTimer","isTestWindow","clearTimeout","setInterval","attachTauriUnloadHandler","__TAURI__","appWindow","onCloseRequested","preventDefault","URLSearchParams","search","htmlReady","$icon","$indicator","STATUSBAR_USER_EXTENSIONS_DISABLED","FILE_EXTENSION_MANAGER","display","addIndicator","isSpecRunnerWindow","firstProjectOpenHandled","EVENT_AFTER_PROJECT_OPEN","setSingleInstanceCLIArgsHandler","EVENT_AFTER_STARTUP_FILES_LOADED","quitString","CMD_QUIT","showInOS","CMD_SHOW_IN_FILE_MANAGER","defaultTerminal","CMD_OPEN_IN_TERMINAL_DO_NOT_TRANSLATE","CMD_EXIT","CMD_SHOW_IN_EXPLORER","CMD_OPEN_IN_CMD","CMD_SHOW_IN_FINDER","_isOpenWithFileFromOS","CMD_ADD_TO_WORKING_SET","FILE_ADD_TO_WORKING_SET","CMD_FILE_OPEN","CMD_ADD_TO_WORKINGSET_AND_OPEN","CMD_OPEN","CMD_FILE_NEW_UNTITLED","FILE_NEW_UNTITLED","CMD_FILE_NEW","FILE_NEW","CMD_FILE_NEW_FOLDER","FILE_NEW_FOLDER","CMD_FILE_SAVE","FILE_SAVE","CMD_FILE_SAVE_ALL","FILE_SAVE_ALL","CMD_FILE_SAVE_AS","FILE_SAVE_AS","CMD_FILE_RENAME","FILE_RENAME","CMD_FILE_DELETE","FILE_DELETE","CMD_FILE_CLOSE","FILE_CLOSE","CMD_FILE_CLOSE_ALL","CMD_FILE_CLOSE_LIST","FILE_CLOSE_LIST","CMD_REOPEN_CLOSED","CMD_NEXT_DOC","NAVIGATE_NEXT_DOC","CMD_PREV_DOC","NAVIGATE_PREV_DOC","CMD_NEXT_DOC_LIST_ORDER","NAVIGATE_NEXT_DOC_LIST_ORDER","CMD_PREV_DOC_LIST_ORDER","NAVIGATE_PREV_DOC_LIST_ORDER","NAVIGATE_SHOW_IN_OS","NAVIGATE_OPEN_IN_TERMINAL","CMD_OPEN_IN_POWER_SHELL","NAVIGATE_OPEN_IN_POWERSHELL","CMD_OPEN_IN_DEFAULT_APP","NAVIGATE_OPEN_IN_DEFAULT_APP","CMD_NEW_BRACKETS_WINDOW","FILE_NEW_WINDOW","FILE_QUIT","CMD_SHOW_IN_TREE","NAVIGATE_SHOW_IN_FILE_TREE","registerInternal","APP_ABORT_QUIT","APP_BEFORE_MENUPOPUP","FILE_CLOSE_WINDOW","APP_RELOAD","APP_RELOAD_WITHOUT_EXTS"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n// jshint ignore: start\n/*jslint regexp: true */\n/*globals logger, jsPromise, path*/\n\ndefine(function (require, exports, module) {\n\n\n    // Load dependent modules\n    const AppInit             = require(\"utils/AppInit\"),\n        CommandManager      = require(\"command/CommandManager\"),\n        Commands            = require(\"command/Commands\"),\n        DeprecationWarning  = require(\"utils/DeprecationWarning\"),\n        EventDispatcher     = require(\"utils/EventDispatcher\"),\n        ProjectManager      = require(\"project/ProjectManager\"),\n        DocumentManager     = require(\"document/DocumentManager\"),\n        MainViewManager     = require(\"view/MainViewManager\"),\n        EditorManager       = require(\"editor/EditorManager\"),\n        FileSystem          = require(\"filesystem/FileSystem\"),\n        FileSystemError     = require(\"filesystem/FileSystemError\"),\n        FileUtils           = require(\"file/FileUtils\"),\n        FileViewController  = require(\"project/FileViewController\"),\n        InMemoryFile        = require(\"document/InMemoryFile\"),\n        StringUtils         = require(\"utils/StringUtils\"),\n        Async               = require(\"utils/Async\"),\n        Metrics             = require(\"utils/Metrics\"),\n        Dialogs             = require(\"widgets/Dialogs\"),\n        DefaultDialogs      = require(\"widgets/DefaultDialogs\"),\n        Strings             = require(\"strings\"),\n        PopUpManager        = require(\"widgets/PopUpManager\"),\n        PreferencesManager  = require(\"preferences/PreferencesManager\"),\n        PerfUtils           = require(\"utils/PerfUtils\"),\n        KeyEvent            = require(\"utils/KeyEvent\"),\n        Menus               = require(\"command/Menus\"),\n        UrlParams           = require(\"utils/UrlParams\").UrlParams,\n        StatusBar           = require(\"widgets/StatusBar\"),\n        WorkspaceManager    = require(\"view/WorkspaceManager\"),\n        LanguageManager     = require(\"language/LanguageManager\"),\n        NewFileContentManager     = require(\"features/NewFileContentManager\"),\n        NodeConnector = require(\"NodeConnector\"),\n        NodeUtils           = require(\"utils/NodeUtils\"),\n        _                   = require(\"thirdparty/lodash\");\n\n    const KernalModeTrust = window.KernalModeTrust;\n    if(!KernalModeTrust){\n        throw new Error(\"KernalModeTrust is not defined. Cannot boot without trust ring\");\n    }\n    async function _resetTauriTrustRingBeforeRestart() {\n        // This is needed as if for a given tauri window, the trust ring can only be set once. So reloading the app\n        // in the same window, tauri will deny setting new keys.\n        // this is a security measure to prevent a malicious extension from setting its own key.\n        try {\n            await KernalModeTrust.dismantleKeyring();\n        } catch (e) {\n            console.error(\"Error while resetting trust ring before restart\", e);\n        }\n    }\n\n    /**\n     * Handlers for commands related to document handling (opening, saving, etc.)\n     */\n\n    /**\n     * Container for label shown above editor; must be an inline element\n     * @type {jQueryObject}\n     */\n    var _$title = null;\n\n    /**\n     * Container for dirty dot; must be an inline element\n     * @type {jQueryObject}\n     */\n    var _$dirtydot = null;\n\n    /**\n     * Container for _$title; need not be an inline element\n     * @type {jQueryObject}\n     */\n    var _$titleWrapper = null;\n\n    /**\n     * Label shown above editor for current document: filename and potentially some of its path\n     * @type {string}\n     */\n    var _currentTitlePath = null;\n\n    /**\n     * Determine the dash character for each platform. Use emdash on Mac\n     * and a standard dash on all other platforms.\n     * @type {string}\n     */\n    var _osDash = brackets.platform === \"mac\" ? \"\\u2014\" : \"-\";\n\n    /**\n     * String template for window title when no file is open.\n     * @type {string}\n     */\n    var WINDOW_TITLE_STRING_NO_DOC = \"{0} \" + _osDash + \" {1}\";\n\n    /**\n    * String template for window title when a file is open.\n    * @type {string}\n    */\n    var WINDOW_TITLE_STRING_DOC = \"{0} \" + _osDash + \" {1}\";\n\n    /**\n     * Container for _$titleWrapper; if changing title changes this element's height, must kick editor to resize\n     * @type {jQueryObject}\n     */\n    var _$titleContainerToolbar = null;\n\n    /**\n     * Last known height of _$titleContainerToolbar\n     * @type {number}\n     */\n    var _lastToolbarHeight = null;\n\n    /**\n     * index to use for next, new Untitled document\n     * @type {number}\n     */\n    var _nextUntitledIndexToUse = 1;\n\n    /**\n     * prevents reentrancy of browserReload()\n     * @type {boolean}\n     */\n    var _isReloading = false;\n\n    /** Unique token used to indicate user-driven cancellation of Save As (as opposed to file IO error) */\n    var USER_CANCELED = { userCanceled: true };\n\n    PreferencesManager.definePreference(\"defaultExtension\", \"string\", \"\", {\n        excludeFromHints: true\n    });\n    EventDispatcher.makeEventDispatcher(exports);\n\n\n    PreferencesManager.definePreference(\"emmet\", \"boolean\", true, {\n        description: Strings.DESCRIPTION_EMMET\n    });\n\n    // Register the Emmet toggle command\n    const EMMET_COMMAND_ID = \"edit.emmet\";\n    const emmetCommand = CommandManager.register(Strings.CMD_TOGGLE_EMMET, EMMET_COMMAND_ID, toggleEmmet);\n\n    // Set initial state based on the preference\n    emmetCommand.setChecked(PreferencesManager.get(\"emmet\"));\n\n    // Helper function to toggle the Emmet preference\n    function toggleEmmet() {\n        PreferencesManager.set(\"emmet\", !PreferencesManager.get(\"emmet\"));\n        emmetCommand.setChecked(PreferencesManager.get(\"emmet\"));\n    }\n\n    // Listen for any change in the \"emmet\" preference and update the menu's toggle state\n    // this is needed because else the menu is not getting updated when the preference is changed\n    PreferencesManager.on(\"change\", \"emmet\", function () {\n        emmetCommand.setChecked(PreferencesManager.get(\"emmet\"));\n    });\n\n    /**\n     * Event triggered when File Save is cancelled, when prompted to save dirty files\n     */\n    const APP_QUIT_CANCELLED = \"appQuitCancelled\";\n    // private event emitted when a file is opened via user right-clicking a file from the os explorer in phcode.\n    const _EVENT_OPEN_WITH_FILE_FROM_OS = \"_openWithFileFromOS\";\n    let _filesOpenedFromOsCount = 0;\n\n\n    /**\n     * JSLint workaround for circular dependency\n     * @type {function}\n     */\n    let handleFileSaveAs;\n\n    // these are files that should be treated separately in metrics for open files.\n    const DEFAULT_PROJECT_FILES = {\n        \"index.html\": true,\n        \"Newly_added_features.md\": true,\n        \"styles.css\": true,\n        \"script.js\": true\n    };\n\n    const METRIC_FILE_SAVE = \"fileSave\",\n        METRIC_FILE_OPEN = \"fileOpen\",\n        METRIC_FILE_CLOSE = \"fileClose\",\n        METRIC_FILE_OPEN_WS = \"fileAddWorkingSet\";\n    function _dpIfDefaultProjectEvent(eventCategory, filePath) {\n        const projectRootPath = ProjectManager.getProjectRoot().fullPath;\n        if(filePath && filePath.startsWith(projectRootPath)){\n            const relativePath = path.relative(projectRootPath, filePath);\n            if(DEFAULT_PROJECT_FILES[relativePath] || relativePath.startsWith(\"images\")){\n                return eventCategory === METRIC_FILE_SAVE ? \"defaultFileSave\" : \"defaultFileOp\";\n            }\n        }\n        return `${eventCategory}`;\n    }\n\n    /**\n     * For analytics. Whenever a file is opened call this function. The function will record the number of times\n     * the standard file types have been opened. We only log the standard filetypes\n     * @param {String} filePath          The path of the file to be registered\n     * @param {boolean} addedToWorkingSet set to true if extensions of files added to the\n     *                                    working set needs to be logged\n     */\n    function _fileOpened(filePath, addedToWorkingSet, encoding) {\n        let language = LanguageManager.getLanguageForPath(filePath);\n\n        Metrics.countEvent(Metrics.EVENT_TYPE.EDITOR,\n            _dpIfDefaultProjectEvent(\"fileEncoding\", filePath), encoding || 'UTF-8');\n        if(addedToWorkingSet){\n            Metrics.countEvent(Metrics.EVENT_TYPE.EDITOR,\n                _dpIfDefaultProjectEvent(METRIC_FILE_OPEN_WS, filePath), language._name.toLowerCase());\n        } else {\n            Metrics.countEvent(Metrics.EVENT_TYPE.EDITOR,\n                _dpIfDefaultProjectEvent(METRIC_FILE_OPEN, filePath), language._name.toLowerCase());\n        }\n    }\n\n    /**\n     * For analytics. Whenever a file is saved call this function.\n     * The function will send the analytics Data\n     * We only log the standard filetypes and fileSize\n     * @param {Document} docToSave The path of the file to be registered\n     */\n    function _fileSavedMetrics(docToSave) {\n        if (!docToSave) {\n            return;\n        }\n        let fileType = docToSave.language ? docToSave.language._name : \"\";\n        Metrics.countEvent(Metrics.EVENT_TYPE.EDITOR,\n            _dpIfDefaultProjectEvent(METRIC_FILE_SAVE, docToSave.file && docToSave.file.fullPath), fileType);\n    }\n\n    /**\n     * For analytics. Whenever a file is closed call this function.\n     * The function will send the analytics Data.\n     * We only log the standard filetypes and fileSize\n     * @param {File} file The path of the file to be registered\n     */\n    function _fileClosed(file) {\n        if (!file) {\n            return;\n        }\n        var language = LanguageManager.getLanguageForPath(file._path),\n            size = -1;\n\n        function _sendData(fileSizeInKB) {\n            let subType = \"\",\n                fileSizeInMB = fileSizeInKB/1024;\n\n            if(fileSizeInMB <= 1) {\n                // We don't log exact file sizes for privacy.\n                if(fileSizeInKB < 0) {\n                    subType = \"\";\n                }\n                if(fileSizeInKB <= 10) {\n                    subType = \"0_to_10KB\";\n                } else if (fileSizeInKB <= 50) {\n                    subType = \"10_to_50KB\";\n                } else if (fileSizeInKB <= 100) {\n                    subType = \"50_to_100KB\";\n                } else if (fileSizeInKB <= 500) {\n                    subType = \"100_to_500KB\";\n                } else {\n                    subType = \"500KB_to_1MB\";\n                }\n\n            } else {\n                if(fileSizeInMB <= 2) {\n                    subType = \"1_to_2MB\";\n                } else if(fileSizeInMB <= 5) {\n                    subType = \"2_to_5MB\";\n                } else if(fileSizeInMB <= 10) {\n                    subType = \"5_to_10MB\";\n                } else {\n                    subType = \"Above_10MB\";\n                }\n            }\n\n            Metrics.countEvent(Metrics.EVENT_TYPE.EDITOR,\n                _dpIfDefaultProjectEvent(METRIC_FILE_CLOSE, file.fullPath),\n                `${language._name.toLowerCase()}.${subType}`);\n        }\n\n        file.stat(function(err, fileStat) {\n            if(!err) {\n                size = fileStat.size.valueOf()/1024;\n            }\n            _sendData(size);\n        });\n    }\n\n    /**\n     * Updates the title bar with new file title or dirty indicator\n     * @private\n     */\n    function _updateTitle() {\n        var currentDoc          = DocumentManager.getCurrentDocument(),\n            windowTitle         = brackets.config.app_title,\n            currentlyViewedFile = MainViewManager.getCurrentlyViewedFile(MainViewManager.ACTIVE_PANE),\n            currentlyViewedPath = currentlyViewedFile && currentlyViewedFile.fullPath,\n            readOnlyString      = (currentlyViewedFile && currentlyViewedFile.readOnly) ? \"[Read Only] - \" : \"\";\n\n\n        if (currentlyViewedPath) {\n            if(!Phoenix.isNativeApp) {\n                // in native app, the app titlebar will have the file name and the title text section in not there.\n                _$title.text(_currentTitlePath);\n            }\n            _$title.attr(\"title\", currentlyViewedPath);\n            if (currentDoc) {\n                // dirty dot is always in DOM so layout doesn't change, and visibility is toggled\n                _$dirtydot.css(\"visibility\", (currentDoc.isDirty) ? \"visible\" : \"hidden\");\n            } else {\n                // hide dirty dot if there is no document\n                _$dirtydot.css(\"visibility\", \"hidden\");\n            }\n        } else {\n            _$title.text(\"\");\n            _$title.attr(\"title\", \"\");\n            _$dirtydot.css(\"visibility\", \"hidden\");\n        }\n\n        // Set _$titleWrapper to a fixed width just large enough to accommodate _$title. This seems equivalent to what\n        // the browser would do automatically, but the CSS trick we use for layout requires _$titleWrapper to have a\n        // fixed width set on it (see the \"#titlebar\" CSS rule for details).\n        _$titleWrapper.css(\"width\", \"\");\n        var newWidth = _$title.width();\n        _$titleWrapper.css(\"width\", newWidth);\n\n        // Changing the width of the title may cause the toolbar layout to change height, which needs to resize the\n        // editor beneath it (toolbar changing height due to window resize is already caught by EditorManager).\n        var newToolbarHeight = _$titleContainerToolbar.height();\n        if (_lastToolbarHeight !== newToolbarHeight) {\n            _lastToolbarHeight = newToolbarHeight;\n            WorkspaceManager.recomputeLayout();\n        }\n\n\n        var projectRoot = ProjectManager.getProjectRoot();\n        if (projectRoot) {\n            var projectName = projectRoot.name;\n            // Construct shell/browser window title, e.g. \" index.html (myProject)  Brackets\"\n            if (currentlyViewedPath) {\n                windowTitle = StringUtils.format(WINDOW_TITLE_STRING_DOC, readOnlyString + projectName, _currentTitlePath);\n                // Display dirty dot when there are unsaved changes\n                if (currentDoc && currentDoc.isDirty) {\n                    windowTitle = \" \" + windowTitle;\n                }\n            } else {\n                // A document is not open\n                windowTitle = StringUtils.format(WINDOW_TITLE_STRING_NO_DOC, projectName, brackets.config.app_title);\n            }\n        }\n        Phoenix.app.setWindowTitle(windowTitle);\n    }\n\n    /**\n     * Returns a short title for a given document.\n     *\n     * @param {Document} doc - the document to compute the short title for\n     * @return {string} - a short title for doc.\n     */\n    function _shortTitleForDocument(doc) {\n        var fullPath = doc.file.fullPath;\n\n        // If the document is untitled then return the filename, (\"Untitled-n.ext\");\n        // otherwise show the project-relative path if the file is inside the\n        // current project or the full absolute path if it's not in the project.\n        if (doc.isUntitled()) {\n            return fullPath.substring(fullPath.lastIndexOf(\"/\") + 1);\n        }\n        return Phoenix.app.getDisplayPath(ProjectManager.makeProjectRelativeIfPossible(fullPath));\n\n    }\n\n    /**\n     * Handles currentFileChange and filenameChanged events and updates the titlebar\n     */\n    function handleCurrentFileChange() {\n        var newFile = MainViewManager.getCurrentlyViewedFile(MainViewManager.ACTIVE_PANE);\n\n        if (newFile) {\n            var newDocument = DocumentManager.getOpenDocumentForPath(newFile.fullPath);\n\n            if (newDocument) {\n                _currentTitlePath = _shortTitleForDocument(newDocument);\n            } else {\n                const filePath = ProjectManager.makeProjectRelativeIfPossible(newFile.fullPath);\n                _currentTitlePath = Phoenix.app.getDisplayPath(filePath);\n            }\n        } else {\n            _currentTitlePath = null;\n        }\n\n        // Update title text & \"dirty dot\" display\n        _updateTitle();\n    }\n\n    /**\n     * Handles dirtyFlagChange event and updates the title bar if necessary\n     */\n    function handleDirtyChange(event, changedDoc) {\n        var currentDoc = DocumentManager.getCurrentDocument();\n\n        if (currentDoc && changedDoc.file.fullPath === currentDoc.file.fullPath) {\n            _updateTitle();\n        }\n    }\n\n    /**\n     * Shows an error dialog indicating that the given file could not be opened due to the given error\n     * @param {!FileSystemError} name\n     * @return {!Dialog}\n     */\n    function showFileOpenError(name, path) {\n        return Dialogs.showModalDialog(\n            DefaultDialogs.DIALOG_ID_ERROR,\n            Strings.ERROR_OPENING_FILE_TITLE,\n            StringUtils.format(\n                Strings.ERROR_OPENING_FILE,\n                StringUtils.breakableUrl(path),\n                FileUtils.getFileErrorString(name)\n            )\n        );\n    }\n\n    /**\n     * @private\n     * Creates a document and displays an editor for the specified file path.\n     * @param {!string} fullPath\n     * @param {boolean=} silent If true, don't show error message\n     * @param {string=} paneId, the id oi the pane in which to open the file. Can be undefined, a valid pane id or ACTIVE_PANE.\n     * @param {{*}=} options, command options\n     * @return {$.Promise} a jQuery promise that will either\n     * - be resolved with a file for the specified file path or\n     * - be rejected with FileSystemError if the file can not be read.\n     * If paneId is undefined, the ACTIVE_PANE constant\n     */\n    function _doOpen(fullPath, silent, paneId, options) {\n        var result = new $.Deferred();\n\n        // workaround for https://github.com/adobe/brackets/issues/6001\n        // TODO should be removed once bug is closed.\n        // if we are already displaying a file do nothing but resolve immediately.\n        // this fixes timing issues in test cases.\n        if (MainViewManager.getCurrentlyViewedPath(paneId || MainViewManager.ACTIVE_PANE) === fullPath) {\n            result.resolve(MainViewManager.getCurrentlyViewedFile(paneId || MainViewManager.ACTIVE_PANE));\n            return result.promise();\n        }\n\n        function _cleanup(fileError, fullFilePath) {\n            if (fullFilePath) {\n                // For performance, we do lazy checking of file existence, so it may be in workingset\n                MainViewManager._removeView(paneId, FileSystem.getFileForPath(fullFilePath));\n                MainViewManager.focusActivePane();\n            }\n            result.reject(fileError);\n        }\n        function _showErrorAndCleanUp(fileError, fullFilePath) {\n            if (silent) {\n                _cleanup(fileError, fullFilePath);\n            } else {\n                showFileOpenError(fileError, fullFilePath).done(function () {\n                    _cleanup(fileError, fullFilePath);\n                });\n            }\n        }\n\n        if (!fullPath) {\n            throw new Error(\"_doOpen() called without fullPath\");\n        } else {\n            var perfTimerName = PerfUtils.markStart(\"Open File:\\t\" + fullPath);\n            result.always(function () {\n                let fileOpenTime = PerfUtils.addMeasurement(perfTimerName);\n                Metrics.valueEvent(Metrics.EVENT_TYPE.PERFORMANCE, \"fileOpen\",\n                    \"timeMs\", Number(fileOpenTime));\n            });\n\n            var file = FileSystem.getFileForPath(fullPath);\n            if (options && options.encoding) {\n                file._encoding = options.encoding;\n            } else {\n                const encoding = PreferencesManager.getViewState(\"encoding\", PreferencesManager.STATE_PROJECT_CONTEXT);\n                if (encoding && encoding[fullPath]) {\n                    file._encoding = encoding[fullPath];\n                }\n            }\n            MainViewManager._open(paneId, file, options)\n                .done(function () {\n                    result.resolve(file);\n                })\n                .fail(function (fileError) {\n                    _showErrorAndCleanUp(fileError, fullPath);\n                    result.reject();\n                });\n        }\n\n        return result.promise();\n    }\n\n    /**\n     * @private\n     * Used to track the default directory for the file open dialog\n     */\n    var _defaultOpenDialogFullPath = null;\n\n    /**\n     * @private\n     * Opens a file and displays its view (editor, image view, etc...) for the specified path.\n     * If no path is specified, a file prompt is provided for input.\n     * @param {?string} fullPath - The path of the file to open; if it's null we'll prompt for it\n     * @param {boolean=} silent - If true, don't show error message\n     * @param {string=}  paneId - the pane in which to open the file. Can be undefined, a valid pane id or ACTIVE_PANE\n     * @param {{*}=} options - options to pass to MainViewManager._open\n     * @return {$.Promise} a jQuery promise resolved with a Document object or\n     *                      rejected with an err\n     */\n    function _doOpenWithOptionalPath(fullPath, silent, paneId, options) {\n        var result;\n        paneId = paneId || MainViewManager.ACTIVE_PANE;\n        if (!fullPath) {\n            // Create placeholder deferred\n            result = new $.Deferred();\n\n            //first time through, default to the current project path\n            if (!_defaultOpenDialogFullPath) {\n                _defaultOpenDialogFullPath = ProjectManager.getProjectRoot().fullPath;\n            }\n            // Prompt the user with a dialog\n            FileSystem.showOpenDialog(true, false, Strings.OPEN_FILE, _defaultOpenDialogFullPath, null, function (err, paths) {\n                if (!err) {\n                    if (paths.length > 0) {\n                        // Add all files to the workingset without verifying that\n                        // they still exist on disk (for faster opening)\n                        var filesToOpen = [];\n\n                        paths.forEach(function (path) {\n                            filesToOpen.push(FileSystem.getFileForPath(path));\n                        });\n                        MainViewManager.addListToWorkingSet(paneId, filesToOpen);\n\n                        _doOpen(paths[paths.length - 1], silent, paneId, options)\n                            .done(function (file) {\n                                _defaultOpenDialogFullPath =\n                                    FileUtils.getDirectoryPath(\n                                        MainViewManager.getCurrentlyViewedPath(paneId)\n                                    );\n                            })\n                            // Send the resulting document that was opened\n                            .then(result.resolve, result.reject);\n                    } else {\n                        // Reject if the user canceled the dialog\n                        result.reject();\n                    }\n                }\n            });\n        } else {\n            result = _doOpen(fullPath, silent, paneId, options);\n        }\n\n        return result.promise();\n    }\n\n    /**\n     * @private\n     * Splits a decorated file path into its parts.\n     * @param {?string} path - a string of the form \"fullpath[:lineNumber[:columnNumber]]\"\n     * @return {{path: string, line: ?number, column: ?number}}\n     */\n    function _parseDecoratedPath(path) {\n        var result = {path: path, line: null, column: null};\n        if (path) {\n            // If the path has a trailing :lineNumber and :columnNumber, strip\n            // these off and assign to result.line and result.column.\n            var matchResult = /(.+?):([0-9]+)(:([0-9]+))?$/.exec(path);\n            if (matchResult) {\n                result.path = matchResult[1];\n                if (matchResult[2]) {\n                    result.line = parseInt(matchResult[2], 10);\n                }\n                if (matchResult[4]) {\n                    result.column = parseInt(matchResult[4], 10);\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @typedef {{fullPath:?string=, silent:boolean=, paneId:string=}} FileCommandData\n     * fullPath: is in the form \"path[:lineNumber[:columnNumber]]\"\n     * lineNumber and columnNumber are 1-origin: lines and columns are 1-based\n     */\n\n    /**\n     * @typedef {{fullPath:?string=, index:number=, silent:boolean=, forceRedraw:boolean=, paneId:string=}} PaneCommandData\n     * fullPath: is in the form \"path[:lineNumber[:columnNumber]]\"\n     * lineNumber and columnNumber are 1-origin: lines and columns are 1-based\n     */\n\n    /**\n     * Opens the given file and makes it the current file. Does NOT add it to the workingset.\n     * @param {FileCommandData=} commandData - record with the following properties:\n     *   fullPath: File to open;\n     *   silent: optional flag to suppress error messages;\n     *   paneId: optional PaneId (defaults to active pane)\n     * @return {$.Promise} a jQuery promise that will be resolved with a file object\n     */\n    function handleFileOpen(commandData) {\n        var fileInfo = _parseDecoratedPath(commandData ? commandData.fullPath : null),\n            silent = (commandData && commandData.silent) || false,\n            paneId = (commandData && commandData.paneId) || MainViewManager.ACTIVE_PANE,\n            result = new $.Deferred();\n\n        _doOpenWithOptionalPath(fileInfo.path, silent, paneId, commandData && commandData.options)\n            .done(function (file) {\n                _fileOpened(file._path, false, file._encoding);\n                if (!commandData || !commandData.options || !commandData.options.noPaneActivate) {\n                    MainViewManager.setActivePaneId(paneId);\n                }\n\n                // If a line and column number were given, position the editor accordingly.\n                if (fileInfo.line !== null) {\n                    if (fileInfo.column === null || (fileInfo.column <= 0)) {\n                        fileInfo.column = 1;\n                    }\n\n                    // setCursorPos expects line/column numbers as 0-origin, so we subtract 1\n                    EditorManager.getCurrentFullEditor().setCursorPos(fileInfo.line - 1,\n                                                                      fileInfo.column - 1,\n                                                                      true);\n                }\n\n                result.resolve(file);\n            })\n            .fail(function (err) {\n                result.reject(err);\n            });\n\n        return result;\n        // Testing notes: here are some recommended manual tests for handleFileOpen, on Macintosh.\n        // Do all tests with brackets already running, and also with brackets not already running.\n        //\n        // drag a file onto brackets icon in desktop (this uses undecorated paths)\n        // drag a file onto brackets icon in taskbar (this uses undecorated paths)\n        // open a file from brackets sidebar (this uses undecorated paths)\n        // from command line: ...../Brackets.app/Contents path         - where 'path' is undecorated\n        // from command line: ...../Brackets.app path                  - where 'path' has the form \"path:line\"\n        // from command line: ...../Brackets.app path                  - where 'path' has the form \"path:line:column\"\n        // from command line: open -a ...../Brackets.app path          - where 'path' is undecorated\n        // do \"View Source\" from Adobe Scout version 1.2 or newer (this will use decorated paths of the form \"path:line:column\")\n    }\n\n    /**\n     * Opens the given file, makes it the current file, does NOT add it to the workingset\n     * @param {FileCommandData} commandData\n     *   fullPath: File to open;\n     *   silent: optional flag to suppress error messages;\n     *   paneId: optional PaneId (defaults to active pane)\n     * @return {$.Promise} a jQuery promise that will be resolved with @type {Document}\n     */\n    function handleDocumentOpen(commandData) {\n        var result = new $.Deferred();\n        handleFileOpen(commandData)\n            .done(function (file) {\n                // if we succeeded with an open file\n                //  then we need to resolve that to a document.\n                //  getOpenDocumentForPath will return null if there isn't a\n                //  supporting document for that file (e.g. an image)\n                var doc = DocumentManager.getOpenDocumentForPath(file.fullPath);\n                result.resolve(doc);\n            })\n            .fail(function (err) {\n                result.reject(err);\n            });\n\n        return result.promise();\n\n    }\n\n    /**\n     * Opens the given file, makes it the current file, AND adds it to the workingset\n     * @param {!PaneCommandData} commandData - record with the following properties:\n     *   fullPath: File to open;\n     *   index: optional index to position in workingset (defaults to last);\n     *   silent: optional flag to suppress error messages;\n     *   forceRedraw: flag to force the working set view redraw;\n     *   paneId: optional PaneId (defaults to active pane)\n     * @return {$.Promise} a jQuery promise that will be resolved with a @type {File}\n     */\n    function handleFileAddToWorkingSetAndOpen(commandData) {\n        return handleFileOpen(commandData).done(function (file) {\n            var paneId = (commandData && commandData.paneId) || MainViewManager.ACTIVE_PANE;\n            MainViewManager.addToWorkingSet(paneId, file, commandData.index, commandData.forceRedraw);\n            _fileOpened(file.fullPath, true);\n        });\n    }\n\n    /**\n     * @deprecated\n     * Opens the given file, makes it the current document, AND adds it to the workingset\n     * @param {!PaneCommandData} commandData - record with the following properties:\n     *   fullPath: File to open;\n     *   index: optional index to position in workingset (defaults to last);\n     *   silent: optional flag to suppress error messages;\n     *   forceRedraw: flag to force the working set view redraw;\n     *   paneId: optional PaneId (defaults to active pane)\n     * @return {$.Promise} a jQuery promise that will be resolved with @type {File}\n     */\n    function handleFileAddToWorkingSet(commandData) {\n        // This is a legacy deprecated command that\n        //  will use the new command and resolve with a document\n        //  as the legacy command would only support.\n        DeprecationWarning.deprecationWarning(\"Commands.FILE_ADD_TO_WORKING_SET has been deprecated.  Use Commands.CMD_ADD_TO_WORKINGSET_AND_OPEN instead.\");\n        var result = new $.Deferred();\n\n        handleFileAddToWorkingSetAndOpen(commandData)\n            .done(function (file) {\n                // if we succeeded with an open file\n                //  then we need to resolve that to a document.\n                //  getOpenDocumentForPath will return null if there isn't a\n                //  supporting document for that file (e.g. an image)\n                var doc = DocumentManager.getOpenDocumentForPath(file.fullPath);\n                result.resolve(doc);\n            })\n            .fail(function (err) {\n                result.reject(err);\n            });\n\n        return result.promise();\n    }\n\n    /**\n     * @private\n     * Ensures the suggested file name doesn't already exit.\n     * @param {Directory} dir  The directory to use\n     * @param {string} baseFileName  The base to start with, \"-n\" will get appended to make unique\n     * @param {boolean} isFolder True if the suggestion is for a folder name\n     * @return {$.Promise} a jQuery promise that will be resolved with a unique name starting with\n     *   the given base name\n     */\n    function _getUntitledFileSuggestion(dir, baseFileName, isFolder) {\n        var suggestedName   = baseFileName + \"-\" + _nextUntitledIndexToUse++,\n            deferred        = $.Deferred();\n\n        if (_nextUntitledIndexToUse > 9999) {\n            //we've tried this enough\n            deferred.reject();\n        } else {\n            var path = dir.fullPath + suggestedName,\n                entry = isFolder ? FileSystem.getDirectoryForPath(path)\n                                 : FileSystem.getFileForPath(path);\n\n            entry.exists(function (err, exists) {\n                if (err || exists) {\n                    _getUntitledFileSuggestion(dir, baseFileName, isFolder)\n                        .then(deferred.resolve, deferred.reject);\n                } else {\n                    deferred.resolve(suggestedName);\n                }\n            });\n        }\n\n        return deferred.promise();\n    }\n\n    /**\n     * Prevents re-entrancy into handleFileNewInProject()\n     *\n     * handleFileNewInProject() first prompts the user to name a file and then asynchronously writes the file when the\n     * filename field loses focus. This boolean prevent additional calls to handleFileNewInProject() when an existing\n     * file creation call is outstanding\n     */\n    var fileNewInProgress = false;\n\n    /**\n     * Bottleneck function for creating new files and folders in the project tree.\n     * @private\n     * @param {boolean} isFolder - true if creating a new folder, false if creating a new file\n     */\n    function _handleNewItemInProject(isFolder) {\n        if (fileNewInProgress) {\n            ProjectManager.forceFinishRename();\n            return;\n        }\n        fileNewInProgress = true;\n\n        // Determine the directory to put the new file\n        // If a file is currently selected in the tree, put it next to it.\n        // If a directory is currently selected in the tree, put it in it.\n        // If an Untitled document is selected or nothing is selected in the tree, put it at the root of the project.\n        var baseDirEntry,\n            selected = ProjectManager.getFileTreeContext();\n        if ((!selected) || (selected instanceof InMemoryFile)) {\n            selected = ProjectManager.getProjectRoot();\n        }\n\n        if (selected.isFile) {\n            baseDirEntry = FileSystem.getDirectoryForPath(selected.parentPath);\n        }\n\n        baseDirEntry = baseDirEntry || selected;\n\n        // Create the new node. The createNewItem function does all the heavy work\n        // of validating file name, creating the new file and selecting.\n        function createWithSuggestedName(suggestedName) {\n            return ProjectManager.createNewItem(baseDirEntry, suggestedName, false, isFolder)\n                .done(function (fileOrStatus) {\n                    if(!(typeof fileOrStatus === 'object' && fileOrStatus.isFile && fileOrStatus.fullPath)){\n                        return;\n                    }\n                    DocumentManager.getDocumentForPath(fileOrStatus.fullPath)\n                        .done(doc =>{\n                            NewFileContentManager.getInitialContentForFile(fileOrStatus.fullPath).then(content =>{\n                                doc.setText(content);\n                            });\n                        })\n                        .fail(console.error);\n                })\n                .always(function () { fileNewInProgress = false; });\n        }\n\n        return _getUntitledFileSuggestion(baseDirEntry, Strings.UNTITLED, isFolder)\n            .then(createWithSuggestedName, createWithSuggestedName.bind(undefined, Strings.UNTITLED));\n    }\n\n    /**\n     * Create a new untitled document in the workingset, and make it the current document.\n     * Promise is resolved (synchronously) with the newly-created Document.\n     */\n    function handleFileNew() {\n        //var defaultExtension = PreferencesManager.get(\"defaultExtension\");\n        //if (defaultExtension) {\n        //    defaultExtension = \".\" + defaultExtension;\n        //}\n        var defaultExtension = \"\";  // disable preference setting for now\n\n        var doc = DocumentManager.createUntitledDocument(_nextUntitledIndexToUse++, defaultExtension);\n        MainViewManager._edit(MainViewManager.ACTIVE_PANE, doc);\n\n        Metrics.countEvent(\n            Metrics.EVENT_TYPE.EDITOR,\n            \"newUntitledFile\",\n            \"create\"\n        );\n\n        return new $.Deferred().resolve(doc).promise();\n    }\n\n    /**\n     * Create a new file in the project tree.\n     */\n    function handleFileNewInProject() {\n        Metrics.countEvent(\n            Metrics.EVENT_TYPE.EDITOR,\n            \"newFile\",\n            \"inProject\"\n        );\n        _handleNewItemInProject(false);\n    }\n\n    /**\n     * Create a new folder in the project tree.\n     */\n    function handleNewFolderInProject() {\n        Metrics.countEvent(\n            Metrics.EVENT_TYPE.EDITOR,\n            \"newFolder\",\n            \"inProject\"\n        );\n        _handleNewItemInProject(true);\n    }\n\n    /**\n     * @private\n     * Shows an Error modal dialog\n     * @param {string} name\n     * @param {string} path\n     * @return {Dialog}\n     */\n    function _showSaveFileError(name, path) {\n        return Dialogs.showModalDialog(\n            DefaultDialogs.DIALOG_ID_ERROR,\n            Strings.ERROR_SAVING_FILE_TITLE,\n            StringUtils.format(\n                Strings.ERROR_SAVING_FILE,\n                StringUtils.breakableUrl(path),\n                FileUtils.getFileErrorString(name)\n            )\n        );\n    }\n\n    let alwaysOverwriteTillProjectSwitch = false;\n    /**\n     * Saves a document to its existing path. Does NOT support untitled documents.\n     * @param {!Document} docToSave\n     * @param {boolean=} force Ignore CONTENTS_MODIFIED errors from the FileSystem\n     * @return {$.Promise} a promise that is resolved with the File of docToSave (to mirror\n     *   the API of _doSaveAs()). Rejected in case of IO error (after error dialog dismissed).\n     */\n    function doSave(docToSave, force) {\n        var result = new $.Deferred(),\n            file = docToSave.file;\n\n        function handleError(error) {\n            _showSaveFileError(error, file.fullPath)\n                .done(function () {\n                    result.reject(error);\n                });\n        }\n\n        function handleContentsModified() {\n            if(alwaysOverwriteTillProjectSwitch){\n                doSave(docToSave, true).then(result.resolve, result.reject);\n                return;\n            }\n            Dialogs.showModalDialog(\n                DefaultDialogs.DIALOG_ID_ERROR,\n                Strings.EXT_MODIFIED_TITLE,\n                StringUtils.format(\n                    Strings.EXT_MODIFIED_WARNING,\n                    StringUtils.breakableUrl(docToSave.file.fullPath)\n                ),\n                [\n                    {\n                        className: Dialogs.DIALOG_BTN_CLASS_LEFT,\n                        id: Dialogs.DIALOG_BTN_SAVE_AS,\n                        text: Strings.SAVE_AS\n                    },\n                    {\n                        className: Dialogs.DIALOG_BTN_CLASS_NORMAL,\n                        id: Dialogs.DIALOG_BTN_CANCEL,\n                        text: Strings.CANCEL\n                    },\n                    {\n                        className: Dialogs.DIALOG_BTN_CLASS_NORMAL,\n                        id: \"alwaysOverwrite\",\n                        text: Strings.ALWAYS_OVERWRITE,\n                        tooltip: Strings.EXT_ALWAYS_MODIFIED_BUTTON_TOOLTIP\n                    },\n                    {\n                        className: Dialogs.DIALOG_BTN_CLASS_PRIMARY,\n                        id: Dialogs.DIALOG_BTN_OK,\n                        text: Strings.SAVE_AND_OVERWRITE\n                    }\n                ]\n            )\n                .done(function (id) {\n                    if (id === Dialogs.DIALOG_BTN_CANCEL) {\n                        result.reject();\n                    } else if (id === Dialogs.DIALOG_BTN_OK) {\n                        // Re-do the save, ignoring any CONTENTS_MODIFIED errors\n                        doSave(docToSave, true).then(result.resolve, result.reject);\n                    } else if (id === Dialogs.DIALOG_BTN_SAVE_AS) {\n                        // Let the user choose a different path at which to write the file\n                        handleFileSaveAs({doc: docToSave}).then(result.resolve, result.reject);\n                    } else if (id === 'alwaysOverwrite'){\n                        alwaysOverwriteTillProjectSwitch = true;\n                        doSave(docToSave, true).then(result.resolve, result.reject);\n                    }\n                });\n        }\n\n        function trySave() {\n            // We don't want normalized line endings, so it's important to pass true to getText()\n            FileUtils.writeText(file, docToSave.getText(true), force)\n                .done(function () {\n                    docToSave.notifySaved();\n                    result.resolve(file);\n                    _fileSavedMetrics(docToSave);\n                })\n                .fail(function (err) {\n                    if (err === FileSystemError.CONTENTS_MODIFIED) {\n                        handleContentsModified();\n                    } else {\n                        handleError(err);\n                    }\n                })\n                .always(function () {\n                    docToSave.isSaving = false;\n                });\n        }\n\n        if (docToSave.isDirty) {\n            docToSave.isSaving = true;\n            if (docToSave.keepChangesTime) {\n                // The user has decided to keep conflicting changes in the editor. Check to make sure\n                // the file hasn't changed since they last decided to do that.\n                docToSave.file.stat(function (err, stat) {\n                    // If the file has been deleted on disk, the stat will return an error, but that's fine since\n                    // that means there's no file to overwrite anyway, so the save will succeed without us having\n                    // to set force = true.\n                    if (!err && docToSave.keepChangesTime === stat.mtime.getTime()) {\n                        // OK, it's safe to overwrite the file even though we never reloaded the latest version,\n                        // since the user already said s/he wanted to ignore the disk version.\n                        force = true;\n                    }\n                    trySave();\n                });\n            } else {\n                trySave();\n            }\n        } else {\n            result.resolve(file);\n        }\n        result.always(function () {\n            MainViewManager.focusActivePane();\n        });\n        return result.promise();\n    }\n\n    /**\n     * Reverts the Document to the current contents of its file on disk. Discards any unsaved changes\n     * in the Document.\n     * @private\n     * @param {Document} doc\n     * @param {boolean=} suppressError If true, then a failure to read the file will be ignored and the\n     *      resulting promise will be resolved rather than rejected.\n     * @return {$.Promise} a Promise that's resolved when done, or (if suppressError is false)\n     *      rejected with a FileSystemError if the file cannot be read (after showing an error\n     *      dialog to the user).\n     */\n    function _doRevert(doc, suppressError) {\n        var result = new $.Deferred();\n\n        FileUtils.readAsText(doc.file)\n            .done(function (text, readTimestamp) {\n                doc.refreshText(text, readTimestamp);\n                result.resolve();\n            })\n            .fail(function (error) {\n                if (suppressError) {\n                    result.resolve();\n                } else {\n                    showFileOpenError(error, doc.file.fullPath)\n                        .done(function () {\n                            result.reject(error);\n                        });\n                }\n            });\n\n        return result.promise();\n    }\n\n    /**\n     * Dispatches the app quit cancelled event\n     */\n    function dispatchAppQuitCancelledEvent() {\n        exports.trigger(exports.APP_QUIT_CANCELLED);\n    }\n\n\n    /**\n     * Opens the native OS save as dialog and saves document.\n     * The original document is reverted in case it was dirty.\n     * Text selection and cursor position from the original document\n     * are preserved in the new document.\n     * When saving to the original document the document is saved as if save was called.\n     * @param {Document} doc\n     * @param {?{cursorPos:!Object, selection:!Object, scrollPos:!Object}} settings - properties of\n     *      the original document's editor that need to be carried over to the new document\n     *      i.e. scrollPos, cursorPos and text selection\n     * @return {$.Promise} a promise that is resolved with the saved document's File. Rejected in\n     *   case of IO error (after error dialog dismissed), or if the Save dialog was canceled.\n     */\n    function _doSaveAs(doc, settings) {\n        var origPath,\n            saveAsDefaultPath,\n            defaultName,\n            result = new $.Deferred();\n\n        function _doSaveAfterSaveDialog(path) {\n            var newFile;\n\n            // Reconstruct old doc's editor's view state, & finally resolve overall promise\n            function _configureEditorAndResolve() {\n                var editor = EditorManager.getActiveEditor();\n                if (editor) {\n                    if (settings) {\n                        editor.setSelections(settings.selections);\n                        editor.setScrollPos(settings.scrollPos.x, settings.scrollPos.y);\n                    }\n                }\n                result.resolve(newFile);\n            }\n\n            // Replace old document with new one in open editor & workingset\n            function openNewFile() {\n                var fileOpenPromise;\n\n                if (FileViewController.getFileSelectionFocus() === FileViewController.PROJECT_MANAGER) {\n                    // If selection is in the tree, leave workingset unchanged - even if orig file is in the list\n                    setTimeout(()=>{\n                        fileOpenPromise = FileViewController\n                            .openAndSelectDocument(path, FileViewController.PROJECT_MANAGER);\n                        // always configure editor after file is opened\n                        fileOpenPromise.always(function () {\n                            _configureEditorAndResolve();\n                        });\n                    }, 100); // this is in a timeout as the file tree may not have updated yet after save as\n                    // file created, and we wait for the file watcher events to get triggered so that the file\n                    // selection is updated.\n                } else {\n                    // If selection is in workingset, replace orig item in place with the new file\n                    var info = MainViewManager.findInAllWorkingSets(doc.file.fullPath).shift();\n\n                    // Remove old file from workingset; no redraw yet since there's a pause before the new file is opened\n                    MainViewManager._removeView(info.paneId, doc.file, true);\n\n                    // Add new file to workingset, and ensure we now redraw (even if index hasn't changed)\n                    fileOpenPromise = handleFileAddToWorkingSetAndOpen({fullPath: path, paneId: info.paneId, index: info.index, forceRedraw: true});\n                    // always configure editor after file is opened\n                    fileOpenPromise.always(function () {\n                        _configureEditorAndResolve();\n                    });\n                }\n            }\n\n            // Same name as before - just do a regular Save\n            if (path === origPath) {\n                doSave(doc).then(result.resolve, result.reject);\n                return;\n            }\n\n            doc.isSaving = true;    // mark that we're saving the document\n\n            // First, write document's current text to new file\n            if (doc.file._encoding && doc.file._encoding !== \"UTF-8\") {\n                const encoding = PreferencesManager.getViewState(\"encoding\", PreferencesManager.STATE_PROJECT_CONTEXT);\n                encoding[path] = doc.file._encoding;\n                PreferencesManager.setViewState(\"encoding\", encoding, PreferencesManager.STATE_PROJECT_CONTEXT);\n            }\n            newFile = FileSystem.getFileForPath(path);\n            newFile._encoding = doc.file._encoding;\n\n            // Save as warns you when you're about to overwrite a file, so we\n            // explicitly allow \"blind\" writes to the filesystem in this case,\n            // ignoring warnings about the contents being modified outside of\n            // the editor.\n            FileUtils.writeText(newFile, doc.getText(true), true)\n                .done(function () {\n                    // If there were unsaved changes before Save As, they don't stay with the old\n                    // file anymore - so must revert the old doc to match disk content.\n                    // Only do this if the doc was dirty: _doRevert on a file that is not dirty and\n                    // not in the workingset has the side effect of adding it to the workingset.\n                    if (doc.isDirty && !(doc.isUntitled())) {\n                        // if the file is dirty it must be in the workingset\n                        // _doRevert is side effect free in this case\n                        _doRevert(doc).always(openNewFile);\n                    } else {\n                        openNewFile();\n                    }\n                    _fileSavedMetrics(doc);\n                })\n                .fail(function (error) {\n                    _showSaveFileError(error, path)\n                        .done(function () {\n                            result.reject(error);\n                        });\n                })\n                .always(function () {\n                    // mark that we're done saving the document\n                    doc.isSaving = false;\n                });\n        }\n\n        if (doc) {\n            origPath = doc.file.fullPath;\n            // If the document is an untitled document, we should default to project root.\n            if (doc.isUntitled()) {\n                // (Issue #4489) if we're saving an untitled document, go ahead and switch to this document\n                //   in the editor, so that if we're, for example, saving several files (ie. Save All),\n                //   then the user can visually tell which document we're currently prompting them to save.\n                var info = MainViewManager.findInAllWorkingSets(origPath).shift();\n\n                if (info) {\n                    MainViewManager._open(info.paneId, doc.file);\n                }\n\n                // If the document is untitled, default to project root.\n                saveAsDefaultPath = ProjectManager.getProjectRoot().fullPath;\n            } else {\n                saveAsDefaultPath = FileUtils.getDirectoryPath(origPath);\n            }\n            defaultName = FileUtils.getBaseName(origPath);\n            var file = FileSystem.getFileForPath(origPath);\n            if (file instanceof InMemoryFile) {\n                var language = LanguageManager.getLanguageForPath(origPath);\n                if (language) {\n                    var fileExtensions = language.getFileExtensions();\n                    if (fileExtensions && fileExtensions.length > 0) {\n                        defaultName += \".\" + fileExtensions[0];\n                    }\n                }\n            }\n            FileSystem.showSaveDialog(Strings.SAVE_FILE_AS, saveAsDefaultPath, defaultName, function (err, selectedPath) {\n                if (!err) {\n                    if (selectedPath) {\n                        _doSaveAfterSaveDialog(selectedPath);\n                    } else {\n                        dispatchAppQuitCancelledEvent();\n                        result.reject(USER_CANCELED);\n                    }\n                } else {\n                    result.reject(err);\n                }\n            });\n        } else {\n            result.reject();\n        }\n        return result.promise();\n    }\n\n    /**\n     * Saves the given file. If no file specified, assumes the current document.\n     * @param {?{doc: ?Document}} commandData  Document to close, or null\n     * @return {$.Promise} resolved with the saved document's File (which MAY DIFFER from the doc\n     *   passed in, if the doc was untitled). Rejected in case of IO error (after error dialog\n     *   dismissed), or if doc was untitled and the Save dialog was canceled (will be rejected with\n     *   USER_CANCELED object).\n     */\n    function handleFileSave(commandData) {\n        var activeEditor = EditorManager.getActiveEditor(),\n            activeDoc = activeEditor && activeEditor.document,\n            doc = (commandData && commandData.doc) || activeDoc,\n            settings;\n\n        if (doc && !doc.isSaving) {\n            if (doc.isUntitled()) {\n                if (doc === activeDoc) {\n                    settings = {\n                        selections: activeEditor.getSelections(),\n                        scrollPos: activeEditor.getScrollPos()\n                    };\n                }\n\n                return _doSaveAs(doc, settings);\n            }\n            return doSave(doc);\n\n        }\n\n        return $.Deferred().reject().promise();\n    }\n\n    /**\n     * Saves all unsaved documents corresponding to 'fileList'. Returns a Promise that will be resolved\n     * once ALL the save operations have been completed. If ANY save operation fails, an error dialog is\n     * immediately shown but after dismissing we continue saving the other files; after all files have\n     * been processed, the Promise is rejected if any ONE save operation failed (the error given is the\n     * first one encountered). If the user cancels any Save As dialog (for untitled files), the\n     * Promise is immediately rejected.\n     *\n     * @param {!Array.<File>} fileList\n     * @return {!$.Promise} Resolved with {!Array.<File>}, which may differ from 'fileList'\n     *      if any of the files were Unsaved documents. Or rejected with {?FileSystemError}.\n     */\n    function _saveFileList(fileList) {\n        // Do in serial because doSave shows error UI for each file, and we don't want to stack\n        // multiple dialogs on top of each other\n        var userCanceled = false,\n            filesAfterSave = [];\n\n        return Async.doSequentially(\n            fileList,\n            function (file) {\n                // Abort remaining saves if user canceled any Save As dialog\n                if (userCanceled) {\n                    return (new $.Deferred()).reject().promise();\n                }\n\n                var doc = DocumentManager.getOpenDocumentForPath(file.fullPath);\n                if (doc) {\n                    var savePromise = handleFileSave({doc: doc});\n                    savePromise\n                        .done(function (newFile) {\n                            filesAfterSave.push(newFile);\n                        })\n                        .fail(function (error) {\n                            if (error === USER_CANCELED) {\n                                userCanceled = true;\n                            }\n                        });\n                    return savePromise;\n                }\n                    // workingset entry that was never actually opened - ignore\n                filesAfterSave.push(file);\n                return (new $.Deferred()).resolve().promise();\n\n            },\n            false  // if any save fails, continue trying to save other files anyway; then reject at end\n        ).then(function () {\n            return filesAfterSave;\n        });\n    }\n\n    /**\n     * Saves all unsaved documents. See _saveFileList() for details on the semantics.\n     * @return {$.Promise}\n     */\n    function saveAll() {\n        return _saveFileList(MainViewManager.getWorkingSet(MainViewManager.ALL_PANES));\n    }\n\n    /**\n     * Prompts user with save as dialog and saves document.\n     * @return {$.Promise} a promise that is resolved once the save has been completed\n     */\n    handleFileSaveAs = function (commandData) {\n        // Default to current document if doc is null\n        var doc = null,\n            settings;\n\n        if (commandData) {\n            doc = commandData.doc;\n        } else {\n            var activeEditor = EditorManager.getActiveEditor();\n            if (activeEditor) {\n                doc = activeEditor.document;\n                settings = {};\n                settings.selections = activeEditor.getSelections();\n                settings.scrollPos = activeEditor.getScrollPos();\n            }\n        }\n\n        // doc may still be null, e.g. if no editors are open, but _doSaveAs() does a null check on\n        // doc.\n        return _doSaveAs(doc, settings);\n    };\n\n    /**\n     * Saves all unsaved documents.\n     * @return {$.Promise} a promise that is resolved once ALL the saves have been completed; or rejected\n     *      after all operations completed if any ONE of them failed.\n     */\n    function handleFileSaveAll() {\n        return saveAll();\n    }\n\n    let closedFilesHistory = new Map();\n\n    function _enableOrDisableReopenClosedCmd() {\n        CommandManager.get(Commands.FILE_REOPEN_CLOSED).setEnabled(!!closedFilesHistory.size);\n    }\n\n    function _addToClosedFilesHistory(filePath, paneID) {\n        closedFilesHistory.set(filePath, {paneID, closeTime: Date.now()});\n        _enableOrDisableReopenClosedCmd();\n    }\n\n    function handleReopenClosed() {\n        // find the file that was most recently closed\n        let leastRecentlyClosedPath, leastRecentlyClosedTime, paneToUse;\n        for(let closedFilePath of closedFilesHistory.keys()){\n            const currentScan = closedFilesHistory.get(closedFilePath);\n            if(!leastRecentlyClosedPath || leastRecentlyClosedTime < currentScan.closeTime) {\n                leastRecentlyClosedPath = closedFilePath;\n                leastRecentlyClosedTime = currentScan.closeTime;\n                paneToUse = currentScan.paneID;\n            }\n        }\n        if(leastRecentlyClosedPath) {\n            closedFilesHistory.delete(leastRecentlyClosedPath);\n            if(MainViewManager.getPaneCount() === 1) {\n                paneToUse = MainViewManager.ACTIVE_PANE;\n            }\n            _enableOrDisableReopenClosedCmd();\n            return FileViewController.openFileAndAddToWorkingSet(leastRecentlyClosedPath, paneToUse);\n        }\n        _enableOrDisableReopenClosedCmd();\n    }\n\n    /**\n     * Closes the specified file: removes it from the workingset, and closes the main editor if one\n     * is open. Prompts user about saving changes first, if document is dirty.\n     *\n     * @param {?{file: File, promptOnly:boolean}} commandData  Optional bag of arguments:\n     *      file - File to close; assumes the current document if not specified.\n     *      promptOnly - If true, only displays the relevant confirmation UI and does NOT actually\n     *          close the document. This is useful when chaining file-close together with other user\n     *          prompts that may be cancelable.\n     *      _forceClose - If true, closes the document without prompting even if there are unsaved\n     *          changes. Only for use in unit tests.\n     * @return {$.Promise} a promise that is resolved when the file is closed, or if no file is open.\n     *      FUTURE: should we reject the promise if no file is open?\n     */\n    function handleFileClose(commandData) {\n        var file,\n            promptOnly,\n            _forceClose,\n            _spawnedRequest,\n            paneId = MainViewManager.ACTIVE_PANE,\n            activePaneID = MainViewManager.getActivePaneId();\n\n        if (commandData) {\n            file        = commandData.file;\n            promptOnly  = commandData.promptOnly;\n            _forceClose = commandData._forceClose;\n            paneId      = commandData.paneId || paneId;\n            _spawnedRequest = commandData.spawnedRequest || false;\n        }\n\n        // utility function for handleFileClose: closes document & removes from workingset\n        function doClose(file) {\n            if (!promptOnly) {\n                MainViewManager._close(paneId, file);\n                let paneClosing = paneId;\n                if(paneId === MainViewManager.ACTIVE_PANE){\n                    paneClosing = activePaneID;\n                }\n                _addToClosedFilesHistory(file.fullPath, paneClosing);\n                _fileClosed(file);\n            }\n        }\n\n        var result = new $.Deferred(), promise = result.promise();\n\n        // Default to current document if doc is null\n        if (!file) {\n            file = MainViewManager.getCurrentlyViewedFile(MainViewManager.ACTIVE_PANE);\n        }\n\n        // No-op if called when nothing is open; TODO: (issue #273) should command be grayed out instead?\n        if (!file) {\n            result.resolve();\n            return promise;\n        }\n\n        var doc = DocumentManager.getOpenDocumentForPath(file.fullPath);\n\n        if (doc && doc.isDirty && !_forceClose && (MainViewManager.isExclusiveToPane(doc.file, paneId) || _spawnedRequest)) {\n            // Document is dirty: prompt to save changes before closing if only the document is exclusively\n            // listed in the requested pane or this is part of a list close request\n            var filename = FileUtils.getBaseName(doc.file.fullPath);\n\n            Dialogs.showModalDialog(\n                DefaultDialogs.DIALOG_ID_SAVE_CLOSE,\n                Strings.SAVE_CLOSE_TITLE,\n                StringUtils.format(\n                    Strings.SAVE_CLOSE_MESSAGE,\n                    StringUtils.breakableUrl(filename)\n                ),\n                [\n                    {\n                        className: Dialogs.DIALOG_BTN_CLASS_LEFT,\n                        id: Dialogs.DIALOG_BTN_DONTSAVE,\n                        text: Strings.DONT_SAVE\n                    },\n                    {\n                        className: Dialogs.DIALOG_BTN_CLASS_NORMAL,\n                        id: Dialogs.DIALOG_BTN_CANCEL,\n                        text: Strings.CANCEL\n                    },\n                    {\n                        className: Dialogs.DIALOG_BTN_CLASS_PRIMARY,\n                        id: Dialogs.DIALOG_BTN_OK,\n                        text: Strings.SAVE\n                    }\n                ]\n            )\n                .done(function (id) {\n                    if (id === Dialogs.DIALOG_BTN_CANCEL) {\n                        dispatchAppQuitCancelledEvent();\n                        result.reject();\n                    } else if (id === Dialogs.DIALOG_BTN_OK) {\n                        // \"Save\" case: wait until we confirm save has succeeded before closing\n                        handleFileSave({doc: doc})\n                            .done(function (newFile) {\n                                doClose(newFile);\n                                result.resolve();\n                            })\n                            .fail(function () {\n                                result.reject();\n                            });\n                    } else {\n                        // \"Don't Save\" case: even though we're closing the main editor, other views of\n                        // the Document may remain in the UI. So we need to revert the Document to a clean\n                        // copy of whatever's on disk.\n                        doClose(file);\n\n                        // Only reload from disk if we've executed the Close for real.\n                        if (promptOnly) {\n                            result.resolve();\n                        } else {\n                            // Even if there are no listeners attached to the document at this point, we want\n                            // to do the revert anyway, because clients who are listening to the global documentChange\n                            // event from the Document module (rather than attaching to the document directly),\n                            // such as the Find in Files panel, should get a change event. However, in that case,\n                            // we want to ignore errors during the revert, since we don't want a failed revert\n                            // to throw a dialog if the document isn't actually open in the UI.\n                            var suppressError = !DocumentManager.getOpenDocumentForPath(file.fullPath);\n                            _doRevert(doc, suppressError)\n                                .then(result.resolve, result.reject);\n                        }\n                    }\n                });\n            result.always(function () {\n                MainViewManager.focusActivePane();\n            });\n        } else {\n            // File is not open, or IS open but Document not dirty: close immediately\n            doClose(file);\n            MainViewManager.focusActivePane();\n            result.resolve();\n        }\n        return promise;\n    }\n\n    /**\n     * @param {!Array.<File>} list - the list of files to close\n     * @param {boolean} promptOnly - true to just prompt for saving documents with actually closing them.\n     * @param {boolean} _forceClose Whether to force all the documents to close even if they have unsaved changes. For unit testing only.\n     * @return {jQuery.Promise} promise that is resolved or rejected when the function finishes.\n     */\n    function _closeList(list, promptOnly, _forceClose) {\n        var result      = new $.Deferred(),\n            unsavedDocs = [];\n\n        list.forEach(function (file) {\n            var doc = DocumentManager.getOpenDocumentForPath(file.fullPath);\n            if (doc && doc.isDirty) {\n                unsavedDocs.push(doc);\n            }\n        });\n\n        if (unsavedDocs.length === 0 || _forceClose) {\n            // No unsaved changes or we want to ignore them, so we can proceed without a prompt\n            result.resolve();\n\n        } else if (unsavedDocs.length === 1) {\n            // Only one unsaved file: show the usual single-file-close confirmation UI\n            var fileCloseArgs = { file: unsavedDocs[0].file, promptOnly: promptOnly, spawnedRequest: true };\n\n            handleFileClose(fileCloseArgs).done(function () {\n                // still need to close any other, non-unsaved documents\n                result.resolve();\n            }).fail(function () {\n                result.reject();\n            });\n\n        } else {\n            // Multiple unsaved files: show a single bulk prompt listing all files\n            var message = Strings.SAVE_CLOSE_MULTI_MESSAGE + FileUtils.makeDialogFileList(_.map(unsavedDocs, _shortTitleForDocument));\n\n            Dialogs.showModalDialog(\n                DefaultDialogs.DIALOG_ID_SAVE_CLOSE,\n                Strings.SAVE_CLOSE_TITLE,\n                message,\n                [\n                    {\n                        className: Dialogs.DIALOG_BTN_CLASS_LEFT,\n                        id: Dialogs.DIALOG_BTN_DONTSAVE,\n                        text: Strings.DONT_SAVE\n                    },\n                    {\n                        className: Dialogs.DIALOG_BTN_CLASS_NORMAL,\n                        id: Dialogs.DIALOG_BTN_CANCEL,\n                        text: Strings.CANCEL\n                    },\n                    {\n                        className: Dialogs.DIALOG_BTN_CLASS_PRIMARY,\n                        id: Dialogs.DIALOG_BTN_OK,\n                        text: Strings.SAVE\n                    }\n                ]\n            )\n                .done(function (id) {\n                    if (id === Dialogs.DIALOG_BTN_CANCEL) {\n                        dispatchAppQuitCancelledEvent();\n                        result.reject();\n                    } else if (id === Dialogs.DIALOG_BTN_OK) {\n                        // Save all unsaved files, then if that succeeds, close all\n                        _saveFileList(list).done(function (listAfterSave) {\n                            // List of files after save may be different, if any were Untitled\n                            result.resolve(listAfterSave);\n                        }).fail(function () {\n                            result.reject();\n                        });\n                    } else {\n                        // \"Don't Save\" case--we can just go ahead and close all files.\n                        result.resolve();\n                    }\n                });\n        }\n\n        // If all the unsaved-changes confirmations pan out above, then go ahead & close all editors\n        // NOTE: this still happens before any done() handlers added by our caller, because jQ\n        // guarantees that handlers run in the order they are added.\n        result.done(function (listAfterSave) {\n            listAfterSave = listAfterSave || list;\n            if (!promptOnly) {\n                MainViewManager._closeList(MainViewManager.ALL_PANES, listAfterSave);\n            }\n        });\n\n        return result.promise();\n    }\n\n    /**\n     * Closes all open files; equivalent to calling handleFileClose() for each document, except\n     * that unsaved changes are confirmed once, in bulk.\n     * @param {?{promptOnly: boolean, _forceClose: boolean}}\n     *          If promptOnly is true, only displays the relevant confirmation UI and does NOT\n     *          actually close any documents. This is useful when chaining close-all together with\n     *          other user prompts that may be cancelable.\n     *          If _forceClose is true, forces the files to close with no confirmation even if dirty.\n     *          Should only be used for unit test cleanup.\n     * @return {$.Promise} a promise that is resolved when all files are closed\n     */\n    function handleFileCloseAll(commandData) {\n        return _closeList(MainViewManager.getAllOpenFiles(),\n                                    (commandData && commandData.promptOnly), (commandData && commandData._forceClose));\n    }\n\n\n    /**\n     * Closes a list of open files; equivalent to calling handleFileClose() for each document, except\n     * that unsaved changes are confirmed once, in bulk.\n     * @param {?{promptOnly: boolean, _forceClose: boolean}}\n     *          If promptOnly is true, only displays the relevant confirmation UI and does NOT\n     *          actually close any documents. This is useful when chaining close-all together with\n     *          other user prompts that may be cancelable.\n     *          If _forceClose is true, forces the files to close with no confirmation even if dirty.\n     *          Should only be used for unit test cleanup.\n     * @return {$.Promise} a promise that is resolved when all files are closed\n     */\n    function handleFileCloseList(commandData) {\n        return _closeList(commandData.fileList);\n    }\n\n    /**\n     * @private - tracks our closing state if we get called again\n     */\n    var _windowGoingAway = false;\n    let exitWaitPromises = [];\n\n    /**\n     * @private\n     * Common implementation for close/quit/reload which all mostly\n     * the same except for the final step\n     * @param {Object} commandData - (not referenced)\n     * @param {!function()} postCloseHandler - called after close\n     * @param {!function()} failHandler - called when the save fails to cancel closing the window\n     */\n    function _handleWindowGoingAway(commandData, postCloseHandler, failHandler) {\n        if (_windowGoingAway) {\n            //if we get called back while we're closing, then just return\n            return (new $.Deferred()).reject().promise();\n        }\n        Metrics.flushMetrics();\n\n        return CommandManager.execute(Commands.FILE_CLOSE_ALL, { promptOnly: true })\n            .done(function () {\n                exitWaitPromises = [];\n                _windowGoingAway = true;\n\n                // Give everyone a chance to save their state - but don't let any problems block\n                // us from quitting\n                try {\n                    // if someone wats to do any deferred tasks, they should add\n                    // their promise to the wait promises list.\n                    ProjectManager.trigger(\"beforeAppClose\", exitWaitPromises);\n                } catch (ex) {\n                    console.error(ex);\n                }\n\n                postCloseHandler();\n            })\n            .fail(function () {\n                _windowGoingAway = false;\n                if (failHandler) {\n                    failHandler();\n                }\n            });\n    }\n\n    /**\n     * @private\n     * Implementation for abortQuit callback to reset quit sequence settings\n     */\n    function handleAbortQuit() {\n        _windowGoingAway = false;\n    }\n\n    /**\n     * @private\n     * Implementation for native APP_BEFORE_MENUPOPUP callback to trigger beforeMenuPopup event\n     */\n    function handleBeforeMenuPopup() {\n        PopUpManager.trigger(\"beforeMenuPopup\");\n    }\n\n    /**\n     * Confirms any unsaved changes, then closes the window\n     * @param {Object} commandData data\n     */\n    function handleFileCloseWindow(commandData) {\n        _forceQuitIfNeeded();\n        return _handleWindowGoingAway(\n            commandData,\n            function (closeSuccess) {\n                console.log('close success: ', closeSuccess);\n                raceAgainstTime(window.PhStore.flushDB())\n                    .finally(()=>{\n                        raceAgainstTime(_safeNodeTerminate())\n                            .finally(()=>{\n                                Phoenix.app.closeWindow();\n                            });\n                    });\n            },\n            function (err) {\n                console.error(\"Quit failed! \", err);\n            }\n        );\n    }\n\n    function newPhoenixWindow(cliArgsArray = null, cwd=null) {\n        let width = window.innerWidth;\n        let height = window.innerHeight;\n        Phoenix.app.openNewPhoenixEditorWindow(width, height, cliArgsArray, cwd);\n    }\n\n    async function _fileExists(fullPath) {\n        try {\n            const {entry} = await FileSystem.resolveAsync(fullPath);\n            return entry.isFile;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    async function _tryToOpenFile(absOrRelativePath, cwdIfRelativePath) {\n        try{\n            let fileToOpen;\n            if(cwdIfRelativePath){\n                fileToOpen = window.path.join(Phoenix.VFS.getTauriVirtualPath(cwdIfRelativePath), absOrRelativePath);\n            } else {\n                fileToOpen = Phoenix.VFS.getTauriVirtualPath(absOrRelativePath);\n            }\n            let isFile = await _fileExists(fileToOpen);\n            if(isFile){\n                await jsPromise(FileViewController.openFileAndAddToWorkingSet(fileToOpen));\n                return true;\n            }\n        } catch (e) {\n            console.warn(\"Opening file failed \", absOrRelativePath, e);\n        }\n        return false;\n    }\n\n    async function _openFilesPassedInFromCLI(args=null, cwd=\"\") {\n        if(!args){\n            const cliArgs= await Phoenix.app.getCommandLineArgs();\n            args = cliArgs && cliArgs.args;\n            cwd = cliArgs && cliArgs.cwd;\n        }\n        if(!args || args.length <= 1){\n            return;\n        }\n\n        let openCount = 0;\n        for(let i=1; i<args.length; i++) { // the first arg is the executable path itself, ignore that\n            const fileArg = args[i];\n            let isOpened = await _tryToOpenFile(fileArg);\n            if(!isOpened){\n                // if here, then, this maybe a relative file path or not a file at all. check if relative path\n                await _tryToOpenFile(fileArg, cwd);\n            }\n            if(isOpened){\n                openCount++;\n            }\n        }\n        if(openCount){\n            exports.trigger(_EVENT_OPEN_WITH_FILE_FROM_OS);\n            _filesOpenedFromOsCount++;\n            Metrics.countEvent(Metrics.EVENT_TYPE.PLATFORM, 'openWith', \"file\", openCount);\n        }\n    }\n\n    async function _safeCheckFileAndGetVirtualPath(absOrRelativePath, relativeToDir=null) {\n        try{\n            let fileToCheck;\n            if(!relativeToDir){\n                fileToCheck = Phoenix.VFS.getTauriVirtualPath(absOrRelativePath);\n                const fileExists = await _fileExists(fileToCheck);\n                if(fileExists){\n                    return fileToCheck;\n                }\n            } else {\n                fileToCheck = window.path.join(Phoenix.VFS.getTauriVirtualPath(relativeToDir), absOrRelativePath);\n                const fileExists = await _fileExists(fileToCheck);\n                if(fileExists){\n                    return fileToCheck;\n                }\n            }\n        } catch (e) {\n            console.warn(\"error opening folder at path\", absOrRelativePath, relativeToDir);\n        }\n        return null;\n    }\n\n    async function _singleInstanceHandler(args, cwd) {\n        const isPrimary = await Phoenix.app.isPrimaryDesktopPhoenixWindow();\n        if(!isPrimary){\n            // only primary phoenix windows can open a new window, else every window is going to make its own\n            // window and cause a runaway phoenix window explosion.\n            return;\n        }\n        if(args.length > 1) {\n            // check if the second arg is a file, if so we just open it and the remaining files in this window\n            let fileToOpen = await _safeCheckFileAndGetVirtualPath(args[1]);\n            if(!fileToOpen){\n                // maybe relative path?\n                fileToOpen = await _safeCheckFileAndGetVirtualPath(args[1], cwd);\n            }\n            if(fileToOpen) {\n                Metrics.countEvent(Metrics.EVENT_TYPE.PLATFORM, 'openWith', \"file\");\n                await _openFilesPassedInFromCLI(args, cwd);\n                await Phoenix.app.focusWindow();\n                return;\n            }\n        }\n        newPhoenixWindow(args, cwd);\n    }\n\n    function handleFileNewWindow() {\n        newPhoenixWindow([]);\n    }\n\n    /** Show a textfield to rename whatever is currently selected in the sidebar (or current doc if nothing else selected) */\n    function handleFileRename() {\n        // Prefer selected sidebar item (which could be a folder)\n        var entry = ProjectManager.getContext();\n        if (!entry) {\n            // Else use current file (not selected in ProjectManager if not visible in tree or workingset)\n            entry = MainViewManager.getCurrentlyViewedFile();\n        }\n        if (entry) {\n            ProjectManager.renameItemInline(entry);\n        }\n    }\n\n\n    /** Are we already listening for a keyup to call detectDocumentNavEnd()? */\n    var _addedNavKeyHandler = false;\n\n    /**\n     * When the Ctrl key is released, if we were in the middle of a next/prev document navigation\n     * sequence, now is the time to end it and update the MRU order. If we allowed the order to update\n     * on every next/prev increment, the 1st & 2nd entries would just switch places forever and we'd\n     * never get further down the list.\n     * @param {jQueryEvent} event Key-up event\n     */\n    function detectDocumentNavEnd(event) {\n        if (event.keyCode === KeyEvent.DOM_VK_CONTROL) {  // Ctrl key\n            MainViewManager.endTraversal();\n            _addedNavKeyHandler = false;\n            $(window.document.body).off(\"keyup\", detectDocumentNavEnd);\n        }\n    }\n\n    /**\n     * Navigate to the next/previous (MRU or list order) document. Don't update MRU order yet\n     * @param {!number} inc Delta indicating in which direction we're going\n     * @param {?boolean} listOrder Whether to navigate using MRU or list order. Defaults to MRU order\n     */\n    function goNextPrevDoc(inc, listOrder) {\n        var result;\n        if (listOrder) {\n            result = MainViewManager.traverseToNextViewInListOrder(inc);\n        } else {\n            result = MainViewManager.traverseToNextViewByMRU(inc);\n        }\n\n        if (result) {\n            var file = result.file,\n                paneId = result.paneId;\n\n            MainViewManager.beginTraversal();\n            CommandManager.execute(Commands.FILE_OPEN, {fullPath: file.fullPath,\n                paneId: paneId });\n\n            // Listen for ending of Ctrl+Tab sequence\n            if (!_addedNavKeyHandler) {\n                _addedNavKeyHandler = true;\n                $(window.document.body).keyup(detectDocumentNavEnd);\n            }\n        }\n    }\n\n    /** Next Doc command handler (MRU order) **/\n    function handleGoNextDoc() {\n        goNextPrevDoc(+1);\n    }\n\n    /** Previous Doc command handler (MRU order) **/\n    function handleGoPrevDoc() {\n        goNextPrevDoc(-1);\n    }\n\n    /** Next Doc command handler (list order) **/\n    function handleGoNextDocListOrder() {\n        goNextPrevDoc(+1, true);\n    }\n\n    /** Previous Doc command handler (list order) **/\n    function handleGoPrevDocListOrder() {\n        goNextPrevDoc(-1, true);\n    }\n\n    /** Show in File Tree command handler **/\n    function handleShowInTree() {\n        let activeFile = MainViewManager.getCurrentlyViewedFile(MainViewManager.ACTIVE_PANE);\n        if(activeFile){\n            ProjectManager.showInTree(activeFile);\n        }\n    }\n\n    function _getDeleteMessageTemplate(isFile, canMoveToTrash) {\n        if(!Phoenix.isNativeApp || !canMoveToTrash){\n            return isFile ? Strings.CONFIRM_FILE_DELETE : Strings.CONFIRM_FOLDER_DELETE;\n        }\n        if(Phoenix.platform === \"win\") {\n            return isFile ? Strings.CONFIRM_FILE_DELETE_RECYCLE_BIN : Strings.CONFIRM_FOLDER_DELETE_RECYCLE_BIN;\n        }\n        return isFile ? Strings.CONFIRM_FILE_DELETE_TRASH : Strings.CONFIRM_FOLDER_DELETE_TRASH;\n    }\n\n    function _getDeleteButtonString(canMoveToTrash) {\n        if(!Phoenix.isNativeApp || !canMoveToTrash){\n            return Strings.DELETE;\n        }\n        if(Phoenix.platform === \"win\") {\n            return Strings.MOVE_TO_RECYCLE_BIN;\n        }\n        return Strings.MOVE_TO_TRASH;\n    }\n\n    /** Delete file command handler\n     *\n     * @param {{file: File}} [commandData]  Optional bag of arguments:\n     *      file - File to delete; assumes the current document if not specified.\n     *  **/\n    function handleFileDelete(commandData={}) {\n        const entry = commandData.file || ProjectManager.getSelectedItem();\n        const canMoveToTrash = Phoenix.app.canMoveToTrash(entry.fullPath);\n        Dialogs.showModalDialog(\n            DefaultDialogs.DIALOG_ID_EXT_DELETED,\n            Strings.CONFIRM_DELETE_TITLE,\n            StringUtils.format(\n                _getDeleteMessageTemplate(entry.isFile, canMoveToTrash),\n                StringUtils.breakableUrl(ProjectManager.getProjectRelativePath(entry.fullPath))\n            ),\n            [\n                {\n                    className: Dialogs.DIALOG_BTN_CLASS_NORMAL,\n                    id: Dialogs.DIALOG_BTN_CANCEL,\n                    text: Strings.CANCEL\n                },\n                {\n                    className: Dialogs.DIALOG_BTN_CLASS_PRIMARY,\n                    id: Dialogs.DIALOG_BTN_OK,\n                    text: _getDeleteButtonString(canMoveToTrash)\n                }\n            ]\n        )\n            .done(function (id) {\n                if (id === Dialogs.DIALOG_BTN_OK) {\n                    if(Phoenix.isNativeApp && canMoveToTrash) {\n                        ProjectManager.moveToTrash(entry);\n                        return;\n                    }\n                    ProjectManager.deleteItem(entry);\n                }\n            });\n    }\n\n    /** Show the selected sidebar (tree or workingset) item in Finder/Explorer */\n    function handleShowInOS() {\n        var entry = ProjectManager.getSelectedItem();\n        if (entry) {\n            brackets.app.openPathInFileBrowser(entry.fullPath)\n                .catch(err=>console.error(\"Error showing '\" + entry.fullPath + \"' in OS folder:\", err));\n        } else {\n            brackets.app.openPathInFileBrowser(ProjectManager.getProjectRoot().fullPath)\n                .catch(err=>console.error(\"Error showing '\" + ProjectManager.getProjectRoot().fullPath + \"' in OS folder:\", err));\n        }\n    }\n\n    function openDefaultTerminal() {\n        const entry = ProjectManager.getSelectedItem();\n        if (entry && entry.fullPath) {\n            NodeUtils.openNativeTerminal(entry.fullPath);\n        } else {\n            NodeUtils.openNativeTerminal(ProjectManager.getProjectRoot().fullPath);\n        }\n    }\n\n    function openPowerShell() {\n        const entry = ProjectManager.getSelectedItem();\n        if (entry && entry.fullPath) {\n            NodeUtils.openNativeTerminal(entry.fullPath, true);\n        } else {\n            NodeUtils.openNativeTerminal(ProjectManager.getProjectRoot().fullPath, true);\n        }\n    }\n\n    function openDefaultApp() {\n        const entry = ProjectManager.getSelectedItem();\n        if (entry && entry.fullPath) {\n            NodeUtils.openInDefaultApp(entry.fullPath);\n        } else {\n            NodeUtils.openInDefaultApp(ProjectManager.getProjectRoot().fullPath);\n        }\n    }\n\n    function raceAgainstTime(promise, timeout = 2000) {\n        const timeoutPromise = new Promise((_resolve, reject) => {\n            setTimeout(() => {\n                reject(new Error(`Timed out after ${timeout} seconds`));\n            }, timeout);\n        });\n\n        return Promise.race([promise, timeoutPromise]);\n    }\n\n    /**\n    * Does a full reload of the browser window\n    * @param {string} href The url to reload into the window\n    */\n    function browserReload(href) {\n        if (_isReloading) {\n            return;\n        }\n\n        _isReloading = true;\n\n        return CommandManager.execute(Commands.FILE_CLOSE_ALL, { promptOnly: true }).done(function () {\n            exitWaitPromises = [];\n            // Give everyone a chance to save their state - but don't let any problems block\n            // us from quitting\n            try {\n                // if someone wats to do any deferred tasks, they should add\n                // their promise to the wait promises list.\n                ProjectManager.trigger(\"beforeAppClose\", exitWaitPromises);\n            } catch (ex) {\n                console.error(ex);\n            }\n\n            // Remove all menus to assure every part of Brackets is reloaded\n            _.forEach(Menus.getAllMenus(), function (value, key) {\n                Menus.removeMenu(key);\n            });\n\n            // If there's a fragment in both URLs, setting location.href won't actually reload\n            var fragment = href.indexOf(\"#\");\n            if (fragment !== -1) {\n                href = href.substr(0, fragment);\n            }\n\n            // Defer for a more successful reload - issue #11539\n            window.setTimeout(function () {\n                exitWaitPromises.push(window.PhStore.flushDB());\n                raceAgainstTime(Promise.all(exitWaitPromises)) // wither wait for flush or time this out\n                    .finally(()=>{\n                        raceAgainstTime(_safeNodeTerminate(), 4000)\n                            .finally(()=>{\n                                _resetTauriTrustRingBeforeRestart();\n                                // we do not wait/raceAgainstTime here purposefully to prevent attacks that will rely\n                                // on this brief window of no trust zone in while the kernal trust key is being reset.\n                                window.location.href = href;\n                            });\n                    });\n            }, 1000);\n        }).fail(function () {\n            _isReloading = false;\n        });\n    }\n\n    /**\n     * Restarts brackets Handler\n     * @param {boolean=} loadWithoutExtensions - true to restart without extensions,\n     *                                           otherwise extensions are loadeed as it is durning a typical boot\n     * @param {Array<String>|string} loadDevExtensionPath If specified, will load the extension from the path. IF\n     * and empty array is specified, it will unload all dev extensions on reload.\n     */\n    function handleReload(loadWithoutExtensions=false, loadDevExtensionPath=[]) {\n        var href    = window.location.href,\n            params  = new UrlParams();\n\n        // Make sure the Reload Without User Extensions parameter is removed\n        params.parse();\n\n        function _removeLoadDevExtensionPathParam() {\n            if (params.get(\"loadDevExtensionPath\")) {\n                params.remove(\"loadDevExtensionPath\");\n                // only remove logging flag if the flag is set for loadDevExtensionPath\n                if (params.get(logger.loggingOptions.LOCAL_STORAGE_KEYS.LOG_TO_CONSOLE_KEY)) {\n                    params.remove(logger.loggingOptions.LOCAL_STORAGE_KEYS.LOG_TO_CONSOLE_KEY);\n                }\n            }\n        }\n\n        if (loadWithoutExtensions) {\n            if (!params.get(\"reloadWithoutUserExts\")) {\n                params.put(\"reloadWithoutUserExts\", true);\n            }\n            _removeLoadDevExtensionPathParam();\n        } else {\n            if (params.get(\"reloadWithoutUserExts\")) {\n                params.remove(\"reloadWithoutUserExts\");\n            }\n            if(loadDevExtensionPath && loadDevExtensionPath.length){\n                params.put(\"loadDevExtensionPath\", loadDevExtensionPath);\n                // since we are loading a development extension, we have to enable detailed logs too on reload\n                params.put(logger.loggingOptions.LOCAL_STORAGE_KEYS.LOG_TO_CONSOLE_KEY, \"true\");\n            } else if (loadDevExtensionPath && loadDevExtensionPath.length === 0) {\n                _removeLoadDevExtensionPathParam();\n            }\n        }\n\n        if (href.indexOf(\"?\") !== -1) {\n            href = href.substring(0, href.indexOf(\"?\"));\n        }\n\n        if (!params.isEmpty()) {\n            href += \"?\" + params.toString();\n        }\n\n        // Give Mac native menus extra time to update shortcut highlighting.\n        // Prevents the menu highlighting from getting messed up after reload.\n        window.setTimeout(function () {\n            browserReload(href);\n        }, 100);\n    }\n\n    /** Reload Without Extensions commnad handler **/\n    var handleReloadWithoutExts = _.partial(handleReload, true);\n\n    /**\n     * Attach a beforeunload handler to notify user about unsaved changes and URL redirection in CEF.\n     * Prevents data loss in scenario reported under #13708\n     * Make sure we don't attach this handler if the current window is actually a test window\n    **/\n\n    function attachBrowserUnloadHandler() {\n        window.onbeforeunload = function(e) {\n            PreferencesManager.setViewState(\"windowClosingTime\", new Date().getTime());\n            _handleWindowGoingAway(null, closeSuccess=>{\n                console.log('close success: ', closeSuccess);\n            }, closeFail=>{\n                console.log('close fail: ', closeFail);\n            });\n            var openDocs = DocumentManager.getAllOpenDocuments();\n\n            // Detect any unsaved changes\n            openDocs = openDocs.filter(function(doc) {\n                return doc && doc.isDirty;\n            });\n\n            // Ensure we are not in normal app-quit or reload workflow\n            if (!_isReloading && !_windowGoingAway) {\n                if (openDocs.length > 0) {\n                    return Strings.WINDOW_UNLOAD_WARNING_WITH_UNSAVED_CHANGES;\n                }\n                return Strings.WINDOW_UNLOAD_WARNING;\n            }\n        };\n    }\n\n    async function _safeFlushDB() {\n        // close should not be interrupted.\n        try{\n            await window.PhStore.flushDB();\n        } catch (e) {\n            console.error(e);\n        }\n    }\n\n    let nodeTerminateDueToShutdown = false;\n    async function _safeNodeTerminate() {\n        // close should not be interrupted.\n        nodeTerminateDueToShutdown = true;\n        try{\n            await NodeConnector.terminateNode();\n        } catch (e) {\n            console.error(e);\n        }\n    }\n    if(window.nodeTerminationPromise) {\n        window.nodeTerminationPromise\n            .then(()=>{\n                if(nodeTerminateDueToShutdown){\n                    return; // normal shutdown\n                }\n                Metrics.countEvent(Metrics.EVENT_TYPE.NODEJS, 'crash', Phoenix.platform);\n                window.fs.forceUseNodeWSEndpoint(false);\n                Dialogs\n                    .showErrorDialog(Strings.ERROR_NODE_JS_CRASH_TITLE, Strings.ERROR_NODE_JS_CRASH_MESSAGE)\n                    .done(()=>{\n                        handleReload();\n                    });\n            });\n    }\n\n    let closeInProgress;\n    let closeClickCounter = 0;\n    const CLOSE_TIMER_RESET_INTERVAL = 4000;\n    let closeTimer = setTimeout(()=>{\n        closeClickCounter = 0;\n        closeTimer = null;\n    }, CLOSE_TIMER_RESET_INTERVAL);\n\n    function _forceQuitIfNeeded() {\n        closeClickCounter++;\n        if(closeTimer){\n            clearTimeout(closeTimer);\n        }\n        closeTimer = setInterval(()=>{\n            closeClickCounter = 0;\n            closeTimer = null;\n        }, CLOSE_TIMER_RESET_INTERVAL);\n        if(closeClickCounter >= 2) {\n            // the user clicked the close button 2 times in the last 4 secs, he's desperate, close the window now!.\n            Phoenix.app.closeWindow(true);\n        }\n    }\n    function attachTauriUnloadHandler() {\n        window.__TAURI__.window.appWindow.onCloseRequested((event)=>{\n            _forceQuitIfNeeded();\n            if(closeInProgress){\n                event.preventDefault();\n                return;\n            }\n            closeInProgress = true;\n            PreferencesManager.setViewState(\"windowClosingTime\", new Date().getTime());\n            event.preventDefault();\n            _handleWindowGoingAway(null, closeSuccess=>{\n                console.log('close success: ', closeSuccess);\n                exitWaitPromises.push(_safeFlushDB());\n                raceAgainstTime(Promise.all(exitWaitPromises))\n                    .finally(()=>{\n                        raceAgainstTime(_safeNodeTerminate())\n                            .finally(()=>{\n                                closeInProgress = false;\n                                Phoenix.app.closeWindow();\n                            });\n                    });\n            }, closeFail=>{\n                console.log('close fail: ', closeFail);\n                closeInProgress = false;\n            });\n        });\n    }\n\n    let isTestWindow = (new window.URLSearchParams(window.location.search || \"\")).get(\"testEnvironment\");\n    if (!isTestWindow) {\n        if(Phoenix.isNativeApp) {\n            attachTauriUnloadHandler();\n        } else {\n            attachBrowserUnloadHandler();\n        }\n    }\n\n    /** Do some initialization when the DOM is ready **/\n    AppInit.htmlReady(function () {\n        // If in Reload Without User Extensions mode, update UI and log console message\n        var params      = new UrlParams(),\n            $icon       = $(\"#toolbar-extension-manager\"),\n            $indicator  = $(\"<div>\" + Strings.STATUSBAR_USER_EXTENSIONS_DISABLED + \"</div>\");\n\n        params.parse();\n\n        if (params.get(\"reloadWithoutUserExts\") === \"true\") {\n            CommandManager.get(Commands.FILE_EXTENSION_MANAGER).setEnabled(false);\n            $icon.css({display: \"none\"});\n            StatusBar.addIndicator(\"status-user-exts\", $indicator, true);\n            console.log(\"Brackets reloaded with extensions disabled\");\n        }\n\n        // Init DOM elements\n        _$titleContainerToolbar = $(\"#titlebar\");\n        _$titleWrapper = $(\".title-wrapper\", _$titleContainerToolbar);\n        _$title = $(\".title\", _$titleWrapper);\n        _$dirtydot = $(\".dirty-dot\", _$titleWrapper);\n    });\n\n    if(Phoenix.isSpecRunnerWindow){\n        _$titleContainerToolbar = $(\"#titlebar\");\n        _$titleWrapper = $(\".title-wrapper\");\n        _$title = $(\".title\");\n        _$dirtydot = $(\".dirty-dot\");\n    }\n\n    let firstProjectOpenHandled = false;\n    ProjectManager.on(ProjectManager.EVENT_AFTER_PROJECT_OPEN, ()=>{\n        closedFilesHistory = new Map();\n        _enableOrDisableReopenClosedCmd();\n        if(firstProjectOpenHandled){\n            return;\n        }\n        firstProjectOpenHandled = true;\n        Phoenix.app.setSingleInstanceCLIArgsHandler(_singleInstanceHandler);\n        _openFilesPassedInFromCLI()\n            .finally(()=>{\n                // in mac, this is not exactly correct. This event will get triggered on startup, but mac will only\n                // raise events in the background and there is no way for us to know when the mac open with events\n                // come. Use this event carefully in mac.\n                ProjectManager.trigger(ProjectManager.EVENT_AFTER_STARTUP_FILES_LOADED);\n            });\n    });\n\n    // Exported for unit testing only\n    exports._parseDecoratedPath = _parseDecoratedPath;\n\n    // Set some command strings\n    let quitString  = Strings.CMD_QUIT,\n        showInOS    = Strings.CMD_SHOW_IN_FILE_MANAGER,\n        defaultTerminal    = Strings.CMD_OPEN_IN_TERMINAL_DO_NOT_TRANSLATE;\n    if (brackets.platform === \"win\") {\n        quitString  = Strings.CMD_EXIT;\n        showInOS    = Strings.CMD_SHOW_IN_EXPLORER;\n        defaultTerminal    = Strings.CMD_OPEN_IN_CMD;\n    } else if (brackets.platform === \"mac\") {\n        showInOS    = Strings.CMD_SHOW_IN_FINDER;\n    }\n\n    // private api\n    exports._EVENT_OPEN_WITH_FILE_FROM_OS = _EVENT_OPEN_WITH_FILE_FROM_OS;\n    exports._isOpenWithFileFromOS = function () {\n        return !!_filesOpenedFromOsCount;\n    };\n\n    // Define public API\n    exports.showFileOpenError = showFileOpenError;\n    exports.APP_QUIT_CANCELLED = APP_QUIT_CANCELLED;\n\n\n    // Deprecated commands\n    CommandManager.register(Strings.CMD_ADD_TO_WORKING_SET,          Commands.FILE_ADD_TO_WORKING_SET,        handleFileAddToWorkingSet);\n    CommandManager.register(Strings.CMD_FILE_OPEN,                   Commands.FILE_OPEN,                      handleDocumentOpen);\n\n    // New commands\n    CommandManager.register(Strings.CMD_ADD_TO_WORKING_SET,          Commands.CMD_ADD_TO_WORKINGSET_AND_OPEN, handleFileAddToWorkingSetAndOpen);\n    CommandManager.register(Strings.CMD_FILE_OPEN,                   Commands.CMD_OPEN,                       handleFileOpen);\n\n    // File Commands\n    CommandManager.register(Strings.CMD_FILE_NEW_UNTITLED,           Commands.FILE_NEW_UNTITLED,              handleFileNew);\n    CommandManager.register(Strings.CMD_FILE_NEW,                    Commands.FILE_NEW,                       handleFileNewInProject);\n    CommandManager.register(Strings.CMD_FILE_NEW_FOLDER,             Commands.FILE_NEW_FOLDER,                handleNewFolderInProject);\n    CommandManager.register(Strings.CMD_FILE_SAVE,                   Commands.FILE_SAVE,                      handleFileSave);\n    CommandManager.register(Strings.CMD_FILE_SAVE_ALL,               Commands.FILE_SAVE_ALL,                  handleFileSaveAll);\n    CommandManager.register(Strings.CMD_FILE_SAVE_AS,                Commands.FILE_SAVE_AS,                   handleFileSaveAs);\n    CommandManager.register(Strings.CMD_FILE_RENAME,                 Commands.FILE_RENAME,                    handleFileRename);\n    CommandManager.register(Strings.CMD_FILE_DELETE,                 Commands.FILE_DELETE,                    handleFileDelete);\n\n    // Close Commands\n    CommandManager.register(Strings.CMD_FILE_CLOSE,                  Commands.FILE_CLOSE,                     handleFileClose);\n    CommandManager.register(Strings.CMD_FILE_CLOSE_ALL,              Commands.FILE_CLOSE_ALL,                 handleFileCloseAll);\n    CommandManager.register(Strings.CMD_FILE_CLOSE_LIST,             Commands.FILE_CLOSE_LIST,                handleFileCloseList);\n    CommandManager.register(Strings.CMD_REOPEN_CLOSED,               Commands.FILE_REOPEN_CLOSED,             handleReopenClosed);\n\n    // Traversal\n    CommandManager.register(Strings.CMD_NEXT_DOC,                    Commands.NAVIGATE_NEXT_DOC,              handleGoNextDoc);\n    CommandManager.register(Strings.CMD_PREV_DOC,                    Commands.NAVIGATE_PREV_DOC,              handleGoPrevDoc);\n\n    CommandManager.register(Strings.CMD_NEXT_DOC_LIST_ORDER,         Commands.NAVIGATE_NEXT_DOC_LIST_ORDER,   handleGoNextDocListOrder);\n    CommandManager.register(Strings.CMD_PREV_DOC_LIST_ORDER,         Commands.NAVIGATE_PREV_DOC_LIST_ORDER,   handleGoPrevDocListOrder);\n\n    // Special Commands\n    CommandManager.register(showInOS,                                Commands.NAVIGATE_SHOW_IN_OS,            handleShowInOS);\n    CommandManager.register(defaultTerminal,                         Commands.NAVIGATE_OPEN_IN_TERMINAL,      openDefaultTerminal);\n    if (brackets.platform === \"win\") {\n        CommandManager.register(Strings.CMD_OPEN_IN_POWER_SHELL,     Commands.NAVIGATE_OPEN_IN_POWERSHELL,    openPowerShell);\n    }\n    CommandManager.register(Strings.CMD_OPEN_IN_DEFAULT_APP,         Commands.NAVIGATE_OPEN_IN_DEFAULT_APP,   openDefaultApp);\n    CommandManager.register(Strings.CMD_NEW_BRACKETS_WINDOW,         Commands.FILE_NEW_WINDOW,                handleFileNewWindow);\n    CommandManager.register(quitString,                              Commands.FILE_QUIT,                      handleFileCloseWindow);\n    CommandManager.register(Strings.CMD_SHOW_IN_TREE,                Commands.NAVIGATE_SHOW_IN_FILE_TREE,     handleShowInTree);\n\n    // These commands have no UI representation and are only used internally\n    CommandManager.registerInternal(Commands.APP_ABORT_QUIT,            handleAbortQuit);\n    CommandManager.registerInternal(Commands.APP_BEFORE_MENUPOPUP,      handleBeforeMenuPopup);\n    CommandManager.registerInternal(Commands.FILE_CLOSE_WINDOW,         handleFileCloseWindow);\n    CommandManager.registerInternal(Commands.APP_RELOAD,                handleReload);\n    CommandManager.registerInternal(Commands.APP_RELOAD_WITHOUT_EXTS,   handleReloadWithoutExts);\n\n    // Listen for changes that require updating the editor titlebar\n    ProjectManager.on(\"projectOpen\", ()=>{\n        alwaysOverwriteTillProjectSwitch = false;\n        _updateTitle();\n    });\n    DocumentManager.on(\"dirtyFlagChange\", handleDirtyChange);\n    DocumentManager.on(\"fileNameChange\", handleCurrentFileChange);\n    MainViewManager.on(\"currentFileChange\", handleCurrentFileChange);\n\n    // Reset the untitled document counter before changing projects\n    ProjectManager.on(\"beforeProjectClose\", function () { _nextUntitledIndexToUse = 1; });\n});\n"],"file":"DocumentCommandHandlers.js"}