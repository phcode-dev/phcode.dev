{"version":3,"sources":["utils/LocalizationUtils.js"],"names":["define","require","exports","module","Strings","getLocalizedLabel","locale","key","toUpperCase","replace","i18n","undefined","DATE_TIME_STYLE","FULL","LONG","MEDIUM","SHORT","getFormattedDateTime","date","lang","dateTimeFormat","Date","dateStyle","timeStyle","Intl","DateTimeFormat","brackets","getLocale","format","dateTimeFromNow","fromDate","diffInSeconds","Math","floor","rtf","RelativeTimeFormat","numeric","abs","trunc","dateTimeFromNowFriendly","diffInMilliseconds","diffInDays","currentYear","getFullYear","dateYear","languageOption","month","day","year"],"mappings":"AAuBAA,OAAO,SAAUC,QAASC,QAASC,QAE/B,MAAMC,QAAUH,QAAQ,WASxB,SAASI,kBAAkBC,QACvB,IAAIC,IAAO,UAAYD,OAAOE,cAAcC,QAAQ,IAAK,KACrDC,KAAON,QAAQG,KAEnB,YAAgBI,IAATD,KAAqBJ,OAASI,KAGzC,MAAME,gBAAkB,CACpBC,KAAM,OACNC,KAAM,OACNC,OAAQ,SACRC,MAAO,SAeX,SAASC,qBAAqBC,KAAMC,KAAMC,gBAUtC,OATIF,OACAA,KAAO,IAAIG,MAEXD,iBACAA,eAAiB,CACbE,UAAWV,gBAAgBG,OAC3BQ,UAAWX,gBAAgBI,QAG5BQ,KAAKC,eAAe,CAACN,MAAQO,SAASC,aAAe,KAAM,MAAOP,gBAAgBQ,OAAOV,MAYpG,SAASW,gBAAgBX,KAAMC,KAAMW,UACjCZ,KAAOA,MAAQ,IAAIG,KACnBS,SAAWA,UAAY,IAAIT,KAC3B,MAAMU,cAAgBC,KAAKC,OAAOf,KAAOY,UAAY,KAE/CI,IAAM,IAAIV,KAAKW,mBAAmB,CAAChB,MAAQO,SAASC,aAAe,KAAM,MAC3E,CAAES,QAAS,SACf,OAAIJ,KAAKK,IAAIN,eAAiB,EAEnBG,IAAIN,OAAO,EAAG,UACdI,KAAKK,IAAIN,eAAiB,GAC1BG,IAAIN,OAAOG,cAAe,UAC1BC,KAAKK,IAAIN,eAAiB,KAC1BG,IAAIN,OAAOI,KAAKM,MAAMP,cAAgB,IAAK,UAC3CC,KAAKK,IAAIN,eAAiB,MAC1BG,IAAIN,OAAOI,KAAKM,MAAMP,cAAgB,MAAO,QAC7CC,KAAKK,IAAIN,eAAiB,OAC1BG,IAAIN,OAAOI,KAAKM,MAAMP,cAAgB,OAAQ,OAC9CC,KAAKK,IAAIN,eAAiB,QAC1BG,IAAIN,OAAOI,KAAKM,MAAMP,cAAgB,QAAU,SAEhDG,IAAIN,OAAOI,KAAKM,MAAMP,cAAgB,SAAW,QAehE,SAASQ,wBAAwBrB,KAAMC,KAAMW,UAEzC,MAAMU,mBAAqBtB,MAD3BY,SAAWA,UAAY,IAAIT,MAErBoB,WAAaT,KAAKM,MAAME,mBAAqB,OAGnD,GAAIR,KAAKK,IAAII,aAAe,GACxB,OAAOZ,gBAAgBX,KAAMC,MAIjC,MAAMuB,YAAcZ,SAASa,cACvBC,SAAW1B,KAAKyB,cAEhBE,eAAiB,CAAC1B,MAAQO,SAASC,aAAe,KAAM,MAE9D,OAAIe,cAAgBE,SACT,IAAIpB,KAAKC,eAAeoB,eAAgB,CAAEC,MAAO,QAASC,IAAK,YAAanB,OAAOV,MAIvF,IAAIM,KAAKC,eAAeoB,eAC3B,CAAEC,MAAO,QAASC,IAAK,UAAWC,KAAM,YAAapB,OAAOV,MAIpEhB,QAAQG,kBAAoBA,kBAC5BH,QAAQe,qBAAuBA,qBAC/Bf,QAAQ2B,gBAAkBA,gBAC1B3B,QAAQqC,wBAA0BA,wBAElCrC,QAAQU,gBAAkBA","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2014 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n// @INCLUDE_IN_API_DOCS\n\ndefine(function (require, exports, module) {\n\n    const Strings = require(\"strings\");\n\n    /**\n     * Converts a language code to its written name, if possible.\n     * If not possible, the language code is simply returned.\n     *\n     * @param {string} locale The two-char language code\n     * @return {string} The language's name or the given language code\n     */\n    function getLocalizedLabel(locale) {\n        var key  = \"LOCALE_\" + locale.toUpperCase().replace(\"-\", \"_\"),\n            i18n = Strings[key];\n\n        return i18n === undefined ? locale : i18n;\n    }\n\n    const DATE_TIME_STYLE = {\n        FULL: \"full\",\n        LONG: \"long\",\n        MEDIUM: \"medium\",\n        SHORT: \"short\"\n    };\n\n    /**\n     * Formats a given date object into a locale-aware date and time string.\n     *\n     * @param {Date} [date] - The date object to format. If not provided, the current date and time will be used.\n     * @param {string} [lang] - Optional language code to use for formatting (e.g., 'en', 'fr').\n     *                          If not provided, defaults to the application locale or 'en'.\n     * @param {Object} [dateTimeFormat] - Optional object specifying the date and time formatting options.\n     *                                    Defaults to `{ dateStyle: 'medium', timeStyle: 'short' }`.\n     * @param {string} [dateTimeFormat.dateStyle] - Specifies the date format style. One of: DATE_TIME_STYLE.*\n     * @param {string} [dateTimeFormat.timeStyle] - Specifies the time format style. One of: DATE_TIME_STYLE.*\n     * @returns {string} - The formatted date and time string (e.g., \"Dec 24, 2024, 10:30 AM\").\n     */\n    function getFormattedDateTime(date, lang, dateTimeFormat) {\n        if(!date){\n            date = new Date();\n        }\n        if(!dateTimeFormat){\n            dateTimeFormat = {\n                dateStyle: DATE_TIME_STYLE.MEDIUM,\n                timeStyle: DATE_TIME_STYLE.SHORT\n            };\n        }\n        return Intl.DateTimeFormat([lang || brackets.getLocale() || \"en\", \"en\"], dateTimeFormat).format(date);\n    }\n\n    /**\n     * Returns a relative time string (e.g., \"2 days ago\", \"in 3 hours\") based on the difference between the given date and now.\n     *\n     * @param {Date} [date] - The date to compare with the current date and time. If not given, defaults to now.\n     * @param {string} [lang] - Optional language code to use for formatting (e.g., 'en', 'fr').\n     *                          If not provided, defaults to the application locale or 'en'.\n     * @param {Date} [fromDate] - Optional date to use instead of now to compute the relative dateTime from.\n     * @returns {string} - A human-readable relative time string (e.g., \"2 days ago\", \"in 3 hours\").\n     */\n    function dateTimeFromNow(date, lang, fromDate) {\n        date = date || new Date();\n        fromDate = fromDate || new Date();\n        const diffInSeconds = Math.floor((date - fromDate) / 1000);\n\n        const rtf = new Intl.RelativeTimeFormat([lang || brackets.getLocale() || \"en\", \"en\"],\n            { numeric: 'auto' });\n        if (Math.abs(diffInSeconds) < 3) {\n            // we consider diffs less than 3 seconds to be always 'now', for better UX and for unit tests stability.\n            return rtf.format(0, 'second');\n        } else if (Math.abs(diffInSeconds) < 60) {\n            return rtf.format(diffInSeconds, 'second');\n        } else if (Math.abs(diffInSeconds) < 3600) {\n            return rtf.format(Math.trunc(diffInSeconds / 60), 'minute');\n        } else if (Math.abs(diffInSeconds) < 86400) {\n            return rtf.format(Math.trunc(diffInSeconds / 3600), 'hour');\n        } else if (Math.abs(diffInSeconds) < 2592000) {\n            return rtf.format(Math.trunc(diffInSeconds / 86400), 'day');\n        } else if (Math.abs(diffInSeconds) < 31536000) {\n            return rtf.format(Math.trunc(diffInSeconds / 2592000), 'month');\n        } else {\n            return rtf.format(Math.trunc(diffInSeconds / 31536000), 'year');\n        }\n    }\n\n    /**\n     * Returns an intelligent date string.\n     * - For dates within the last 30 days or the future: relative time (e.g., \"2 days ago\", \"in 3 hours\").\n     * - For dates earlier this year: formatted date (e.g., \"Jan 5\").\n     * - For dates not in the current year: formatted date with year (e.g., \"Jan 5, 2023\").\n     *\n     * @param {Date} date - The date to compare and format.\n     * @param {string} [lang] - Optional language code to use for formatting (e.g., 'en', 'fr').\n     * @param {Date} [fromDate] - Optional date to use instead of now to compute the relative dateTime from.\n     * @returns {string} - An intelligently formatted date string.\n     */\n    function dateTimeFromNowFriendly(date, lang, fromDate) {\n        fromDate = fromDate || new Date();\n        const diffInMilliseconds = date - fromDate;\n        const diffInDays = Math.trunc(diffInMilliseconds / (1000 * 60 * 60 * 24));\n\n        // If within the last 30 days or the future, use relative time\n        if (Math.abs(diffInDays) <= 30) {\n            return dateTimeFromNow(date, lang);\n        }\n\n        // If in the current year, format as \"MMM DD\"\n        const currentYear = fromDate.getFullYear();\n        const dateYear = date.getFullYear();\n\n        const languageOption = [lang || brackets.getLocale() || \"en\", \"en\"];\n\n        if (currentYear === dateYear) {\n            return new Intl.DateTimeFormat(languageOption, { month: \"short\", day: \"numeric\" }).format(date);\n        }\n\n        // For dates in previous years, format as \"MMM DD, YYYY\"\n        return new Intl.DateTimeFormat(languageOption,\n            { month: \"short\", day: \"numeric\", year: \"numeric\" }).format(date);\n    }\n\n    // Define public API\n    exports.getLocalizedLabel = getLocalizedLabel;\n    exports.getFormattedDateTime = getFormattedDateTime;\n    exports.dateTimeFromNow = dateTimeFromNow;\n    exports.dateTimeFromNowFriendly = dateTimeFromNowFriendly;\n    // public constants\n    exports.DATE_TIME_STYLE = DATE_TIME_STYLE;\n});\n"],"file":"LocalizationUtils.js"}