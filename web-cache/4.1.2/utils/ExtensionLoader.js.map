{"version":3,"sources":["utils/ExtensionLoader.js"],"names":["define","require","exports","module","_","EventDispatcher","FileSystem","FileUtils","Async","ExtensionUtils","ThemeManager","UrlParams","NodeUtils","PathUtils","DefaultExtensions","JSON","parse","EXTENSION_TAKEDOWN_LOCALSTORAGE_KEY","_getTakedownListLS","list","localStorage","getItem","Array","isArray","e","console","error","loadedExtensionIDs","Set","takedownExtensionList","EXTENSION_TAKEDOWN_URL","brackets","config","extensionTakedownURL","_anyTakenDownExtensionLoaded","size","smaller","larger","matches","id","has","push","fetchWithTimeout","url","ms","c","AbortController","t","setTimeout","abort","fetch","signal","finally","clearTimeout","then","response","ok","Error","status","statusText","json","data","log","every","x","dataToWrite","stringify","setItem","compromisedExtensionsLoaded","length","writtenData","location","reload","catch","desktopOnlyExtensions","desktopOnly","DefaultExtensionsList","Phoenix","isNativeApp","defaultExtensionsList","isTestWindow","index","indexOf","splice","customExtensionLoadPaths","_DELETED_EXTENSION_FILE_MARKER","EXTENSION_LOAD_TIMOUT_SECONDS","INIT_EXTENSION_TIMEOUT","EVENT_EXTENSION_LOADED","EVENT_EXTENSION_DISABLED","EVENT_EXTENSION_LOAD_FAILED","_init","_extensions","_initExtensionTimeout","srcPath","getNativeBracketsDirectoryPath","contexts","pathLib","VFS","path","replace","globalPaths","_getGlobalRequireJSConfig","paths","Object","keys","forEach","key","makePathAbsolute","DEFAULT_EXTENSIONS_PATH_BASE","getDefaultExtensionPath","window","PhoenixBaseURL","_getExtensionPath","normalize","getExtensionDir","getDevExtensionPath","getDevExtensionDir","getUserExtensionPath","getUserExtensionDir","getRequireContextForExtension","name","_getInitExtensionTimeout","_setInitExtensionTimeout","value","_mergeConfigFromURL","baseConfig","deferred","$","Deferred","extensionConfigFile","baseUrl","getJSON","done","extensionConfig","extend","omit","resolve","err","reject","fail","promise","_mergeConfig","startsWith","savedFSlib","fs","_loadNodeExtension","extensionMainPath","nodeConfig","mainPlatformPath","getTauriPlatformPath","_loadNodeExtensionModule","loadExtensionModule","entryPoint","metadata","context","locale","getLocale","waitSeconds","text","useXhr","_url","_protocol","_hostname","_port","isDefaultExtensionModule","mergedConfig","extensionRequire","libRequire","extensionRequireDeferred","nativeDir","nodeIsRequired","main","join","initPromise","initExtension","withTimeout","logger","reportError","errorMessage","ERROR_TIMEOUT","errback","additionalInfo","String","requireType","originalError","target","src","stack","loadExtension","loadMetadata","always","isExtensionTakenDown","leaveTrail","warn","add","theme","disabled","trigger","_testExtensionByURL","result","testExtension","extensionPath","entry","isFile","async","_removeExtensionsMarkedForDelete","directory","contents","extensions","promises","extensionEntry","isDirectory","extensionName","markedRemove","getFileForPath","existsAsync","deleteMarkerExists","Promise","unlink","fullPath","all","_loadAll","processExtension","getDirectoryForPath","getContents","doInParallel","item","extConfig","getVirtualServingURLForPath","loadAllDefaultExtensions","_loadDefaultExtension","extensionFolderName","loadAllExtensionsInNativeDirectory","loadExtensionFromNativeDirectory","testAllExtensionsInNativeDirectory","extensionsDir","perf","spec","i","loadResult","basePath","testAllDefaultExtensions","bracketsPath","srcBaseUrl","URL","href","endsWith","getSourcePathForExtension","devTempExtDir","getDevTempExtensionDir","customExtensionLoadPath","srcBasePath","ensureTrailingSlash","relativePath","_attachThemeLoadListeners","off","EVENT_THEME_LOADED","on","refresh","_getRandomPrefix","uuid","crypto","randomUUID","split","_loadCustomExtensionPath","extPath","assetsServeDir","getTauriAssetServeDir","getTauriDir","newExtVersionStr","extParentPath","basename","extDestPath","ensureExistsDirAsync","copy","_copiedPath","init","params","get","customLoadPaths","customPath","create","disabledExtensionPath","KernalModeTrust","extensionID","makeEventDispatcher"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n *\n */\n\n\n// @INCLUDE_IN_API_DOCS\n\n/**\n * ExtensionLoader searches the filesystem for extensions, then creates a new context for each one and loads it.\n * This module dispatches the following events:\n *      \"load\" - when an extension is successfully loaded. The second argument is the file path to the\n *          extension root.\n *      \"loadFailed\" - when an extension load is unsuccessful. The second argument is the file path to the\n *          extension root.\n */\n// jshint ignore: start\n/*global logger, path*/\n/*eslint-env es6*/\n/*eslint no-console: 0*/\n/*eslint strict: [\"error\", \"global\"]*/\n\ndefine(function (require, exports, module) {\n\n\n    require(\"utils/Global\");\n\n    const _              = require(\"thirdparty/lodash\"),\n        EventDispatcher = require(\"utils/EventDispatcher\"),\n        FileSystem     = require(\"filesystem/FileSystem\"),\n        FileUtils      = require(\"file/FileUtils\"),\n        Async          = require(\"utils/Async\"),\n        ExtensionUtils = require(\"utils/ExtensionUtils\"),\n        ThemeManager   = require(\"view/ThemeManager\"),\n        UrlParams      = require(\"utils/UrlParams\").UrlParams,\n        NodeUtils = require(\"utils/NodeUtils\"),\n        PathUtils      = require(\"thirdparty/path-utils/path-utils\"),\n        DefaultExtensions = JSON.parse(require(\"text!extensions/default/DefaultExtensions.json\"));\n\n    // takedown/dont load extensions that are compromised at app start - start\n    const EXTENSION_TAKEDOWN_LOCALSTORAGE_KEY = \"PH_EXTENSION_TAKEDOWN_LIST\";\n\n    function _getTakedownListLS() {\n        try{\n            let list = localStorage.getItem(EXTENSION_TAKEDOWN_LOCALSTORAGE_KEY);\n            if(list) {\n                list = JSON.parse(list);\n                if (Array.isArray(list)) {\n                    return list;\n                }\n            }\n        } catch (e) {\n            console.error(e);\n        }\n        return [];\n    }\n\n    const loadedExtensionIDs = new Set();\n    let takedownExtensionList = new Set(_getTakedownListLS());\n\n    const EXTENSION_TAKEDOWN_URL = brackets.config.extensionTakedownURL;\n\n    function _anyTakenDownExtensionLoaded() {\n        if (takedownExtensionList.size === 0 || loadedExtensionIDs.size === 0) {\n            return [];\n        }\n        let smaller;\n        let larger;\n\n        if (takedownExtensionList.size < loadedExtensionIDs.size) {\n            smaller = takedownExtensionList;\n            larger = loadedExtensionIDs;\n        } else {\n            smaller = loadedExtensionIDs;\n            larger = takedownExtensionList;\n        }\n\n        const matches = [];\n\n        for (const id of smaller) {\n            if (larger.has(id)) {\n                matches.push(id);\n            }\n        }\n\n        return matches;\n    }\n\n    function fetchWithTimeout(url, ms) {\n        const c = new AbortController();\n        const t = setTimeout(() => c.abort(), ms);\n        return fetch(url, { signal: c.signal }).finally(() => clearTimeout(t));\n    }\n\n    // we dont want a restart after user does too much in the app causing data loss. So we wont reload after 20 seconds.\n    fetchWithTimeout(EXTENSION_TAKEDOWN_URL, 20000)\n        .then(response => {\n            if (!response.ok) {\n                throw new Error(`HTTP ${response.status} - ${response.statusText}`);\n            }\n            return response.json();\n        })\n        .then(data => {\n            console.log('Extension takedown data:', data);\n            if (!Array.isArray(data) || !data.every(x => typeof x === \"string\")) {\n                console.error(\"Takedown list must be an array of strings.\");\n                return;\n            }\n            const dataToWrite = JSON.stringify(data);\n            localStorage.setItem(EXTENSION_TAKEDOWN_LOCALSTORAGE_KEY, dataToWrite);\n            takedownExtensionList = new Set(data);\n            const compromisedExtensionsLoaded = _anyTakenDownExtensionLoaded();\n            if(!compromisedExtensionsLoaded.length){\n                return;\n            }\n            // if we are here, we have already loaded some compromised extensions. we need to reload app as soon as\n            // possible. no await after this. all sync js calls to prevent extension from tampering with this list.\n            const writtenData = localStorage.getItem(EXTENSION_TAKEDOWN_LOCALSTORAGE_KEY);\n            if(writtenData !== dataToWrite) {\n                // the write did not succeded. local storage write can fail if storage full, if so we may cause infinite\n                // reloads here if we dont do the check.\n                console.error(\"Failed to write taken down extension to localstorage\");\n                return;\n            }\n            location.reload();\n        })\n        .catch(console.error);\n    // takedown/dont load extensions that are compromised at app start - end\n\n    const desktopOnlyExtensions = DefaultExtensions.desktopOnly;\n    const DefaultExtensionsList = Phoenix.isNativeApp ?\n        [...DefaultExtensions.defaultExtensionsList, ...desktopOnlyExtensions]:\n        DefaultExtensions.defaultExtensionsList;\n\n    if(Phoenix.isTestWindow) {\n        // we dont load the heavy weight git extension by default for tests as huge number\n        // of tests written before git integration and too hard to fix those failing tests for now.\n        // we will just have new tests from git specific workflows.\n        const index = DefaultExtensionsList.indexOf(\"Git\");\n        if(index !== -1) {\n            DefaultExtensionsList.splice(index, 1);\n        }\n    }\n\n    const customExtensionLoadPaths = {};\n\n    const _DELETED_EXTENSION_FILE_MARKER = \"_phcode_extension_marked_for_delete\";\n\n    // default async initExtension timeout\n    var EXTENSION_LOAD_TIMOUT_SECONDS = 60,\n        INIT_EXTENSION_TIMEOUT = EXTENSION_LOAD_TIMOUT_SECONDS * 1000;\n\n    /**\n     * Extension loaded event\n     *\n     * @const\n     * @type {string}\n     */\n    const EVENT_EXTENSION_LOADED = \"load\";\n\n    /**\n     * Extension disabled event\n     *\n     * @const\n     * @type {string}\n     */\n    const EVENT_EXTENSION_DISABLED = \"disabled\";\n\n    /**\n     * Extension load failed event\n     *\n     * @const\n     * @type {string}\n     */\n    const EVENT_EXTENSION_LOAD_FAILED = \"loadFailed\";\n\n    var _init       = false,\n        _extensions = {},\n        _initExtensionTimeout = INIT_EXTENSION_TIMEOUT,\n        srcPath     = FileUtils.getNativeBracketsDirectoryPath();\n\n    /**\n     * Stores require.js contexts of extensions\n     *\n     * @private\n     * @type {Object.<string, Object>}\n     */\n    var contexts    = {};\n\n    var pathLib =  Phoenix.VFS.path;\n\n    // The native directory path ends with either \"test\" or \"src\". We need \"src\" to\n    // load the text and i18n modules.\n    srcPath = srcPath.replace(/\\/test$/, \"/src\"); // convert from \"test\" to \"src\"\n\n\n    // Retrieve the global paths\n    var globalPaths = brackets._getGlobalRequireJSConfig().paths;\n\n    // Convert the relative paths to absolute\n    Object.keys(globalPaths).forEach(function (key) {\n        globalPaths[key] = PathUtils.makePathAbsolute(srcPath + \"/\" + globalPaths[key]);\n    });\n\n    /**\n     * Returns the path to the default extensions directory relative to Phoenix base URL\n     *\n     * @private\n     */\n    const DEFAULT_EXTENSIONS_PATH_BASE = \"extensions/default\";\n\n    /**\n     * Responsible to get the default extension path\n     *\n     * @returns {string}\n     */\n    function getDefaultExtensionPath() {\n        return window.PhoenixBaseURL + DEFAULT_EXTENSIONS_PATH_BASE;\n    }\n\n    /**\n     * Returns the full path to the development extensions directory.\n     *\n     * @private\n     */\n    function _getExtensionPath() {\n        return pathLib.normalize(Phoenix.VFS.getExtensionDir());\n    }\n\n    /**\n     * Returns the full path to the development extensions directory.\n     *\n     * @private\n     */\n    function getDevExtensionPath() {\n        return pathLib.normalize(Phoenix.VFS.getDevExtensionDir());\n    }\n\n    /**\n     * Returns the full path of the default user extensions directory. This is in the users\n     * application support directory, which is typically\n     * /Users/\"user\"/Application Support/Brackets/extensions/user on the mac, and\n     * C:\\Users\\\"user\"\\AppData\\Roaming\\Brackets\\extensions\\user on windows.\n     */\n    function getUserExtensionPath() {\n        return pathLib.normalize(Phoenix.VFS.getUserExtensionDir());\n    }\n\n    /**\n     * Returns the require.js require context used to load an extension\n     *\n     * @param {!string} name used to identify the extension\n     * @return {!Object} A require.js require object used to load the extension, or undefined if\n     * there is no require object with that name\n     */\n    function getRequireContextForExtension(name) {\n        return contexts[name];\n    }\n\n    /**\n     * Get timeout value for rejecting an extension's async initExtension promise.\n     *\n     * @private\n     * @return {number} Timeout in milliseconds\n     */\n    function _getInitExtensionTimeout() {\n        return _initExtensionTimeout;\n    }\n\n    /**\n     * Set timeout for rejecting an extension's async initExtension promise.\n     *\n     * @private\n     * @param {number} value Timeout in milliseconds\n     */\n    function _setInitExtensionTimeout(value) {\n        _initExtensionTimeout = value;\n    }\n\n    /**\n     * Loads optional requirejs-config.json file for an extension\n     *\n     * @private\n     * @param {Object} baseConfig\n     * @return {$.Promise}\n     */\n    function _mergeConfigFromURL(baseConfig) {\n        var deferred = new $.Deferred(),\n            extensionConfigFile = baseConfig.baseUrl + \"/requirejs-config.json\";\n\n        // Optional JSON config for require.js\n        $.getJSON(extensionConfigFile).done(function (extensionConfig) {\n            if(Object.keys(extensionConfig || {}).length === 0){\n                deferred.resolve(baseConfig);\n                return;\n            }\n            try {\n                if(!extensionConfig.paths){\n                    extensionConfig.paths = {};\n                }\n                // baseConfig.paths properties will override any extension config paths\n                _.extend(extensionConfig.paths, baseConfig.paths);\n\n                // Overwrite baseUrl, context, locale (paths is already merged above)\n                _.extend(extensionConfig, _.omit(baseConfig, \"paths\"));\n\n                deferred.resolve(extensionConfig);\n            } catch (err) {\n                // Failed to parse requirejs-config.json\n                deferred.reject(\"failed to parse requirejs-config.json\");\n            }\n        }).fail(function (err) {\n            // If requirejs-config.json isn't specified or if there is a bad config, resolve with the baseConfig\n            // to try loading the extension\n            if(err.status === 200) {\n                // we received the file, but its invalid json\n                console.error(\"[Extension] The require config file provided is invalid\", extensionConfigFile);\n            }\n            deferred.resolve(baseConfig);\n        });\n\n        return deferred.promise();\n    }\n\n    /**\n     * Loads optional requirejs-config.json file for an extension\n     *\n     * @private\n     * @param {Object} baseConfig\n     * @return {$.Promise}\n     */\n    function _mergeConfig(baseConfig) {\n        if(baseConfig.baseUrl.startsWith(\"http://\") || baseConfig.baseUrl.startsWith(\"https://\")\n            || baseConfig.baseUrl.startsWith(\"phtauri://\") || baseConfig.baseUrl.startsWith(\"asset://\")) {\n            return _mergeConfigFromURL(baseConfig);\n        }\n        throw new Error(\"Config can only be loaded from an http url, but got\" + baseConfig.baseUrl);\n    }\n    const savedFSlib = window.fs;\n\n    function _loadNodeExtension(name, extensionMainPath, nodeConfig) {\n        const mainPlatformPath = Phoenix.fs.getTauriPlatformPath(extensionMainPath);\n        console.log(\"Loading node extension for \" + name, extensionMainPath, \":\", mainPlatformPath, nodeConfig);\n        NodeUtils._loadNodeExtensionModule(mainPlatformPath); // let load errors get reported to bugsnag\n    }\n\n    /**\n     * Loads the extension module that lives at baseUrl into its own Require.js context\n     *\n     * @private\n     * @param {!string} name used to identify the extension\n     * @param {!{baseUrl: string}} config object with baseUrl property containing absolute path of extension\n     * @param {string} entryPoint name of the main js file to load\n     * @param {Object} metadata\n     * @return {!$.Promise} A promise object that is resolved when the extension is loaded, or rejected\n     *              if the extension fails to load or throws an exception immediately when loaded.\n     *              (Note: if extension contains a JS syntax error, promise is resolved not rejected).\n     */\n    function loadExtensionModule(name, config, entryPoint, metadata) {\n        let extensionConfig = {\n            context: name,\n            baseUrl: config.baseUrl,\n            paths: globalPaths,\n            locale: brackets.getLocale(),\n            waitSeconds: EXTENSION_LOAD_TIMOUT_SECONDS,\n            config: {\n                text: {\n                    useXhr: function(_url, _protocol, _hostname, _port) {\n                        // as we load extensions in cross domain fashion, we have to use xhr\n                        // https://github.com/requirejs/text#xhr-restrictions\n                        // else user installed extension require will fail in tauri\n                        return true;\n                    }\n                }\n            }\n        };\n        const isDefaultExtensionModule =( extensionConfig.baseUrl\n            && extensionConfig.baseUrl.startsWith(`${window.PhoenixBaseURL}extensions/default/`));\n        // Read optional requirejs-config.json\n        return _mergeConfig(extensionConfig).then(function (mergedConfig) {\n            // Create new RequireJS context and load extension entry point\n            var extensionRequire = brackets.libRequire.config(mergedConfig),\n                extensionRequireDeferred = new $.Deferred();\n            if(!isDefaultExtensionModule && config.nativeDir && metadata.nodeConfig){\n                if(!Phoenix.isNativeApp && metadata.nodeConfig.nodeIsRequired) {\n                    extensionRequireDeferred.reject(\n                        new Error(`Extension ${name} cannot be loaded in browser as it needs node(nodeConfig.nodeIsRequired:true)`));\n                    return extensionRequireDeferred.promise();\n                }\n                if(Phoenix.isNativeApp) {\n                    if(!metadata.nodeConfig.main){\n                        extensionRequireDeferred.reject(\n                            new Error(`Extension ${name} doesnt specify a main file(nodeConfig.main) in package.json!`));\n                        return extensionRequireDeferred.promise();\n                    }\n                    _loadNodeExtension(name, path.join(config.nativeDir, metadata.nodeConfig.main),\n                        metadata.nodeConfig);\n                } else {\n                    console.log(`Extension ${name} optionally needs node. Node not loaded in browser.`);\n                }\n            }\n            contexts[name] = extensionRequire;\n            extensionRequire([entryPoint], extensionRequireDeferred.resolve, extensionRequireDeferred.reject);\n\n            return extensionRequireDeferred.promise();\n        }).then(function (module) {\n            // Extension loaded normally\n            if(savedFSlib !== window.fs) {\n                console.error(\"fslib overwrite detected while loading extension. This means that\" +\n                    \" some extension tried to modify a core library. reverting to original lib..\");\n                // note that the extension name here may not be that actual extension that did the\n                // overwrite. So we dont log the extension name here.\n                window.fs = savedFSlib;\n            }\n            var initPromise;\n\n            _extensions[name] = module;\n\n            // Optional sync/async initExtension\n            if (module && module.initExtension && (typeof module.initExtension === \"function\")) {\n                // optional async extension init\n                try {\n                    initPromise = Async.withTimeout(module.initExtension(), _getInitExtensionTimeout());\n                } catch (err) {\n                    // Synchronous error while initializing extension\n                    console.error(\"[Extension] Error -- error thrown during initExtension for \" + name + \": \" + err);\n                    logger.reportError(err);\n                    return new $.Deferred().reject(err).promise();\n                }\n\n                // initExtension may be synchronous and may not return a promise\n                if (initPromise) {\n                    // WARNING: These calls to initPromise.fail() and initPromise.then(),\n                    // could also result in a runtime error if initPromise is not a valid\n                    // promise. Currently, the promise is wrapped via Async.withTimeout(),\n                    // so the call is safe as-is.\n                    initPromise.fail(function (err) {\n                        let errorMessage = \"[Extension] Error -- timeout during initExtension for \" + name;\n                        if (err === Async.ERROR_TIMEOUT) {\n                            console.error(errorMessage);\n                        } else {\n                            errorMessage = \"[Extension] Error -- failed initExtension for \" + name;\n                            console.error(errorMessage + (err ? \": \" + err : \"\"));\n                        }\n                        if(isDefaultExtensionModule){\n                            logger.reportError(err, errorMessage);\n                        }\n                    });\n\n                    return initPromise;\n                }\n            }\n        }, function errback(err) {\n            // Extension failed to load during the initial require() call\n            var additionalInfo = String(err);\n            if (err.requireType === \"scripterror\" && err.originalError) {\n                // This type has a misleading error message - replace it with something clearer (URL of require() call that got a 404 result)\n                additionalInfo = \"Module does not exist: \" + err.originalError.target.src;\n            }\n            console.error(\"[Extension] failed to load \" + config.baseUrl + \" - \" + additionalInfo);\n            if(isDefaultExtensionModule){\n                logger.reportError(err, \"[Extension] failed to load \" + config.baseUrl + \" - \" + additionalInfo);\n            }\n\n            if (err.requireType === \"define\") {\n                // This type has a useful stack (exception thrown by ext code or info on bad getModule() call)\n                console.log(err.stack);\n            }\n        });\n    }\n\n    /**\n     * Loads the extension that lives at baseUrl into its own Require.js context\n     *\n     * @param {!string} name used to identify the extension\n     * @param {!{baseUrl: string}} config object with baseUrl property containing absolute path of extension\n     * @param {!string} entryPoint name of the main js file to load\n     * @return {!$.Promise} A promise object that is resolved when the extension is loaded, or rejected\n     *              if the extension fails to load or throws an exception immediately when loaded.\n     *              (Note: if extension contains a JS syntax error, promise is resolved not rejected).\n     */\n    function loadExtension(name, config, entryPoint) {\n        var promise = new $.Deferred();\n\n        // Try to load the package.json to figure out if we are loading a theme.\n        ExtensionUtils.loadMetadata(config.baseUrl, name).always(promise.resolve);\n\n        return promise\n            .then(function (metadata) {\n                if (isExtensionTakenDown(metadata.name)) {\n                    logger.leaveTrail(\"skip load taken down extension: \" + metadata.name);\n                    console.warn(\"skip load taken down extension: \" + metadata.name);\n                    return new $.Deferred().reject(\"disabled\").promise();\n                }\n\n                if(metadata.name) {\n                    loadedExtensionIDs.add(metadata.name);\n                }\n\n                // No special handling for themes... Let the promise propagate into the ExtensionManager\n                if (metadata && metadata.theme) {\n                    return;\n                }\n\n                if (!metadata.disabled) {\n                    return loadExtensionModule(name, config, entryPoint, metadata);\n                }\n                return new $.Deferred().reject(\"disabled\").promise();\n\n            })\n            .then(function () {\n                exports.trigger(EVENT_EXTENSION_LOADED, config.baseUrl);\n            }, function (err) {\n                if (err === \"disabled\") {\n                    exports.trigger(EVENT_EXTENSION_DISABLED, config.baseUrl);\n                } else {\n                    exports.trigger(EVENT_EXTENSION_LOAD_FAILED, config.baseUrl);\n                }\n            });\n    }\n\n    /**\n     * Runs unit tests for the extension that lives at baseUrl into its own Require.js context\n     *\n     * @private\n     * @param {!string} name used to identify the extension\n     * @param {!{baseUrl: string}} config object with baseUrl property containing absolute path of extension\n     * @param {!string} entryPoint name of the main js file to load\n     * @return {!$.Promise} A promise object that is resolved when all extensions complete loading.\n     */\n    function _testExtensionByURL(name, config, entryPoint) {\n        var result = new $.Deferred();\n\n        try{\n            var extensionRequire = brackets.libRequire.config({\n                context: name,\n                baseUrl: config.baseUrl,\n                paths: $.extend({}, config.paths, globalPaths),\n                waitSeconds: EXTENSION_LOAD_TIMOUT_SECONDS\n            });\n\n            extensionRequire([entryPoint], function () {\n                console.log(\"Test extension loaded: \", name);\n                result.resolve();\n            }, function (err) {\n                // Something went wrong while loading extension\n                console.log(\"Unit tests not found for:\", name, err);\n                result.reject();\n            });\n        } catch (e) {\n            console.error(\"Test extension load failed: \", name, e);\n            result.resolve();\n        }\n\n        return result.promise();\n    }\n\n    /**\n     * Runs unit tests for the extension that lives at baseUrl into its own Require.js context\n     *\n     * @param {!string} name used to identify the extension\n     * @param {!{baseUrl: string}} config object with baseUrl property containing absolute path of extension\n     * @param {!string} entryPoint name of the main js file to load\n     * @return {!$.Promise} A promise object that is resolved when all extensions complete loading.\n     */\n    function testExtension(name, config, entryPoint) {\n        var result = new $.Deferred(),\n            extensionPath = config.baseUrl + \"/\" + entryPoint + \".js\";\n        if(extensionPath.startsWith(\"http://\") || extensionPath.startsWith(\"https://\")\n            || extensionPath.startsWith(\"phtauri://\") || extensionPath.startsWith(\"asset://\")) {\n            return _testExtensionByURL(name, config, entryPoint);\n        }\n\n        FileSystem.resolve(extensionPath, function (err, entry) {\n            if (!err && entry.isFile) {\n                // unit test file exists\n                var extensionRequire = brackets.libRequire.config({\n                    context: name,\n                    baseUrl: config.baseUrl,\n                    paths: $.extend({}, config.paths, globalPaths)\n                });\n\n                extensionRequire([entryPoint], function () {\n                    result.resolve();\n                });\n            } else {\n                result.reject();\n            }\n        });\n\n        return result.promise();\n    }\n\n    async function _removeExtensionsMarkedForDelete(directory, contents) {\n        let extensions = [];\n        let promises = [];\n\n        for (let extensionEntry of contents) {\n            try {\n                if (extensionEntry.isDirectory) {\n                    const extensionName = extensionEntry.name;\n                    let markedRemove = FileSystem.getFileForPath(\n                        path.join(directory, extensionName, _DELETED_EXTENSION_FILE_MARKER));\n\n                    // Push the promise to the array without awaiting it\n                    promises.push(markedRemove.existsAsync().then(deleteMarkerExists => {\n                        if (!deleteMarkerExists) {\n                            extensions.push(extensionName);\n                        } else {\n                            return new Promise((resolve) => {\n                                // this never rejects. if we cant process, we continue with other extensions.\n                                extensionEntry.unlink(err => {\n                                    if (err) {\n                                        console.error(\"Error removing extension marked for removal:\",\n                                            extensionName, extensionEntry.fullPath, err);\n                                        resolve(err);\n                                    } else {\n                                        console.log(\"Removed extension marked for delete:\",\n                                            extensionName, extensionEntry.fullPath);\n                                        resolve();\n                                    }\n                                });\n                            });\n                        }\n                    }));\n                }\n            } catch (e) {\n                console.error(\"Error processing extension path:\", extensionEntry);\n            }\n        }\n\n        // Await all promises concurrently\n        await Promise.all(promises);\n\n        return extensions;\n    }\n\n\n    /**\n     * Loads a file entryPoint from each extension folder within the baseUrl into its own Require.js context\n     *\n     * @private\n     * @param {!string} directory an absolute native path that contains a directory of extensions.\n     *                  each subdirectory is interpreted as an independent extension\n     * @param {!string} entryPoint Module name to load (without .js suffix)\n     * @param {function} processExtension\n     * @return {!$.Promise} A promise object that is resolved when all extensions complete loading.\n     */\n    function _loadAll(directory, entryPoint, processExtension) {\n        var result = new $.Deferred();\n\n        FileSystem.getDirectoryForPath(directory).getContents( async function (err, contents) {\n            if (err) {\n                console.error(\"[Extension] Error -- could not read native directory: \" + directory);\n                result.reject();\n                return;\n            }\n\n            const extensions = await _removeExtensionsMarkedForDelete(directory, contents);\n\n            if (extensions.length === 0) {\n                result.resolve();\n                return;\n            }\n\n            Async.doInParallel(extensions, function (item) {\n                const extConfig = {\n                    // we load user installed extensions in file system from our virtual/asset server URL\n                    baseUrl: Phoenix.VFS.getVirtualServingURLForPath(directory + \"/\" + item),\n                    nativeDir: directory + \"/\" + item,\n                    paths: {}\n                };\n                console.log(\"Loading Extension from virtual fs: \", extConfig);\n                return processExtension(item, extConfig, entryPoint);\n            }).always(function () {\n                // Always resolve the promise even if some extensions had errors\n                result.resolve();\n            });\n        });\n\n        return result.promise();\n    }\n\n    /**\n     * Loads All brackets default extensions from brackets base https URL.\n     *\n     * @return {!$.Promise} A promise object that is resolved when all extensions complete loading.\n     */\n    function loadAllDefaultExtensions() {\n        const extensionPath = getDefaultExtensionPath();\n        const result = new $.Deferred();\n\n        Async.doInParallel(DefaultExtensionsList, function (extensionEntry) {\n            logger.leaveTrail(\"loading default extension: \" + extensionEntry);\n            var extConfig = {\n                baseUrl: extensionPath + \"/\" + extensionEntry\n            };\n            return loadExtension(extensionEntry, extConfig, 'main');\n        }).always(function () {\n            // Always resolve the promise even if some extensions had errors\n            result.resolve();\n        });\n\n        return result.promise();\n\n    }\n\n    /**\n     * Loads the default extension located at given extensions/default/extensionFolderName . used for tests\n     *\n     * @private\n     * @param {string} extensionFolderName\n     * @return {!$.Promise} A promise object that is resolved when all extensions complete loading.\n     */\n    function _loadDefaultExtension(extensionFolderName) {\n        const extensionPath = getDefaultExtensionPath();\n\n        logger.leaveTrail(\"loading default extension: \" + extensionFolderName);\n        var extConfig = {\n            baseUrl: extensionPath + \"/\" + extensionFolderName\n        };\n        return loadExtension(extensionFolderName, extConfig, 'main');\n    }\n\n    /**\n     * Loads the extension that lives at baseUrl into its own Require.js context\n     *\n     * @param {!string} directory an absolute native path that contains a directory of extensions.\n     *                  each subdirectory is interpreted as an independent extension\n     * @return {!$.Promise} A promise object that is resolved when all extensions complete loading.\n     */\n    function loadAllExtensionsInNativeDirectory(directory) {\n        return _loadAll(directory,  \"main\", loadExtension);\n    }\n\n    /**\n     * Loads a given extension at the path from virtual fs. Used by `debug menu> load project as extension`\n     *\n     * @param directory\n     * @return {!Promise}\n     */\n    function loadExtensionFromNativeDirectory(directory) {\n        logger.leaveTrail(\"loading custom extension from path: \" + directory);\n        const extConfig = {\n            baseUrl: Phoenix.VFS.getVirtualServingURLForPath(directory.replace(/\\/$/, \"\")),\n            nativeDir: directory\n        };\n        return loadExtension(\"ext\" + directory.replace(\"/\", \"-\"), // /fs/user/extpath to ext-fs-user-extpath\n            extConfig, 'main');\n    }\n\n    /**\n     * Runs unit test for the extension that lives at baseUrl into its own Require.js context\n     *\n     * @param {!string} directory an absolute native path that contains a directory of extensions.\n     *                  each subdirectory is interpreted as an independent extension\n     * @return {!$.Promise} A promise object that is resolved when all extensions complete loading.\n     */\n    function testAllExtensionsInNativeDirectory(directory) {\n        const result = new $.Deferred();\n        const extensionsDir = _getExtensionPath() + \"/\" + directory,\n            config = {\n                baseUrl: Phoenix.VFS.getVirtualServingURLForPath(extensionsDir)\n            };\n\n        config.paths = {\n            \"perf\": Phoenix.VFS.getVirtualServingURLForPath( \"/test/perf\"),\n            \"spec\": Phoenix.VFS.getVirtualServingURLForPath(\"/test/spec\")\n        };\n\n        FileSystem.getDirectoryForPath(extensionsDir).getContents(function (err, contents) {\n            if (!err) {\n                let i,\n                    extensions = [];\n\n                for (i = 0; i < contents.length; i++) {\n                    if (contents[i].isDirectory) {\n                        // FUTURE (JRB): read package.json instead of just using the entrypoint \"main\".\n                        // Also, load sub-extensions defined in package.json.\n                        extensions.push(contents[i].name);\n                    }\n                }\n\n                if (extensions.length === 0) {\n                    result.resolve();\n                    return;\n                }\n\n                Async.doInParallel(extensions, function (extensionName) {\n                    let loadResult = new $.Deferred();\n                    var extConfig = {\n                        // we load extensions in virtual file system from our virtual server URL\n                        basePath: 'extensions/default',\n                        baseUrl: config.baseUrl + \"/\" + extensionName,\n                        paths: config.paths\n                    };\n                    console.log(\"Loading Extension Test from virtual fs: \", extConfig);\n                    _testExtensionByURL(extensionName, extConfig, 'unittests').always(function () {\n                        // Always resolve the promise even if some extensions had errors\n                        console.log(\"tested\", extensionName);\n                        loadResult.resolve();\n                    });\n                    return loadResult.promise();\n                }).always(function () {\n                    // Always resolve the promise even if some extensions had errors\n                    result.resolve();\n                });\n            } else {\n                console.error(\"[Extension Load Test] Error -- could not read native directory: \" + directory);\n                result.reject();\n            }\n        });\n\n        return result.promise();\n    }\n\n    /**\n     * Runs unit test for the extension that lives at baseUrl into its own Require.js context\n     *\n     * @return {!$.Promise} A promise object that is resolved when all extensions complete loading.\n     */\n    function testAllDefaultExtensions() {\n        const bracketsPath = FileUtils.getNativeBracketsDirectoryPath();\n        const baseUrl = window.PhoenixBaseURL;\n        let srcBaseUrl = new URL(baseUrl + '../src').href;\n        let result = new $.Deferred();\n        if(!srcBaseUrl.endsWith(\"/\")) {\n            srcBaseUrl = srcBaseUrl + \"/\";\n        }\n\n        Async.doInParallel(DefaultExtensionsList, function (extensionEntry) {\n            const loadResult = new $.Deferred();\n            const extConfig = {\n                basePath: 'extensions/default',\n                baseUrl: new URL(srcBaseUrl + DEFAULT_EXTENSIONS_PATH_BASE + \"/\" + extensionEntry).href,\n                paths: {\n                    \"perf\": bracketsPath + \"/perf\",\n                    \"spec\": bracketsPath + \"/spec\"\n                }\n            };\n            console.log(\"Testing default extension: \", extensionEntry);\n            _testExtensionByURL(extensionEntry, extConfig, 'unittests').always(function () {\n                // Always resolve the promise even if some extensions had errors\n                console.log(\"load complete\", extensionEntry);\n                loadResult.resolve();\n            });\n            return loadResult.promise();\n        }).always(function () {\n            // Always resolve the promise even if some extensions had errors\n            result.resolve();\n        });\n\n        return result.promise();\n    }\n\n    // eg: extensionPath = /tauri/home/home/.local/share/io.phcode.dev/assets/extensions/devTemp/theme/14/theme.css\n    // eg: customExtensionLoadPath = /tauri/home/home/.local/share/io.phcode.dev/assets/extensions/devTemp/theme/14\n    // eg: srcBasePath = /tauri/home/home/myExtension\n    /**\n     * To get the source path for extension\n     *\n     * @param extensionPath\n     * @returns {string}\n     */\n    function getSourcePathForExtension(extensionPath) {\n        const devTempExtDir = `${Phoenix.VFS.getDevTempExtensionDir()}/`;\n        if(extensionPath.startsWith(devTempExtDir)) {\n            for(let customExtensionLoadPath of Object.keys(customExtensionLoadPaths)){\n                let srcBasePath = customExtensionLoadPaths[customExtensionLoadPath];\n                if(extensionPath.startsWith(Phoenix.VFS.ensureTrailingSlash(customExtensionLoadPath))) {\n                    const relativePath = extensionPath.replace(Phoenix.VFS.ensureTrailingSlash(customExtensionLoadPath), \"\");\n                    if(!srcBasePath.endsWith(\"/\")){\n                        srcBasePath = srcBasePath + \"/\";\n                    }\n                    return `${srcBasePath}${relativePath}`;\n                }\n            }\n        }\n        return extensionPath;\n    }\n\n    function _attachThemeLoadListeners() {\n        ThemeManager.off(`${ThemeManager.EVENT_THEME_LOADED}.extensionLoader`);\n        ThemeManager.on(`${ThemeManager.EVENT_THEME_LOADED}.extensionLoader`, ()=>{\n            ThemeManager.refresh(true);\n        });\n    }\n\n    function _getRandomPrefix() {\n        let uuid = crypto.randomUUID();\n        // for example \"36b8f84d-df4e-4d49-b662-bcde71a8764f\"\n        return uuid.split(\"-\")[0]; // Eg. return 36b8f84d\n    }\n    function _loadCustomExtensionPath(extPath) {\n        const assetsServeDir = Phoenix.VFS.getTauriAssetServeDir();\n        if(assetsServeDir && extPath.startsWith(Phoenix.VFS.getTauriDir()) &&\n            !extPath.startsWith(assetsServeDir)) {\n            // we have to do this random number thingy as tauri caches assets and will serve stale assets.\n            // this is problematic when the user is editing extension code and he cant see the updates on reload.\n            const newExtVersionStr = _getRandomPrefix();\n            const extParentPath = `${Phoenix.VFS.getDevTempExtensionDir()}/${Phoenix.path.basename(extPath)}`;\n            const extDestPath = `${extParentPath}/${newExtVersionStr}`;\n            customExtensionLoadPaths[extDestPath] = extPath;\n            Phoenix.fs.unlink(extParentPath, ()=>{\n                // ignore any errors in delete\n                Phoenix.VFS.ensureExistsDirAsync(extParentPath)\n                    .then(()=>{\n                        Phoenix.fs.copy(extPath, extDestPath, function (err, _copiedPath) {\n                            if (err) {\n                                console.error(`Error copying extension from ${extPath} to ${extDestPath}`, err);\n                                result.reject(err);\n                            } else {\n                                _attachThemeLoadListeners();\n                                loadExtensionFromNativeDirectory(extDestPath)\n                                    .fail(console.error);\n                            }\n                        });\n                    }).catch((err)=>{\n                    console.error(`Error creating dir ${extDestPath}`, err);\n                    result.reject(err);\n                });\n            });\n            // custom extensions are always loaded marked as resolved to prevent the main event loop from taking\n            // too long to load\n            let result = new $.Deferred();\n            result.resolve();\n            return result.promise();\n        }\n        return loadExtensionFromNativeDirectory(extPath);\n    }\n\n    /**\n     * Load extensions.\n     *\n     * @param {?Array.<string>} A list containing references to extension source\n     *      location. A source location may be either (a) a folder name inside\n     *      src/extensions or (b) an absolute path.\n     * @return {!$.Promise} A promise object that is resolved when all extensions complete loading.\n     */\n    function init(paths) {\n        require(\"extensionsIntegrated/loader\");\n        var params = new UrlParams();\n\n        if (_init) {\n            // Only init once. Return a resolved promise.\n            return new $.Deferred().resolve().promise();\n        }\n\n        if (!paths) {\n            params.parse();\n\n            if (params.get(\"reloadWithoutUserExts\") !== \"true\") {\n                paths = [\n                    \"default\",\n                    getUserExtensionPath(),\n                    getDevExtensionPath()\n                ];\n            } else {\n                paths = [];\n            }\n            if(params.get(\"loadDevExtensionPath\")){\n                let customLoadPaths = params.get(\"loadDevExtensionPath\").split(\",\");\n                for(let customPath of customLoadPaths){\n                    paths.push(\"custom:\" + customPath);\n                }\n            }\n        }\n\n        // Load extensions before restoring the project\n\n        // Get a Directory for the user extension directory and create it if it doesn't exist.\n        // Note that this is an async call and there are no success or failure functions passed\n        // in. If the directory *doesn't* exist, it will be created. Extension loading may happen\n        // before the directory is finished being created, but that is okay, since the extension\n        // loading will work correctly without this directory.\n        // If the directory *does* exist, nothing else needs to be done. It will be scanned normally\n        // during extension loading.\n        var extensionPath = getUserExtensionPath();\n        FileSystem.getDirectoryForPath(extensionPath).create();\n        FileSystem.getDirectoryForPath(getDevExtensionPath()).create();\n\n        // Create the extensions/disabled directory, too.\n        var disabledExtensionPath = extensionPath.replace(/\\/user$/, \"/disabled\");\n        FileSystem.getDirectoryForPath(disabledExtensionPath).create();\n\n        // just before extensions are loaded, we need to delete the boot time trust ring keys so that extensions\n        // won't have keys to enter kernal mode in the app.\n        delete window.KernalModeTrust;\n\n        var promise = Async.doInParallel(paths, function (extPath) {\n            if(extPath === \"default\"){\n                return loadAllDefaultExtensions();\n            } else if(extPath.startsWith(\"custom:\")){\n                return _loadCustomExtensionPath(extPath.replace(\"custom:\", \"\"));\n            } else {\n                return loadAllExtensionsInNativeDirectory(extPath);\n            }\n        }, false);\n\n        promise.always(function () {\n            _init = true;\n        });\n\n        return promise;\n    }\n\n    function isExtensionTakenDown(extensionID) {\n        if(!extensionID){\n            // extensions without id can happen with local development. these are never distributed in store.\n            // so safe to return false here.\n            return false;\n        }\n        return takedownExtensionList.has(extensionID);\n    }\n\n\n    EventDispatcher.makeEventDispatcher(exports);\n\n    // unit tests\n    if(Phoenix.isTestWindow) {\n        exports._loadDefaultExtension = _loadDefaultExtension;\n        exports._setInitExtensionTimeout = _setInitExtensionTimeout;\n        exports._getInitExtensionTimeout = _getInitExtensionTimeout;\n    }\n\n    // private internal usage\n    exports._DELETED_EXTENSION_FILE_MARKER = _DELETED_EXTENSION_FILE_MARKER;\n\n    // public API\n    exports.init = init;\n    exports.getDefaultExtensionPath = getDefaultExtensionPath;\n    exports.getUserExtensionPath = getUserExtensionPath;\n    exports.getRequireContextForExtension = getRequireContextForExtension;\n    exports.getSourcePathForExtension = getSourcePathForExtension;\n    exports.loadExtension = loadExtension;\n    exports.testExtension = testExtension;\n    exports.loadAllExtensionsInNativeDirectory = loadAllExtensionsInNativeDirectory;\n    exports.loadExtensionFromNativeDirectory = loadExtensionFromNativeDirectory;\n    exports.isExtensionTakenDown = isExtensionTakenDown;\n    exports.testAllExtensionsInNativeDirectory = testAllExtensionsInNativeDirectory;\n    exports.testAllDefaultExtensions = testAllDefaultExtensions;\n    exports.EVENT_EXTENSION_LOADED = EVENT_EXTENSION_LOADED;\n    exports.EVENT_EXTENSION_DISABLED = EVENT_EXTENSION_DISABLED;\n    exports.EVENT_EXTENSION_LOAD_FAILED = EVENT_EXTENSION_LOAD_FAILED;\n});\n"],"file":"ExtensionLoader.js"}