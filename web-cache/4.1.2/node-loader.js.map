{"version":3,"sources":["node-loader.js"],"names":["nodeLoader","KernalModeTrust","window","Error","nodeLoadstartTime","Date","now","phcodeExecHandlerMap","nodeConnectorIDMap","pendingExecPromiseMap","currentCommandID","wssEndpoint","controlSocket","dataSocket","SOCKET_TYPE_DATA","SOCKET_TYPE_CONTROL","LARGE_DATA_THRESHOLD","MAX_RECONNECT_BACKOFF_TIME_MS","NODE_CONNECTOR_CREATE_TIMEOUT","MAX_QUEUE_LENGTH","pendingNodeConnectorExecMap","pendingNodeConnectorEventMap","isTimerRunningMap","WS_COMMAND","RESPONSE","EXEC","EVENT","LARGE_DATA_SOCKET_ANNOUNCE","CONTROL_SOCKET_ANNOUNCE","WS_ERR_CODES","NO_SUCH_FN","mergeMetadataAndArrayBuffer","metadata","bufferData","ArrayBuffer","hasBufferData","metadataString","JSON","stringify","metadataUint8Array","TextEncoder","encode","metadataBuffer","buffer","sizePrefixLength","byteLength","concatenatedBuffer","concatenatedUint8Array","Uint8Array","DataView","setUint32","set","splitMetadataAndBuffer","buffer1Length","getUint32","buffer1","slice","parse","TextDecoder","decode","buffer2","MAX_PENDING_SEND_BUFFER","pendingSendBuffer","_drainPendingSendBuffer","copyPendingSendBuffer","commandObject","dataBuffer","_sendWithAppropriateSocket","_isSocketOpen","socket","readyState","WebSocket","OPEN","socketToUse","atleastOneSocketUsable","send","length","push","_sendInitCommand","commandCode","commandID","data","_sendExec","nodeConnectorID","execHandlerFnName","dataObjectToSend","command","_sendExecResponse","defaultWS","response","originalCommand","error","_sendEvent","eventName","event","_sendError","err","defaultMessage","message","code","stack","_isObject","variable","_extractBuffer","result","_isJSONStringifiable","e","_errNClearQueue","pendingExecList","ws","_queueExec","setTimeout","_drainExecQueue","_execPhcodeConnectorFn","moduleExports","Promise","then","catch","_queueEvent","pendingEventList","_drainEventQueue","_triggerEvent","nodeConnector","trigger","processWSCommand","pendingExecPromise","cause","nodeStack","reject","resolve","console","createNodeConnector","newNodeConnector","execPeer","triggerPeer","EventDispatcher","makeEventDispatcher","_silentlyCloseSocket","autoReconnect","close","_wait","timeMS","async","_establishAndMaintainConnection","socketType","firstConnectCB","binaryType","resolved","wsClosePromiseResolve","wsClosePromise","isLargeDataWS","addEventListener","backoffTime","Math","min","setNodeWSEndpoint","websocketEndpoint","nodeSetupDonePromise","NODE_COMMANDS","COMMAND_RESPONSE_PREFIX","COMMAND_ERROR_PREFIX","child","pendingCommands","PHNODE_PREFERENCES_KEY","setInspectEnabled","enabled","prefs","localStorage","getItem","inspectEnabled","setItem","isInspectEnabled","getRandomNumber","max","floor","random","nodeTerminationResolve","nodeTerminationPromise","PhNodeEngine","isNodeReady","nodeErrorLogCount","MAX_NODE_ERROR_LOGS_ALLOWED","NODE_ERROR_LOGS_RESET_INTERVAL","setInterval","debugMode","__TAURI__","path","resolveResource","Phoenix","platform","cliArgs","invoke","nodeSrcPath","dirname","inspectPort","isTestWindow","argsArray","shell","Command","sidecar","on","isNodeTerminated","log","signal","logger","reportError","stdout","line","startsWith","replace","jsonMsg","type","stderr","spawn","execNode","commandData","newCommandID","resolveP","rejectP","write","promise","terminateNode","getInspectPort","fs","phoenixFSURL","forceUseNodeWSEndpoint","phoenixNodeURL","localAutoAuthURL","autoAuthURL","_nodeLoadTime","isNativeApp"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*global fs, logger*/\n\nfunction nodeLoader() {\n    const KernalModeTrust = window.KernalModeTrust;\n    if(!KernalModeTrust){\n        throw new Error(\"KernalModeTrust is not defined. Cannot boot nodeLoader without trust ring\");\n    }\n    const nodeLoadstartTime = Date.now();\n    const phcodeExecHandlerMap = {};\n    const nodeConnectorIDMap = {};\n    // This holds the list {resolve, reject} for all waiting exec functions executed with execPeer here.\n    const pendingExecPromiseMap = {};\n    let currentCommandID = 1; // should be greater than 0!\n    let wssEndpoint, controlSocket, dataSocket;\n    const SOCKET_TYPE_DATA = \"data\",\n        SOCKET_TYPE_CONTROL = \"control\";\n    const LARGE_DATA_THRESHOLD = 2*1024*1024; // 2MB\n    const MAX_RECONNECT_BACKOFF_TIME_MS = 1000;\n\n    // If a NodeConnector has been created on this end, we can promptly process events and exec messages. However,\n    // in cases where a NodeConnector hasn't been created yet on this end, we temporarily queue execs and event triggers\n    // for up to 10 seconds. This approach ensures that the other side remains unaware of the status of the\n    // NodeConnector at both ends, allowing them to initiate message transmission via the WebSocket as soon as they\n    // invoke the createNodeConnector API on their side.\n\n    // Timeout duration for NodeConnector creation (10 seconds)\n    const NODE_CONNECTOR_CREATE_TIMEOUT = 10000;\n    // Max number of messages to queue for a single node connector.\n    const MAX_QUEUE_LENGTH = 2000;\n\n    // These arrays hold queues of event and exec messages received from the other side while a NodeConnector\n    // was not yet created on this end. Messages are queued for up to 10 seconds.\n    const pendingNodeConnectorExecMap = {};\n    const pendingNodeConnectorEventMap = {};\n\n    // This timer clears the pending maps above if a NodeConnector is not created within 10 seconds.\n    const isTimerRunningMap = {};\n\n\n    const WS_COMMAND = {\n        RESPONSE: \"response\",\n        EXEC: \"exec\",\n        EVENT: \"event\",\n        LARGE_DATA_SOCKET_ANNOUNCE: \"largeDataSock\",\n        CONTROL_SOCKET_ANNOUNCE: \"controlSock\"\n    };\n\n    const WS_ERR_CODES = {\n        NO_SUCH_FN: \"NoSuchFn\"\n    };\n\n    /**\n     *\n     * @param metadata {Object} Max size can be 4GB\n     * @param bufferData {ArrayBuffer} [optional]\n     * @return {ArrayBuffer}\n     * @private\n     */\n    function mergeMetadataAndArrayBuffer(metadata, bufferData) {\n        if (bufferData instanceof ArrayBuffer) {\n            metadata.hasBufferData = true;\n        }\n        bufferData = bufferData || new ArrayBuffer(0);\n        if (typeof metadata !== 'object') {\n            throw new Error(\"metadata should be an object, but was \" + typeof metadata);\n        }\n        if (!(bufferData instanceof ArrayBuffer)) {\n            throw new Error(\"Expected bufferData to be an instance of ArrayBuffer, but was \" + typeof bufferData);\n        }\n\n        const metadataString = JSON.stringify(metadata);\n        const metadataUint8Array = new TextEncoder().encode(metadataString);\n        const metadataBuffer = metadataUint8Array.buffer;\n        const sizePrefixLength = 4; // 4 bytes for a 32-bit integer\n\n        if (metadataBuffer.byteLength > 4294000000) {\n            throw new Error(\"metadata too large. Should be below 4,294MB, but was \" + metadataBuffer.byteLength);\n        }\n\n        const concatenatedBuffer = new ArrayBuffer(sizePrefixLength + metadataBuffer.byteLength + bufferData.byteLength);\n        const concatenatedUint8Array = new Uint8Array(concatenatedBuffer);\n\n        // Write the length of metadataBuffer as a 32-bit integer\n        new DataView(concatenatedBuffer).setUint32(0, metadataBuffer.byteLength, true);\n\n        // Copy the metadataUint8Array and bufferData (if provided) to the concatenatedUint8Array\n        concatenatedUint8Array.set(metadataUint8Array, sizePrefixLength);\n        if (bufferData.byteLength > 0) {\n            concatenatedUint8Array.set(new Uint8Array(bufferData), sizePrefixLength + metadataBuffer.byteLength);\n        }\n\n        return concatenatedBuffer;\n    }\n\n    function splitMetadataAndBuffer(concatenatedBuffer) {\n        if(!(concatenatedBuffer instanceof ArrayBuffer)){\n            throw new Error(\"Expected ArrayBuffer message from websocket\");\n        }\n        const sizePrefixLength = 4;\n        const buffer1Length = new DataView(concatenatedBuffer).getUint32(0, true); // Little endian\n\n        const buffer1 = concatenatedBuffer.slice(sizePrefixLength, sizePrefixLength + buffer1Length);\n        const metadata = JSON.parse(new TextDecoder().decode(buffer1));\n        let buffer2;\n        if (concatenatedBuffer.byteLength > sizePrefixLength + buffer1Length) {\n            buffer2 = concatenatedBuffer.slice(sizePrefixLength + buffer1Length);\n        }\n        if(!buffer2 && metadata.hasBufferData) {\n            // This happens if the sender is sending 0 length buffer. So we have to create an empty buffer here\n            buffer2 = new ArrayBuffer(0);\n        }\n\n        return {\n            metadata,\n            bufferData: buffer2\n        };\n    }\n\n    const MAX_PENDING_SEND_BUFFER = 10000;\n    let pendingSendBuffer = [];\n\n    function _drainPendingSendBuffer() {\n        const copyPendingSendBuffer = pendingSendBuffer;\n        // empty to prevent race conditions\n        pendingSendBuffer = [];\n        // Using a for...of loop for better readability\n        for(let {commandObject, dataBuffer} of copyPendingSendBuffer) {\n            _sendWithAppropriateSocket(commandObject, dataBuffer);\n        }\n    }\n\n    function _isSocketOpen(socket) {\n        return socket && socket.readyState === WebSocket.OPEN;\n    }\n\n    function _sendWithAppropriateSocket(commandObject, dataBuffer) {\n        let socketToUse = controlSocket || dataSocket;\n        const atleastOneSocketUsable = _isSocketOpen(controlSocket) || _isSocketOpen(dataSocket);\n        if(!socketToUse || !atleastOneSocketUsable){\n            // We got a send event before a websocket connection is established by phcode. Queue it to send later.\n            if(pendingSendBuffer.length > MAX_PENDING_SEND_BUFFER){\n                throw new Error(\"Too many node ws messages queued before a node connection was established to phnode.\");\n            }\n            pendingSendBuffer.push({commandObject, dataBuffer});\n            return;\n        }\n        if((dataBuffer && dataBuffer.byteLength > LARGE_DATA_THRESHOLD && dataSocket && _isSocketOpen(dataSocket))\n        || (_isSocketOpen(dataSocket) && !_isSocketOpen(controlSocket))) {\n            socketToUse = dataSocket;\n        }\n        socketToUse.send(mergeMetadataAndArrayBuffer(commandObject, dataBuffer));\n    }\n\n    function _sendInitCommand(socket, commandCode) {\n        currentCommandID++;\n        const commandID = currentCommandID;\n        socket.send(mergeMetadataAndArrayBuffer({\n            commandCode: commandCode,\n            commandID: commandID,\n            data: null\n        }, null));\n    }\n\n    function _sendExec(nodeConnectorID, commandID, execHandlerFnName, dataObjectToSend = null, dataBuffer = null) {\n        const command = {\n            nodeConnectorID: nodeConnectorID,\n            commandID: commandID,\n            execHandlerFnName,\n            commandCode: WS_COMMAND.EXEC,\n            data: dataObjectToSend\n        };\n        _sendWithAppropriateSocket(command, dataBuffer);\n    }\n\n    /**\n     *\n     * @param defaultWS If specified, will use the given socket.\n     * @param metadata\n     * @param dataObjectToSend\n     * @param dataBuffer {ArrayBuffer}\n     * @private\n     */\n    function _sendExecResponse(defaultWS, metadata, dataObjectToSend = null, dataBuffer = null) {\n        const response = {\n            originalCommand: metadata.commandCode,\n            commandCode: WS_COMMAND.RESPONSE,\n            commandID: metadata.commandID,\n            error: metadata.error,\n            data: dataObjectToSend\n        };\n        let socketToUse = defaultWS || controlSocket;\n        if(dataBuffer && dataBuffer.byteLength > LARGE_DATA_THRESHOLD && dataSocket) {\n            socketToUse = dataSocket;\n        }\n        socketToUse.send(mergeMetadataAndArrayBuffer(response, dataBuffer));\n    }\n\n    function _sendEvent(nodeConnectorID, eventName, dataObjectToSend = null, dataBuffer = null) {\n        const event = {\n            nodeConnectorID,\n            eventName,\n            commandCode: WS_COMMAND.EVENT,\n            data: dataObjectToSend\n        };\n        _sendWithAppropriateSocket(event, dataBuffer);\n    }\n\n    function _sendError(defaultWS, metadata, err= { }, defaultMessage = \"Operation failed! \") {\n        metadata.error = {\n            message: err.message || defaultMessage,\n            code: err.code,\n            stack: err.stack\n        };\n        _sendExecResponse(defaultWS, metadata);\n    }\n\n    function _isObject(variable) {\n        return typeof variable === 'object' && variable !== null;\n    }\n\n    function _extractBuffer(result) {\n        if(_isObject(result) && result.buffer instanceof ArrayBuffer) {\n            const buffer = result.buffer;\n            delete result.buffer;\n            return buffer;\n        }\n        return null;\n    }\n\n    function _isJSONStringifiable(result) {\n        try {\n            JSON.stringify(result);\n            return true;\n        } catch (e){\n            return false;\n        }\n    }\n\n    function _errNClearQueue(nodeConnectorID) {\n        const pendingExecList = pendingNodeConnectorExecMap[nodeConnectorID];\n        pendingNodeConnectorExecMap[nodeConnectorID] = [];\n        for(const { ws, metadata } of pendingExecList) {\n            _sendError(\n                ws, metadata,\n                new Error(`NodeConnector ${nodeConnectorID} not found to exec function ${metadata.execHandlerFnName}`)\n            );\n        }\n    }\n\n    function _queueExec(nodeConnectorID, ws, metadata, bufferData) {\n        let pendingExecList = pendingNodeConnectorExecMap[nodeConnectorID];\n        if(!pendingExecList){\n            pendingExecList = [];\n            pendingNodeConnectorExecMap[nodeConnectorID] = pendingExecList;\n        }\n        if(pendingExecList.length > MAX_QUEUE_LENGTH) {\n            _sendError(ws, metadata,\n                new Error(`Too Many exec while waiting for NodeConnector ${nodeConnectorID} creation to exec fn ${metadata.execHandlerFnName}`));\n            return;\n        }\n        pendingExecList.push({ws, metadata, bufferData});\n        if(!isTimerRunningMap[nodeConnectorID]){\n            isTimerRunningMap[nodeConnectorID] = true;\n            setTimeout(() => {\n                // the node connector was not established\n                isTimerRunningMap[nodeConnectorID] = false;\n                _errNClearQueue(nodeConnectorID);\n            }, NODE_CONNECTOR_CREATE_TIMEOUT);\n        }\n    }\n\n    function _drainExecQueue(nodeConnectorID) {\n        let pendingExecList = pendingNodeConnectorExecMap[nodeConnectorID] || [];\n        pendingNodeConnectorExecMap[nodeConnectorID] = [];\n        for(const {ws, metadata, bufferData} of pendingExecList) {\n            _execPhcodeConnectorFn(ws, metadata, bufferData);\n        }\n    }\n\n    function _execPhcodeConnectorFn(ws, metadata, dataBuffer) {\n        const nodeConnectorID = metadata.nodeConnectorID;\n        const execHandlerFnName = metadata.execHandlerFnName;\n        const moduleExports = phcodeExecHandlerMap[nodeConnectorID];\n        if(!moduleExports){\n            // node connector not yet created. Queue it.\n            _queueExec(nodeConnectorID, ws, metadata, dataBuffer);\n            return;\n        }\n        try{\n            if(typeof moduleExports[execHandlerFnName] !== 'function'){\n                const err = new Error(\"execHandlerFnName: \" + execHandlerFnName\n                    + \" no such function in node connector module: \" + nodeConnectorID);\n                err.code = WS_ERR_CODES.NO_SUCH_FN;\n                throw err;\n            }\n            const response = moduleExports[execHandlerFnName](metadata.data, dataBuffer);\n            if(!(response instanceof Promise)) {\n                throw new Error(`execHandlerFnName: ${nodeConnectorID}::${execHandlerFnName} : `\n                    + \" is expected to return a promise that resolve to ({data, ?buffer})\");\n            }\n            response\n                .then((result)=>{\n                    const buffer = _extractBuffer(result);\n                    if(!_isJSONStringifiable(result)) {\n                        throw new Error(`execHandlerFnName: ${nodeConnectorID}::${execHandlerFnName} : `\n                            + \" is expected to return a promise that resolve to an object that can be JSON.stringify -ed. To pass an array buffer, use resolve({buffer:arrayBufferObj})\");\n                    }\n                    _sendExecResponse(ws, metadata, result, buffer);\n                }).catch(err =>{\n                _sendError(ws, metadata, err,\n                    `Error executing function in: ${nodeConnectorID}:${execHandlerFnName}`);\n            });\n        } catch (e) {\n            _sendError(ws, metadata, e, \"Phcode Could not execute function in: \" + nodeConnectorID);\n        }\n    }\n\n    function _queueEvent(nodeConnectorID, ws, metadata, bufferData) {\n        let pendingEventList = pendingNodeConnectorEventMap[nodeConnectorID];\n        if(!pendingEventList){\n            pendingEventList = [];\n            pendingNodeConnectorEventMap[nodeConnectorID] = pendingEventList;\n        }\n        if(pendingEventList.length > MAX_QUEUE_LENGTH) {\n            _sendError(ws, metadata,\n                new Error(`Too Many events: ${metadata.eventName} while waiting for NodeConnector ${nodeConnectorID} creation`));\n            return;\n        }\n        pendingEventList.push({ws, metadata, bufferData});\n        if(!isTimerRunningMap[nodeConnectorID]){\n            isTimerRunningMap[nodeConnectorID] = true;\n            setTimeout(() => {\n                // the node connector was not established\n                isTimerRunningMap[nodeConnectorID] = false;\n                _errNClearQueue(nodeConnectorID);\n            }, NODE_CONNECTOR_CREATE_TIMEOUT);\n        }\n    }\n\n    function _drainEventQueue(nodeConnectorID) {\n        let pendingEventList = pendingNodeConnectorEventMap[nodeConnectorID] || [];\n        pendingNodeConnectorEventMap[nodeConnectorID] = [];\n        for(const {ws, metadata, bufferData} of pendingEventList) {\n            _triggerEvent(ws, metadata, bufferData);\n        }\n    }\n\n    function _triggerEvent(ws, metadata, dataBuffer) {\n        const nodeConnectorID = metadata.nodeConnectorID;\n        const nodeConnector = nodeConnectorIDMap[nodeConnectorID];\n        if(!nodeConnector){\n            // node connector not yet created. Queue it.\n            _queueEvent(nodeConnectorID, ws, metadata, dataBuffer);\n            return;\n        }\n        nodeConnector.trigger(metadata.eventName, metadata.data, dataBuffer);\n    }\n\n    function processWSCommand(ws, metadata, dataBuffer) {\n        try{\n            switch (metadata.commandCode) {\n            case WS_COMMAND.EXEC:\n                _execPhcodeConnectorFn(ws, metadata, dataBuffer);\n                return;\n            case WS_COMMAND.EVENT:\n                _triggerEvent(ws, metadata, dataBuffer);\n                return;\n            case WS_COMMAND.RESPONSE:\n                const commandID = metadata.commandID;\n                const pendingExecPromise = pendingExecPromiseMap[commandID];\n                if(!pendingExecPromise){\n                    throw new Error(\"Unable to find response handler for \"+ JSON.stringify(metadata));\n                }\n                if(metadata.error) {\n                    const error = new Error(metadata.error.message, {cause: metadata.error.stack});\n                    error.code = metadata.error.code;\n                    error.nodeStack = metadata.error.stack;\n                    pendingExecPromise.reject(error);\n                } else {\n                    const result = metadata.data;\n                    if(dataBuffer instanceof ArrayBuffer) {\n                        result.buffer = dataBuffer;\n                    }\n                    pendingExecPromise.resolve(result);\n                }\n                delete pendingExecPromiseMap[commandID];\n                break;\n            default: console.error(\"unknown command: \"+ metadata);\n            }\n        } catch (e) {\n            console.error(e);\n        }\n    }\n\n    function createNodeConnector(nodeConnectorID, moduleExports) {\n        if(nodeConnectorIDMap[nodeConnectorID]) {\n            throw new Error(\"A node connector of the name is already registered: \" + nodeConnectorID);\n        }\n        if(!_isObject(moduleExports) || !nodeConnectorID) {\n            throw new Error(\"Invalid Argument. Expected createNodeConnector(string, module/Object) for \" + nodeConnectorID);\n        }\n\n        phcodeExecHandlerMap[nodeConnectorID] = moduleExports;\n        const newNodeConnector = {\n            /**\n             * Executes a peer function with specified parameters. Most of the time you would use dataObjectToSend to send\n             * simple JSON serializable objects. But in the event you have to send a binary ArrayBuffer, you can use\n             * the optional `dataBuffer` field. Note that at this time, you can only send and receive a single binary buffer\n             *\n             * @param {string} execHandlerFnName - The name of the function to execute on the peer.\n             * @param {Object|string|null} dataObjectToSend - Optional data to send along with the function call.\n             * @param {ArrayBuffer|null} dataBuffer - Optional binary data to send along with the function call.\n             *\n             * @returns {Promise} - A promise that resolves or rejects based on the result of the function execution.\n             *\n             * @throws {Error} - If `dataBuffer` is provided and is not an instance of `ArrayBuffer`.\n             */\n            execPeer: function (execHandlerFnName, dataObjectToSend = null, dataBuffer = null) {\n                if ((dataBuffer && !(dataBuffer instanceof ArrayBuffer)) || dataObjectToSend instanceof ArrayBuffer) {\n                    throw new Error(\"execPeer should be called with exactly 3 arguments or less (FnName:string, data:Object|string, buffer:ArrayBuffer)\");\n                }\n                if (dataBuffer instanceof ArrayBuffer && !_isObject(dataObjectToSend)) {\n                    throw new Error(\"execPeer second argument should be an object if sending binary data (FnName:string, data:Object, buffer:ArrayBuffer)\");\n                }\n                return new Promise((resolve, reject) =>{\n                    currentCommandID ++;\n                    pendingExecPromiseMap[currentCommandID] = {resolve, reject};\n                    _sendExec(nodeConnectorID, currentCommandID, execHandlerFnName, dataObjectToSend, dataBuffer);\n                });\n            },\n            /**\n             * Triggers an event to be sent to a peer. Most of the time you would use dataObjectToSend to send\n             * simple JSON serializable objects. But in the event you have to send a binary ArrayBuffer, you can use\n             * the optional `dataBuffer` field. Note that at this time, you can only send and receive a single binary buffer\n             *\n             * @param {string} eventName - The name of the event to trigger.\n             * @param {Object|string|null} dataObjectToSend - Optional data associated with the event. Can be an object, string, or null.\n             * @param {ArrayBuffer|null} dataBuffer - Optional binary data associated with the event. Must be an ArrayBuffer or null.\n             *\n             * @throws {Error} Throws an error if dataBuffer is provided but is not an ArrayBuffer.\n             */\n            triggerPeer: function (eventName, dataObjectToSend = null, dataBuffer = null) {\n                if (dataBuffer && !(dataBuffer instanceof ArrayBuffer)) {\n                    throw new Error(\"triggerPeer should be called with exactly 3 arguments (eventName:string, data:Object|string, buffer:ArrayBuffer)\");\n                }\n                _sendEvent(nodeConnectorID, eventName, dataObjectToSend, dataBuffer);\n            }\n        };\n        window.EventDispatcher.makeEventDispatcher(newNodeConnector);\n        nodeConnectorIDMap[nodeConnectorID] = newNodeConnector;\n\n        // At this point, it's possible that a node connector has been created on the other end, and it might have sent\n        // us exec and trigger events that need to be processed. These events will be queued for execution, and we will\n        // handle them after the current event loop call.\n        // We use a setTimeout with a zero-millisecond delay to ensure that the event queues are drained during the\n        // next tick of the event loop.\n        setTimeout(() => {\n            _drainExecQueue(nodeConnectorID);\n            _drainEventQueue(nodeConnectorID);\n        }, 0);\n\n        // At this time, the node connector at the other side may not be created, but it is still safe to use this\n        // node connector now as the events will be queued at the other end for up to 10 seconds for a node connector\n        // to be created at the other end.\n        return newNodeConnector;\n    }\n\n    function _silentlyCloseSocket(socket) {\n        if(!socket) {\n            return;\n        }\n        try{\n            socket.autoReconnect = false;\n            socket.close();\n        } catch (e) {\n            console.error(\"node-loader: \", e);\n        }\n    }\n\n    function _wait(timeMS) {\n        return new Promise((resolve)=>{\n            setTimeout(resolve, timeMS);\n        });\n    }\n\n    async function _establishAndMaintainConnection(socketType, firstConnectCB) {\n        let ws = new WebSocket(wssEndpoint);\n        ws.binaryType = 'arraybuffer';\n        ws.autoReconnect = true;\n        const resolved = false;\n        while(ws.autoReconnect) {\n            let wsClosePromiseResolve;\n            const wsClosePromise = new Promise((resolve) => {wsClosePromiseResolve = resolve;});\n            if(socketType === SOCKET_TYPE_CONTROL) {\n                controlSocket = ws;\n            } else {\n                ws.isLargeDataWS = true;\n                dataSocket = ws;\n            }\n            // eslint-disable-next-line no-loop-func\n            ws.addEventListener(\"open\", () =>{\n                ws.backoffTime = 0;\n                if(!resolved) {\n                    firstConnectCB();\n                }\n                if(ws.isLargeDataWS){\n                    _sendInitCommand(ws, WS_COMMAND.LARGE_DATA_SOCKET_ANNOUNCE);\n                } else {\n                    _sendInitCommand(ws, WS_COMMAND.CONTROL_SOCKET_ANNOUNCE);\n                }\n                _drainPendingSendBuffer();\n            });\n\n            // eslint-disable-next-line no-loop-func\n            ws.addEventListener('message', function (event) {\n                const {metadata, bufferData} = splitMetadataAndBuffer(event.data);\n                processWSCommand(ws, metadata, bufferData);\n            });\n\n            ws.addEventListener('error', function (event) {\n                console.error(\"PhoenixFS websocket error event: \", event);\n            });\n\n            ws.addEventListener('close', function () {\n                wsClosePromiseResolve();\n            });\n            await wsClosePromise;\n            const backoffTime = Math.min(ws.backoffTime * 2, MAX_RECONNECT_BACKOFF_TIME_MS) || 1;\n            ws.backoffTime = backoffTime;\n            await _wait(backoffTime);\n            if(ws.autoReconnect) {\n                ws = new WebSocket(wssEndpoint);\n                ws.backoffTime = backoffTime;\n                ws.binaryType = 'arraybuffer';\n                ws.autoReconnect = true;\n            }\n        }\n    }\n\n    async function setNodeWSEndpoint(websocketEndpoint) {\n        return new Promise((resolve, reject)=>{\n            if(websocketEndpoint === wssEndpoint) {\n                reject(new Error(\"A connection on the same websocket address is in progress: \" + websocketEndpoint));\n            }\n            _silentlyCloseSocket(controlSocket);\n            controlSocket = null;\n            _silentlyCloseSocket(dataSocket);\n            dataSocket = null;\n            wssEndpoint = websocketEndpoint;\n            let resolved = false;\n            function firstConnectCB() {\n                if(!resolved){\n                    resolve();\n                    resolved = true;\n                }\n            }\n            _establishAndMaintainConnection(SOCKET_TYPE_CONTROL, firstConnectCB);\n            _establishAndMaintainConnection(SOCKET_TYPE_DATA, firstConnectCB);\n        });\n    }\n\n\n    window.nodeSetupDonePromise = new Promise((resolve, reject) =>{\n        const NODE_COMMANDS = {\n            TERMINATE: \"terminate\",\n            PING: \"ping\",\n            SET_DEBUG_MODE: \"setDebugMode\",\n            GET_ENDPOINTS: \"getEndpoints\"\n        };\n        const COMMAND_RESPONSE_PREFIX = 'phnodeResp_1!5$:'; // a string thats not likely to just start with in\n        const COMMAND_ERROR_PREFIX = 'phnodeErr_1!5$:';\n        let command, child;\n        let resolved = false;\n        let commandID = 0, pendingCommands = {};\n        const PHNODE_PREFERENCES_KEY = \"PhNode.Prefs\";\n        function setInspectEnabled(enabled) {\n            // cannot use PhStore instead of localStorage here as this is required at boot. Should be fine\n            // as this to use non-persistent local storage(due to safari ITP) here as this is a debug flag.\n            const prefs = JSON.parse(localStorage.getItem(PHNODE_PREFERENCES_KEY) || \"{}\");\n            prefs.inspectEnabled = enabled;\n            localStorage.setItem(PHNODE_PREFERENCES_KEY, JSON.stringify(prefs));\n        }\n        function isInspectEnabled() {\n            // cannot use PhStore instead of localStorage here as this is required at boot.\n            const prefs = JSON.parse(localStorage.getItem(PHNODE_PREFERENCES_KEY) || \"{}\");\n            return !!prefs.inspectEnabled;\n        }\n\n        function getRandomNumber(min, max) {\n            return Math.floor(Math.random() * (max - min + 1)) + min;\n        }\n\n        let nodeTerminationResolve;\n        const nodeTerminationPromise = new Promise((resolve) => { nodeTerminationResolve = resolve;});\n        window.nodeTerminationPromise = nodeTerminationPromise;\n\n        // createNodeConnector can me immediately used after this, no need to wait for node nodeSetupDonePromise\n        // All messages to be sent to node will be queued and sent when node comes online in its time.\n        window.PhNodeEngine = {\n            createNodeConnector,\n            setInspectEnabled,\n            isInspectEnabled\n        };\n        window.isNodeReady = false;\n        let nodeErrorLogCount = 0;\n        // 10 node error logs are allowed on console every 2 seconds to prevent freeze due to\n        const MAX_NODE_ERROR_LOGS_ALLOWED = 10;\n        const NODE_ERROR_LOGS_RESET_INTERVAL = 2000;\n        setInterval(()=>{\n            // allow only logging up to x log lines in a given interval.\n            if(!window.debugMode && nodeErrorLogCount > MAX_NODE_ERROR_LOGS_ALLOWED){\n                console.error(\"Too many node Errors, some errors were omitted from console.\",\n                    \"Please enable `Debug menu> Phoenix code diagnostic tools> enable detailed logs` to view all.\");\n            }\n            nodeErrorLogCount = 0;\n        }, NODE_ERROR_LOGS_RESET_INTERVAL);\n\n        window.__TAURI__.path.resolveResource(\"src-node/index.js\")\n            .then(async nodeSrcPath=>{\n                if(Phoenix.platform === \"linux\") {\n                    // in linux installed distributions, src-node is present in the same dir as the executable.\n                    const cliArgs = await window.__TAURI__.invoke('_get_commandline_args');\n                    nodeSrcPath = `${window.path.dirname(cliArgs[0])}/src-node/index.js`;\n                }\n                // node is designed such that it is not required at boot time to lower startup time.\n                // Keep this so to increase boot speed.\n                const inspectPort = Phoenix.isTestWindow ? getRandomNumber(5000, 50000) : 9229;\n                const argsArray = isInspectEnabled() ? [`--inspect=${inspectPort}`, nodeSrcPath] : [nodeSrcPath, ''];\n                command = window.__TAURI__.shell.Command.sidecar('phnode', argsArray);\n                command.on('close', data => {\n                    window.isNodeTerminated = true;\n                    window.isNodeReady = false;\n                    nodeTerminationResolve();\n                    console.log(`PhNode: command finished with code ${data.code} and signal ${data.signal}`);\n                    if(!resolved) {\n                        reject(\"PhNode: closed - Terminated.\");\n                    }\n                });\n                command.on('error', error => {\n                    window.isNodeTerminated = true;\n                    window.isNodeReady = false;\n                    nodeTerminationResolve();\n                    console.error(`PhNode: command error: \"${error}\"`);\n                    if(!resolved) {\n                        logger.reportError(error, `PhNode failed to start!`);\n                        reject(\"PhNode: closed - Terminated.\");\n                    }\n                });\n                command.stdout.on('data', line => {\n                    if(line){\n                        if(line.startsWith(COMMAND_RESPONSE_PREFIX)){\n                            // its a js response object\n                            line = line.replace(COMMAND_RESPONSE_PREFIX, \"\");\n                            const jsonMsg = JSON.parse(line);\n                            pendingCommands[jsonMsg.commandID].resolve(jsonMsg.message);\n                            delete pendingCommands[jsonMsg.commandID];\n                        } else if(line.startsWith(COMMAND_ERROR_PREFIX)){\n                            // its a js response object\n                            line = line.replace(COMMAND_ERROR_PREFIX, \"\");\n                            const err = JSON.parse(line);\n                            logger.reportError(err, `PhNode ${err.type}:${err.code?err.code:''}`);\n                        } else {\n                            console.log(`PhNode: ${line}`);\n                        }\n                    }\n                });\n                command.stderr.on('data', line => {\n                    if(window.debugMode || nodeErrorLogCount < MAX_NODE_ERROR_LOGS_ALLOWED){\n                        // in release builds, too many node errors from file system/other sources can\n                        // happen, Eg. user opens a very large project and fs watchers goes bust.\n                        // if that happens, the app may get stuck logging large number of errors to console, so\n                        // we show atmost 10 error lines every 10 seconds in non-debug builds.\n                        console.error(`PhNode: ${line}`);\n                    }\n                    nodeErrorLogCount ++;\n                });\n                child = await command.spawn();\n\n                const execNode = function (commandCode, commandData) {\n                    if(window.isNodeTerminated){\n                        return Promise.reject(\"Node is terminated! Cannot execute: \" + commandCode);\n                    }\n                    const newCommandID = commandID ++;\n                    child.write(JSON.stringify({\n                        commandCode: commandCode, commandID: newCommandID, commandData\n                    }) + \"\\n\");\n                    let resolveP, rejectP;\n                    const promise = new Promise((resolve, reject) => { resolveP = resolve; rejectP=reject; });\n                    pendingCommands[newCommandID]= {resolve: resolveP, reject: rejectP};\n                    return promise;\n                };\n\n                window.PhNodeEngine.terminateNode = function () {\n                    if(!window.isNodeTerminated) {\n                        execNode(NODE_COMMANDS.TERMINATE);\n                    }\n                    return nodeTerminationPromise;\n                };\n                window.PhNodeEngine.getInspectPort = function () {\n                    return inspectPort;\n                };\n\n                execNode(NODE_COMMANDS.GET_ENDPOINTS)\n                    .then(message=>{\n                        fs.setNodeWSEndpoint(message.phoenixFSURL);\n                        fs.forceUseNodeWSEndpoint(true);\n                        setNodeWSEndpoint(message.phoenixNodeURL);\n                        KernalModeTrust.localAutoAuthURL = message.autoAuthURL;\n                        window.isNodeReady = true;\n                        resolve(message);\n                        // node is designed such that it is not required at boot time to lower startup time.\n                        // Keep this so to increase boot speed.\n                        window.PhNodeEngine._nodeLoadTime = Date.now() - nodeLoadstartTime;\n                    });\n                execNode(NODE_COMMANDS.SET_DEBUG_MODE, window.debugMode);\n            });\n    });\n}\n\nif(Phoenix.isNativeApp) {\n    nodeLoader();\n}\n"],"file":"node-loader.js"}