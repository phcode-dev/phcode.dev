{"version":3,"sources":["extensionsIntegrated/NavigationAndHistory/FileRecovery.js"],"names":["define","require","exports","module","NativeApp","FileSystem","ProjectManager","MainViewManager","FileSystemError","FileUtils","DocumentManager","NotificationUI","Mustache","Strings","FileViewController","recoveryTemplate","EventDispatcher","Metrics","EventManager","makeEventDispatcher","registerEventHandler","BACKUP_INTERVAL_MS","sessionRestoreDir","getDirectoryForPath","path","normalize","getApplicationSupportDirectory","trackedProjects","simpleHash","str","hash","i","length","char","charCodeAt","Math","abs","createDir","dir","Promise","resolve","reject","create","err","ALREADY_EXISTS","console","error","fullPath","silentlyRemoveFile","getFileForPath","unlink","silentlyRemoveDirectory","getProjectRestoreRoot","projectPath","baseName","basename","restoreRootPath","getRestoreFilePath","projectFilePath","projectRootPath","startsWith","pathWithinProject","replace","restoreRoot","getProjectFilePath","restoreFilePath","project","filePathInProject","async","ensureFolderIsClean","folder","unlinkEmptyDirectoryAsync","integrityCheck","input","firstCommaIndex","indexOf","expectedLengthPart","slice","actualString","expectedLength","parseInt","isNaN","loadLastBackedUpFileContents","currentProjectLoadCount","projectLoadCount","restoreFolder","allEntries","getAllDirectoryContents","backupExists","entry","isDirectory","text","jsPromise","readAsText","lastBackedUpFileContents","lastBackedupLoadInProgress","notificationHTML","render","PROJECT_TO_RECOVER","restoreNotification","close","createToastFromTemplate","RECOVER_UNSAVED_FILES_TITLE","dismissOnClick","toastStyle","NOTIFICATION_STYLES_CSS_CLASS","SUCCESS","countEvent","EVENT_TYPE","PROJECT","currentProjectRoot","projectOpened","_event","projectRoot","firstEditHandled","trackedFileUpdateTimestamps","trackedFileContents","changeErrorReported","catch","writeFileIgnoreFailure","filePath","contents","parentDir","dirname","file","restoreContentsWithIntegrity","writeText","e","backupChangedDocs","trackedFilePaths","Object","keys","trackedFilePath","restorePath","content","cleanupUntrackedFiles","docPathsToTrack","allTrackingPaths","trackedPath","restoreFile","backupInProgress","changeScanner","getProjectRoot","openDocs","getAllOpenDocuments","dirtyDocsExists","doc","isDirty","lastTrackedTimestamp","lastChangeTimestamp","getText","log","$","addClass","logger","reportError","beforeProjectClosed","ensureOpenEditors","pathList","allOpenFiles","getAllOpenFiles","openFilePaths","openFileAndAddToWorkingSet","restoreBtnClicked","projectToRestore","pathsToRestore","isWithinProject","document","getDocumentForPath","setText","discardBtnClicked","initWith","scanIntervalMs","restoreDir","on","EVENT_AFTER_PROJECT_OPEN","EVENT_PROJECT_BEFORE_CLOSE","setInterval","_evt","waitPromises","exitProjectRoot","push","init","window","testEnvironment","_FileRecoveryExtensionForTests"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2016 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*global path, logger, jsPromise*/\n\n/**\n * This file outlines the process phcode follows to restore files if the application crashes or if a user closes\n * the application without saving their files.\n *\n * For each project in phcode, there's a unique 'restore' folder located in the appdata directory.\n * This folder is named according to the pattern <projectName>-<projectPathHash>.\n *\n * The restore folder monitors all files being edited in phcode, and this tracking is updated every 5 seconds\n * by a function called changeScanner. The function backs up changes every 5 seconds, and only unsaved files\n * that have been modified since the last backup are synced again. When files are saved, they're removed from\n * the backup during this changeScanner process because there's no need to restore them.\n *\n * When opening a project, we first check for the existence of a 'restore' folder associated with that project\n * and scan for any files within it. If we find any, these files are marked for potential restoration.\n *\n * During this process, we load all recoverable file data into memory and temporarily halt any writing activity\n * to the 'restore' folder. This safeguard is in place to prevent any accidental overwriting of the restore files'\n * data in case the user edits any files currently marked for restoration.\n *\n * Once we've cached the data from the restore files, we present a notification to the user, asking if they would\n * like these files to be restored. If the user agrees, we then open all of these files in the editor and populate\n * them with the previously cached, restored content.\n */\n\ndefine(function (require, exports, module) {\n    const NativeApp = require(\"utils/NativeApp\"),\n        FileSystem = require(\"filesystem/FileSystem\"),\n        ProjectManager = require(\"project/ProjectManager\"),\n        MainViewManager = require(\"view/MainViewManager\"),\n        FileSystemError = require(\"filesystem/FileSystemError\"),\n        FileUtils = require(\"file/FileUtils\"),\n        DocumentManager = require(\"document/DocumentManager\"),\n        NotificationUI = require(\"widgets/NotificationUI\"),\n        Mustache = require(\"thirdparty/mustache/mustache\"),\n        Strings = require(\"strings\"),\n        FileViewController  = require(\"project/FileViewController\"),\n        recoveryTemplate = require(\"text!./html/recovery-template.html\"),\n        EventDispatcher = require(\"utils/EventDispatcher\"),\n        Metrics = require(\"utils/Metrics\"),\n        EventManager = require(\"utils/EventManager\");\n\n    EventDispatcher.makeEventDispatcher(exports);\n    EventManager.registerEventHandler(\"ph-recovery\", exports);\n\n    const BACKUP_INTERVAL_MS = 5000;\n    let sessionRestoreDir = FileSystem.getDirectoryForPath(\n        path.normalize(NativeApp.getApplicationSupportDirectory() + \"/sessionRestore\"));\n\n    const trackedProjects = {};\n\n    function simpleHash(str) {\n        let hash = 0;\n        for (let i = 0; i < str.length; i++) {\n            let char = str.charCodeAt(i);\n            // eslint-disable-next-line no-bitwise\n            hash = ((hash << 5) - hash) + char;\n            // eslint-disable-next-line no-bitwise\n            hash = hash & hash; // Convert to 32bit integer\n        }\n        return Math.abs(hash) + \"\";\n    }\n\n    function createDir(dir) {\n        return new Promise((resolve, reject)=>{\n            dir.create(function (err) {\n                if (err && err !== FileSystemError.ALREADY_EXISTS) {\n                    console.error(\"[recovery] Error creating project crash restore folder \" + dir.fullPath, err);\n                    reject(err);\n                }\n                resolve();\n            });\n        });\n    }\n\n    function silentlyRemoveFile(path) {\n        return new Promise((resolve)=>{\n            FileSystem.getFileForPath(path).unlink((err)=>{\n                if(err) {\n                    console.error(err);\n                }\n                resolve();\n            });\n        });\n    }\n\n    function silentlyRemoveDirectory(dir) {\n        return new Promise((resolve)=>{\n            dir.unlink((err)=>{\n                if(err) {\n                    console.error(err);\n                }\n                resolve();\n            });\n        });\n    }\n\n    function getProjectRestoreRoot(projectPath) {\n        const baseName = path.basename(projectPath),\n            restoreRootPath = path.normalize(`${sessionRestoreDir.fullPath}/${baseName}_${simpleHash(projectPath)}`);\n        return FileSystem.getDirectoryForPath(restoreRootPath);\n    }\n\n    function getRestoreFilePath(projectFilePath, projectRootPath) {\n        if(!projectFilePath.startsWith(projectRootPath) || !trackedProjects[projectRootPath]){\n            console.error(`[recovery] cannot backed up as ${projectFilePath} is not in project ${projectRootPath}`);\n            return null;\n        }\n        let pathWithinProject = projectFilePath.replace(projectRootPath, \"\");\n        let restoreRoot = trackedProjects[projectRootPath].restoreRoot;\n        return path.normalize(`${restoreRoot.fullPath}/${pathWithinProject}`);\n    }\n\n    // try not to use this\n    function getProjectFilePath(restoreFilePath, projectRootPath) {\n        const project = trackedProjects[projectRootPath];\n        if(!project || !restoreFilePath.startsWith(project.restoreRoot.fullPath)){\n            return null;\n        }\n\n        let filePathInProject = restoreFilePath.replace(project.restoreRoot.fullPath, \"\");\n        return path.normalize(`${projectRootPath}/${filePathInProject}`);\n    }\n\n    /**\n     * the restore folder may have empty folders as files get deleted according to backup algorithm. This fn will\n     * ensure that there are no empty folders and restore folder exists\n     * @param folder\n     * @return {Promise<void>}\n     */\n    async function ensureFolderIsClean(folder) {\n        await createDir(folder);\n        await folder.unlinkEmptyDirectoryAsync();\n        await createDir(folder);\n    }\n\n    function integrityCheck(input) {\n        // The backup is of the form \"length,string_backed_up\" so that we can do integrity checks. ideally we should use\n        // crypto hash functions but that may be expensive. since this is reversible with undo, not doing it for now.\n        if(!input){\n            return null;\n        }\n        // Find the first comma\n        const firstCommaIndex = input.indexOf(',');\n\n        // If there's no comma or it's at the very beginning, the input is invalid\n        if (firstCommaIndex === -1 || firstCommaIndex === 0) {\n            return null;\n        }\n\n        // Extract the parts\n        const expectedLengthPart = input.slice(0, firstCommaIndex);\n        const actualString = input.slice(firstCommaIndex + 1);\n\n        // Parse the length part (should be the first part before the comma)\n        const expectedLength = parseInt(expectedLengthPart, 10);\n        if (isNaN(expectedLength)) {\n            return null;\n        }\n\n        // The second part is the actual string after the commas\n        if (actualString.length === expectedLength) {\n            return actualString;\n        }\n        return null;\n    }\n\n    async function loadLastBackedUpFileContents(projectRootPath) {\n        const project = trackedProjects[projectRootPath];\n        if(!project){\n            console.error(\"[recovery] Cannot load backup, no tracking info of project \" + projectRootPath);\n            return;\n        }\n        const currentProjectLoadCount = project.projectLoadCount;\n        let restoreFolder = project.restoreRoot;\n        await ensureFolderIsClean(restoreFolder);\n        let allEntries = await FileSystem.getAllDirectoryContents(restoreFolder);\n        let backupExists = false;\n        for(let entry of allEntries){\n            if(entry.isDirectory){\n                continue;\n            }\n            let text = integrityCheck(await jsPromise(FileUtils.readAsText(entry)));\n            if(!text){\n                continue;\n            }\n            let projectFilePath = getProjectFilePath(entry.fullPath, projectRootPath);\n            if(currentProjectLoadCount !== project.projectLoadCount){\n                // this means that while we were tying to load a project backup, the user switched to another project\n                // and then switched back to this project, all before the first backup load was complete. so\n                // we just return without doing anything here. This function will be eventually called on projectOpened\n                // event handler.\n                return;\n            }\n            project.lastBackedUpFileContents[projectFilePath] = text;\n            backupExists = true;\n        }\n        project.lastBackedupLoadInProgress = false;\n        if(backupExists) {\n            let notificationHTML = Mustache.render(recoveryTemplate, {\n                Strings: Strings,\n                PROJECT_TO_RECOVER: projectRootPath\n            });\n            if(project.restoreNotification){\n                project.restoreNotification.close();\n                project.restoreNotification = null;\n            }\n            project.restoreNotification = NotificationUI.createToastFromTemplate( Strings.RECOVER_UNSAVED_FILES_TITLE,\n                notificationHTML, {\n                    dismissOnClick: false,\n                    toastStyle: NotificationUI.NOTIFICATION_STYLES_CSS_CLASS.SUCCESS\n                });\n            Metrics.countEvent(Metrics.EVENT_TYPE.PROJECT, \"recovery\", \"notified\");\n        } else {\n            Metrics.countEvent(Metrics.EVENT_TYPE.PROJECT, \"recovery\", \"none\");\n        }\n    }\n\n    let currentProjectRoot = null;\n    function projectOpened(_event, projectRoot) {\n        if(projectRoot.fullPath === '/') {\n            console.error(\"[recovery] Backups will not be done for root folder `/`\");\n            return;\n        }\n        if(currentProjectRoot && currentProjectRoot.fullPath === projectRoot.fullPath){\n            // If we get a redundant project open event return. This is because of #SEARCH_THIS_TAG_IN_FILE_1\n            return;\n        }\n        currentProjectRoot = projectRoot;\n        if(trackedProjects[projectRoot.fullPath]){\n            if(trackedProjects[projectRoot.fullPath].restoreNotification){\n                trackedProjects[projectRoot.fullPath].restoreNotification.close();\n                trackedProjects[projectRoot.fullPath].restoreNotification = null;\n            }\n            trackedProjects[projectRoot.fullPath].projectLoadCount++;// we use this to prevent race conditions\n            // on frequent project switch before all project backup files are loaded.\n            trackedProjects[projectRoot.fullPath].lastBackedUpFileContents = {};\n            trackedProjects[projectRoot.fullPath].firstEditHandled = false;\n            trackedProjects[projectRoot.fullPath].lastBackedupLoadInProgress = true;\n            trackedProjects[projectRoot.fullPath].trackedFileUpdateTimestamps = {};\n            trackedProjects[projectRoot.fullPath].trackedFileContents = {};\n            trackedProjects[projectRoot.fullPath].changeErrorReported = false;\n            loadLastBackedUpFileContents(projectRoot.fullPath).catch(err=>{\n                console.error(\"[recovery] loadLastBackedUpFileContents failed \", err);\n            });\n            return;\n        }\n        trackedProjects[projectRoot.fullPath] = {\n            projectLoadCount: 0, // we use this to prevent race conditions on frequent project switch before all\n            // project backup files are loaded.\n            projectRoot: projectRoot,\n            restoreRoot: getProjectRestoreRoot(projectRoot.fullPath),\n            lastBackedUpFileContents: {},\n            firstEditHandled: false, // after a project is loaded, has the first edit by user on any file been handled?\n            lastBackedupLoadInProgress: true, // while the backup is loading, we need to prevent write over the existing\n            // backup with backup info of the current session\n            trackedFileUpdateTimestamps: {},\n            trackedFileContents: {},\n            restoreNotification: null,\n            changeErrorReported: false // we only report change errors once to prevent too many Bugsnag reports\n        };\n        loadLastBackedUpFileContents(projectRoot.fullPath).catch(err=>{\n            console.error(\"[recovery] loadLastBackedUpFileContents failed \", err);\n        });\n    }\n\n    async function writeFileIgnoreFailure(filePath, contents) {\n        try {\n            let parentDir = FileSystem.getDirectoryForPath(path.dirname(filePath));\n            await createDir(parentDir);\n            let file = FileSystem.getFileForPath(filePath);\n            const restoreContentsWithIntegrity = contents.length + \",\" + contents;\n            await jsPromise(FileUtils.writeText(file, restoreContentsWithIntegrity, true));\n        } catch (e) {\n            console.error(e);\n        }\n    }\n\n    async function backupChangedDocs(projectRoot) {\n        const project = trackedProjects[projectRoot.fullPath];\n        let trackedFilePaths =  Object.keys(project.trackedFileContents);\n        for(let trackedFilePath of trackedFilePaths){\n            const restorePath = getRestoreFilePath(trackedFilePath, projectRoot.fullPath);\n            if(restorePath) {\n                const content = project.trackedFileContents[trackedFilePath];\n                await writeFileIgnoreFailure(restorePath, content);\n            }\n            delete project.trackedFileContents[trackedFilePath];\n        }\n    }\n\n    async function cleanupUntrackedFiles(docPathsToTrack, projectRoot) {\n        const project = trackedProjects[projectRoot.fullPath];\n        let allTrackingPaths = Object.keys(project.trackedFileUpdateTimestamps);\n        for(let trackedPath of allTrackingPaths){\n            if(!docPathsToTrack[trackedPath]){\n                const restoreFile = getRestoreFilePath(trackedPath, projectRoot.fullPath);\n                if(restoreFile) {\n                    await silentlyRemoveFile(restoreFile);\n                }\n                delete project.trackedFileUpdateTimestamps[trackedPath];\n            }\n        }\n    }\n\n    let backupInProgress = false;\n\n    /**\n     * This gets executed every 5 seconds and should be as light-weight as possible. If there are no changes to be\n     * backed up, then this function should return as soon as possible without waiting for any async flows.\n     * @return {Promise<void>}\n     */\n    async function changeScanner() {\n        let currentProjectRoot = ProjectManager.getProjectRoot();\n        const project = trackedProjects[currentProjectRoot.fullPath];\n        if(backupInProgress || currentProjectRoot.fullPath === \"/\" || !project || project.lastBackedupLoadInProgress){\n            // trackingProjectRoot can be \"/\" if debug>open virtual file system menu is clicked. Don't track root fs\n            return;\n        }\n        backupInProgress = true;\n        try{\n            // do backup\n            const openDocs = DocumentManager.getAllOpenDocuments();\n            let docPathsToTrack = {}, dirtyDocsExists = false;\n            for(let doc of openDocs){\n                if(doc && doc.isDirty){\n                    dirtyDocsExists = true;\n                    docPathsToTrack[doc.file.fullPath] = true;\n                    const lastTrackedTimestamp = project.trackedFileUpdateTimestamps[doc.file.fullPath];\n                    if(!lastTrackedTimestamp || lastTrackedTimestamp !== doc.lastChangeTimestamp){\n                        // Already backed up, only need to consider it again if its contents changed\n                        project.trackedFileContents[doc.file.fullPath] = doc.getText();\n                        project.trackedFileUpdateTimestamps[doc.file.fullPath] = doc.lastChangeTimestamp;\n                    }\n                }\n            }\n            if(!project.firstEditHandled && dirtyDocsExists) {\n                // this means that the last backup session has been fully loaded in memory and a new edit has been\n                // done by the user. The user may not have yet clicked on the restore backup button. But as the user\n                // made an edit, we should delete the project restore folder to start a new backup session. The user\n                // can still restore the last backup session from the in memory `project.lastBackedUpFileContents`\n                console.log(\"Discarding old backup for restore...\");\n                await silentlyRemoveDirectory(project.restoreRoot);\n                await createDir(project.restoreRoot);\n                await backupChangedDocs(currentProjectRoot);\n                project.firstEditHandled = true;\n                if(project.restoreNotification) {\n                    // this means the user edited a file while the restore dialog was shown. This generally means the\n                    // restore folder has been nuked to make way for the new session, but the old restore contents are still\n                    // available in project.lastBackedUpFileContents. So the contents can be restored, but the restore\n                    // data has already been discarded. We hide the discard option in the case as it's already done.\n                    $(\"#DISCARD_UNSAVED_FILES_RESTORE\").addClass(\"forced-hidden\");\n                }\n            } else {\n                await backupChangedDocs(currentProjectRoot);\n                await cleanupUntrackedFiles(docPathsToTrack, currentProjectRoot);\n            }\n        } catch (e) {\n            console.error(\"[recovery] changeScanner error\", e);\n            if(!project.changeErrorReported){\n                project.changeErrorReported = true;\n                // we only report change errors once to prevent too many Bugsnag reports\n                logger.reportError(e);\n            }\n        }\n        backupInProgress = false;\n    }\n\n    function beforeProjectClosed() {\n        let currentProjectRoot = ProjectManager.getProjectRoot();\n        const project = trackedProjects[currentProjectRoot.fullPath];\n        if(project.restoreNotification) {\n            project.restoreNotification.close();\n            project.restoreNotification = null;\n        }\n        changeScanner().catch(err=>{\n            console.error(\"[recovery] beforeProjectClosed failed which scanning for changes to backup\", err);\n        });\n    }\n\n    async function ensureOpenEditors(pathList) {\n        let allOpenFiles = MainViewManager.getAllOpenFiles();\n        let openFilePaths = {};\n        for(let file of allOpenFiles){\n            openFilePaths[file.fullPath] = true;\n        }\n        for(let path of pathList) {\n            if(!openFilePaths[path]){\n                let file = FileSystem.getFileForPath(path);\n                await jsPromise(FileViewController.openFileAndAddToWorkingSet(file.fullPath));\n            }\n        }\n    }\n\n    async function restoreBtnClicked(_event, projectToRestore) {\n        let currentProjectRoot = ProjectManager.getProjectRoot();\n        const project = trackedProjects[currentProjectRoot.fullPath];\n        Metrics.countEvent(Metrics.EVENT_TYPE.PROJECT, \"recovery\", \"restoreClick\");\n        if(!project || projectToRestore !== currentProjectRoot.fullPath){\n            console.error(`[recovery] current project ${currentProjectRoot.fullPath} != restore ${projectToRestore}`);\n            return;\n        }\n        let pathsToRestore = Object.keys(project.lastBackedUpFileContents);\n        await ensureOpenEditors(pathsToRestore);\n        for(let filePath of pathsToRestore){\n            if(ProjectManager.isWithinProject(filePath)) {\n                console.log(\"restoring\", filePath);\n                let document = await jsPromise(DocumentManager.getDocumentForPath(filePath));\n                document.setText(project.lastBackedUpFileContents[filePath]);\n            } else {\n                console.error(\"[recovery] Skipping restore of non project file: \", filePath);\n            }\n        }\n        if(project.restoreNotification){\n            project.restoreNotification.close();\n            project.restoreNotification = null;\n        }\n    }\n\n    async function discardBtnClicked(_event, projectToRestore) {\n        let currentProjectRoot = ProjectManager.getProjectRoot();\n        const project = trackedProjects[currentProjectRoot.fullPath];\n        Metrics.countEvent(Metrics.EVENT_TYPE.PROJECT, \"recovery\", \"discardClick\");\n        if(!project || projectToRestore !== currentProjectRoot.fullPath){\n            console.error(`[recovery] current project ${currentProjectRoot.fullPath} != restore ${projectToRestore}`);\n            return;\n        }\n        trackedProjects[currentProjectRoot.fullPath].lastBackedUpFileContents = {};\n        // if first edit is handled, the restore directory is nuked and the backup discarded.The discard button will\n        // not be shown so this fn should never get called in the case. We also should mark firstEditHandled to true to\n        // indicate a fresh backup start for the project\n        trackedProjects[currentProjectRoot.fullPath].firstEditHandled = true;\n        if(project.restoreNotification) {\n            project.restoreNotification.close();\n            project.restoreNotification = null;\n        }\n        await silentlyRemoveDirectory(project.restoreRoot);\n        await createDir(project.restoreRoot);\n        await backupChangedDocs(currentProjectRoot);\n    }\n\n    function initWith(scanIntervalMs, restoreDir) {\n        ProjectManager.on(ProjectManager.EVENT_AFTER_PROJECT_OPEN, projectOpened);\n        ProjectManager.on(ProjectManager.EVENT_PROJECT_BEFORE_CLOSE, beforeProjectClosed);\n        exports.on(\"restoreProject\", restoreBtnClicked);\n        exports.on(\"discardProject\", discardBtnClicked);\n        sessionRestoreDir = restoreDir;\n        createDir(sessionRestoreDir);\n        setInterval(changeScanner, scanIntervalMs);\n        let currentProjectRoot = ProjectManager.getProjectRoot();\n        if(currentProjectRoot) {\n            // ##SEARCH_THIS_TAG_IN_FILE_1\n            // At boot, the startup project may be opened and we may never get the projectOpened event triggered\n            // for the startup project. So we call manually.\n            projectOpened(null, currentProjectRoot);\n        }\n        ProjectManager.on(\"beforeAppClose\", (_evt, waitPromises)=>{\n            // this is a safe exit, we should delete all restore data.\n            let exitProjectRoot = ProjectManager.getProjectRoot();\n            if(exitProjectRoot) {\n                const restoreRoot = getProjectRestoreRoot(exitProjectRoot.fullPath);\n                waitPromises.push(silentlyRemoveDirectory(restoreRoot));\n            }\n        });\n    }\n\n    function init() {\n        if(!window.testEnvironment){\n            initWith(BACKUP_INTERVAL_MS, sessionRestoreDir);\n        } else {\n            // this is a test environment, expose functions to test\n            exports.getProjectRestoreRoot = getProjectRestoreRoot;\n            exports.initWith = initWith;\n            window._FileRecoveryExtensionForTests = exports;\n        }\n    }\n\n    exports.init = init;\n});\n"],"file":"FileRecovery.js"}