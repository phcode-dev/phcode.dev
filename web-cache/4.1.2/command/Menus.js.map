{"version":3,"sources":["command/Menus.js"],"names":["define","require","exports","module","_","Commands","EventDispatcher","KeyBindingManager","Keys","Strings","StringUtils","CommandManager","PopUpManager","ViewUtils","Metrics","MainViewManager","AppInit","DeprecationWarning","KEY","allMenuCommands","Set","AppMenuBar","FILE_MENU","EDIT_MENU","FIND_MENU","VIEW_MENU","NAVIGATE_MENU","DEBUG_MENU","HELP_MENU","ContextMenuIds","EDITOR_MENU","INLINE_EDITOR_MENU","PROJECT_MENU","WORKING_SET_CONTEXT_MENU","WORKING_SET_CONFIG_MENU","SPLITVIEW_MENU","SubMenuIds","GIT_SUB_MENU","EVENT_BEFORE_CONTEXT_MENU_OPEN","EVENT_BEFORE_CONTEXT_MENU_CLOSE","EVENT_BEFORE_SUB_MENU_OPEN","EVENT_BEFORE_SUB_MENU_CLOSE","EVENT_MENU_ADDED","EVENT_SUB_MENU_ADDED","EVENT_MENU_ITEM_ADDED","FILE_OPEN_CLOSE_COMMANDS","sectionMarker","FILE_NEW","FILE_SAVE_COMMANDS","FILE_SAVE","FILE_LIVE","FILE_LIVE_FILE_PREVIEW","FILE_SETTINGS","FILE_EXTENSION_MANAGER","EDIT_UNDO_REDO_COMMANDS","EDIT_UNDO","EDIT_TEXT_COMMANDS","EDIT_CUT","EDIT_SELECTION_COMMANDS","EDIT_SELECT_ALL","EDIT_MODIFY_SELECTION","EDIT_INDENT","EDIT_COMMENT_SELECTION","EDIT_LINE_COMMENT","EDIT_CODE_HINTS_COMMANDS","SHOW_CODE_HINTS","EDIT_TOGGLE_OPTIONS","TOGGLE_CLOSE_BRACKETS","FIND_FIND_COMMANDS","CMD_FIND","FIND_FIND_IN_COMMANDS","CMD_FIND_IN_FILES","FIND_REPLACE_COMMANDS","CMD_REPLACE","VIEW_HIDESHOW_COMMANDS","VIEW_HIDE_SIDEBAR","VIEW_FONTSIZE_COMMANDS","VIEW_ZOOM_SUBMENU","VIEW_TOGGLE_OPTIONS","TOGGLE_ACTIVE_LINE","NAVIGATE_GOTO_COMMANDS","NAVIGATE_QUICK_OPEN","NAVIGATE_DOCUMENTS_COMMANDS","NAVIGATE_NEXT_DOC","NAVIGATE_OS_COMMANDS","NAVIGATE_SHOW_IN_FILE_TREE","NAVIGATE_QUICK_EDIT_COMMANDS","TOGGLE_QUICK_EDIT","NAVIGATE_QUICK_DOCS_COMMANDS","TOGGLE_QUICK_DOCS","MenuSection","BEFORE","AFTER","FIRST","LAST","FIRST_IN_SECTION","LAST_IN_SECTION","DIVIDER","SUBMENU","menuMap","contextMenuMap","menuItemMap","subMenuItemMap","getMenu","id","getSubMenu","getContextMenu","getAllMenuItemCommands","getAllMenus","removeMenuItemEventListeners","menuItem","_command","off","_enabledChanged","_checkedChanged","_nameChanged","_keyBindingAdded","_keyBindingRemoved","getMenuItem","_getHTMLMenu","$","jQueryIdEscape","get","_getHTMLMenuItem","_addKeyBindingToMenuItem","commandID","$menuItem","key","displayKey","$shortcut","find","length","html","canAssignBinding","append","data","text","formatKeyDescriptor","_addExistingKeyBinding","getCommand","getID","bindings","getKeyBindings","binding","_menuDividerIDCount","_getNextMenuItemDividerID","_insertInList","$list","$element","position","$relativeElement","inserted","prepend","after","before","MenuItem","command","options","this","isDivider","isNative","bind","_hideWhenCommandDisabled","hideWhenCommandDisabled","on","Menu","prototype","_getMenuItemId","commandId","_getMenuItemForCommand","foundMenuItem","closest","_getRelativeMenuItem","relativeID","hasOwnProperty","console","error","$sectionMarker","$listElem","prev","next","removeMenuItem","menuItemID","commandObj","parent","remove","removeMenuDivider","$HTMLMenuItem","addMenuItem","keyBindings","self","name","getName","has","add","log","keyboardIcon","KEYBOARD_SHORTCUT_CHANGE_TITLE","$menuAnchor","event","showShortcutSelectionDialog","preventDefault","stopPropagation","hasClass","countEvent","EVENT_TYPE","UI_MENU","logger","leaveTrail","focusActivePane","FILE_SAVE_AS","FILE_SAVE_ALL","execute","_options","eventSource","SOURCE_UI_MENU_CLICK","sourceType","addClass","currentWidth","width","removeClass","css","closeSubMenu","dividerId","Array","isArray","addBinding","menuId","trigger","addMenuDivider","addSubMenu","menu","ContextMenu","parentMenuItem","e","openSubMenu","open","removeSubMenu","subMenuID","subMenu","forEach","value","startsWith","close","getParentMenu","parents","checked","getChecked","enabled","getEnabled","brackets","app","setMenuItemState","err","toggleClass","setMenuTitle","htmlName","getOptions","keyBinding","shortcutKey","setMenuItemShortcut","empty","lastOpenedMenuID","closeAll","$openDropdownMenuList","getOpenMenu","_closeAllSubMenus","Object","values","openMenu","getDropdownToggleMenuID","click","assignedShortcutsMenus","altKeyReleased","_addAltMenuShortcut","menuName","platform","shortCutKey","toUpperCase","push","newShortcutList","secondLetterShortCutKey","menuShortcutCommandID","register","menusIdsForShortcut","map","item","currentIndex","indexOf","menuToOpen","isMenuShortcut","addMenu","escape","$menubar","$toggle","$popUp","$dropdown","$newMenu","$this","is","focus","addPopUp","_switchMenus","$menuDropdownToggle","menuID","mainMenu","$dropdownToggles","index","nextIndex","ARROW_LEFT","$nextDropdownToggle","eq","_switchMenuItems","$dropdownMenu","$selected","first","$next","ARROW_DOWN","$nextLi","ARROW_UP","$prevLi","last","submenuID","submenu","_execMenuItem","menuKeyboardNavigationHandler","allowedKeys","ARROW_RIGHT","ESCAPE","ENTER","RETURN","includes","$focusedElement","isDescendantOfTitleBar","SPACE","removeMenu","apply","arguments","hide","listenToContextMenu","registerContextMenu","cmenu","window","document","body","addEventListener","ALT","create","constructor","parentClass","makeEventDispatcher","mouseOrLocation","$window","escapedId","$menuWindow","posTop","posLeft","children","$parentMenuItem","elementRect","top","offset","left","outerWidth","height","clip","getElementClipSize","bottom","Math","max","right","pageY","pageX","isOpen","assignContextMenuToSelector","selector","buttonOffset","buttonHeight","outerHeight","htmlReady","addGlobalKeydownHook","removeGlobalKeydownHook","deprecateConstant"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n// @INCLUDE_IN_API_DOCS\n\n/*global logger*/\n\ndefine(function (require, exports, module) {\n\n\n    let _ = require(\"thirdparty/lodash\");\n\n    // Load dependent modules\n    let Commands = require(\"command/Commands\"),\n        EventDispatcher = require(\"utils/EventDispatcher\"),\n        KeyBindingManager = require(\"command/KeyBindingManager\"),\n        Keys = require(\"command/Keys\"),\n        Strings = require(\"strings\"),\n        StringUtils = require(\"utils/StringUtils\"),\n        CommandManager = require(\"command/CommandManager\"),\n        PopUpManager = require(\"widgets/PopUpManager\"),\n        ViewUtils = require(\"utils/ViewUtils\"),\n        Metrics = require(\"utils/Metrics\"),\n        MainViewManager = require(\"view/MainViewManager\"),\n        AppInit = require(\"utils/AppInit\"),\n        DeprecationWarning = require(\"utils/DeprecationWarning\");\n\n    // make sure the global brackets letiable is loaded\n    require(\"utils/Global\");\n\n    const KEY = Keys.KEY;\n    const allMenuCommands = new Set();\n    /**\n     * Brackets Application Menu Constants\n     * @enum {string}\n     */\n    let AppMenuBar = {\n        FILE_MENU: \"file-menu\",\n        EDIT_MENU: \"edit-menu\",\n        FIND_MENU: \"find-menu\",\n        VIEW_MENU: \"view-menu\",\n        NAVIGATE_MENU: \"navigate-menu\",\n        DEBUG_MENU: \"debug-menu\",\n        HELP_MENU: \"help-menu\"\n    };\n\n    /**\n     * Brackets Context Menu Constants\n     * @enum {string}\n     */\n    let ContextMenuIds = {\n        EDITOR_MENU: \"editor-context-menu\",\n        INLINE_EDITOR_MENU: \"inline-editor-context-menu\",\n        PROJECT_MENU: \"project-context-menu\",\n        WORKING_SET_CONTEXT_MENU: \"workingset-context-menu\",\n        WORKING_SET_CONFIG_MENU: \"workingset-configuration-menu\",\n        SPLITVIEW_MENU: \"splitview-menu\"\n    };\n\n    /**\n     * Brackets well known submenus\n     * @enum {string}\n     */\n    let SubMenuIds = {\n        GIT_SUB_MENU: \"git-submenu\"\n    };\n\n    /**\n     * Event triggered before the context menu opens.\n     * @event EVENT_BEFORE_CONTEXT_MENU_OPEN\n     */\n    const EVENT_BEFORE_CONTEXT_MENU_OPEN = \"beforeContextMenuOpen\";\n\n    /**\n     * Event triggered before the context menu closes.\n     * @event EVENT_BEFORE_CONTEXT_MENU_CLOSE\n     */\n    const EVENT_BEFORE_CONTEXT_MENU_CLOSE = \"beforeContextMenuClose\";\n\n    /**\n     * Event triggered before a sub-menu opens.\n     * @event EVENT_BEFORE_SUB_MENU_OPEN\n     */\n    const EVENT_BEFORE_SUB_MENU_OPEN = \"beforeSubMenuOpen\";\n\n    /**\n     * Event triggered before a sub-menu closes.\n     * @event EVENT_BEFORE_SUB_MENU_CLOSE\n     */\n    const EVENT_BEFORE_SUB_MENU_CLOSE = \"beforeSubMenuClose\";\n\n    /**\n     * Event triggered when a menu or menu is added\n     * @event EVENT_MENU_ADDED\n     */\n    const EVENT_MENU_ADDED = \"menuAdded\";\n\n    /**\n     * Event triggered when a menu or submenu is added\n     * @event EVENT_SUB_MENU_ADDED\n     */\n    const EVENT_SUB_MENU_ADDED = \"subMenuAdded\";\n\n    /**\n     * Event triggered when a menu item is added\n     * @event EVENT_MENU_ITEM_ADDED\n     */\n    const EVENT_MENU_ITEM_ADDED = \"menuItemAdded\";\n\n\n\n    // Define each section as a separate constant\n    const FILE_OPEN_CLOSE_COMMANDS = { sectionMarker: Commands.FILE_NEW };\n    const FILE_SAVE_COMMANDS = { sectionMarker: Commands.FILE_SAVE };\n    const FILE_LIVE = { sectionMarker: Commands.FILE_LIVE_FILE_PREVIEW };\n    const FILE_SETTINGS = { sectionMarker: Commands.FILE_EXTENSION_MANAGER };\n    const FILE_EXTENSION_MANAGER = { sectionMarker: Commands.FILE_EXTENSION_MANAGER }; // Deprecated\n\n    const EDIT_UNDO_REDO_COMMANDS = { sectionMarker: Commands.EDIT_UNDO };\n    const EDIT_TEXT_COMMANDS = { sectionMarker: Commands.EDIT_CUT };\n    const EDIT_SELECTION_COMMANDS = { sectionMarker: Commands.EDIT_SELECT_ALL };\n    const EDIT_MODIFY_SELECTION = { sectionMarker: Commands.EDIT_INDENT };\n    const EDIT_COMMENT_SELECTION = { sectionMarker: Commands.EDIT_LINE_COMMENT };\n    const EDIT_CODE_HINTS_COMMANDS = { sectionMarker: Commands.SHOW_CODE_HINTS };\n    const EDIT_TOGGLE_OPTIONS = { sectionMarker: Commands.TOGGLE_CLOSE_BRACKETS };\n\n    const FIND_FIND_COMMANDS = { sectionMarker: Commands.CMD_FIND };\n    const FIND_FIND_IN_COMMANDS = { sectionMarker: Commands.CMD_FIND_IN_FILES };\n    const FIND_REPLACE_COMMANDS = { sectionMarker: Commands.CMD_REPLACE };\n\n    const VIEW_HIDESHOW_COMMANDS = { sectionMarker: Commands.VIEW_HIDE_SIDEBAR };\n    const VIEW_FONTSIZE_COMMANDS = { sectionMarker: Commands.VIEW_ZOOM_SUBMENU };\n    const VIEW_TOGGLE_OPTIONS = { sectionMarker: Commands.TOGGLE_ACTIVE_LINE };\n\n    const NAVIGATE_GOTO_COMMANDS = { sectionMarker: Commands.NAVIGATE_QUICK_OPEN };\n    const NAVIGATE_DOCUMENTS_COMMANDS = { sectionMarker: Commands.NAVIGATE_NEXT_DOC };\n    const NAVIGATE_OS_COMMANDS = { sectionMarker: Commands.NAVIGATE_SHOW_IN_FILE_TREE };\n    const NAVIGATE_QUICK_EDIT_COMMANDS = { sectionMarker: Commands.TOGGLE_QUICK_EDIT };\n    const NAVIGATE_QUICK_DOCS_COMMANDS = { sectionMarker: Commands.TOGGLE_QUICK_DOCS };\n\n\n\n    /**\n     * Brackets Application Menu Section Constants\n     * It is preferred that plug-ins specify the location of new MenuItems\n     * in terms of a menu section rather than a specific MenuItem. This provides\n     * looser coupling to Bracket's internal MenuItems and makes menu organization\n     * more semantic.\n     * Use these constants as the \"relativeID\" parameter when calling addMenuItem() and\n     * specify a position of FIRST_IN_SECTION or LAST_IN_SECTION.\n     *\n     * Menu sections are denoted by dividers or the beginning/end of a menu\n     *\n     * @enum {string}\n     */\n    const MenuSection = {\n        FILE_OPEN_CLOSE_COMMANDS,\n        FILE_SAVE_COMMANDS,\n        FILE_LIVE,\n        FILE_SETTINGS,\n        FILE_EXTENSION_MANAGER, // Deprecated\n\n        EDIT_UNDO_REDO_COMMANDS,\n        EDIT_TEXT_COMMANDS,\n        EDIT_SELECTION_COMMANDS,\n        EDIT_MODIFY_SELECTION,\n        EDIT_COMMENT_SELECTION,\n        EDIT_CODE_HINTS_COMMANDS,\n        EDIT_TOGGLE_OPTIONS,\n\n        FIND_FIND_COMMANDS,\n        FIND_FIND_IN_COMMANDS,\n        FIND_REPLACE_COMMANDS,\n\n        VIEW_HIDESHOW_COMMANDS,\n        VIEW_FONTSIZE_COMMANDS,\n        VIEW_TOGGLE_OPTIONS,\n\n        NAVIGATE_GOTO_COMMANDS,\n        NAVIGATE_DOCUMENTS_COMMANDS,\n        NAVIGATE_OS_COMMANDS,\n        NAVIGATE_QUICK_EDIT_COMMANDS,\n        NAVIGATE_QUICK_DOCS_COMMANDS\n    };\n\n\n    /**\n     * Insertion position constants\n     * Used by addMenu(), addMenuItem(), and addSubMenu() to\n     * specify the relative position of a newly created menu object\n     * @enum {string}\n     */\n    const BEFORE = \"before\",\n        AFTER = \"after\",\n        FIRST = \"first\",\n        LAST = \"last\",\n        FIRST_IN_SECTION = \"firstInSection\",\n        LAST_IN_SECTION = \"lastInSection\";\n\n    /**\n     * Other constants\n     */\n    let DIVIDER = \"---\";\n    let SUBMENU = \"SUBMENU\";\n\n    /**\n     * Maps menuID's to Menu objects\n     * @type {Object} menuMap\n     * @property {Object.<string, Menu>} menuID - A map of Menu IDs to Menu objects.\n     * @private\n     */\n    let menuMap = {};\n\n    /**\n     * Maps contextMenuID's to ContextMenu objects\n     * @type {Object} contextMenuMap\n     * @property {Object.<string, ContextMenu>} contextMenuID - A map of ContextMenu IDs to ContextMenu objects.\n     * @private\n     */\n    let contextMenuMap = {};\n\n    /**\n     * Maps menuItemID's to MenuItem object\n     * @type {Object} menuItemMap\n     * @property {Object.<string, MenuItem>} menuItemID - A map of MenuItem IDs to MenuItem objects.\n     * @private\n     */\n    let menuItemMap = {};\n\n    /**\n     * Maps menuItemID's to ContextMenu objects\n     * @type {Object} subMenuItemMap\n     * @property {Object.<string, ContextMenu>} menuItemId - A map of MenuItem IDs to ContextMenu objects.\n     * @private\n     */\n    let subMenuItemMap = {};\n\n    /**\n     * Retrieves the Menu object for the corresponding id.\n     * @param {string} id\n     * @return {Menu}\n     */\n    function getMenu(id) {\n        return menuMap[id];\n    }\n\n    /**\n     * Retrieves the subMenu object for the corresponding id if present.\n     * @param {string} id\n     * @return {Menu}\n     */\n    function getSubMenu(id) {\n        return getContextMenu(id);\n    }\n\n    /**\n     * retruns a set containing all commands that has a menu item registered\n     * @returns {Set<string>}\n     */\n    function getAllMenuItemCommands() {\n        return new Set(allMenuCommands);\n    }\n\n    /**\n     * Retrieves the map of all Menu objects.\n     * @return {Object.<string, Menu>}\n     */\n    function getAllMenus() {\n        return menuMap;\n    }\n\n    /**\n     * Retrieves the ContextMenu object for the corresponding id.\n     * @param {string} id\n     * @return {ContextMenu}\n     */\n    function getContextMenu(id) {\n        return contextMenuMap[id];\n    }\n\n    /**\n    * Removes the attached event listeners from the corresponding object.\n    * @param {MenuItem} menuItem\n    * @private\n    */\n    function removeMenuItemEventListeners(menuItem) {\n        menuItem._command\n            .off(\"enabledStateChange\", menuItem._enabledChanged)\n            .off(\"checkedStateChange\", menuItem._checkedChanged)\n            .off(\"nameChange\", menuItem._nameChanged)\n            .off(\"keyBindingAdded\", menuItem._keyBindingAdded)\n            .off(\"keyBindingRemoved\", menuItem._keyBindingRemoved);\n    }\n\n    /**\n     * Retrieves the MenuItem object for the corresponding id.\n     * @param {string} id\n     * @return {MenuItem}\n     */\n    function getMenuItem(id) {\n        return menuItemMap[id];\n    }\n\n    function _getHTMLMenu(id) {\n        return $(\"#\" + StringUtils.jQueryIdEscape(id)).get(0);\n    }\n\n    function _getHTMLMenuItem(id) {\n        return $(\"#\" + StringUtils.jQueryIdEscape(id)).get(0);\n    }\n\n    function _addKeyBindingToMenuItem(commandID, $menuItem, key, displayKey) {\n        let $shortcut = $menuItem.find(\".menu-shortcut\");\n\n        if ($shortcut.length === 0) {\n            const html = KeyBindingManager.canAssignBinding(commandID) ?\n                \"<span class='menu-shortcut' />\" :\n                \"<span class='menu-shortcut fixed-shortcut' />\";\n            $shortcut = $(html);\n            $menuItem.append($shortcut);\n        }\n\n        $shortcut.data(\"key\", key);\n        $shortcut.text(KeyBindingManager.formatKeyDescriptor(displayKey));\n    }\n\n    function _addExistingKeyBinding(menuItem) {\n        const commandID = menuItem.getCommand().getID();\n        let bindings = KeyBindingManager.getKeyBindings(commandID),\n            binding = null;\n\n        if (bindings.length > 0) {\n            // add the latest key binding\n            binding = bindings[bindings.length - 1];\n            _addKeyBindingToMenuItem(commandID, $(_getHTMLMenuItem(menuItem.id)), binding.key, binding.displayKey);\n        }\n\n        return binding;\n    }\n\n    let _menuDividerIDCount = 1;\n    function _getNextMenuItemDividerID() {\n        return \"brackets-menuDivider-\" + _menuDividerIDCount++;\n    }\n\n    // Help function for inserting elements into a list\n    function _insertInList($list, $element, position, $relativeElement) {\n        // Determine where to insert. Default is LAST.\n        let inserted = false;\n        if (position) {\n\n            // Adjust relative position for menu section positions since $relativeElement\n            // has already been resolved by _getRelativeMenuItem() to a menuItem\n            if (position === FIRST_IN_SECTION) {\n                position = BEFORE;\n            } else if (position === LAST_IN_SECTION) {\n                position = AFTER;\n            }\n\n            if (position === FIRST) {\n                $list.prepend($element);\n                inserted = true;\n            } else if ($relativeElement && $relativeElement.length > 0) {\n                if (position === AFTER) {\n                    $relativeElement.after($element);\n                    inserted = true;\n                } else if (position === BEFORE) {\n                    $relativeElement.before($element);\n                    inserted = true;\n                }\n            }\n        }\n\n        // Default to LAST\n        if (!inserted) {\n            $list.append($element);\n        }\n    }\n\n    /**\n     * MenuItem represents a single menu item that executes a Command or a menu divider. MenuItems\n     * may have a sub-menu. A MenuItem may correspond to an HTML-based\n     * menu item or a native menu item if Brackets is running in a native application shell\n     *\n     * Since MenuItems may have a native implementation clients should create MenuItems through\n     * addMenuItem() and should NOT construct a MenuItem object directly.\n     * Clients should also not access HTML content of a menu directly and instead use\n     * the MenuItem API to query and modify menus items.\n     *\n     * MenuItems are views on to Command objects so modify the underlying Command to modify the\n     * name, enabled, and checked state of a MenuItem. The MenuItem will update automatically\n     *\n     * @constructor\n     *\n     * @param {string} id\n     * @param {string|Command} command - the Command this MenuItem will reflect.\n     *                                   Use DIVIDER to specify a menu divider\n     * @param [options]\n     * @param {boolean} options.hideWhenCommandDisabled will not show the menu item if command is disabled.\n     */\n    function MenuItem(id, command, options = {}) {\n        this.id = id;\n        this.isDivider = (command === DIVIDER);\n        this.isNative = false;\n\n        if (!this.isDivider && command !== SUBMENU) {\n            // Bind event handlers\n            this._enabledChanged = this._enabledChanged.bind(this);\n            this._checkedChanged = this._checkedChanged.bind(this);\n            this._nameChanged = this._nameChanged.bind(this);\n            this._keyBindingAdded = this._keyBindingAdded.bind(this);\n            this._keyBindingRemoved = this._keyBindingRemoved.bind(this);\n\n            this._command = command;\n            this._hideWhenCommandDisabled = options.hideWhenCommandDisabled;\n            this._command\n                .on(\"enabledStateChange\", this._enabledChanged)\n                .on(\"checkedStateChange\", this._checkedChanged)\n                .on(\"nameChange\", this._nameChanged)\n                .on(\"keyBindingAdded\", this._keyBindingAdded)\n                .on(\"keyBindingRemoved\", this._keyBindingRemoved);\n        }\n    }\n\n    /**\n     * Menu represents a top-level menu in the menu bar. A Menu may correspond to an HTML-based\n     * menu or a native menu if Brackets is running in a native application shell.\n     *\n     * Since menus may have a native implementation clients should create Menus through\n     * addMenu() and should NOT construct a Menu object directly.\n     * Clients should also not access HTML content of a menu directly and instead use\n     * the Menu API to query and modify menus.\n     *\n     * @constructor\n     *\n     * @param {string} id\n     */\n    function Menu(id) {\n        this.id = id;\n    }\n\n    Menu.prototype._getMenuItemId = function (commandId) {\n        return (this.id + \"-\" + commandId);\n    };\n\n    /**\n     * Determine MenuItem in this Menu, that has the specified command\n     *\n     * @param {Command} command - the command to search for.\n     * @private\n     * @return {?HTMLLIElement} menu item list element\n     */\n    Menu.prototype._getMenuItemForCommand = function (command) {\n        if (!command) {\n            return null;\n        }\n        let foundMenuItem = menuItemMap[this._getMenuItemId(command.getID())];\n        if (!foundMenuItem) {\n            return null;\n        }\n        return $(_getHTMLMenuItem(foundMenuItem.id)).closest(\"li\");\n    };\n\n    /**\n     * Determine relative MenuItem\n     *\n     * @param {?string} relativeID - id of command (future: sub-menu).\n     * @param {?string} position - only needed when relativeID is a MenuSection\n     * @return {?HTMLLIElement} menu item list element\n     * @private\n     */\n    Menu.prototype._getRelativeMenuItem = function (relativeID, position) {\n        let $relativeElement;\n\n        if (relativeID) {\n            if (position === FIRST_IN_SECTION || position === LAST_IN_SECTION) {\n                if (!relativeID.hasOwnProperty(\"sectionMarker\")) {\n                    console.error(\"Bad Parameter in _getRelativeMenuItem(): relativeID must be a MenuSection when position refers to a menu section\");\n                    return null;\n                }\n\n                // Determine the $relativeElement by traversing the sibling list and\n                // stop at the first divider found\n                // TODO: simplify using nextUntil()/prevUntil()\n                let $sectionMarker = this._getMenuItemForCommand(CommandManager.get(relativeID.sectionMarker));\n                if (!$sectionMarker) {\n                    console.error(\"_getRelativeMenuItem(): MenuSection \" + relativeID.sectionMarker +\n                        \" not found in Menu \" + this.id);\n                    return null;\n                }\n                let $listElem = $sectionMarker;\n                $relativeElement = $listElem;\n                while (true) {\n                    $listElem = (position === FIRST_IN_SECTION ? $listElem.prev() : $listElem.next());\n                    if ($listElem.length === 0) {\n                        break;\n                    } else if ($listElem.find(\".divider\").length > 0) {\n                        break;\n                    } else {\n                        $relativeElement = $listElem;\n                    }\n                }\n\n            } else {\n                if (relativeID.hasOwnProperty(\"sectionMarker\")) {\n                    console.error(\"Bad Parameter in _getRelativeMenuItem(): if relativeID is a MenuSection, position must be FIRST_IN_SECTION or LAST_IN_SECTION\");\n                    return null;\n                }\n\n                // handle FIRST, LAST, BEFORE, & AFTER\n                let command = CommandManager.get(relativeID);\n                if (command) {\n                    // Lookup Command for this Command id\n                    // Find MenuItem that has this command\n                    $relativeElement = this._getMenuItemForCommand(command);\n                }\n                if (!$relativeElement) {\n                    console.error(\"_getRelativeMenuItem(): MenuItem with Command id \" + relativeID +\n                        \" not found in Menu \" + this.id);\n                    return null;\n                }\n            }\n\n            return $relativeElement;\n\n        } else if (position && position !== FIRST && position !== LAST) {\n            console.error(\"Bad Parameter in _getRelativeMenuItem(): relative position specified with no relativeID\");\n            return null;\n        }\n\n        return $relativeElement;\n    };\n\n    /**\n     * Removes the specified menu item from this Menu. Key bindings are unaffected; use KeyBindingManager\n     * directly to remove key bindings if desired.\n     *\n     * @param {!string | Command} command - command the menu would execute if we weren't deleting it.\n     */\n    Menu.prototype.removeMenuItem = function (command) {\n        let menuItemID,\n            commandID;\n\n        if (!command) {\n            console.error(\"removeMenuItem(): missing required parameters: command\");\n            return;\n        }\n\n        if (typeof (command) === \"string\") {\n            let commandObj = CommandManager.get(command);\n            if (!commandObj) {\n                console.error(\"removeMenuItem(): command not found: \" + command);\n                return;\n            }\n            commandID = command;\n        } else {\n            commandID = command.getID();\n        }\n        menuItemID = this._getMenuItemId(commandID);\n\n        let menuItem = getMenuItem(menuItemID);\n        removeMenuItemEventListeners(menuItem);\n\n        $(_getHTMLMenuItem(menuItemID)).parent().remove();\n\n        delete menuItemMap[menuItemID];\n    };\n\n    /**\n     * Removes the specified menu divider from this Menu.\n     *\n     * @param {!string} menuItemID - the menu item id of the divider to remove.\n     */\n    Menu.prototype.removeMenuDivider = function (menuItemID) {\n        let menuItem,\n            $HTMLMenuItem;\n\n        if (!menuItemID) {\n            console.error(\"removeMenuDivider(): missing required parameters: menuItemID\");\n            return;\n        }\n\n        menuItem = getMenuItem(menuItemID);\n\n        if (!menuItem) {\n            console.error(\"removeMenuDivider(): parameter menuItemID: %s is not a valid menu item id\", menuItemID);\n            return;\n        }\n\n        if (!menuItem.isDivider) {\n            console.error(\"removeMenuDivider(): parameter menuItemID: %s is not a menu divider\", menuItemID);\n            return;\n        }\n\n        // Targeting parent to get the menu divider <hr> and the <li> that contains it\n        $HTMLMenuItem = $(_getHTMLMenuItem(menuItemID)).parent();\n        if ($HTMLMenuItem) {\n            $HTMLMenuItem.remove();\n        } else {\n            console.error(\"removeMenuDivider(): HTML menu divider not found: %s\", menuItemID);\n            return;\n        }\n\n        if (!menuItemMap[menuItemID]) {\n            console.error(\"removeMenuDivider(): menu divider not found in menuItemMap: %s\", menuItemID);\n            return;\n        }\n\n        delete menuItemMap[menuItemID];\n    };\n\n    /**\n     * Adds a new menu item with the specified id and display text. The insertion position is\n     * specified via the relativeID and position arguments which describe a position\n     * relative to another MenuItem or MenuGroup. It is preferred that plug-ins\n     * insert new  MenuItems relative to a menu section rather than a specific\n     * MenuItem (see Menu Section Constants).\n     *\n     * TODO: Sub-menus are not yet supported, but when they are implemented this API will\n     * allow adding new MenuItems to sub-menus as well.\n     *\n     * Note, keyBindings are bound to Command objects not MenuItems. The provided keyBindings\n     *      will be bound to the supplied Command object rather than the MenuItem.\n     *\n     * @param {!string | Command} command - the command the menu will execute.\n     *      Pass Menus.DIVIDER for a menu divider, or just call addMenuDivider() instead.\n     * @param {?(string | {key: string, platform: string[]})} [keyBindings] - Register one or more key bindings to associate with the supplied command\n     * @param {?string} [position] - constant defining the position of new MenuItem relative to\n     *      other MenuItems. Values:\n     *          - With no relativeID, use Menus.FIRST or LAST (default is LAST)\n     *          - Relative to a command id, use BEFORE or AFTER (required)\n     *          - Relative to a MenuSection, use FIRST_IN_SECTION or LAST_IN_SECTION (required)\n     * @param {?string} [relativeID] - command id OR one of the MenuSection.* constants. Required\n     *      for all position constants except FIRST and LAST.\n     * @param [options]\n     * @param {boolean} options.hideWhenCommandDisabled will not show the menu item if command is disabled. Helps to\n     *   clear the clutter on greyed out menu items if not applicable to context.\n     *\n     * @return {MenuItem} the newly created MenuItem\n     */\n    Menu.prototype.addMenuItem = function (command, keyBindings, position, relativeID, options = {}) {\n        const self = this;\n        let id,\n            $menuItem,\n            menuItem,\n            name,\n            commandID;\n\n        if (!command) {\n            console.error(\"addMenuItem(): missing required parameters: command\");\n            return null;\n        }\n\n        if (typeof (command) === \"string\") {\n            if (command === DIVIDER) {\n                name = DIVIDER;\n                commandID = _getNextMenuItemDividerID();\n            } else {\n                commandID = command;\n                command = CommandManager.get(commandID);\n                if (!command) {\n                    console.error(\"addMenuItem(): commandID not found: \" + commandID);\n                    return null;\n                }\n                name = command.getName();\n                if (!allMenuCommands.has(commandID)) {\n                    allMenuCommands.add(commandID);\n                }\n            }\n        } else {\n            commandID = command.getID();\n            name = command.getName();\n            if (!allMenuCommands.has(commandID)) {\n                allMenuCommands.add(commandID);\n            }\n        }\n\n        // Internal id is the a composite of the parent menu id and the command id.\n        id = self._getMenuItemId(commandID);\n\n        if (menuItemMap[id]) {\n            console.log(\"MenuItem added with same id of existing MenuItem: \" + id);\n            return null;\n        }\n\n        // create MenuItem\n        menuItem = new MenuItem(id, command, {\n            hideWhenCommandDisabled: options.hideWhenCommandDisabled\n        });\n        menuItemMap[id] = menuItem;\n\n\n        if (name === DIVIDER) {\n            $menuItem = $(\"<li><hr class='divider' id='\" + id + \"' /></li>\");\n        } else {\n            // Create the HTML Menu\n            let keyboardIcon = '';\n            if (KeyBindingManager.canAssignBinding(commandID)) {\n                keyboardIcon = `<span class='keyboard-icon' title='${Strings.KEYBOARD_SHORTCUT_CHANGE_TITLE}'><i class=\"fa-regular fa-keyboard\"></i></span>`;\n            }\n            $menuItem = $(\"<li><a href='#' class='menuAnchor' id='\" + id + \"'> <span class='menu-name'></span>\" +\n                `<span class='right-pusher'></span>${keyboardIcon}` +\n                \"</a></li>\");\n            const $menuAnchor = $menuItem.find(\".menuAnchor\");\n\n            $menuItem.find(\".keyboard-icon\").on(\"click\", (event) => {\n                KeyBindingManager.showShortcutSelectionDialog(command);\n                event.preventDefault();\n                event.stopPropagation();\n            });\n\n            $menuItem.on(\"click\", function (event) {\n                if ($menuAnchor.hasClass('disabled')) {\n                    event.preventDefault();\n                    event.stopPropagation();\n                    return true;\n                }\n                Metrics.countEvent(Metrics.EVENT_TYPE.UI_MENU, \"click\", menuItem._command.getID());\n                logger.leaveTrail(\"UI Menu Click: \" + menuItem._command.getID());\n                MainViewManager.focusActivePane();\n                const commandId = menuItem._command.getID();\n\n                // NOTE: we handle save commands differently because we want save commands to go through the\n                // CommandManager.execute() to trigger beforeExecuteCommand events consistently, whether invoked via\n                // menu click or keyboard shortcut.\n                // because there are listeners that uses beforeExecuteCommand to listen to save commands\n                // (for ex: tabbar listens to save commands to add placeholder tabs to working set)\n                // Other commands use direct execution to preserve file tree context\n                if(commandId === Commands.FILE_SAVE ||\n                   commandId === Commands.FILE_SAVE_AS ||\n                   commandId === Commands.FILE_SAVE_ALL) {\n                    CommandManager.execute(commandId);\n                } else if (menuItem._command._options.eventSource) {\n                    menuItem._command.execute({\n                        eventSource: CommandManager.SOURCE_UI_MENU_CLICK,\n                        sourceType: self.id\n                    });\n                } else {\n                    menuItem._command.execute();\n                }\n            });\n\n            let self = this;\n            $menuItem.on(\"mouseenter\", function () {\n                // This is to prevent size jumps when the keyboard\n                // icon hides and shows as selection changes\n                $menuAnchor.addClass(\"use-invisible-for-width-compute\");\n                const currentWidth = $(this).width(); // Get the current width\n                $menuAnchor.removeClass(\"use-invisible-for-width-compute\");\n                $(this).css('min-width', currentWidth + 'px');\n                self.closeSubMenu();\n                // now show selection\n                $menuItem.parent().find(\".menuAnchor\").removeClass(\"selected\");\n                if (!$menuAnchor.hasClass('disabled')) {\n                    $menuAnchor.addClass(\"selected\");\n                }\n            });\n            $menuItem.on(\"mouseleave\", function () {\n                $(this).css('min-width', '');\n                self.closeSubMenu();\n                $menuItem.find(\".menuAnchor\").removeClass(\"selected\");\n            });\n        }\n\n        // Insert menu item\n        let $relativeElement = this._getRelativeMenuItem(relativeID, position);\n        _insertInList($(\"li#\" + StringUtils.jQueryIdEscape(this.id) + \" > ul.dropdown-menu\"),\n            $menuItem, position, $relativeElement);\n\n\n        // Initialize MenuItem state\n        if (menuItem.isDivider) {\n            menuItem.dividerId = commandID;\n        } else {\n            if (keyBindings) {\n                // Add key bindings. The MenuItem listens to the Command object to update MenuItem DOM with shortcuts.\n                if (!Array.isArray(keyBindings)) {\n                    keyBindings = [keyBindings];\n                }\n            }\n\n            // Note that keyBindings passed during MenuItem creation take precedent over any existing key bindings\n            KeyBindingManager.addBinding(commandID, keyBindings);\n\n            // Look for existing key bindings\n            _addExistingKeyBinding(menuItem);\n\n            menuItem._checkedChanged();\n            menuItem._enabledChanged();\n            menuItem._nameChanged();\n        }\n\n        const menuId = self.id;\n        exports.trigger(EVENT_MENU_ITEM_ADDED, menuId, commandID, menuItem);\n\n        return menuItem;\n    };\n\n    /**\n     * Inserts divider item in menu.\n     * @param {?string} position - constant defining the position of new the divider relative\n     *      to other MenuItems. Default is LAST.  (see Insertion position constants).\n     * @param {?string} relativeID - id of menuItem, sub-menu, or menu section that the new\n     *      divider will be positioned relative to. Required for all position constants\n     *      except FIRST and LAST\n     *\n     * @return {MenuItem} the newly created divider\n     */\n    Menu.prototype.addMenuDivider = function (position, relativeID) {\n        return this.addMenuItem(DIVIDER, \"\", position, relativeID);\n    };\n\n    /**\n     * NOT IMPLEMENTED\n     *\n     * All properties are required unless noted as optional.\n     *\n     * @param {Array<{id: string, command: string | Command, bindings: string | Array<{key: string, platform: string}> | undefined}>} jsonStr\n     * @param {?string} position - constant defining the position of the new MenuItem relative\n     *      to other MenuItems. Default is LAST.  (see Insertion position constants).\n     * @param {?string} relativeID - id of menuItem, sub-menu, or menu section that the new\n     *      menuItem will be positioned relative to. Required when position is\n     *      AFTER or BEFORE, ignored when position is FIRST or LAST.\n     *\n     * @return {MenuItem} the newly created MenuItem\n     * @private\n     */\n    // Menu.prototype.createMenuItemsFromJSON = function (jsonStr, position, relativeID) {\n    //     NOT IMPLEMENTED\n    // };\n\n\n\n    /**\n     * NOT IMPLEMENTED\n     * @param {!string} text displayed in menu item\n     * @param {!string} id\n     * @param {?string} position - constant defining the position of new the MenuItem relative\n     *      to other MenuItems. Default is LAST.  (see Insertion position constants)\n     * @param {?string} relativeID - id of menuItem, sub-menu, or menu section that the new\n     *      menuItem will be positioned relative to. Required when position is\n     *      AFTER or BEFORE, ignored when position is FIRST or LAST.\n     *\n     * @return {MenuItem} newly created menuItem for sub-menu\n     * @private\n     */\n    // MenuItem.prototype.createSubMenu = function (text, id, position, relativeID) {\n    //     NOT IMPLEMENTED\n    // };\n\n    /**\n     *\n     * Creates a new submenu and a menuItem and adds the menuItem of the submenu\n     * to the menu and returns the submenu.\n     *\n     * A submenu will have the same structure of a menu with a additional field\n     * parentMenuItem which has the reference of the submenu's parent menuItem.\n\n     * A submenu will raise the following events:\n     * - beforeSubMenuOpen\n     * - beforeSubMenuClose\n     *\n     * Note, This function will create only a context submenu.\n     *\n     * TODO: Make this function work for Menus\n     *\n     *\n     * @param {!string} name displayed in menu item of the submenu\n     * @param {!string} id\n     * @param {?string} position - constant defining the position of new MenuItem of the submenu relative to\n     *      other MenuItems. Values:\n     *          - With no relativeID, use Menus.FIRST or LAST (default is LAST)\n     *          - Relative to a command id, use BEFORE or AFTER (required)\n     *          - Relative to a MenuSection, use FIRST_IN_SECTION or LAST_IN_SECTION (required)\n     * @param {?string} relativeID - command id OR one of the MenuSection.* constants. Required\n     *      for all position constants except FIRST and LAST.\n     *\n     * @return {Menu} the newly created submenu\n     */\n    Menu.prototype.addSubMenu = function (name, id, position, relativeID) {\n\n        if (!name || !id) {\n            console.error(\"addSubMenu(): missing required parameters: name and id\");\n            return null;\n        }\n\n        // Guard against duplicate context menu ids\n        if (contextMenuMap[id]) {\n            console.log(\"Context menu added with id of existing Context Menu: \" + id);\n            return null;\n        }\n\n        let menu = new ContextMenu(id);\n        contextMenuMap[id] = menu;\n\n        let menuItemID = this.id + \"-\" + id;\n\n        if (menuItemMap[menuItemID]) {\n            console.log(\"MenuItem added with same id of existing MenuItem: \" + id);\n            return null;\n        }\n\n        // create MenuItem\n        let menuItem = new MenuItem(menuItemID, SUBMENU);\n        menuItemMap[menuItemID] = menuItem;\n        subMenuItemMap[menuItemID] = menu;\n\n        menu.parentMenuItem = menuItem;\n\n        // create MenuItem DOM\n        // Create the HTML MenuItem\n        let $menuItem = $(\"<li><a class='sub-menu-item menuAnchor' href='#' id='\" + menuItemID + \"'> \" +\n            \"<span class='menu-name'>\" + name + \"</span>\" +\n            \"<span class='right-pusher'></span>\" +\n            \"<span>&rtrif;</span>\" +\n            \"</a></li>\");\n        const $menuAnchor = $menuItem.find(\".menuAnchor\");\n\n        let self = this;\n        $menuItem.on(\"mouseenter\", function (e) {\n            $menuAnchor.addClass(\"use-invisible-for-width-compute\");\n            const currentWidth = $(this).width(); // Get the current width\n            $menuAnchor.removeClass(\"use-invisible-for-width-compute\");\n            $(this).css('min-width', currentWidth + 'px'); // Set min-width to the current width\n            if (self.openSubMenu && self.openSubMenu.id === menu.id) {\n                return;\n            }\n            self.closeSubMenu();\n            self.openSubMenu = menu;\n            menu.open();\n            $menuItem.parent().find(\".menuAnchor\").removeClass(\"selected\");\n            $menuItem.find(\".menuAnchor\").addClass(\"selected\");\n        });\n\n        $menuItem.on(\"mouseleave\", function () {\n            $(this).css('min-width', '');\n            $menuItem.find(\".menuAnchor\").removeClass(\"selected\");\n        });\n\n        // Insert menu item\n        let $relativeElement = this._getRelativeMenuItem(relativeID, position);\n        _insertInList($(\"li#\" + StringUtils.jQueryIdEscape(this.id) + \" > ul.dropdown-menu\"),\n            $menuItem, position, $relativeElement);\n\n        exports.trigger(EVENT_SUB_MENU_ADDED, id, menu);\n\n        return menu;\n    };\n\n\n    /**\n     * Removes the specified submenu from this Menu.\n     *\n     * Note, this function will only remove context submenus\n     *\n     * TODO: Make this function work for Menus\n     *\n     * @param {!string} subMenuID - the menu id of the submenu to remove.\n     */\n    Menu.prototype.removeSubMenu = function (subMenuID) {\n        let subMenu,\n            parentMenuItem,\n            commandID = \"\";\n\n        if (!subMenuID) {\n            console.error(\"removeSubMenu(): missing required parameters: subMenuID\");\n            return;\n        }\n\n        subMenu = getContextMenu(subMenuID);\n\n        if (!subMenu || !subMenu.parentMenuItem) {\n            console.error(\"removeSubMenu(): parameter subMenuID: %s is not a valid submenu id\", subMenuID);\n            return;\n        }\n\n        parentMenuItem = subMenu.parentMenuItem;\n\n\n        if (!menuItemMap[parentMenuItem.id]) {\n            console.error(\"removeSubMenu(): parent menuItem not found in menuItemMap: %s\", parentMenuItem.id);\n            return;\n        }\n\n        // Remove all of the menu items in the submenu\n        _.forEach(menuItemMap, function (value, key) {\n            if (_.startsWith(key, subMenuID)) {\n                if (value.isDivider) {\n                    subMenu.removeMenuDivider(key);\n                } else {\n                    commandID = value.getCommand();\n                    subMenu.removeMenuItem(commandID);\n                }\n            }\n        });\n\n        $(_getHTMLMenuItem(parentMenuItem.id)).parent().remove(); // remove the menu item\n        $(_getHTMLMenu(subMenuID)).remove(); // remove the menu\n\n\n        delete menuItemMap[parentMenuItem.id];\n        delete subMenuItemMap[parentMenuItem.id];\n        delete contextMenuMap[subMenuID];\n    };\n\n    /**\n     * Closes the submenu if the menu has a submenu open.\n     */\n    Menu.prototype.closeSubMenu = function () {\n        if (this.openSubMenu) {\n            this.openSubMenu.close();\n            this.openSubMenu = null;\n        }\n    };\n    /**\n     * Gets the Command associated with a MenuItem\n     * @return {Command}\n     */\n    MenuItem.prototype.getCommand = function () {\n        return this._command;\n    };\n\n    /**\n     * NOT IMPLEMENTED\n     * Returns the parent MenuItem if the menu item is a sub-menu, returns null otherwise.\n     * @return {MenuItem}\n     * @private\n     */\n    // MenuItem.prototype.getParentMenuItem = function () {\n    //     NOT IMPLEMENTED;\n    // };\n\n    /**\n     * Returns the parent Menu for this MenuItem\n     * @return {Menu}\n     */\n    MenuItem.prototype.getParentMenu = function () {\n        let parent = $(_getHTMLMenuItem(this.id)).parents(\".dropdown\").get(0);\n        if (!parent) {\n            return null;\n        }\n\n        return getMenu(parent.id);\n    };\n\n    /**\n     * Synchronizes MenuItem checked state with underlying Command checked state\n     * @private\n     */\n    MenuItem.prototype._checkedChanged = function () {\n        let checked = !!this._command.getChecked();\n        if (this.isNative) {\n            let enabled = !!this._command.getEnabled();\n            let command = this._command;\n            brackets.app.setMenuItemState(this._command.getID(), enabled, checked, function (err) {\n                if (err) {\n                    console.log(\"Error setting menu item checked state for \" + command + \": \" + err);\n                }\n            });\n        } else {\n            ViewUtils.toggleClass($(_getHTMLMenuItem(this.id)), \"checked\", checked);\n        }\n    };\n\n    /**\n     * Synchronizes MenuItem enabled state with underlying Command enabled state\n     * @private\n     */\n    MenuItem.prototype._enabledChanged = function () {\n        if (this.isNative) {\n            let enabled = !!this._command.getEnabled();\n            let checked = !!this._command.getChecked();\n            let command = this._command;\n            brackets.app.setMenuItemState(this._command.getID(), enabled, checked, function (err) {\n                if (err) {\n                    console.log(\"Error setting menu item enabled state for \" + command + \": \" + err);\n                }\n            });\n        } else {\n            ViewUtils.toggleClass($(_getHTMLMenuItem(this.id)), \"disabled\", !this._command.getEnabled());\n            if (this._hideWhenCommandDisabled) {\n                ViewUtils.toggleClass($(_getHTMLMenuItem(this.id)), \"forced-hidden\", !this._command.getEnabled());\n            }\n        }\n    };\n\n    /**\n     * Synchronizes MenuItem name with underlying Command name\n     * @private\n     */\n    MenuItem.prototype._nameChanged = function () {\n        if (this.isNative) {\n            let command = this._command;\n            brackets.app.setMenuTitle(this._command.getID(), this._command.getName(), function (err) {\n                if (err) {\n                    console.log(\"Error setting menu title for \" + command + \": \" + err);\n                }\n            });\n        } else {\n            const htmlName = this._command.getOptions().htmlName;\n            if(htmlName) {\n                $(_getHTMLMenuItem(this.id)).find(\".menu-name\").html(htmlName);\n                return;\n            }\n            $(_getHTMLMenuItem(this.id)).find(\".menu-name\").text(this._command.getName());\n        }\n    };\n\n    /**\n     * @private\n     * Updates MenuItem DOM with a keyboard shortcut label\n     */\n    MenuItem.prototype._keyBindingAdded = function (event, keyBinding) {\n        if (this.isNative) {\n            let shortcutKey = keyBinding.displayKey || keyBinding.key,\n                command = this._command;\n            brackets.app.setMenuItemShortcut(this._command.getID(), shortcutKey, KeyBindingManager.formatKeyDescriptor(shortcutKey), function (err) {\n                if (err) {\n                    console.error(\"Error setting menu item shortcut key \" + shortcutKey + \", \" + command + \" : \" + err);\n                }\n            });\n        } else {\n            _addKeyBindingToMenuItem(this._command.getID(), $(_getHTMLMenuItem(this.id)), keyBinding.key, keyBinding.displayKey);\n        }\n    };\n\n    /**\n     * @private\n     * Updates MenuItem DOM to remove keyboard shortcut label\n     */\n    MenuItem.prototype._keyBindingRemoved = function (event, keyBinding) {\n        if (this.isNative) {\n            let shortcutKey = keyBinding.displayKey || keyBinding.key,\n                command = this._command;\n            brackets.app.setMenuItemShortcut(this._command.getID(), \"\", \"\", function (err) {\n                if (err) {\n                    console.error(\"Error setting menu item shortcut: \" + err, shortcutKey, command);\n                }\n            });\n        } else {\n            let $shortcut = $(_getHTMLMenuItem(this.id)).find(\".menu-shortcut\");\n\n            if ($shortcut.length > 0 && $shortcut.data(\"key\") === keyBinding.key) {\n                // check for any other bindings\n                if (_addExistingKeyBinding(this) === null) {\n                    $shortcut.empty();\n                }\n            }\n        }\n    };\n\n    let lastOpenedMenuID = 'file-menu';\n    /**\n     * Closes all menus that are open\n     */\n    function closeAll() {\n        const $openDropdownMenuList = $(\"#titlebar .dropdown.open\");\n        if ($openDropdownMenuList.length) {\n            // this means the title bar has focus on close, and we have to focus editor in this case.\n            MainViewManager.focusActivePane();\n        }\n        if (getOpenMenu()) {\n            lastOpenedMenuID = getOpenMenu();\n        }\n        $(\".dropdown\").removeClass(\"open\");\n    }\n\n    function _closeAllSubMenus() {\n        for (let menu of Object.values(menuMap)) {\n            menu.closeSubMenu();\n        }\n    }\n\n    /**\n     * Opens a menu with the given id\n     * @param id\n     * @returns {null}\n     */\n    function openMenu(id) {\n        if (!id) {\n            id = lastOpenedMenuID;\n        }\n        if (!menuMap[id]) {\n            console.error(\"openMenu- no such menu: \" + id);\n            return null;\n        }\n        $(`#${getDropdownToggleMenuID(id)}`).click();\n    }\n\n    /**\n     * returns the currently open menu id if present or null\n     * @return {null|string}\n     */\n    function getOpenMenu() {\n        const $openDropdownMenuList = $(\"#titlebar .dropdown.open\");\n        if ($openDropdownMenuList.length !== 1) {\n            return null;\n        }\n        return $openDropdownMenuList[0].id;\n    }\n\n    function getDropdownToggleMenuID(id) {\n        return `${id}-dropdown-toggle`;\n    }\n\n    let assignedShortcutsMenus = {};\n    let altKeyReleased = true;\n    window.document.body.addEventListener(\n        \"keyup\",\n        (event) => {\n            if (event.key === KEY.ALT) {\n                altKeyReleased = true;\n            }\n        },\n        true\n    );\n    function _addAltMenuShortcut(menuName, id) {\n        if (brackets.platform === \"mac\") {\n            // Alt menu shortcuts are unavailable on macOS due to its UI conventions(Alt is reserved for AltGr\n            // international keyboard typing).\n            // On macOS, menus can be accessed by double-pressing the Command key instead.\n            return;\n        }\n        let shortCutKey = menuName[0].toUpperCase();\n        if (assignedShortcutsMenus[shortCutKey]) {\n            assignedShortcutsMenus[shortCutKey].push({ menuName, id });\n            // now the array may have second leter shortcut like Eg. for like letter i = [Find] sinse File is already\n            // registered with F. So when we try to insert a new menu item say `Inspect` which should ideally take\n            // precedence for the i key shortcut, we have to remove all second elemnts in array that doent start with\n            // the first letter shortcut.\n            const newShortcutList = [];\n            for (let menu of assignedShortcutsMenus[shortCutKey]) {\n                if (menu.menuName.toUpperCase().startsWith(shortCutKey)) {\n                    // remove all shortcuts that doesnt have the first letter as the shortcut\n                    newShortcutList.push(menu);\n                }\n            }\n            assignedShortcutsMenus[shortCutKey] = newShortcutList;\n            // the shortcut key is already registered, check if can use the second letter to register\n            // an alternate single letter shortcut\n            const secondLetterShortCutKey = menuName[1];\n            if (secondLetterShortCutKey && assignedShortcutsMenus[secondLetterShortCutKey]) {\n                // the second letter is taken too, we dont do anything in this case.\n                return;\n            }\n            shortCutKey = secondLetterShortCutKey;\n        }\n        assignedShortcutsMenus[shortCutKey] = [{ menuName, id }];\n        const menuShortcutCommandID = `AltMenu-${shortCutKey}`;\n        console.log(`Registering 'Alt-${shortCutKey}' menu shortcut handler..`);\n        CommandManager.register(`Menu Shortcut For ${shortCutKey}`, menuShortcutCommandID, function () {\n            const menusIdsForShortcut = assignedShortcutsMenus[shortCutKey].map(item => item.id);\n            if (altKeyReleased) {\n                // this happens if the user started a new session of pressing alt-followed by key to open menu.\n                // we have to open the first menu item in this case.\n                altKeyReleased = false;\n                openMenu(menusIdsForShortcut[0]);\n                return true;\n            }\n            // if we are here, then another manu is already open as user is trying switch between two menus with same\n            // shortcut. Eg. Alt-F -file menu is open, switch to find menu.\n            let currentIndex = menusIdsForShortcut.indexOf(lastOpenedMenuID);\n            let menuToOpen;\n            // Check if the current menu is the last in the array or if it's not found (-1)\n            if (currentIndex === -1 || currentIndex === menusIdsForShortcut.length - 1) {\n                // If so, circle back to the first menu\n                menuToOpen = menusIdsForShortcut[0];\n            } else {\n                // Otherwise, go to the next menu\n                menuToOpen = menusIdsForShortcut[currentIndex + 1];\n            }\n            openMenu(menuToOpen);\n            return true;\n        });\n        KeyBindingManager.addBinding(menuShortcutCommandID, `Alt-${shortCutKey}`, null, { isMenuShortcut: true });\n    }\n\n    /**\n     * Adds a top-level menu to the application menu bar which may be native or HTML-based.\n     *\n     * @param {!string} name - display text for menu\n     * @param {!string} id - unique identifier for a menu.\n     *      Core Menus in Brackets use a simple  title as an id, for example \"file-menu\".\n     *      Extensions should use the following format: \"author.myextension.mymenuname\".\n     * @param {?string} position - constant defining the position of new the Menu relative\n     *  to other Menus. Default is LAST (see Insertion position constants).\n     *\n     * @param {?string} relativeID - id of Menu the new Menu will be positioned relative to. Required\n     *      when position is AFTER or BEFORE, ignored when position is FIRST or LAST\n     *\n     * @return {?Menu} the newly created Menu\n     */\n    function addMenu(name, id, position, relativeID) {\n        name = _.escape(name);\n        let $menubar = $(\"#titlebar .nav\"),\n            menu;\n\n        if (!name || !id) {\n            console.error(\"call to addMenu() is missing required parameters\");\n            return null;\n        }\n\n        // Guard against duplicate menu ids\n        if (menuMap[id]) {\n            console.log(\"Menu added with same name and id of existing Menu: \" + id);\n            return null;\n        }\n\n        menu = new Menu(id);\n        menuMap[id] = menu;\n\n\n        let $toggle = $(`<a id=\"${getDropdownToggleMenuID(id)}\" href='#' class='dropdown-toggle' data-toggle='dropdown'>${name}</a>`),\n            $popUp = $(\"<ul class='dropdown-menu'></ul>\"),\n            $dropdown = $(\"<li class='dropdown' id='\" + id + \"'></li>\"),\n            $newMenu = $dropdown.append($toggle).append($popUp);\n\n        $toggle.on(\"mouseenter\", function () {\n            _closeAllSubMenus();\n            const $this = $(this); // Cache the jQuery object of the current element\n\n            // Check if '#titlebar' or any of its descendants has focus\n            if ($('#titlebar, #titlebar *').is(':focus')) {\n                // If '#titlebar' or a descendant has focus, add 'selected' class and focus the current element\n                $this.addClass('selected').focus();\n            } else {\n                // Otherwise, just add 'selected' class\n                $this.addClass('selected');\n            }\n        });\n\n        $toggle.on(\"mouseleave\", function () {\n            $(this).removeClass('selected');\n        });\n\n        // Insert menu\n        let $relativeElement = relativeID && $(_getHTMLMenu(relativeID));\n        _insertInList($menubar, $newMenu, position, $relativeElement);\n\n        // Install ESC key handling\n        PopUpManager.addPopUp($popUp, closeAll, false);\n\n        _addAltMenuShortcut(name, id);\n        exports.trigger(EVENT_MENU_ADDED, id, menu);\n\n        return menu;\n    }\n\n    function _switchMenus($menuDropdownToggle, event) {\n        // remove the class 'open' from its parent element\n        $menuDropdownToggle.parent().removeClass('open');\n        const menuID = $menuDropdownToggle.parent().get(0).id;\n        const mainMenu = menuMap[menuID];\n        const $dropdownToggles = $('#titlebar .dropdown-toggle');\n        let currentIndex = $dropdownToggles.index($menuDropdownToggle);\n        currentIndex = event.key === KEY.ARROW_LEFT ? currentIndex - 1 : currentIndex + 1;\n        let nextIndex = currentIndex;\n        if (nextIndex < 0) {\n            nextIndex = 0;\n        } else if (nextIndex >= $dropdownToggles.length) {\n            nextIndex = $dropdownToggles.length - 1;\n        }\n        const $nextDropdownToggle = $dropdownToggles.eq(nextIndex);\n        $nextDropdownToggle.parent().addClass('open');\n        $nextDropdownToggle.focus();\n        lastOpenedMenuID = $nextDropdownToggle.parent()[0].id;\n        mainMenu && mainMenu.closeSubMenu();\n    }\n\n    function _switchMenuItems($menuDropdownToggle, event) {\n        // change code such that if event.key is KEY.ARROW_UP or KEY.ARROW_DOWN, the selection will move formward or back\n        const menuID = $menuDropdownToggle.parent().get(0).id;\n        const $dropdownMenu = $menuDropdownToggle.parent().find(\".dropdown-menu\");\n        const $selected = $dropdownMenu.find('li a.selected');\n        const currentWidth = $dropdownMenu.width();\n        $dropdownMenu.css('min-width', currentWidth + 'px'); // This is to prevent size jumps when the keyboard\n        // icon hides and shows as selection changes\n        if ($selected.length === 0) {\n            // If no selected class exists, add it to the first <a> tag\n            $dropdownMenu.find('li a').first().addClass('selected');\n        } else {\n            // Remove the class from the current item\n            $selected.removeClass('selected');\n\n            // Determine the next or previous item based on the arrow key pressed\n            let $next;\n            if (event.key === KEY.ARROW_DOWN) {\n                let $nextLi = $selected.closest('li').next('li');\n                $next = $nextLi.find('a');\n                while (($next.length === 0 || $next.hasClass('disabled') || !$next.is(':visible')) && $nextLi.length) {\n                    $nextLi = $nextLi.next('li');\n                    $next = $nextLi.find('a');\n                }\n                if ($next.length === 0) {\n                    $next = $dropdownMenu.find('li a').first();\n                }\n            } else if (event.key === KEY.ARROW_UP) {\n                let $prevLi = $selected.closest('li').prev('li');\n                $next = $prevLi.find('a');\n                while (($next.length === 0 || $next.hasClass('disabled') || !$next.is(':visible')) && $prevLi.length) {\n                    $prevLi = $prevLi.prev('li');\n                    $next = $prevLi.find('a');\n                }\n                if ($next.length === 0) {\n                    $next = $dropdownMenu.find('li a').last();\n                }\n            }\n\n            // Add the 'selected' class to the next item\n            $next.addClass('selected');\n            const mainMenu = menuMap[menuID];\n            if ($next.hasClass(\"sub-menu-item\")) {\n                const submenuID = $next.get(0).id;\n                const submenu = subMenuItemMap[submenuID];\n                if (submenu) {\n                    mainMenu.closeSubMenu();\n                    mainMenu.openSubMenu = submenu;\n                    submenu.open();\n                }\n            } else {\n                mainMenu.closeSubMenu();\n            }\n        }\n    }\n\n    function _execMenuItem($menuDropdownToggle, event) {\n        // change code such that if event.key is KEY.ARROW_UP or KEY.ARROW_DOWN, the selection will move formward or back\n        const $dropdownMenu = $menuDropdownToggle.parent().find(\".dropdown-menu\");\n        const $selected = $dropdownMenu.find('li a.selected');\n        if ($selected.length === 1 && $dropdownMenu.is(':visible')) {\n            // something is selected\n            MainViewManager.focusActivePane();\n            $selected.click();\n            event.preventDefault();\n            event.stopPropagation();\n            return true;\n        }\n    }\n\n    function menuKeyboardNavigationHandler(event) {\n        const allowedKeys = [KEY.ARROW_LEFT, KEY.ARROW_RIGHT, KEY.ARROW_UP, KEY.ARROW_DOWN,\n        KEY.ESCAPE, KEY.ENTER, KEY.RETURN];\n        if (!allowedKeys.includes(event.key)) {\n            return;\n        }\n        if ($('#titlebar, #titlebar *').is(':focus')) {\n            // If '#titlebar' or a descendant has focus, add 'selected' class and focus the current element\n            if (event.key === KEY.ESCAPE) {\n                MainViewManager.focusActivePane();\n                event.preventDefault();\n                event.stopPropagation();\n                return;\n            }\n            const $focusedElement = $(':focus');\n            const isDescendantOfTitleBar = $focusedElement.closest('#titlebar').length > 0;\n            if (!isDescendantOfTitleBar) {\n                return;\n            }\n            if ($focusedElement.hasClass('dropdown-toggle')) {\n                if (event.key === KEY.ARROW_LEFT || event.key === KEY.ARROW_RIGHT) {\n                    // the main menu has focus, like file, edit etc..\n                    return _switchMenus($focusedElement, event);\n                } else if (event.key === KEY.ARROW_UP || event.key === KEY.ARROW_DOWN) {\n                    return _switchMenuItems($focusedElement, event);\n                } else if (event.key === KEY.ENTER || event.key === KEY.RETURN || event.key === KEY.SPACE) {\n                    return _execMenuItem($focusedElement, event);\n                }\n            }\n        }\n    }\n\n    /**\n     * Removes a top-level menu from the application menu bar which may be native or HTML-based.\n     *\n     * @param {!string} id - unique identifier for a menu.\n     *      Core Menus in Brackets use a simple title as an id, for example \"file-menu\".\n     *      Extensions should use the following format: \"author.myextension.mymenuname\".\n     */\n    function removeMenu(id) {\n        let menu,\n            commandID = \"\";\n\n        if (!id) {\n            console.error(\"removeMenu(): missing required parameter: id\");\n            return;\n        }\n\n        if (!menuMap[id]) {\n            console.error(\"removeMenu(): menu id not found: %s\", id);\n            return;\n        }\n\n        // Remove all of the menu items in the menu\n        menu = getMenu(id);\n\n        _.forEach(menuItemMap, function (value, key) {\n            if (_.startsWith(key, id)) {\n                if (value.isDivider) {\n                    menu.removeMenuDivider(key);\n                } else {\n                    commandID = value.getCommand();\n                    menu.removeMenuItem(commandID);\n                }\n            }\n        });\n\n        $(_getHTMLMenu(id)).remove();\n\n        delete menuMap[id];\n    }\n\n    /**\n     * Represents a context menu that can open at a specific location in the UI.\n     *\n     * Clients should not create this object directly and should instead use registerContextMenu()\n     * to create new ContextMenu objects.\n     *\n     * Context menus in brackets may be HTML-based or native so clients should not reach into\n     * the HTML and should instead manipulate ContextMenus through the API.\n     *\n     * Events:\n     * - beforeContextMenuOpen\n     * - beforeContextMenuClose\n     *\n     * @constructor\n     * @extends {Menu}\n     */\n    function ContextMenu(id) {\n        Menu.apply(this, arguments);\n\n        let $newMenu = $(\"<li class='dropdown context-menu' id='\" + StringUtils.jQueryIdEscape(id) + \"'></li>\"),\n            $popUp = $(\"<ul class='dropdown-menu'></ul>\"),\n            $toggle = $(\"<a href='#' class='dropdown-toggle' data-toggle='dropdown'></a>\").hide();\n\n        // assemble the menu fragments\n        $newMenu.append($toggle).append($popUp);\n\n        // insert into DOM\n        $(\"#context-menu-bar > ul\").append($newMenu);\n\n        let self = this;\n        PopUpManager.addPopUp($popUp,\n            function () {\n                self.close();\n            },\n            false);\n\n        // Listen to ContextMenu's beforeContextMenuOpen event to first close other popups\n        PopUpManager.listenToContextMenu(this);\n    }\n    ContextMenu.prototype = Object.create(Menu.prototype);\n    ContextMenu.prototype.constructor = ContextMenu;\n    ContextMenu.prototype.parentClass = Menu.prototype;\n    EventDispatcher.makeEventDispatcher(ContextMenu.prototype);\n\n\n    /**\n     * Displays the ContextMenu at the specified location and dispatches the\n     * \"beforeContextMenuOpen\" event or \"beforeSubMenuOpen\" event (for submenus).\n     * The menu location may be adjusted to prevent clipping by the browser window.\n     * All other menus and ContextMenus will be closed before a new menu\n     * will be closed before a new menu is shown (if the new menu is not\n     * a submenu).\n     *\n     * In case of submenus, the parentMenu of the submenu will not be closed when the\n     * sub menu is open.\n     *\n     * @param {MouseEvent | {pageX:number, pageY:number}} mouseOrLocation - pass a MouseEvent\n     *      to display the menu near the mouse or pass in an object with page x/y coordinates\n     *      for a specific location.This paramter is not used for submenus. Submenus are always\n     *      displayed at a position relative to the parent menu.\n     */\n    ContextMenu.prototype.open = function (mouseOrLocation) {\n        Metrics.countEvent(Metrics.EVENT_TYPE.UI_MENU, \"contextMenuOpen\", this.id);\n        if (!this.parentMenuItem &&\n            (!mouseOrLocation || !mouseOrLocation.hasOwnProperty(\"pageX\") || !mouseOrLocation.hasOwnProperty(\"pageY\"))) {\n            console.error(\"ContextMenu open(): missing required parameter\");\n            return;\n        }\n\n        let $window = $(window),\n            escapedId = StringUtils.jQueryIdEscape(this.id),\n            $menuAnchor = $(\"#\" + escapedId),\n            $menuWindow = $(\"#\" + escapedId + \" > ul\"),\n            posTop,\n            posLeft;\n\n        // only show context menu if it has menu items\n        if ($menuWindow.children().length <= 0) {\n            return;\n        }\n\n\n        // adjust positioning so menu is not clipped off bottom or right\n        if (this.parentMenuItem) { // If context menu is a submenu\n\n            this.trigger(EVENT_BEFORE_SUB_MENU_OPEN);\n\n            let $parentMenuItem = $(_getHTMLMenuItem(this.parentMenuItem.id));\n\n            posTop = $parentMenuItem.offset().top;\n            posLeft = $parentMenuItem.offset().left + $parentMenuItem.outerWidth();\n\n            let elementRect = {\n                top: posTop,\n                left: posLeft,\n                height: $menuWindow.height() + 25,\n                width: $menuWindow.width()\n            },\n                clip = ViewUtils.getElementClipSize($window, elementRect);\n\n            if (clip.bottom > 0) {\n                posTop = Math.max(0, posTop + $parentMenuItem.height() - $menuWindow.height());\n            }\n\n            posTop -= 30;   // shift top for hidden parent element\n            posLeft += 3;\n\n            if (clip.right > 0) {\n                posLeft = Math.max(0, posLeft - $parentMenuItem.outerWidth() - $menuWindow.outerWidth());\n            }\n        } else {\n            this.trigger(EVENT_BEFORE_CONTEXT_MENU_OPEN);\n\n            // close all other dropdowns\n            closeAll();\n\n            posTop = mouseOrLocation.pageY;\n            posLeft = mouseOrLocation.pageX;\n\n            let elementRect = {\n                top: posTop,\n                left: posLeft,\n                height: $menuWindow.height() + 25,\n                width: $menuWindow.width()\n            },\n                clip = ViewUtils.getElementClipSize($window, elementRect);\n\n            if (clip.bottom > 0) {\n                posTop = Math.max(0, posTop - clip.bottom);\n            }\n            posTop -= 30;   // shift top for hidden parent element\n            posLeft += 5;\n\n\n            if (clip.right > 0) {\n                posLeft = Math.max(0, posLeft - clip.right);\n            }\n        }\n\n        // open the context menu at final location\n        $menuAnchor.addClass(\"open\")\n            .css({ \"left\": posLeft, \"top\": posTop });\n    };\n\n\n    /**\n     * Closes the context menu.\n     */\n    ContextMenu.prototype.close = function () {\n        if (this.parentMenuItem) {\n            this.trigger(EVENT_BEFORE_SUB_MENU_CLOSE);\n        } else {\n            this.trigger(EVENT_BEFORE_CONTEXT_MENU_CLOSE);\n        }\n        this.closeSubMenu();\n        $(\"#\" + StringUtils.jQueryIdEscape(this.id)).removeClass(\"open\");\n    };\n\n    /**\n     * Detect if current context menu is already open\n     */\n    ContextMenu.prototype.isOpen = function () {\n        return $(\"#\" + StringUtils.jQueryIdEscape(this.id)).hasClass(\"open\");\n    };\n\n\n    /**\n     * Associate a context menu to a DOM element.\n     * This static function take care of registering event handlers for the click event\n     * listener and passing the right \"position\" object to the Context#open method\n     */\n    ContextMenu.assignContextMenuToSelector = function (selector, cmenu) {\n        $(selector).on(\"click\", function (e) {\n            let buttonOffset,\n                buttonHeight;\n\n            e.stopPropagation();\n\n            if (cmenu.isOpen()) {\n                cmenu.close();\n            } else {\n                buttonOffset = $(this).offset();\n                buttonHeight = $(this).outerHeight();\n                cmenu.open({\n                    pageX: buttonOffset.left,\n                    pageY: buttonOffset.top + buttonHeight\n                });\n            }\n        });\n    };\n\n\n    /**\n     * Registers new context menu with Brackets.\n\n     * Extensions should generally use the predefined context menus built into Brackets. Use this\n     * API to add a new context menu to UI that is specific to an extension.\n     *\n     * After registering  a new context menu clients should:\n     *      - use addMenuItem() to add items to the context menu\n     *      - call open() to show the context menu.\n     *      For example:\n     *      ```js\n     *      $(\"#my_ID\").contextmenu(function (e) {\n     *          if (e.which === 3) {\n     *              my_cmenu.open(e);\n     *          }\n     *      });\n     *      ```\n     * To make menu items be contextual to things like selection, listen for the \"beforeContextMenuOpen\"\n     * to make changes to Command objects before the context menu is shown. MenuItems are views of\n     * Commands, which control a MenuItem's name, enabled state, and checked state.\n     *\n     * @param {string} id - unique identifier for context menu.\n     *      Core context menus in Brackets use a simple title as an id.\n     *      Extensions should use the following format: \"author.myextension.mycontextmenu name\"\n     * @return {?ContextMenu} the newly created context menu\n     */\n    function registerContextMenu(id) {\n        if (!id) {\n            console.error(\"call to registerContextMenu() is missing required parameters\");\n            return null;\n        }\n\n        // Guard against duplicate menu ids\n        if (contextMenuMap[id]) {\n            console.log(\"Context Menu added with same name and id of existing Context Menu: \" + id);\n            return null;\n        }\n\n        let cmenu = new ContextMenu(id);\n        contextMenuMap[id] = cmenu;\n        return cmenu;\n    }\n\n    AppInit.htmlReady(function () {\n        $('#titlebar').on('focusin', function () {\n            KeyBindingManager.addGlobalKeydownHook(menuKeyboardNavigationHandler);\n        });\n        $('#titlebar').on('focusout', function () {\n            KeyBindingManager.removeGlobalKeydownHook(menuKeyboardNavigationHandler);\n        });\n    });\n\n    EventDispatcher.makeEventDispatcher(exports);\n\n    // Deprecated menu ids\n    DeprecationWarning.deprecateConstant(ContextMenuIds, \"WORKING_SET_MENU\", \"WORKING_SET_CONTEXT_MENU\");\n    DeprecationWarning.deprecateConstant(ContextMenuIds, \"WORKING_SET_SETTINGS_MENU\", \"WORKING_SET_CONFIG_MENU\");\n\n    // Define public API\n    exports.AppMenuBar = AppMenuBar;\n    exports.ContextMenuIds = ContextMenuIds;\n    exports.MenuSection = MenuSection;\n    exports.BEFORE = BEFORE;\n    exports.AFTER = AFTER;\n    exports.LAST = LAST;\n    exports.FIRST = FIRST;\n    exports.FIRST_IN_SECTION = FIRST_IN_SECTION;\n    exports.LAST_IN_SECTION = LAST_IN_SECTION;\n    exports.DIVIDER = DIVIDER;\n    exports.getMenu = getMenu;\n    exports.getSubMenu = getSubMenu;\n    exports.getAllMenus = getAllMenus;\n    exports.getMenuItem = getMenuItem;\n    exports.getContextMenu = getContextMenu;\n    exports.addMenu = addMenu;\n    exports.removeMenu = removeMenu;\n    exports.openMenu = openMenu;\n    exports.getOpenMenu = getOpenMenu;\n    exports.registerContextMenu = registerContextMenu;\n    exports.closeAll = closeAll;\n    exports.getAllMenuItemCommands = getAllMenuItemCommands;\n    exports.Menu = Menu;\n    exports.MenuItem = MenuItem;\n    exports.ContextMenu = ContextMenu;\n    exports.SubMenuIds = SubMenuIds;\n    // public events\n    exports.EVENT_BEFORE_CONTEXT_MENU_OPEN = EVENT_BEFORE_CONTEXT_MENU_OPEN;\n    exports.EVENT_BEFORE_CONTEXT_MENU_CLOSE = EVENT_BEFORE_CONTEXT_MENU_CLOSE;\n    exports.EVENT_BEFORE_SUB_MENU_OPEN = EVENT_BEFORE_SUB_MENU_OPEN;\n    exports.EVENT_BEFORE_SUB_MENU_CLOSE = EVENT_BEFORE_SUB_MENU_CLOSE;\n    exports.EVENT_MENU_ADDED = EVENT_MENU_ADDED;\n    exports.EVENT_SUB_MENU_ADDED = EVENT_SUB_MENU_ADDED;\n    exports.EVENT_MENU_ITEM_ADDED = EVENT_MENU_ITEM_ADDED;\n});\n"],"file":"Menus.js"}