{"version":3,"sources":["editor/Editor.js"],"names":["define","require","exports","module","CommandManager","Commands","CodeMirror","LanguageManager","EventDispatcher","PerfUtils","PreferencesManager","StateManager","TextRange","TokenUtils","HTMLUtils","MainViewManager","Metrics","_","tabSpacesStateManager","_createInternalStateManager","_INTERNAL_STATES","TAB_SPACES","IndentHelper","EditorPreferences","ChangeHelper","ErrorPopupHelper","InlineWidgetHelper","registeredGutters","cmOptions","init","CLOSE_BRACKETS","CLOSE_TAGS","DRAG_DROP","HIGHLIGHT_MATCHES","LINEWISE_COPY_CUT","SCROLL_PAST_END","SHOW_CURSOR_SELECT","SHOW_LINE_NUMBERS","SMART_INDENT","SPACE_UNITS","STYLE_ACTIVE_LINE","TAB_SIZE","AUTO_TAB_SPACES","USE_TAB_CHAR","WORD_WRAP","INDENT_LINE_COMMENT","INPUT_STYLE","LINE_NUMBER_GUTTER","LINE_NUMBER_GUTTER_PRIORITY","CODE_FOLDING_GUTTER_PRIORITY","editorOptions","Object","keys","_duringFocus","BOUNDARY_CHECK_NORMAL","BOUNDARY_IGNORE_TOP","BOUNDARY_BULLSEYE","_copyPos","pos","Pos","line","ch","_checkTopBoundary","options","_checkBottomBoundary","_buildPreferencesContext","fullPath","_buildContext","getLanguageForPath","getId","undefined","_instances","Editor","document","makeMasterEditor","container","range","self","this","isReadOnly","editable","push","addRef","jquery","get","$container","$","addClass","_visibleRange","startLine","endLine","_handleDocumentChange","bind","_handleDocumentDeleted","_handleDocumentLanguageChanged","_doWorkingSetSync","on","mode","_getModeFromDocument","_inlineWidgets","_inlineWidgetQueues","_hideMarks","_lastEditorWidth","_markTypesMap","_$messagePopover","_paneId","_hostEditor","codeMirrorKeyMap","Tab","_handleTabKey","Shift-Tab","Left","instance","_handleSoftTabNavigation","Right","Backspace","Delete","Esc","_instance","canConsumeEscapeKeyEvent","getSelections","length","clearSelection","hasSelection","removeAllInlineWidgets","Home","Cmd-Left","End","Cmd-Right","currentOptions","_currentOptions","zipObject","map","prefName","_getOption","_mouseHandlerOverride","_cm","_repeat","event","ctrlKey","metaKey","setTimeout","execute","NAVIGATE_JUMPTO_DEFINITION","countEvent","EVENT_TYPE","EDITOR","getMode","name","addNew","altKey","toggleClass","Boolean","_codeMirror","autoCloseBrackets","autoCloseTags","coverGutterNextToScrollbar","continueComments","cursorScrollMargin","dragDrop","electricChars","configureMouse","extraKeys","highlightSelectionMatches","indentUnit","indentWithTabs","inputStyle","lineNumbers","lineWiseCopyCut","lineWrapping","matchBrackets","maxScanLineLength","maxScanLines","matchTags","bothTags","scrollPastEnd","showCursorWhenSelecting","smartIndent","styleActiveLine","tabSize","readOnly","wrapperEl","getWrapperElement","transparentImg","Image","handleCMDragStart","e","dataTransfer","setDragImage","src","addEventListener","err","_focused","_installEditorListeners","_renderGutters","editor","_handleCursorActivity","domEvent","_handleKeypressEvents","changeList","_handleEditorChange","_toggleMasterEditor","setOption","_duringSync","_resetText","getText","_updateHiddenLines","setCursorPos","_makeEditable","defineProperty","getScrollInfo","top","getRootElement","$cmElement","$el","$editor","find","lineHeight","parseFloat","getComputedStyle","defaultHeight","scrollScaleFactor","shiftKey","horizontalDelta","deltaX","deltaY","scrollLeft","preventDefault","scrollDelta","scrollTop","makeEventDispatcher","prototype","markDeprecated","addHelpers","markPaneId","paneId","_associateEditor","getInlineWidgetsBelowCursor","cursor","getCursorPos","getAllInlineWidgetsForLine","getFocusedInlineWidget","doc","isDirty","addToWorkingSet","file","destroy","trigger","remove","splice","indexOf","releaseRef","off","dispose","_masterEditor","_makeNonEditable","_disassociateEditor","forEach","inlineWidget","_removeInlineWidgetInternal","_updateStyleActiveLine","_handleWhitespaceForElectricChars","selections","lineStr","sel","getLine","end","test","setSelections","keyStr","String","fromCharCode","which","keyCode","getLanguage","selectAllNoScroll","cm","info","operation","scrollTo","left","execCommand","isTextSubset","mark","clear","_hideLines","lineCount","text","currentText","getValue","textLF","currentTextLF","replace","perfTimerName","markStart","cursorPos","scrollPos","getScrollPos","setValue","refresh","clearHistory","markClean","setScrollPos","x","y","addMeasurement","getFile","expandTabs","getCursor","getColOffset","getEndingCursorPos","lastLine","getRange","column","i","getTabSize","getCharIndexForColumn","lineNum","iCol","center","setCursor","centerOnCursor","setSize","width","height","getViewport","CENTERING_MARGIN","_normalizeRange","anchorPos","headPos","start","reversed","getMarkOptionUnderlineError","className","getMarkOptionUnderlineWarn","getMarkOptionUnderlineInfo","getMarkOptionUnderlineSpellcheck","getMarkOptionHyperlinkText","getMarkOptionMatchingRefs","getMarkOptionRenameOutline","startStyle","endStyle","clearWhenEmpty","inclusiveLeft","inclusiveRight","centerOptions","$scrollerElement","editorHeight","getScrollerElement","statusBarHeight","documentCursorPosition","cursorCoords","bottom","screenCursorPosition","Math","min","max","clientHeight","indexFromPos","posFromIndex","index","posWithinRange","endInclusive","somethingSelected","getSelection","primarySel","listSelections","result","anchor","head","primary","hasMultipleCursors","convertToLineSelections","defaults","expandEndAtStartOfLine","mergeAdjacent","combinedSelections","prevSel","each","newSel","cloneDeep","selectionForEdit","selectionsToTrack","getSelectedText","allSelections","coordsChar","coordinates","charCoords","getToken","precise","assign","token","getTokenAt","getCharacterAtPosition","lineText","lineNumber","retrievedText","getPrevCharacterAtPosition","getNextToken","skipWhitespace","next","string","getPreviousToken","prev","execFn","markText","markType","cursorFrom","cursorTo","newMark","metadata","markToken","setBookmark","findMarks","marks","filter","findMarksAt","getMarksAfter","position","getMarksBefore","getAllMarks","clearAllMarks","Array","isArray","from","to","some","isSamePosition","position1","position2","getHistory","setHistory","createHistoryRestorePoint","restorePointName","history","done","changeGeneration","restoreHistoryPoint","canRestore","historyEntry","newHistory","historyLength","lastHistoryItem","undoSelection","undo","console","error","setSelection","origin","replaceSelection","replacement","select","replaceSelections","replaceRange","replaceMultipleRanges","ranges","sort","a","b","primIndex","toggleOverwrite","state","selectWordAt","word","findWordAt","getTextBetween","startPos","endPos","getWordAt","wordRange","getNumberAt","maxDigits","maxDigitsOverflow","type","str","right","decimalAlreadyFound","digitCount","substring","isLineVisible","coords","scrollInfo","getFirstVisibleLine","getLastVisibleLine","value","collapsed","totalHeight","scrollHeight","_getLineSpaceElement","children","adjustScrollPos","heightDelta","getTextHeight","defaultTextHeight","addInlineWidget","removeInlineWidget","removeAllInlineWidgetsForLine","getInlineWidgets","setInlineWidgetHeight","displayErrorMessageAtCursor","getVirtualScrollAreaTop","topPadding","offsetTop","scroller","offset","focus","hasFocus","getViewState","restoreViewState","viewState","selection","handleResize","focusedItem","window","activeElement","restoreFocus","contains","refreshAll","redo","notifyVisibilityChange","show","onParentShown","setVisible","css","isFullyVisible","is","getModeForRange","knownMixed","outerMode","startMode","getModeAt","endMode","getOption","getModeForSelection","sels","isMixed","tagInfo","getTagInfo","tokenType","ATTR_VALUE","attr","toLowerCase","hasMixedSel","rangeMode","getLanguageForSelection","getLanguageForMode","getLanguageForPosition","getModeForDocument","SPACING_OPTIONS","Set","_updateOption","oldValue","newValue","has","newUseAutoTabs","getAutoTabSpaces","_computeTabSpaces","newUseTabCharCfg","getUseTabChar","newSpaceUnits","getSpaceUnits","newTabSize","newTabUnits","getAutoTabUnits","currentIndentUnit","expectedIndentUnit","_toggleLinePadding","registerGutter","unregisterGutter","updateLayout","forceRefresh","curRoot","curWidth","$editorHolder","editorAreaHt","parent","style","_getRegisteredGutters","languageId","_filterByLanguages","gutter","languages","_sortByPriority","priority","_getName","gutters","rootElement","removeClass","setGutterMarker","gutterName","marker","isGutterRegistered","warn","getGutterMarker","lineInfo","gutterMarkers","clearGutterMarker","isGutterActive","includes","clearGutter","_toggleComment","indentLineComment","getIndentLineComment","toggleComment","indent","getRegisteredGutters","languageIds","isNaN","gutterExists","forEveryEditor","computedTabSpaces","Map","_getCachedSpaceCfg","key","cachedCfg","setUseTabChar","computedValues","useTabChar","set","context","setTabSize","isValidTabSize","tabUnits","MIN_SPACE_UNITS","MAX_LINES_TO_SCAN_FOR_INDENT","scanFullFile","recompute","detectedVals","_detectIndent","amount","DEFAULT_SPACE_UNITS","DEFAULT_TAB_SIZE","spaceUnits","MAX_SPACE_UNITS","MAX_AUTO_TAB_UNITS","_autoDetectTabSpaces","setAutoTabSpaces","setSpaceUnits","isValidSpaceUnit","setCloseBrackets","getCloseBrackets","setShowLineNumbers","getShowLineNumbers","setShowActiveLine","getShowActiveLine","setWordWrap","getWordWrap","setIndentLineComment","callback","showLinePadding","$holders","$holder","EVENT_BEFORE_CHANGE","EVENT_CHANGE","EVENT_BEFORE_SELECTION_CHANGE","EVENT_CURSOR_ACTIVITY","EVENT_KEY_PRESS","EVENT_KEY_DOWN","EVENT_KEY_UP","EVENT_FOCUS","EVENT_BLUR","EVENT_UPDATE","EVENT_SCROLL","EVENT_VIEW_PORT_CHANGE","EVENT_LOST_CONTENT","EVENT_OPTION_CHANGE"],"mappings":"AAwEAA,OAAO,SAAUC,QAASC,QAASC,QAG/B,IAAIC,eAAiBH,QAAQ,0BACzBI,SAAWJ,QAAQ,oBACnBK,WAAaL,QAAQ,wCACrBM,gBAAkBN,QAAQ,4BAC1BO,gBAAkBP,QAAQ,yBAC1BQ,UAAYR,QAAQ,mBACpBS,mBAAqBT,QAAQ,kCAC7BU,aAAeV,QAAQ,4BACvBW,UAAYX,QAAQ,sBAAsBW,UAC1CC,WAAaZ,QAAQ,oBACrBa,UAAYb,QAAQ,sBACpBc,gBAAkBd,QAAQ,wBAC1Be,QAAUf,QAAQ,iBAClBgB,EAAIhB,QAAQ,qBAEhB,MAAMiB,sBAAwBP,aAAaQ,4BAA4BR,aAAaS,iBAAiBC,YAIrG,IAAIC,aAAerB,QAAQ,+BACvBsB,kBAAoBtB,QAAQ,oCAC5BuB,aAAevB,QAAQ,+BACvBwB,iBAAmBxB,QAAQ,mCAC3ByB,mBAAqBzB,QAAQ,qCAa7B0B,kBAAoB,GAEpBC,UAAY,GAEhBL,kBAAkBM,KAAKD,WAEvB,MAAME,eAAiBP,kBAAkBO,eACrCC,WAAaR,kBAAkBQ,WAC/BC,UAAYT,kBAAkBS,UAC9BC,kBAAoBV,kBAAkBU,kBACtCC,kBAAoBX,kBAAkBW,kBACtCC,gBAAkBZ,kBAAkBY,gBACpCC,mBAAqBb,kBAAkBa,mBACvCC,kBAAoBd,kBAAkBc,kBACtCC,aAAef,kBAAkBe,aACjCC,YAAchB,kBAAkBgB,YAChCC,kBAAoBjB,kBAAkBiB,kBACtCC,SAAWlB,kBAAkBkB,SAC7BC,gBAAkBnB,kBAAkBmB,gBACpCC,aAAepB,kBAAkBoB,aACjCC,UAAYrB,kBAAkBqB,UAC9BC,oBAAsBtB,kBAAkBsB,oBACxCC,YAAcvB,kBAAkBuB,YAE9BC,mBAAqBxB,kBAAkBwB,mBACzCC,4BAA8BzB,kBAAkByB,4BAChDC,6BAA+B1B,kBAAkB0B,6BAErD,IAAIC,cAAgB,IAAIC,OAAOC,KAAKxB,WAAYc,iBAShD,IAAIW,cAAe,EAMnB,MAAMC,sBAAwB,EAMxBC,oBAAsB,EAMtBC,kBAAoB,EAS1B,SAASC,SAASC,KACd,OAAO,IAAIpD,WAAWqD,IAAID,IAAIE,KAAMF,IAAIG,IAQ5C,SAASC,kBAAkBC,SACvB,OAAQA,UAAYR,oBAGxB,SAASS,qBAAqBD,SAC1B,OAAO,EAWX,SAASE,yBAAyBC,UAC9B,OAAOxD,mBAAmByD,cAAcD,SACpCA,SAAW3D,gBAAgB6D,mBAAmBF,UAAUG,aAAUC,GAS1E,IAAIC,WAAa,GAqBjB,SAASC,OAAOC,SAAUC,iBAAkBC,UAAWC,MAAOb,SAC1D,IAAIc,KAAOC,KAEPC,WAAchB,SAAWA,QAAQgB,aAAgBN,SAASO,SAE9DT,WAAWU,KAAKH,MAGhBA,KAAKL,SAAWA,SAChBA,SAASS,SAELP,UAAUQ,SAEVR,UAAYA,UAAUS,IAAI,IAG9B,IAAIC,WAAaC,EAAEX,WACnBU,WAAWE,SAAS,iBAEhBX,QACAE,KAAKU,cAAgB,IAAI5E,UAAU6D,SAAUG,MAAMa,UAAWb,MAAMc,UAIxEZ,KAAKa,sBAAwBb,KAAKa,sBAAsBC,KAAKd,MAC7DA,KAAKe,uBAAyBf,KAAKe,uBAAuBD,KAAKd,MAC/DA,KAAKgB,+BAAiChB,KAAKgB,+BAA+BF,KAAKd,MAC/EA,KAAKiB,kBAAoBjB,KAAKiB,kBAAkBH,KAAKd,MACrDL,SAASuB,GAAG,SAAUlB,KAAKa,uBAC3BlB,SAASuB,GAAG,UAAWlB,KAAKe,wBAC5BpB,SAASuB,GAAG,kBAAmBlB,KAAKgB,gCAEpCrB,SAASuB,GAAG,mBAAoBlB,KAAKiB,mBAErC,IAAIE,KAAOnB,KAAKoB,uBAIhBpB,KAAKqB,eAAiB,GACtBrB,KAAKsB,oBAAsB,GAC3BtB,KAAKuB,WAAa,GAClBvB,KAAKwB,iBAAmB,KAExBxB,KAAKyB,cAAgB,GAErBzB,KAAK0B,iBAAmB,KAGxB1B,KAAK2B,QAAU,KAGf3B,KAAK4B,YAAc,KAGnB,IAAIC,iBAAmB,CACnBC,IAAO,WAAc/B,KAAKgC,iBAC1BC,YAAa,aAEbC,KAAQ,SAAUC,UACdnC,KAAKoC,0BAA0B,EAAG,UAEtCC,MAAS,SAAUF,UACfnC,KAAKoC,yBAAyB,EAAG,UAErCE,UAAa,SAAUH,UACnBnC,KAAKoC,0BAA0B,EAAG,YAEtCG,OAAU,SAAUJ,UAChBnC,KAAKoC,yBAAyB,EAAG,YAErCI,IAAO,SAAUC,WACRzC,KAAK0C,6BAGN1C,KAAK2C,gBAAgBC,OAAS,EAC9B5C,KAAK6C,iBACE7C,KAAK8C,eACZ9C,KAAK6C,iBAEL7C,KAAK+C,2BAGbC,KAAQ,kBACRC,WAAY,kBACZC,IAAO,cACPC,YAAa,eAGbC,eAAiBnD,KAAKoD,gBAAkBjH,EAAEkH,UAC1CjF,cACAjC,EAAEmH,IAAIlF,cAAe,SAAUmF,UAC3B,OAAOxD,KAAKyD,WAAWD,aAM/B,SAASE,sBAAsBC,IAAKC,QAASC,OAOzC,OANIA,MAAMC,SAAWD,MAAME,UACvBC,WAAW,KACPzI,eAAe0I,QAAQzI,SAAS0I,4BAChC/H,QAAQgI,WAAWhI,QAAQiI,WAAWC,OAAQ,YAAaV,IAAIW,UAAUC,OAC1E,KAEA,CACHC,OAAQX,MAAMY,QAStBjE,WAAWkE,YAAY,oBAAqBC,SAAS1E,KAAKwD,WAAW,qBAIrExD,KAAK2E,YAAc,IAAInJ,WAAWqE,UAAW,CACzC+E,kBAAmBzB,eAAenG,gBAClC6H,cAAe1B,eAAelG,YAC9B6H,4BAA4B,EAC5BC,kBAAkB,EAClBC,mBAAoB,EACpBC,SAAU9B,eAAejG,WACzBgI,eAAe,EACfC,eAAgB1B,sBAChB2B,UAAWvD,iBACXwD,0BAA2BlC,eAAehG,mBAC1CmI,WAAYnC,eAAetF,cAAgBsF,eAAexF,UAAYwF,eAAe1F,aACrF8H,eAAgBpC,eAAetF,cAC/B2H,WAAYrC,eAAenF,aAC3ByH,YAAatC,eAAe5F,mBAC5BmI,gBAAiBvC,eAAe/F,mBAChCuI,aAAcxC,eAAerF,WAC7B8H,cAAe,CAAEC,kBAAmB,IAAOC,aAAc,KACzDC,UAAW,CAAEC,UAAU,GACvBC,eAAgBnG,OAASqD,eAAe9F,iBACxC6I,wBAAyB/C,eAAe7F,oBACxC6I,YAAahD,eAAe3F,cAC5B4I,gBAAiBjD,eAAezF,mBAChC2I,QAASlD,eAAexF,UACxB2I,SAAUrG,aAUd,IACI,MAAMsG,UAAYxG,KAAK4E,YAAY6B,oBACnC,GAAID,UAAW,CAEX,MAAME,eAAiB,IAAIC,MAE3B,SAASC,kBAAkBC,GACnBA,GAAKA,EAAEC,cAAuD,mBAAhCD,EAAEC,aAAaC,cAC7CF,EAAEC,aAAaC,aAAaL,eAAgB,EAAG,GAHvDA,eAAeM,IAAM,yEAMrBR,UAAUS,iBAAiB,YAAaL,oBAG9C,MAAOM,MAOTjH,KAAKkH,UAAW,EAEhBlH,KAAKmH,0BAELnH,KAAKoH,iBAELpH,KAAKkB,GAAG,iBAAkB,SAAU0C,MAAOyD,QACvCtH,KAAKuH,sBAAsB1D,SAE/B5D,KAAKkB,GAAG,WAAY,SAAU0C,MAAOyD,OAAQE,UACzCxH,KAAKyH,sBAAsBD,YAE/BvH,KAAKkB,GAAG,SAAU,SAAU0C,MAAOyD,OAAQI,YACvC1H,KAAK2H,oBAAoBD,cAE7BzH,KAAKkB,GAAG,QAAS,SAAU0C,MAAOyD,QAC1BtH,KAAK6B,YAEL7B,KAAK6B,YAAYjC,SAASgI,oBAAoB5H,KAAK6B,aAGnD7B,KAAKJ,SAASgI,oBAAoB5H,QAK1CC,KAAK2E,YAAYiD,UAAU,OAAQzG,MAInCnB,KAAK6H,aAAc,EACnB7H,KAAK8H,WAAWnI,SAASoI,WACzB/H,KAAK6H,aAAc,EAEf/H,QACAE,KAAKgI,qBACLhI,KAAKiI,aAAanI,MAAMa,UAAW,IAInCf,kBACAD,SAASuI,cAAclI,MAI3B3B,OAAO8J,eAAenI,KAAM,YAAa,CACrCM,IAAK,WACD,OAAON,KAAK2E,YAAYyD,gBAAgBC,OAKhDhK,OAAO8J,eAAenI,KAAM,MAAO,CAC/BM,IAAK,WACD,OAAOE,EAAER,KAAKsI,qBAItB,MAAMC,WAAavI,KAAKwI,IACxBD,WAAW,GAAGvB,iBAAiB,QAAUpD,QACrC,MAAM6E,QAAUF,WAAWG,KAAK,sBAI1BC,WAAaC,WAAWC,iBAAiBJ,QAAQ,IAAIE,YACrDG,cAAgB,GAAIC,kBAAoBJ,WAAxB,GAGtB,GAAI/E,MAAMoF,SAAU,CAChB,IAAIC,gBAAkBrF,MAAMsF,OAO5B,GALqB,IAAjBtF,MAAMuF,SACNF,gBAAkBrF,MAAMuF,QAIJ,IAApBF,gBAGA,OAFAR,QAAQ,GAAGW,YAAcH,qBACzBrF,MAAMyF,iBAWd,GALqB,IAAjBzF,MAAMsF,SACNT,QAAQ,GAAGW,YAAcxF,MAAMsF,QAId,IAAjBtF,MAAMuF,OAAc,CACpB,MAAMG,YAAc1F,MAAMuF,OAC1BV,QAAQ,GAAGc,WAAcD,YAAYP,kBACrCnF,MAAMyF,oBAKlB3N,gBAAgB8N,oBAAoB9J,OAAO+J,WAC3C/N,gBAAgBgO,eAAehK,OAAO+J,UAAW,WAAY,sBAE7DjN,aAAamN,WAAWjK,QACxBhD,aAAaiN,WAAWjK,QACxB9C,mBAAmB+M,WAAWjK,QAE9BA,OAAO+J,UAAUG,WAAa,SAAUC,QACpC7J,KAAK2B,QAAUkI,OAGf7J,KAAKL,SAASmK,iBAAiB9J,MAK/BA,KAAKiB,kBAAkB,KAAMjB,KAAKL,WAOtCD,OAAO+J,UAAUM,4BAA8B,WAC3C,IAAIhK,KAAOC,KACPgK,OACAlL,KAFOkB,KACOiK,eACAnL,KAClB,OAHWkB,KAGCkK,2BAA2BpL,OAM3CY,OAAO+J,UAAUhH,yBAA2B,WACxC,IAAI1C,KAAOC,KACX,OADWA,KACE0C,gBAAgBC,OAAS,GAD3B3C,KAEE6C,gBAFF7C,KAGC+J,+BAHD/J,KAICmK,0BAGhBzK,OAAO+J,UAAUxI,kBAAoB,SAAU2C,MAAOwG,KAC9CA,MAAQpK,KAAKL,UAAYK,KAAK2B,SAAW3B,KAAKL,SAAS0K,SACvDpO,gBAAgBqO,gBAAgBtK,KAAK2B,QAAS3B,KAAKL,SAAS4K,MAAO,GAAG,IAS9E7K,OAAO+J,UAAUe,QAAU,WACvBxK,KAAKyK,QAAQ,gBAAiBzK,MAI9BQ,EAAER,KAAKsI,kBAAkBoC,SAEzBjL,WAAWkL,OAAOlL,WAAWmL,QAAQ5K,MAAO,GAG5CA,KAAKL,SAASkL,aACd7K,KAAKL,SAASmL,IAAI,SAAU9K,KAAKa,uBACjCb,KAAKL,SAASmL,IAAI,UAAW9K,KAAKe,wBAClCf,KAAKL,SAASmL,IAAI,kBAAmB9K,KAAKgB,gCAC1ChB,KAAKL,SAASmL,IAAI,mBAAoB9K,KAAKiB,mBAEvCjB,KAAKU,eACLV,KAAKU,cAAcqK,UAInB/K,KAAKL,SAASqL,gBAAkBhL,KAChCA,KAAKL,SAASsL,mBAEdjL,KAAKL,SAASuL,oBAAoBlL,MAKtC,IAAID,KAAOC,KACXA,KAAKqB,eAAe8J,QAAQ,SAAUC,cAClCrL,KAAKsL,4BAA4BD,iBASzC1L,OAAO+J,UAAUnC,sBAAwB,SAAU1D,OAC/C5D,KAAKsL,0BAOT5L,OAAO+J,UAAU8B,kCAAoC,WACjD,IAAIxL,KAAOC,KACPkC,SAAWlC,KAAK2E,YAChB6G,WACAC,QAEJD,WAAaxL,KAAK0C,gBAAgBY,IAAI,SAAUoI,KAS5C,OARAD,QAAUvJ,SAASyJ,QAAQD,IAAIE,IAAI9M,SAEnB,KAAK+M,KAAKJ,WAItBC,IAAIE,IAAI7M,GAAKgB,KAAKJ,SAASgM,QAAQD,IAAIE,IAAI9M,MAAM6D,QAE9C+I,MAEX1L,KAAK8L,cAAcN,aAQvB9L,OAAO+J,UAAUjC,sBAAwB,SAAU5D,OAC/C,IAAImI,OAASC,OAAOC,aAAarI,MAAMsI,OAAStI,MAAMuI,SAElD,aAAaN,KAAKE,SAClB/L,KAAKuL,qCAUb7L,OAAO+J,UAAUrI,qBAAuB,WAIpC,OAAOpB,KAAKL,SAASyM,cAAc/H,WAAa,cAOpD3E,OAAO+J,UAAU4C,kBAAoB,WACjC,IAAIC,GAAKtM,KAAK2E,YACV4H,KAAOvM,KAAK2E,YAAYyD,gBAI5BkE,GAAGE,UAAU,WACTF,GAAGG,SAASF,KAAKG,KAAMH,KAAKlE,KAC5BiE,GAAGK,YAAY,gBAOvBjN,OAAO+J,UAAUmD,aAAe,WAC5B,OAAOlI,QAAQ1E,KAAKU,gBAQxBhB,OAAO+J,UAAUzB,mBAAqB,WAClC,GAAIhI,KAAKU,cAAe,CACpB,IAAI4L,GAAKtM,KAAK2E,YACV5E,KAAOC,KACXsM,GAAGE,UAAU,WACTzM,KAAKwB,WAAW4J,QAAQ,SAAU0B,MAC1BA,MACAA,KAAKC,UAGb/M,KAAKwB,WAAa,GAClBxB,KAAKwB,WAAWpB,KAAKJ,KAAKgN,WAAW,EAAGhN,KAAKW,cAAcC,YAC3DZ,KAAKwB,WAAWpB,KAAKJ,KAAKgN,WAAWhN,KAAKW,cAAcE,QAAU,EAAGb,KAAKiN,kBAWtFtN,OAAO+J,UAAU3B,WAAa,SAAUmF,MACpC,IAAIC,YAAclN,KAAK2E,YAAYwI,WAG/BC,OACAC,cACJ,IAFaJ,KAAOA,KAAKK,QAAQ,gBAAiB,MAAQ,SACtCJ,YAAcA,YAAYI,QAAQ,gBAAiB,MAAQ,MAC/E,CAKA,IAAIC,cAAgB5R,UAAU6R,UAAU,0BAA4BxN,KAAKL,UAAYK,KAAKL,SAAS4K,KAAKnL,WAEpGqO,UAAYzN,KAAKiK,eACjByD,UAAY1N,KAAK2N,eAGrB3N,KAAK2E,YAAYiJ,SAASX,MAC1BjN,KAAK2E,YAAYkJ,UAIjB7N,KAAK2E,YAAYmJ,eACjB9N,KAAK2E,YAAYoJ,YAGjB/N,KAAKiI,aAAawF,WAClBzN,KAAKgO,aAAaN,UAAUO,EAAGP,UAAUQ,GAEzCvS,UAAUwS,eAAeZ,iBAQ7B7N,OAAO+J,UAAU2E,QAAU,WACvB,OAAOpO,KAAKL,SAAS4K,MAiBzB7K,OAAO+J,UAAUQ,aAAe,SAAUoE,WAAYnC,OAIpC,UAAVA,MACAA,MAAQ,OACS,QAAVA,QACPA,MAAQ,MAEZ,IAAIlC,OAASrL,SAASqB,KAAK2E,YAAY2J,UAAUpC,QAKjD,OAHImC,aACArE,OAAOjL,GAAKiB,KAAKuO,aAAavE,SAE3BA,QASXtK,OAAO+J,UAAU+E,mBAAqB,SAAUH,YAC5C,IAAII,SAAWzO,KAAK2E,YAAY8J,WAC5BzE,OAAS,CACTlL,KAAM2P,SACN1P,GAAIiB,KAAK2E,YAAYgH,QAAQ8C,UAAU9L,QAM3C,OAHI0L,aACArE,OAAOjL,GAAKiB,KAAKuO,aAAavE,SAE3BA,QASXtK,OAAO+J,UAAU8E,aAAe,SAAU3P,KACtC,IAAIE,KAAOkB,KAAK2E,YAAY+J,SAAS,CAAE5P,KAAMF,IAAIE,KAAMC,GAAI,GAAKH,KAC5DyH,QAAU,KACVsI,OAAS,EACTC,EAEJ,IAAKA,EAAI,EAAGA,EAAI9P,KAAK6D,OAAQiM,IACT,OAAZ9P,KAAK8P,IACW,OAAZvI,UACAA,QAAU3G,OAAOmP,cAEjBxI,QAAU,IACVsI,QAAWtI,QAAWsI,OAAStI,UAGnCsI,SAGR,OAAOA,QAUXjP,OAAO+J,UAAUqF,sBAAwB,SAAUC,QAASJ,QACxD,IAAI7P,KAAOkB,KAAK2E,YAAYgH,QAAQoD,SAChC1I,QAAU,KACV2I,KAAO,EACPJ,EAEJ,IAAKA,EAAI,EAAGI,KAAOL,OAAQC,IACP,OAAZ9P,KAAK8P,IACW,OAAZvI,UACAA,QAAU3G,OAAOmP,cAEjBxI,QAAU,IACV2I,MAAS3I,QAAW2I,KAAO3I,UAG/B2I,OAGR,OAAOJ,GAWXlP,OAAO+J,UAAUxB,aAAe,SAAUnJ,KAAMC,GAAIkQ,OAAQZ,YACpDA,aACAtP,GAAKiB,KAAKuO,aAAa,CAAEzP,KAAMA,KAAMC,GAAIA,MAE7CiB,KAAK2E,YAAYuK,UAAUpQ,KAAMC,IAC7BkQ,QACAjP,KAAKmP,kBASbzP,OAAO+J,UAAU2F,QAAU,SAAUC,MAAOC,QACxCtP,KAAK2E,YAAYyK,QAAQC,MAAOC,SAapC5P,OAAO+J,UAAU8F,YAAc,WAC3B,OAAOvP,KAAK2E,YAAY4K,eAI5B,IAAIC,iBAAmB,IA6GvB,SAASC,gBAAgBC,UAAWC,SAChC,OAAIA,QAAQ7Q,KAAO4Q,UAAU5Q,MAAS6Q,QAAQ7Q,OAAS4Q,UAAU5Q,MAAQ6Q,QAAQ5Q,GAAK2Q,UAAU3Q,GACrF,CAAE6Q,MAAOjR,SAASgR,SAAU/D,IAAKjN,SAAS+Q,WAAYG,UAAU,GAEpE,CAAED,MAAOjR,SAAS+Q,WAAY9D,IAAKjN,SAASgR,SAAUE,UAAU,GAkS3E,SAASC,8BACL,MAAO,CACHC,UAAW,8BAInB,SAASC,6BACL,MAAO,CACHD,UAAW,6BAInB,SAASE,6BACL,MAAO,CACHF,UAAW,6BAInB,SAASG,mCACL,MAAO,CACHH,UAAW,oCAInB,SAASI,6BACL,MAAO,CACHJ,UAAW,8BAInB,SAASK,4BACL,MAAO,CACHL,UAAW,sCAInB,SAASM,6BACL,MAAO,CACHN,UAAW,6BACXO,WAAY,kCACZC,SAAU,mCACVC,gBAAgB,EAChBC,eAAe,EACfC,gBAAgB,GAnbxBhR,OAAO+J,UAAU0F,eAAiB,SAAUwB,eACxC,IAAIC,iBACAC,aADmBrQ,EAAER,KAAK8Q,sBACMxB,SAGhCyB,gBAAkBvQ,EAAE,eAAe8O,SAEnC0B,uBAAyBhR,KAAK2E,YAAYsM,aAAa,KAAM,SAASC,OACtEC,qBAAuBnR,KAAK2E,YAAYsM,aAAa,KAAM,QAAQC,OAEvE,GAtuBsB,IAsuBlBP,eAaJ,GAAK3R,kBAAkB2R,gBAAmBQ,qBAlCvB,IAkC8CN,cACpBM,qBAAsC,IAAfN,aAAyC,CAEzG,IAAIjS,IAAMoS,uBAAyBH,aAAe,EAAIE,gBAClDxE,KAAOvM,KAAK2E,YAAYyD,gBAC5BxJ,IAAMwS,KAAKC,IAAID,KAAKE,IAAI1S,IAAK,GAAK2N,KAAK+C,OAAS/C,KAAKgF,cACrDvR,KAAKgO,aAAa,KAAMpP,UAnB5B,CACI,IAAIA,IAAMoS,uBAAyBH,aAAe,EAAIE,gBACtD/Q,KAAKgO,aAAa,KAAMpP,OA0BhCc,OAAO+J,UAAU+H,aAAe,SAAU/D,WACtC,OAAOzN,KAAK2E,YAAY6M,aAAa/D,YAQzC/N,OAAO+J,UAAUgI,aAAe,SAAUC,OACtC,OAAO1R,KAAK2E,YAAY8M,aAAaC,QAYzChS,OAAO+J,UAAUkI,eAAiB,SAAU/S,IAAKgR,MAAOhE,IAAKgG,cACzD,OAAIhC,MAAM9Q,MAAQF,IAAIE,MAAQ8M,IAAI9M,MAAQF,IAAIE,OACtC8S,cACQhC,MAAM9Q,KAAOF,IAAIE,MAAQ8Q,MAAM7Q,IAAMH,IAAIG,MAC5C6M,IAAI9M,KAAOF,IAAIE,MAAQ8M,IAAI7M,IAAMH,IAAIG,KAEtC6Q,MAAM9Q,KAAOF,IAAIE,MAAQ8Q,MAAM7Q,IAAMH,IAAIG,MAC5C6M,IAAI9M,KAAOF,IAAIE,MAAQ8M,IAAI7M,GAAKH,IAAIG,MAUjDW,OAAO+J,UAAU5G,aAAe,WAC5B,OAAO7C,KAAK2E,YAAYkN,qBAoC5BnS,OAAO+J,UAAUqI,aAAe,WAC5B,OAAOrC,gBAAgBzP,KAAKiK,cAAa,EAAO,UAAWjK,KAAKiK,cAAa,EAAO,UAaxFvK,OAAO+J,UAAU/G,cAAgB,WAC7B,IAAIqP,WAAa/R,KAAK8R,eACtB,OAAO3V,EAAEmH,IAAItD,KAAK2E,YAAYqN,iBAAkB,SAAUtG,KACtD,IAAIuG,OAASxC,gBAAgB/D,IAAIwG,OAAQxG,IAAIyG,MAO7C,OANIF,OAAOrC,MAAM9Q,OAASiT,WAAWnC,MAAM9Q,MAAQmT,OAAOrC,MAAM7Q,KAAOgT,WAAWnC,MAAM7Q,IACpFkT,OAAOrG,IAAI9M,OAASiT,WAAWnG,IAAI9M,MAAQmT,OAAOrG,IAAI7M,KAAOgT,WAAWnG,IAAI7M,GAC5EkT,OAAOG,SAAU,EAEjBH,OAAOG,SAAU,EAEdH,UAQfvS,OAAO+J,UAAU4I,mBAAqB,WAClC,MAAM7G,WAAaxL,KAAK2E,YAAYqN,iBACpC,OAAOxG,WAAW7I,OAAS,GAqB/BjD,OAAO+J,UAAU6I,wBAA0B,SAAU9G,WAAYvM,SAC7D,IAAIc,KAAOC,KACXf,QAAUA,SAAW,GACrB9C,EAAEoW,SAAStT,QAAS,CAAEuT,wBAAwB,EAAOC,eAAe,IAIpE,IAAIC,mBAAqB,GAAIC,QAyB7B,OAxBAxW,EAAEyW,KAAKpH,WAAY,SAAUE,KACzB,IAAImH,OAAS1W,EAAE2W,UAAUpH,KAGzBmH,OAAOjD,MAAM7Q,GAAK,EAGlB,IAAI8D,aAAgBgQ,OAAOjD,MAAM9Q,OAAS+T,OAAOjH,IAAI9M,MAAU+T,OAAOjD,MAAM7Q,KAAO8T,OAAOjH,IAAI7M,IAC1FE,QAAQuT,wBAA2B3P,cAAkC,IAAlBgQ,OAAOjH,IAAI7M,KAC9D8T,OAAOjH,IAAM,CAAE9M,KAAM+T,OAAOjH,IAAI9M,KAAO,EAAGC,GAAI,IAO9C4T,SAAW5S,KAAK4R,eAAekB,OAAOjD,MAAO+C,QAAQI,iBAAiBnD,MAAO+C,QAAQI,iBAAiBnH,IAAK3M,QAAQwT,gBACnHE,QAAQI,iBAAiBnH,IAAI9M,KAAO+T,OAAOjH,IAAI9M,KAC/C6T,QAAQK,kBAAkB7S,KAAKuL,OAE/BiH,QAAU,CAAEI,iBAAkBF,OAAQG,kBAAmB,CAACtH,MAC1DgH,mBAAmBvS,KAAKwS,YAGzBD,oBAWXhT,OAAO+J,UAAUwJ,gBAAkB,SAAUC,eACzC,GAAIA,cACA,OAAOlT,KAAK2E,YAAYmN,eAE5B,IAAIpG,IAAM1L,KAAK8R,eACf,OAAO9R,KAAKL,SAAS+O,SAAShD,IAAIkE,MAAOlE,IAAIE,MAYjDlM,OAAO+J,UAAU0J,WAAa,SAAUC,YAAajS,MACjD,OAAOnB,KAAK2E,YAAYwO,WAAWC,YAAajS,OAYpDzB,OAAO+J,UAAU4J,WAAa,SAAUzU,IAAKuC,MACzC,OAAOnB,KAAK2E,YAAY0O,WAAWzU,IAAKuC,OAc5CzB,OAAO+J,UAAU6J,SAAW,SAAUtJ,OAAQuJ,SAC1C,IAAIjH,GAAKtM,KAAK2E,YACdqF,OAAS3L,OAAOmV,OAAO,GAAIxJ,QAAUhK,KAAKiK,gBAE1C,IAAIwJ,MAAQ1X,WAAW2X,WAAWpH,GAAItC,OAAQuJ,SAE9C,OADAE,MAAM3U,KAAOkL,OAAOlL,KACb2U,OAWX/T,OAAO+J,UAAUkK,uBAAyB,SAAU/U,KAChD,MAAM0N,GAAKtM,KAAK2E,YAChB,IAAIiP,SAAWtH,GAAGX,QAAQ/M,IAAIE,MAC9B,OAAIF,IAAIG,IAAM6U,SAASjR,QAAU/D,IAAIE,MAAQwN,GAAGU,YACrC,KAGJV,GAAGoC,SAAS9P,IAAK,CAAEE,KAAMF,IAAIE,KAAMC,GAAIH,IAAIG,GAAK,KAS3DW,OAAO+J,UAAUkC,QAAU,SAAUkI,YACjC,MAAMC,cAAgB9T,KAAK2E,YAAYgH,QAAQkI,YAC/C,YAAyBrU,IAAlBsU,cAA8B,KAAOA,eAYhDpU,OAAO+J,UAAUsK,2BAA6B,SAAUnV,KACpD,OAAe,IAAXA,IAAIG,GACG,KAEJiB,KAAK2T,uBAAuB,CAAE7U,KAAMF,IAAIE,KAAMC,GAAIH,IAAIG,GAAK,KAatEW,OAAO+J,UAAUuK,aAAe,SAAUhK,OAAQiK,gBAAiB,EAAMV,SACrEvJ,OAAS3L,OAAOmV,OAAO,GAAIxJ,QAAUhK,KAAKiK,gBAC1C,IAAIwJ,MACAS,KADQlU,KAAKsT,SAAStJ,OAAQuJ,SAE9BnJ,IAAMpK,KAAKL,SACfuU,KAAKpV,KAAOkL,OAAOlL,KAEnB,EAAG,CACC,GAAIoV,KAAKtI,IAAMxB,IAAIuB,QAAQ3B,OAAOlL,MAAM6D,OACpCqH,OAAOjL,GAAKmV,KAAKtI,IAAM,MACpB,CAAA,IAAIxB,IAAIuB,QAAQ3B,OAAOlL,KAAO,GAG9B,CACHoV,KAAO,KACP,MAJAlK,OAAOjL,GAAK,EACZiL,OAAOlL,QAKXoV,KAAOlU,KAAKsT,SAAStJ,OAAQuJ,UACxBzU,KAAOkL,OAAOlL,WACdmV,iBAAmB,KAAKpI,KAAKqI,KAAKC,SAE3C,OAAOD,MAaXxU,OAAO+J,UAAU2K,iBAAmB,SAAUpK,OAAQiK,gBAAiB,EAAMV,SACzEvJ,OAAS3L,OAAOmV,OAAO,GAAIxJ,QAAUhK,KAAKiK,gBAC1C,IAAIwJ,MACAY,KADQrU,KAAKsT,SAAStJ,OAAQuJ,SAE9BnJ,IAAMpK,KAAKL,SACf0U,KAAKvV,KAAOkL,OAAOlL,KAEnB,EAAG,CACC,GAAIuV,KAAKzE,MAAQ5F,OAAOjL,GACpBiL,OAAOjL,GAAKsV,KAAKzE,UACd,CAAA,KAAI5F,OAAOlL,KAAO,GAIrB,MAHAkL,OAAOjL,GAAKqL,IAAIuB,QAAQ3B,OAAOlL,KAAO,GAAG6D,OACzCqH,OAAOlL,QAIXuV,KAAOrU,KAAKsT,SAAStJ,OAAQuJ,UACxBzU,KAAOkL,OAAOlL,WACdmV,iBAAmB,KAAKpI,KAAKwI,KAAKF,SAE3C,OAAOE,MAaX3U,OAAO+J,UAAU+C,UAAY,SAAU8H,QACnC,OAAOtU,KAAK2E,YAAY6H,UAAU8H,SAqDtC5U,OAAOoQ,4BAA8BA,4BAKrCpQ,OAAOsQ,2BAA6BA,2BAKpCtQ,OAAOuQ,2BAA6BA,2BAKpCvQ,OAAOwQ,iCAAmCA,iCAK1CxQ,OAAOyQ,2BAA6BA,2BAKpCzQ,OAAO0Q,0BAA4BA,0BAKnC1Q,OAAO2Q,2BAA6BA,2BAoEpC3Q,OAAO+J,UAAU8K,SAAW,SAAUC,SAAUC,WAAYC,SAAUzV,SAClE,IAAI0V,QAAU3U,KAAK2E,YAAY4P,SAASE,WAAYC,SAAUzV,SAG9D,OAFA0V,QAAQH,SAAWA,SACnBG,QAAQC,SAAW3V,SAAWA,QAAQ2V,SAC/BD,SAUXjV,OAAO+J,UAAUoL,UAAY,SAAUL,SAAUxK,OAAQ/K,SACrD,IAAIwU,MAAQzT,KAAKsT,SAAStJ,QAC1B,OAAOhK,KAAKuU,SAASC,SAAU,CAAE1V,KAAMkL,OAAOlL,KAAMC,GAAI0U,MAAM7D,OAC1D,CAAE9Q,KAAMkL,OAAOlL,KAAMC,GAAI0U,MAAM7H,KAAO3M,UAqB9CS,OAAO+J,UAAUqL,YAAc,SAAUN,SAAU/G,UAAWxO,SAC1DwO,UAAYA,WAAazN,KAAKiK,eAC9B,IAAI0K,QAAU3U,KAAK2E,YAAYmQ,YAAYrH,UAAWxO,SAEtD,OADA0V,QAAQH,SAAWA,SACZG,SAUXjV,OAAO+J,UAAUsL,UAAY,SAAUN,WAAYC,SAAUF,UACzD,IAAIQ,MACJ,OADYhV,KAAK2E,YAAYoQ,UAAUN,WAAYC,WAAa,IACnDO,OAAO,SAAUpI,MAC1B,OAAO2H,UAAW3H,KAAK2H,WAAaA,YAU5C9U,OAAO+J,UAAUyL,YAAc,SAAUzH,UAAW+G,UAChD,IAAIQ,MACJ,OADYhV,KAAK2E,YAAYuQ,YAAYzH,YAAc,IAC1CwH,OAAO,SAAUpI,MAC1B,OAAO2H,UAAW3H,KAAK2H,WAAaA,YAU5C9U,OAAO+J,UAAU0L,cAAgB,SAAUC,SAAUZ,UACjD,OAAOxU,KAAK+U,UAAUK,SAAU,CAAEtW,KAAMkB,KAAKgN,YAAajO,GAAI,GAAKyV,WAAa,IASpF9U,OAAO+J,UAAU4L,eAAiB,SAAUD,SAAUZ,UAClD,OAAOxU,KAAK+U,UAAU,CAAEjW,KAAM,EAAGC,GAAI,GAAKqW,SAAUZ,WAAa,IAQrE9U,OAAO+J,UAAU6L,YAAc,SAAUd,UACrC,IAAIQ,MACJ,OADYhV,KAAK2E,YAAY2Q,eAAiB,IACjCL,OAAO,SAAUpI,MAC1B,OAAO2H,UAAW3H,KAAK2H,WAAaA,YAU5C9U,OAAO+J,UAAU8L,cAAgB,SAAUf,SAAU/O,aACjD,MAAM1F,KAAOC,KAEbD,KAAK4E,YAAY6H,UAAU,WACvB,IAAIwI,MAAQjV,KAAKuV,YAAYd,UAEzB/O,aAAe+P,MAAMC,QAAQhQ,eAE7BuP,MAAQA,MAAMC,OAAO,SAAUpI,MAC3B,MAAM/M,MAAQ+M,KAAKnE,OACnB,IAAK5I,MACD,OAAO,EAGX,MAAMa,UAAYb,MAAM4V,KAAK5W,KACvB8B,QAAUd,MAAM6V,GAAG7W,KAGzB,OAAO2G,YAAYmQ,KAAK9W,MAAQA,MAAQ6B,WAAa7B,MAAQ8B,YAKrE,IAAK,IAAIiM,QAAQmI,MACbnI,KAAKC,WAYjBpN,OAAO+J,UAAUoM,eAAiB,SAAUC,UAAWC,WACnD,OAAOD,UAAUhX,OAASiX,UAAUjX,MAAQgX,UAAU/W,KAAOgX,UAAUhX,IAQ3EW,OAAO+J,UAAUuM,WAAa,WAC1B,OAAOhW,KAAK2E,YAAYqR,cAQ5BtW,OAAO+J,UAAUwM,WAAa,WAC1B,OAAOjW,KAAK2E,YAAYsR,cAQ5BvW,OAAO+J,UAAUyM,0BAA4B,SAAUC,kBACnD,MAAMC,QAAUpW,KAAKgW,aACjBI,QAAQC,MAAQD,QAAQC,KAAK1T,SAC7ByT,QAAQC,KAAKD,QAAQC,KAAK1T,OAAS,GAAGwT,iBAAmBA,kBAK7DnW,KAAK2E,YAAY2R,kBAAiB,IAStC5W,OAAO+J,UAAU8M,oBAAsB,SAAUJ,kBAC7C,MAAMC,QAAUpW,KAAKgW,aACrB,IAAKI,QAAQC,OAASD,QAAQC,KAAK1T,OAC/B,OAEJ,IAAI6T,YAAa,EACjB,IAAK,IAAI5H,EAAIwH,QAAQC,KAAK1T,OAAS,EAAGiM,GAAK,EAAGA,IAAK,CAE/C,MAAM6H,aAAeL,QAAQC,KAAKzH,GAClC,GAAI6H,aAAaN,mBAAqBA,iBAAkB,CACpDK,YAAa,EACb,OAGR,IAAKA,WACD,OAEJ,MAAMlK,GAAKtM,KAAK2E,YACV5E,KAAOC,KACbsM,GAAGE,UAAU,WACT,IAAIkK,WAAa3W,KAAKiW,aAAcW,cAChCC,gBAAkBF,WAAWL,MAAQK,WAAWL,KAAK1T,QAClDyT,QAAQC,KAAKD,QAAQC,KAAK1T,OAAS,GAC1C,KAAOiU,iBAAmBA,gBAAgBT,mBAAqBA,kBAAkB,CAK7E,GAHAQ,eADAD,WAAa3W,KAAKiW,cACSK,KAAK1T,OAChC2J,GAAGuK,gBAECF,iBADJD,WAAa3W,KAAKiW,cACeK,KAAK1T,SAElC2J,GAAGwK,OAECH,iBADJD,WAAa3W,KAAKiW,cACeK,KAAK1T,QAAQ,CAE1CoU,QAAQC,MAAM,+CACd,MAGRJ,gBAAkBF,WAAWL,MAAQK,WAAWL,KAAK1T,QAC9C+T,WAAWL,KAAKK,WAAWL,KAAK1T,OAAS,OAiB5DjD,OAAO+J,UAAUwN,aAAe,SAAUrH,MAAOhE,IAAKqD,OAAQ0B,cAAeuG,QACzElX,KAAK8L,cAAc,CAAC,CAAE8D,MAAOA,MAAOhE,IAAKA,KAAOgE,QAAUX,OAAQ0B,cAAeuG,SAUrFxX,OAAO+J,UAAU0N,iBAAmB,SAAUC,YAAaC,QACvDrX,KAAK2E,YAAYwS,iBAAiBC,YAAaC,SAWnD3X,OAAO+J,UAAU6N,kBAAoB,SAAUF,YAAaC,QACxDrX,KAAK2E,YAAY2S,kBAAkBF,YAAaC,SAapD3X,OAAO+J,UAAU8N,aAAe,SAAUH,YAAa1B,KAAMC,GAAIuB,QAC7DlX,KAAK2E,YAAY4S,aAAaH,YAAa1B,KAAMC,GAAIuB,SAmBzDxX,OAAO+J,UAAU+N,sBAAwB,SAAUC,OAAQP,QAEvD,IAAInX,KAAOC,KACXD,KAAKyM,UAAU,KACXiL,OAAOC,KAAK,CAACC,EAAGC,IACRD,EAAEjC,KAAK5W,OAAS8Y,EAAElC,KAAK5W,KAChB8Y,EAAElC,KAAK3W,GAAK4Y,EAAEjC,KAAK3W,GAEvB6Y,EAAElC,KAAK5W,KAAO6Y,EAAEjC,KAAK5W,MAIhC2Y,OAAOtM,QAAQrL,QACXC,KAAKwX,aAAazX,MAAMmN,KAAMnN,MAAM4V,KAAM5V,MAAM6V,GAAIuB,aAQhExX,OAAO+J,UAAU7G,eAAiB,WAC9B,IAAIhE,IAAMoB,KAAKiK,eACfjK,KAAKiI,aAAarJ,IAAIE,KAAMF,IAAIG,KAkBpCW,OAAO+J,UAAUqC,cAAgB,SAAUN,WAAYyD,OAAQ0B,cAAeuG,QAC1E,IAAIW,UAAYrM,WAAW7I,OAAS,EAAG1D,QACnCiY,SACAjY,QAAU,CAAEiY,OAAQA,SAExBlX,KAAK2E,YAAYmH,cAAc3P,EAAEmH,IAAIkI,WAAY,SAAUE,IAAKgG,OAI5D,OAHIhG,IAAI0G,UACJyF,UAAYnG,OAET,CAAEQ,OAAQxG,IAAImE,SAAWnE,IAAIE,IAAMF,IAAIkE,MAAOuC,KAAMzG,IAAImE,SAAWnE,IAAIkE,MAAQlE,IAAIE,OAC1FiM,UAAW5Y,SACXgQ,QACAjP,KAAKmP,eAAewB,gBAS5BjR,OAAO+J,UAAUqO,gBAAkB,SAAUC,OACzC/X,KAAK2E,YAAYmT,gBAAgBC,QAQrCrY,OAAO+J,UAAUuO,aAAe,SAAUpZ,KACtC,IAAIqZ,KAAOjY,KAAK2E,YAAYuT,WAAWtZ,KACvCoB,KAAKiX,aAAagB,KAAK/F,OAAQ+F,KAAK9F,OASxCzS,OAAO+J,UAAU0O,eAAiB,SAAUC,SAAUC,QAClD,MAAMpL,KAAOjN,KAAK2E,YAAY+J,SAAS0J,SAAUC,QACjD,OAAOpL,MASXvN,OAAO+J,UAAU6O,UAAY,SAAU1Z,KACnC,MAAM2Z,UAAYvY,KAAK2E,YAAYuT,WAAWtZ,KACxCqO,KAAOjN,KAAK2E,YAAY+J,SAAS6J,UAAUrG,OAAQqG,UAAUpG,MACnE,MAAO,CACHlF,KAAAA,KACAmL,SAAUG,UAAUrG,OACpBmG,OAAQE,UAAUpG,OAY1BzS,OAAO+J,UAAU+O,YAAc,SAAU5Z,IAAK6Z,UAAY,IAEtD,MAAMhF,MAAQzT,KAAK2E,YAAY+O,WAAW9U,KACpC8Z,kBAAoBD,UAAY,EAEtC,GAAmB,WAAfhF,MAAMkF,MAAoC,WAAflF,MAAMkF,KAAmB,CACpD,MAAMC,IAAMnF,MAAMU,OAClB,IAAIzH,KAAO9N,IAAIG,GAAK0U,MAAM7D,MACtBiJ,MAAQnM,KACRoM,qBAAsB,EACtBC,WAAa,EAGjB,KAAOrM,KAAO,GAAK,GAAK,UAAYb,KAAK+M,IAAIlM,KAAO,KAAOqM,WAAaL,mBAAmB,CAEvF,GAAsB,MAAlBE,IAAIlM,KAAO,IAAeoM,oBAEvB,CAAA,GAAsB,MAAlBF,IAAIlM,KAAO,IAAcoM,oBAChC,MACG,GAAsB,MAAlBF,IAAIlM,KAAO,GAAY,CAC9BA,OACA,YALAoM,qBAAsB,EAO1BC,aACArM,OAIJ,KAAOmM,MAAQD,IAAIjW,QAAU,QAAUkJ,KAAK+M,IAAIC,SAAWE,WAAaL,mBAAmB,CAEvF,GAAmB,MAAfE,IAAIC,QAAmBC,qBAEpB,GAAmB,MAAfF,IAAIC,QAAkBC,oBAC7B,WAFAA,qBAAsB,EAI1BC,aACAF,QAIJ,GAAInM,OAASmM,OAASE,aAAeL,kBAAmB,CACpD,MAAMzL,KAAO2L,IAAII,UAAUtM,KAAMmM,OACjC,GAAa,MAAT5L,MAAyB,MAATA,KAChB,MAAO,CACHA,KAAM2L,IAAII,UAAUtM,KAAMmM,OAC1BT,SAAU,CAAEtZ,KAAMF,IAAIE,KAAMC,GAAI0U,MAAM7D,MAAQlD,MAC9C2L,OAAQ,CAAEvZ,KAAMF,IAAIE,KAAMC,GAAI0U,MAAM7D,MAAQiJ,SAM5D,OAAO,MAOXnZ,OAAO+J,UAAUuD,UAAY,WACzB,OAAOhN,KAAK2E,YAAYqI,aAQ5BtN,OAAO+J,UAAUwP,cAAgB,SAAUna,MACvC,IAAIoa,OAASlZ,KAAK2E,YAAY0O,WAAW,CAAEvU,KAAMA,KAAMC,GAAI,GAAK,SAC5Doa,WAAanZ,KAAK2E,YAAYyD,gBAC9BC,IAAM8Q,WAAW9Q,IACjB6I,OAASiI,WAAW9Q,IAAM8Q,WAAW5H,aAGzC,OAAQ2H,OAAO7Q,KAAOA,KAAO6Q,OAAOhI,QAAUA,QAOlDxR,OAAO+J,UAAU2P,oBAAsB,WACnC,OAAQpZ,KAAKU,cAAgBV,KAAKU,cAAcC,UAAY,GAOhEjB,OAAO+J,UAAU4P,mBAAqB,WAClC,OAAQrZ,KAAKU,cAAgBV,KAAKU,cAAcE,QAAUZ,KAAKgN,YAAc,GAUjFtN,OAAO+J,UAAUsD,WAAa,SAAU2I,KAAMC,IAS1C,IAAI2D,MARJ,KAAI3D,IAAMD,MAcV,OANY1V,KAAK2E,YAAY4P,SACzB,CAAEzV,KAAM4W,KAAM3W,GAAI,GAClB,CAAED,KAAM6W,GAAK,EAAG5W,GAAIiB,KAAK2E,YAAYgH,QAAQgK,GAAK,GAAGhT,QACrD,CAAE4W,WAAW,EAAM9I,eAAe,EAAMC,gBAAgB,EAAMF,gBAAgB,KAUtF9Q,OAAO+J,UAAU+P,YAAc,WAC3B,OAAOxZ,KAAK8Q,qBAAqB2I,cAOrC/Z,OAAO+J,UAAUqH,mBAAqB,WAClC,OAAO9Q,KAAK2E,YAAYmM,sBAO5BpR,OAAO+J,UAAUnB,eAAiB,WAC9B,OAAOtI,KAAK2E,YAAY6B,qBAW5B9G,OAAO+J,UAAUiQ,qBAAuB,WACpC,OAAOlZ,EAAE,oBAAqBR,KAAK8Q,sBAAsB6I,WAAWrZ,IAAI,IAO5EZ,OAAO+J,UAAUkE,aAAe,WAC5B,IAAIwL,WAAanZ,KAAK2E,YAAYyD,gBAClC,MAAO,CAAE6F,EAAGkL,WAAWzM,KAAMwB,EAAGiL,WAAW9Q,MAQ/C3I,OAAO+J,UAAUmQ,gBAAkB,SAAUlM,UAAWmM,aACpD7Z,KAAK2E,YAAY8H,SAASiB,UAAUO,EAAGP,UAAUQ,EAAI2L,cAQzDna,OAAO+J,UAAUuE,aAAe,SAAUC,EAAGC,GACzClO,KAAK2E,YAAY8H,SAASwB,EAAGC,IAOjCxO,OAAO+J,UAAUqQ,cAAgB,WAC7B,OAAO9Z,KAAK2E,YAAYoV,qBAY5Bra,OAAO+J,UAAUuQ,gBAAkBpd,mBAAmBod,gBAKtDta,OAAO+J,UAAU3G,uBAAyBlG,mBAAmBkG,uBAO7DpD,OAAO+J,UAAUwQ,mBAAqBrd,mBAAmBqd,mBAMzDva,OAAO+J,UAAUyQ,8BAAgCtd,mBAAmBsd,8BAOpExa,OAAO+J,UAAUS,2BAA6BtN,mBAAmBsN,2BAOjExK,OAAO+J,UAAU0Q,iBAAmBvd,mBAAmBud,iBAMvDza,OAAO+J,UAAUU,uBAAyBvN,mBAAmBuN,uBAQ7DzK,OAAO+J,UAAU2Q,sBAAwBxd,mBAAmBwd,sBAS5D1a,OAAO+J,UAAU4Q,4BAA8B1d,iBAAiB0d,4BAShE3a,OAAO+J,UAAU6Q,wBAA0B,WACvC,IAAIC,WAAava,KAAK0Z,uBAAuBc,UACzCC,SAAWza,KAAK8Q,qBACpB,OAAOtQ,EAAEia,UAAUC,SAASrS,IAAMoS,SAASlR,UAAYgR,YAI3D7a,OAAO+J,UAAUkR,MAAQ,WAMrB,IAAIpc,aAAJ,CAIAA,cAAe,EACf,IACIyB,KAAK2E,YAAYgW,QACnB,QACEpc,cAAe,KAKvBmB,OAAO+J,UAAUmR,SAAW,WACxB,OAAO5a,KAAKkH,UAWhBxH,OAAO+J,UAAUoR,aAAe,WAC5B,MAAO,CACHrP,WAAYxL,KAAK0C,gBACjBgL,UAAW1N,KAAK2N,iBASxBjO,OAAO+J,UAAUqR,iBAAmB,SAAUC,WACtCA,UAAUC,WAGVhb,KAAKiX,aAAa8D,UAAUC,UAAUpL,MAAOmL,UAAUC,UAAUpP,KAEjEmP,UAAUvP,YACVxL,KAAK8L,cAAciP,UAAUvP,YAE7BuP,UAAUrN,WACV1N,KAAKgO,aAAa+M,UAAUrN,UAAUO,EAAG8M,UAAUrN,UAAUQ,IAQrExO,OAAO+J,UAAUoE,QAAU,SAAUoN,cAIjC,IAAIC,YAAcC,OAAOxb,SAASyb,cAC9BC,aAAe7a,EAAE8a,SAAStb,KAAK2E,YAAYmM,qBAAsBoK,aACrElb,KAAK2E,YAAYkJ,UACbwN,cACAH,YAAYP,SAQpBjb,OAAO+J,UAAU8R,WAAa,SAAUN,cACpCjb,KAAK6N,QAAQoN,cACbjb,KAAKma,mBAAmBhP,QAAQ,SAAUC,cACtCA,aAAayC,aAKrBnO,OAAO+J,UAAUqN,KAAO,WACpB9W,KAAK2E,YAAYmS,QAIrBpX,OAAO+J,UAAU+R,KAAO,WACpBxb,KAAK2E,YAAY6W,QASrB9b,OAAO+J,UAAUgS,uBAAyB,SAAUC,KAAM7N,SAClD6N,OAAS7N,cAAuBrO,IAAZqO,UACpB7N,KAAK6N,UAEL6N,MACA1b,KAAKqB,eAAe8J,QAAQ,SAAUC,cAClCA,aAAauQ,mBAWzBjc,OAAO+J,UAAUmS,WAAa,SAAUF,KAAM7N,SAC1C7N,KAAKwI,IAAIqT,IAAI,UAAYH,KAAO,GAAK,QACrC1b,KAAKyb,uBAAuBC,KAAM7N,UAOtCnO,OAAO+J,UAAUqS,eAAiB,WAC9B,OAAOtb,EAAER,KAAKsI,kBAAkByT,GAAG,aAiBvCrc,OAAO+J,UAAUuS,gBAAkB,SAAUpM,MAAOhE,IAAKqQ,YACrD,IAAIC,UAAYlc,KAAK2E,YAAYN,UAC7B8X,UAAYpgB,WAAWqgB,UAAUpc,KAAK2E,YAAaiL,OACnDyM,QAAUtgB,WAAWqgB,UAAUpc,KAAK2E,YAAaiH,KACrD,OAAKqQ,YAAcC,UAAU5X,OAAS6X,UAAU7X,KAGpC6X,WAAcE,SAAWF,UAAU7X,OAAS+X,QAAQ/X,KAGzD6X,UAFI,KAFAnc,KAAK2E,YAAY2X,UAAU,SAqB1C5c,OAAO+J,UAAU8S,oBAAsB,SAAUvB,WAE7C,IAAIjb,KAAOC,KACPwc,KAAOxB,UAAY,CAACA,WAAahb,KAAK0C,gBACtCqP,WAAaiJ,WAAahb,KAAK8R,eAC/BoK,UAAYlc,KAAK2E,YAAYN,UAC7B8X,UAAYpgB,WAAWqgB,UAAUpc,KAAK2E,YAAaoN,WAAWnC,OAC9D6M,QAEJ,GAFeP,UAAU5X,OAAS6X,UAAU7X,KAE/B,CAMT,GAAuB,cAAnB4X,UAAU5X,MAAwByN,WAAWnC,MAAM9Q,OAASiT,WAAWnG,IAAI9M,MAAQiT,WAAWnC,MAAM7Q,KAAOgT,WAAWnG,IAAI7M,GAAI,CAC9H,IAAI2d,QAAU1gB,UAAU2gB,WAAW3c,KAAM+R,WAAWnC,OAAO,GACvDgN,UAEJ,GAFgBF,QAAQtH,SAASwH,YAEf5gB,UAAU6gB,YAAkD,UAApCH,QAAQI,KAAKxY,KAAKyY,cACxD,MAAO,MAIf,GAAIhL,WAAWnC,MAAM9Q,OAASiT,WAAWnG,IAAI9M,MAAQiT,WAAWnC,MAAM7Q,KAAOgT,WAAWnG,IAAI7M,GAAI,CAC5F,IAAIsd,QAAUtgB,WAAWqgB,UAAUpc,KAAK2E,YAAaoN,WAAWnG,KAEhE,GAAIuQ,UAAU7X,OAAS+X,QAAQ/X,KAC3B,OAAO,KAKf,IAAI0Y,YASJ,OATkB7gB,EAAEyZ,KAAK4G,KAAM,SAAU9Q,KACrC,GAAI8Q,OAASzK,WAET,OAAO,EAGX,IAAIkL,UAAYld,KAAKic,gBAAgBtQ,IAAIkE,MAAOlE,IAAIE,KAAK,GACzD,OAASqR,WAAaA,UAAU3Y,OAAS6X,UAAU7X,OAG5C,KAGJ6X,UAAU7X,KAGrB,OAAOtE,KAAK2E,YAAY2X,UAAU,SAStC5c,OAAO+J,UAAUyT,wBAA0B,WACvC,OAAOld,KAAKL,SAASyM,cAAc+Q,mBAAmBnd,KAAKuc,wBAQ/D7c,OAAO+J,UAAU2T,uBAAyB,SAAUxe,KAChD,IAAImB,KAAOC,KAEX,OADApB,IAAMA,KADKoB,KACOiK,eACXjK,KAAKL,SAASyM,cAAc+Q,mBAFxBnd,KAEgDuc,oBAAoB,CAAE3M,MAAOhR,IAAKgN,IAAKhN,QAStGc,OAAO+J,UAAU4T,mBAAqB,WAClC,OAAOrd,KAAK2E,YAAY2X,UAAU,SAOtC5c,OAAO+J,UAAU9J,SAAW,KAU5BD,OAAO+J,UAAUjI,iBAAmB,KASpC9B,OAAO+J,UAAU5B,aAAc,EAS/BnI,OAAO+J,UAAU9E,YAAc,KAM/BjF,OAAO+J,UAAUpI,eAAiB,KAMlC3B,OAAO+J,UAAU/I,cAAgB,KAOjChB,OAAO+J,UAAUnI,oBAAsB,KAOvC5B,OAAO+J,UAAUlI,WAAa,KAU9B7B,OAAO+J,UAAUjG,WAAa,SAAUD,UACpC,OAAO3H,mBAAmB0E,IAAIiD,SAAU3H,mBAAmByD,cAAcW,KAAKL,SAAS4K,KAAKnL,SAAUY,KAAKL,SAASyM,cAAc7M,WAItI,MAAM+d,gBAAkB,IAAIC,IAAI,CAC5B3f,gBACAC,aACAJ,YACAE,WASJ+B,OAAO+J,UAAU+T,cAAgB,SAAUja,UACvC,IAAIka,SAAWzd,KAAKoD,gBAAgBG,UAChCma,SAAW1d,KAAKwD,WAAWD,UAE/B,MAAMnE,SAAWY,KAAKL,SAAS4K,KAAKnL,SACpC,GAAIke,gBAAgBK,IAAIpa,UAAW,CAC/B,MAAMqa,eAAiBle,OAAOme,iBAAiBze,UAC3Cwe,gBACAE,kBAAkB9d,MAEtB,MAAM+d,iBAAmBre,OAAOse,cAAc5e,UACxC6e,cAAgBve,OAAOwe,cAAc9e,UACrC+e,WAAaze,OAAOmP,WAAWzP,UAC/Bgf,YAAc1e,OAAO2e,gBAAgBjf,UAC3C,GAAIY,KAAKoD,gBAAgBxF,mBAAqBggB,gBAC1C5d,KAAKoD,gBAAgBvF,gBAAkBkgB,kBACvC/d,KAAKoD,gBAAgB3F,eAAiBwgB,eACtCje,KAAKoD,gBAAgBzF,YAAcwgB,WAAY,CAE/C,MAAMG,kBAAoBte,KAAK2E,YAAY2X,UAAU,cACrD,IAAIiC,mBAUJ,GAAID,qBARAC,mBADAX,eACqBG,iBACjBK,YAAcpe,KAAKoD,gBAAgBzF,UACnCqC,KAAKoD,gBAAgB3F,aAEJsgB,iBACjB/d,KAAKoD,gBAAgBzF,UACrBqC,KAAKoD,gBAAgB3F,cAGzB,OA0BR,OAvBAuC,KAAKoD,gBAAgBxF,iBAAmBggB,eACxC5d,KAAKoD,gBAAgBvF,cAAgBkgB,iBACrC/d,KAAKoD,gBAAgB3F,aAAewgB,cACpCje,KAAKoD,gBAAgBzF,UAAYwgB,WACjCne,KAAK2E,YAAYiD,UAAU9K,UAAUe,cAAekgB,kBAChDH,eACIG,kBACA/d,KAAK2E,YAAYiD,UAAU9K,UAAUa,UAAWqC,KAAKoD,gBAAgBzF,WACrEqC,KAAK2E,YAAYiD,UAAU,aAAcwW,YAAcpe,KAAKoD,gBAAgBzF,aAE5EqC,KAAK2E,YAAYiD,UAAU9K,UAAUa,UAAWqC,KAAKoD,gBAAgBzF,WACrEqC,KAAK2E,YAAYiD,UAAU,aAAc5H,KAAKoD,gBAAgB3F,gBAGlEuC,KAAK2E,YAAYiD,UAAU,cAAmC,IAArBmW,iBACrC/d,KAAKoD,gBAAgBzF,UACrBqC,KAAKoD,gBAAgB3F,cAEzBuC,KAAK2E,YAAYiD,UAAU9K,UAAUa,UAAWqC,KAAKoD,gBAAgBzF,YAEzEqC,KAAK2E,YAAYiD,UAAU9K,UAAUe,cAAekgB,kBACpD/d,KAAKyK,QAAQ,eAAgB7M,gBAAiBggB,qBAC9C5d,KAAKyK,QAAQ,eAAgB5M,aAAckgB,kBAI/C,GAAIN,WAAaC,SAAU,CAGvB,GAFA1d,KAAKoD,gBAAgBG,UAAYma,SAE7Bna,WAAa7F,kBACbsC,KAAKsL,6BACF,CAAA,GAAI/H,WAAalG,iBAAmB2C,KAAKU,cAE5C,OACO6C,WAAahG,mBACpBmC,OAAO8e,oBAAoBd,UAC3B1d,KAAK2E,YAAYiD,UAAU9K,UAAUS,mBAAoBmgB,UACrDA,SACAhe,OAAO+e,eAAexgB,mBAAoBC,6BAE1CwB,OAAOgf,iBAAiBzgB,oBAE5B+B,KAAKub,cAELvb,KAAK2E,YAAYiD,UAAU9K,UAAUyG,UAAWma,UAGpD1d,KAAKyK,QAAQ,eAAgBlH,SAAUma,YAS/Che,OAAO+J,UAAU6B,uBAAyB,WAClCtL,KAAK6C,eACD7C,KAAK2E,YAAY2X,UAAU,oBAC3Btc,KAAK2E,YAAYiD,UAAU,mBAAmB,GAGlD5H,KAAK2E,YAAYiD,UAAU,kBAAmB5H,KAAKoD,gBAAgB1F,qBAU3EgC,OAAO+J,UAAUkV,aAAe,SAAUC,cACtC,IAAIC,QAAU7e,KAAKsI,iBACfwW,SAAWte,EAAEqe,SAASxP,QACtB0P,cACAC,aADgBhf,KAAKwI,IAAIyW,SACI3P,SAE5BuP,QAAQK,MAAM5P,QAAU9O,EAAEqe,SAASvP,WAAa0P,aAO1CF,WAAa9e,KAAKwB,uBACJhC,IAAjBof,eACAA,cAAe,IANnB5e,KAAKoP,QAAQ,KAAM4P,mBACExf,IAAjBof,eACAA,cAAe,IAOvB5e,KAAKwB,iBAAmBsd,SAEpBF,cACA5e,KAAKub,WAAWqD,eAIxBlf,OAAO+J,UAAU0V,sBAAwB,WACrC,MAAMC,WAAapf,KAAKL,SAASyM,cAAc7M,QAE/C,SAAS8f,mBAAmBC,QACxB,OAAQA,OAAOC,WAAaD,OAAOC,UAAU3U,QAAQwU,aAAe,EAGxE,SAASI,gBAAgB7H,EAAGC,GACxB,OAAOD,EAAE8H,SAAW7H,EAAE6H,SAG1B,SAASC,SAASJ,QACd,OAAOA,OAAOhb,KAMlB,MAAMqb,QAAU9iB,kBAAkByG,IAAIoc,UAKtC,OAJIC,QAAQ/U,QAAQ3M,oBAAsB,GAAK+B,KAAK2E,YAAY2X,UAAUxf,UAAUS,qBAChFV,kBAAkBsD,KAAK,CAAEmE,KAAMrG,mBAAoBwhB,SAAUvhB,8BAGzDrB,kBAAkB6a,KAAK8H,iBAC1BvK,OAAOoK,oBACP/b,IAAIoc,WAObhgB,OAAO+J,UAAUrC,eAAiB,WAC9B,MAAMwY,YAAc5f,KAAKsI,iBACnBqX,QAAU3f,KAAKmf,wBAErBnf,KAAK2E,YAAYiD,UAAU,UAAW+X,SACtC3f,KAAK2E,YAAYkJ,UAEb8R,QAAQ/U,QAAQ3M,oBAAsB,EACtCuC,EAAEof,aAAanf,SAAS,uBAExBD,EAAEof,aAAaC,YAAY,wBAYnCngB,OAAO+J,UAAUqW,gBAAkB,SAAUjM,WAAYkM,WAAYC,QACjE,GAAKtgB,OAAOugB,mBAAmBF,YAK/B,OAAO/f,KAAK2E,YAAYmb,gBAAgBjM,WAAYkM,WAAYC,QAJ5DjJ,QAAQmJ,KAAK,yEAYrBxgB,OAAO+J,UAAU0W,gBAAkB,SAAUtM,WAAYkM,YACrD,IAAKrgB,OAAOugB,mBAAmBF,YAE3B,YADAhJ,QAAQmJ,KAAK,wEAGjB,IAAIE,SAAWpgB,KAAK2E,YAAYyb,SAASvM,YACrCwM,cACJ,OADoBD,UAAYA,SAASC,eAAiB,IACrCN,aASzBrgB,OAAO+J,UAAU6W,kBAAoB,SAAUzM,WAAYkM,YACvD/f,KAAK8f,gBAAgBjM,WAAYkM,WAAY,OAQjDrgB,OAAO+J,UAAU8W,eAAiB,SAAUR,YACxC,MAAMJ,QAAU3f,KAAKmf,wBACrB,OAAOQ,QAAQa,SAAST,aAO5BrgB,OAAO+J,UAAUgX,YAAc,SAAUV,YAChCrgB,OAAOugB,mBAAmBF,YAI/B/f,KAAK2E,YAAY8b,YAAYV,YAHzBhJ,QAAQmJ,KAAK,qEAWrBxgB,OAAO+J,UAAUiX,eAAiB,WAC9B,MAAMC,kBAAoBjhB,OAAOkhB,qBAAqB5gB,KAAKL,SAAS4K,KAAKnL,UACzEY,KAAK2E,YAAYkc,cAAc,CAC3BC,OAAQH,qBAQhBjhB,OAAOqhB,qBAAuB,WAC1B,OAAOlkB,mBAQX6C,OAAOugB,mBAAqB,SAAUF,YAClC,OAAOljB,kBAAkB+Y,KAAK,SAAU0J,QACpC,OAAOA,OAAOhb,OAASyb,cAU/BrgB,OAAO+e,eAAiB,SAAUna,KAAMmb,SAAUuB,aAM9C,GALIC,MAAMxB,YACN1I,QAAQmJ,KAAK,2FACbT,SAAW,GAGVnb,MAAwB,iBAATA,KAApB,CAKA,IAAIgb,OAAS,CAAEhb,KAAMA,KAAMmb,SAAUA,SAAUF,UAAWyB,aACtDE,aAAerkB,kBAAkB+Y,KAAK,SAAU0J,QAC5C,OAAOA,OAAOhb,OAASA,QAI3BzH,kBAAkBsD,KAAKmf,QAG3B5f,OAAOyhB,eAAe,SAAU9Z,QAC5BA,OAAOD,wBAdP2P,QAAQC,MAAM,wDAsBtBtX,OAAOgf,iBAAmB,SAAUpa,MAChC,IAAIsK,EAAG0Q,OACPziB,kBAAoBA,kBAAkBoY,OAAO,SAAUqK,QACnD,OAAOA,OAAOhb,OAASA,OAG3B5E,OAAOyhB,eAAe,SAAU9Z,QAC5BA,OAAOD,oBAKf,IAAIga,kBAAoB,IAAIC,IAC5B,SAASC,mBAAmBC,KAGxB,IAAIC,UAAYplB,sBAAsBkE,IAAIihB,KAC1C,OAAIC,WAGGJ,kBAAkB9gB,IAAIihB,KAUjC7hB,OAAO+hB,cAAgB,SAAUnI,MAAOla,UACpC,IAAIsiB,eAAiBJ,mBAAmBliB,UACxC,GAAIM,OAAOme,iBAAiBze,WAAasiB,eAOrC,OANAA,eAAeC,WAAarI,MAE5Bld,sBAAsBwlB,IAAIxiB,SAAUsiB,gBACpChiB,OAAOyhB,eAAe9Z,SAClBA,OAAOmW,cAAc3f,eACtBuB,WACI,EAEX,IAAIH,QAAUG,UAAY,CAAEyiB,QAASziB,UACrC,OAAOxD,mBAAmBgmB,IAAI/jB,aAAcyb,MAAOra,UAQvDS,OAAOse,cAAgB,SAAU5e,UAC7B,IAAIsiB,eAAiBJ,mBAAmBliB,UACxC,OAAIM,OAAOme,iBAAiBze,WAAasiB,eAC9BA,eAAeC,WAEnB/lB,mBAAmB0E,IAAIzC,aAAcsB,yBAAyBC,YAUzEM,OAAOoiB,WAAa,SAAUxI,MAAOla,UACjC,IAAIsiB,eAAiBJ,mBAAmBliB,UACxC,GAAIM,OAAOme,iBAAiBze,WAAasiB,eASrC,OARIjlB,kBAAkBslB,eAAezI,SACjCoI,eAAerb,QAAUiT,MAEzBld,sBAAsBwlB,IAAIxiB,SAAUsiB,gBACpChiB,OAAOyhB,eAAe9Z,SAClBA,OAAOmW,cAAc7f,WACtByB,YAEA,EAEX,IAAIH,QAAUG,UAAY,CAAEyiB,QAASziB,UACrC,OAAOxD,mBAAmBgmB,IAAIjkB,SAAU2b,MAAOra,UAQnDS,OAAOmP,WAAa,SAAUzP,UAC1B,IAAIsiB,eAAiBJ,mBAAmBliB,UACxC,OAAIM,OAAOme,iBAAiBze,WAAasiB,gBAAkBA,eAAerb,QAC/Dqb,eAAerb,QAEnBzK,mBAAmB0E,IAAI3C,SAAUwB,yBAAyBC,YAQrEM,OAAO2e,gBAAkB,SAAUjf,UAC/B,IAAIsiB,eAAiBJ,mBAAmBliB,UACxC,OAAIM,OAAOme,iBAAiBze,WAAasiB,gBAAkBA,eAAeM,SAC/DN,eAAeM,SAEnBvlB,kBAAkBwlB,iBAG7B,MAAMC,6BAA+B,IACrC,SAASpE,kBAAkBzW,OAAQ8a,aAAcC,WAC7C,MAAMhjB,SAAWiI,OAAO1H,SAAS4K,KAAKnL,SACtC,GAAIkiB,mBAAmBliB,YAAcgjB,UACjC,OAGJ,MAAMC,aAAehb,OAAOib,cAAcH,kBAAe3iB,EAAY0iB,8BAC/DP,WAAoC,QAAtBU,aAAa1J,KACjC,IAAI4J,OAASF,aAAaE,OACrBF,aAAa1J,MAAS4J,SAEvBA,OAAS9lB,kBAAkB+lB,qBAE/BpmB,sBAAsBwlB,IAAIxiB,SAAU,MACpCgiB,kBAAkBQ,IAAIxiB,SAAU,CAC5BuiB,WAAAA,WACAtb,QAAS5J,kBAAkBgmB,iBAC3BC,WAAYf,WAAa,EAAIvQ,KAAKC,IAAIkR,OAAQ9lB,kBAAkBkmB,iBAChEX,SAAUL,WAAavQ,KAAKC,IAAIkR,OAAQ9lB,kBAAkBmmB,oBAAsB,IAGxFljB,OAAOmjB,qBAAuB,SAAUxb,OAAQ8a,aAAcC,WAC1D,IAAK/a,OACD,OAEJ,MAAMjI,SAAWiI,OAAO1H,SAAS4K,KAAKnL,SACjCM,OAAOme,iBAAiBze,aAGzBkiB,mBAAmBliB,WAAcgjB,WAIrCtE,kBAAkBzW,OAAQ8a,aAAcC,WACxC/a,OAAOmW,cAAc5f,kBAJjByJ,OAAOmW,cAAc5f,mBAc7B8B,OAAOojB,iBAAmB,SAAUxJ,MAAOla,UACvC,MAAMH,QAAUG,UAAY,CAAEyiB,QAASziB,UACvC,OAAOxD,mBAAmBgmB,IAAIhkB,gBAAiB0b,MAAOra,UAQ1DS,OAAOme,iBAAmB,SAAUze,UAChC,OAAOxD,mBAAmB0E,IAAI1C,gBAAiBuB,yBAAyBC,YAU5EM,OAAOqjB,cAAgB,SAAUzJ,MAAOla,UACpC,IAAIsiB,eAAiBJ,mBAAmBliB,UACxC,GAAIM,OAAOme,iBAAiBze,WAAasiB,eASrC,OARIjlB,kBAAkBumB,iBAAiB1J,SACnCoI,eAAegB,WAAapJ,MAE5Bld,sBAAsBwlB,IAAIxiB,SAAUsiB,gBACpChiB,OAAOyhB,eAAe9Z,SAClBA,OAAOmW,cAAc/f,cACtB2B,YAEA,EAEX,IAAIH,QAAUG,UAAY,CAAEyiB,QAASziB,UACrC,OAAOxD,mBAAmBgmB,IAAInkB,YAAa6b,MAAOra,UAQtDS,OAAOwe,cAAgB,SAAU9e,UAC7B,IAAIsiB,eAAiBJ,mBAAmBliB,UACxC,OAAIM,OAAOme,iBAAiBze,WAAasiB,gBAAkBA,eAAegB,WAC/DhB,eAAegB,WAEnB9mB,mBAAmB0E,IAAI7C,YAAa0B,yBAAyBC,YAUxEM,OAAOujB,iBAAmB,SAAU3J,MAAOla,UACvC,IAAIH,QAAUG,UAAY,CAAEyiB,QAASziB,UACrC,OAAOxD,mBAAmBgmB,IAAI5kB,eAAgBsc,MAAOra,UAQzDS,OAAOwjB,iBAAmB,SAAU9jB,UAChC,OAAOxD,mBAAmB0E,IAAItD,eAAgBmC,yBAAyBC,YAU3EM,OAAOyjB,mBAAqB,SAAU7J,MAAOla,UACzC,IAAIH,QAAUG,UAAY,CAAEyiB,QAASziB,UACrC,OAAOxD,mBAAmBgmB,IAAIrkB,kBAAmB+b,MAAOra,UAQ5DS,OAAO0jB,mBAAqB,SAAUhkB,UAClC,OAAOxD,mBAAmB0E,IAAI/C,kBAAmB4B,yBAAyBC,YAU9EM,OAAO2jB,kBAAoB,SAAU/J,MAAOla,UACxC,OAAOxD,mBAAmBgmB,IAAIlkB,kBAAmB4b,QAQrD5Z,OAAO4jB,kBAAoB,SAAUlkB,UACjC,OAAOxD,mBAAmB0E,IAAI5C,kBAAmByB,yBAAyBC,YAU9EM,OAAO6jB,YAAc,SAAUjK,MAAOla,UAClC,IAAIH,QAAUG,UAAY,CAAEyiB,QAASziB,UACrC,OAAOxD,mBAAmBgmB,IAAI9jB,UAAWwb,MAAOra,UAQpDS,OAAO8jB,YAAc,SAAUpkB,UAC3B,OAAOxD,mBAAmB0E,IAAIxC,UAAWqB,yBAAyBC,YAUtEM,OAAO+jB,qBAAuB,SAAUnK,MAAOla,UAC3C,IAAIH,QAAUG,UAAY,CAAEyiB,QAASziB,UACrC,OAAOxD,mBAAmBgmB,IAAI7jB,oBAAqBub,MAAOra,UAQ9DS,OAAOkhB,qBAAuB,SAAUxhB,UACpC,OAAOxD,mBAAmB0E,IAAIvC,oBAAqBoB,yBAAyBC,YAShFM,OAAOyhB,eAAiB,SAAUuC,SAAUtkB,UACxCK,WAAW0L,QAAQ,SAAU9D,QACpBjI,SAEMiI,OAAO1H,SAAS4K,KAAKnL,WAAaA,UACzCskB,SAASrc,QAFTqc,SAASrc,WAcrB3H,OAAO8e,mBAAqB,SAAUmF,iBAElC,IAAIC,SAAW,GACfnkB,WAAW0L,QAAQ,SAAU9D,QACzB,IAAI0X,cAAgB1X,OAAOmB,IAAIyW,UACU,IAArC2E,SAAShZ,QAAQmU,gBACjB6E,SAASzjB,KAAK4e,iBAItB5iB,EAAEyW,KAAKgR,SAAU,SAAUC,SACvBA,QAAQpf,YAAY,oBAAqBC,QAAQif,qBAIzDjkB,OAAOxB,4BAA8BA,4BACrCwB,OAAOvB,6BAA+BA,6BAiCtCuB,OAAOokB,oBAAsB,eAC7BpkB,OAAOqkB,aAAe,SACtBrkB,OAAOskB,8BAAgC,wBACvCtkB,OAAOukB,sBAAwB,iBAC/BvkB,OAAOwkB,gBAAkB,WACzBxkB,OAAOykB,eAAiB,UACxBzkB,OAAO0kB,aAAe,QACtB1kB,OAAO2kB,YAAc,QACrB3kB,OAAO4kB,WAAa,OACpB5kB,OAAO6kB,aAAe,SACtB7kB,OAAO8kB,aAAe,SACtB9kB,OAAO+kB,uBAAyB,iBAChC/kB,OAAOglB,mBAAqB,cAC5BhlB,OAAOilB,oBAAsB,eAG7BvmB,cAAc+M,QAAQ,SAAU5H,UAC5B3H,mBAAmBsF,GAAG,SAAUqC,SAAU,WACtC9D,WAAW0L,QAAQ,SAAU9D,QACzBA,OAAOmW,cAAcja,gBAMjCnI,QAAQsE,OAASA,OACjBtE,QAAQoD,sBA78FsB,EA88F9BpD,QAAQqD,oBAAsBA,oBAC9BrD,QAAQsD,kBAn8FkB","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n// @INCLUDE_IN_API_DOCS\n\n/**\n * Editor is a 1-to-1 wrapper for a CodeMirror editor instance. It layers on Brackets-specific\n * functionality and provides APIs that cleanly pass through the bits of CodeMirror that the rest\n * of our codebase may want to interact with. An Editor is always backed by a Document, and stays\n * in sync with its content; because Editor keeps the Document alive, it's important to always\n * destroy() an Editor that's going away so it can release its Document ref.\n *\n * For now, there's a distinction between the \"master\" Editor for a Document - which secretly acts\n * as the Document's internal model of the text state - and the multitude of secondary Editors\n * which, via Document, sync their changes to and from that master.\n *\n * For now, direct access to the underlying CodeMirror object is still possible via `_codeMirror` --\n * but this is considered deprecated and may go away.\n *\n * The Editor object dispatches the following events: (available as `Editor.EVENT_*` constants. see below)\n *    - keydown, keypress, keyup -- When any key event happens in the editor (whether it changes the\n *      text or not). Handlers are passed `(BracketsEvent, Editor, KeyboardEvent)`. The 3nd arg is the\n *      raw DOM event. Note: most listeners will only want to listen for \"keypress\".\n *    - change - Triggered with an array of change objects. Parameters: (editor, changeList)\n *    - beforeChange - (self, changeObj)\n *    - beforeSelectionChange - (selectionObj)\n *    - focus - Fired when an editor is focused\n *    - blur - Fired when an editor loses focused\n *    - update - Will be fired whenever Editor updates its DOM display.\n *    - cursorActivity -- When the user moves the cursor or changes the selection, or an edit occurs.\n *      Note: do not listen to this in order to be generally informed of edits--listen to the\n *      \"change\" event on Document instead.\n *    - scroll -- When the editor is scrolled, either by user action or programmatically.\n *    - viewportChange - (from: number, to: number) Fires whenever the view port of the editor changes\n *      (due to scrolling, editing, or any other factor). The from and to arguments give the new start\n *      and end of the viewport. This is combination with `editorInstance.getViewPort()` can be used to\n *      selectively redraw visual elements in code like syntax analyze only parts of code instead\n *      of the full code everytime.\n *    - lostContent -- When the backing Document changes in such a way that this Editor is no longer\n *      able to display accurate text. This occurs if the Document's file is deleted, or in certain\n *      Document->editor syncing edge cases that we do not yet support (the latter cause will\n *      eventually go away).\n *    - optionChange -- Triggered when an option for the editor is changed. The 2nd arg to the listener\n *      is a string containing the editor option that is changing. The 3rd arg, which can be any\n *      data type, is the new value for the editor option.\n *    - beforeDestroy - Triggered before the object is about to dispose of all its internal state data\n *      so that listeners can cache things like scroll pos, etc...\n *\n * The Editor also dispatches \"change\" events internally, but you should listen for those on\n * Documents, not Editors.\n *\n * To listen for events, do something like this: (see EventDispatcher for details on this pattern)\n *     `editorInstance.on(\"eventname\", handler);`\n */\ndefine(function (require, exports, module) {\n\n\n    let CommandManager = require(\"command/CommandManager\"),\n        Commands = require(\"command/Commands\"),\n        CodeMirror = require(\"thirdparty/CodeMirror/lib/codemirror\"),\n        LanguageManager = require(\"language/LanguageManager\"),\n        EventDispatcher = require(\"utils/EventDispatcher\"),\n        PerfUtils = require(\"utils/PerfUtils\"),\n        PreferencesManager = require(\"preferences/PreferencesManager\"),\n        StateManager = require(\"preferences/StateManager\"),\n        TextRange = require(\"document/TextRange\").TextRange,\n        TokenUtils = require(\"utils/TokenUtils\"),\n        HTMLUtils = require(\"language/HTMLUtils\"),\n        MainViewManager = require(\"view/MainViewManager\"),\n        Metrics = require(\"utils/Metrics\"),\n        _ = require(\"thirdparty/lodash\");\n\n    const tabSpacesStateManager = StateManager._createInternalStateManager(StateManager._INTERNAL_STATES.TAB_SPACES);\n\n    /* Editor helpers */\n\n    let IndentHelper = require(\"./EditorHelper/IndentHelper\"),\n        EditorPreferences = require(\"./EditorHelper/EditorPreferences\"),\n        ChangeHelper = require(\"./EditorHelper/ChangeHelper\"),\n        ErrorPopupHelper = require(\"./EditorHelper/ErrorPopupHelper\"),\n        InlineWidgetHelper = require(\"./EditorHelper/InlineWidgetHelper\");\n\n    /* Editor preferences */\n\n    /**\n     * A list of gutter name and priorities currently registered for editors.\n     * The line number gutter is defined as \\{ name: LINE_NUMBER_GUTTER, priority: 100 }\n     * @private\n     * @type {Array<Object>} items - An array of objects, where each object contains the following properties:\n     * @property {string} name - The name of the item.\n     * @property {number} priority - The priority of the item.\n     * @property {Array} languageIds - An array of language IDs.\n     */\n    let registeredGutters = [];\n\n    let cmOptions = {};\n\n    EditorPreferences.init(cmOptions);\n\n    const CLOSE_BRACKETS = EditorPreferences.CLOSE_BRACKETS,\n        CLOSE_TAGS = EditorPreferences.CLOSE_TAGS,\n        DRAG_DROP = EditorPreferences.DRAG_DROP,\n        HIGHLIGHT_MATCHES = EditorPreferences.HIGHLIGHT_MATCHES,\n        LINEWISE_COPY_CUT = EditorPreferences.LINEWISE_COPY_CUT,\n        SCROLL_PAST_END = EditorPreferences.SCROLL_PAST_END,\n        SHOW_CURSOR_SELECT = EditorPreferences.SHOW_CURSOR_SELECT,\n        SHOW_LINE_NUMBERS = EditorPreferences.SHOW_LINE_NUMBERS,\n        SMART_INDENT = EditorPreferences.SMART_INDENT,\n        SPACE_UNITS = EditorPreferences.SPACE_UNITS,\n        STYLE_ACTIVE_LINE = EditorPreferences.STYLE_ACTIVE_LINE,\n        TAB_SIZE = EditorPreferences.TAB_SIZE,\n        AUTO_TAB_SPACES = EditorPreferences.AUTO_TAB_SPACES,\n        USE_TAB_CHAR = EditorPreferences.USE_TAB_CHAR,\n        WORD_WRAP = EditorPreferences.WORD_WRAP,\n        INDENT_LINE_COMMENT = EditorPreferences.INDENT_LINE_COMMENT,\n        INPUT_STYLE = EditorPreferences.INPUT_STYLE;\n\n    const LINE_NUMBER_GUTTER = EditorPreferences.LINE_NUMBER_GUTTER,\n        LINE_NUMBER_GUTTER_PRIORITY = EditorPreferences.LINE_NUMBER_GUTTER_PRIORITY,\n        CODE_FOLDING_GUTTER_PRIORITY = EditorPreferences.CODE_FOLDING_GUTTER_PRIORITY;\n\n    let editorOptions = [...Object.keys(cmOptions), AUTO_TAB_SPACES];\n\n    /* Editor preferences */\n\n    /**\n     * Guard flag to prevent focus() reentrancy (via blur handlers), even across Editors\n     * @private\n     * @type {boolean}\n     */\n    var _duringFocus = false;\n\n    /**\n     * Constant: Normal boundary check when centering text.\n     * @type {number}\n     */\n    const BOUNDARY_CHECK_NORMAL = 0;\n\n    /**\n     * Constant: Ignore the upper boundary when centering text.\n     * @type {number}\n     */\n    const BOUNDARY_IGNORE_TOP = 1;\n\n    /**\n     * Constant: Bulls-eye mode, strictly center the text always.\n     * @type {number}\n     */\n    const BOUNDARY_BULLSEYE = 2;\n\n\n    /**\n     * @private\n     * Create a copy of the given CodeMirror position\n     * @param {!CodeMirror.Pos} pos\n     * @return {CodeMirror.Pos}\n     */\n    function _copyPos(pos) {\n        return new CodeMirror.Pos(pos.line, pos.ch);\n    }\n\n    /**\n     * Helper functions to check options.\n     * @private\n     * @param {number} options BOUNDARY_CHECK_NORMAL or BOUNDARY_IGNORE_TOP\n     */\n    function _checkTopBoundary(options) {\n        return (options !== BOUNDARY_IGNORE_TOP);\n    }\n\n    function _checkBottomBoundary(options) {\n        return true;\n    }\n\n    /**\n     * Helper function to build preferences context based on the full path of\n     * the file.\n     * @private\n     * @param {string} fullPath Full path of the file\n     *\n     * @return {*} A context for the specified file name\n     */\n    function _buildPreferencesContext(fullPath) {\n        return PreferencesManager._buildContext(fullPath,\n            fullPath ? LanguageManager.getLanguageForPath(fullPath).getId() : undefined);\n    }\n\n    /**\n     * List of all current (non-destroy()ed) Editor instances. Needed when changing global preferences\n     * that affect all editors, e.g. tabbing or color scheme settings.\n     * @private\n     * @type {Array.<Editor>}\n     */\n    var _instances = [];\n\n    /**\n     * Creates a new CodeMirror editor instance bound to the given Document. The Document need not have\n     * a \"master\" Editor realized yet, even if makeMasterEditor is false; in that case, the first time\n     * an edit occurs we will automatically ask EditorManager to create a \"master\" editor to render the\n     * Document modifiable.\n     *\n     * ALWAYS call destroy() when you are done with an Editor - otherwise it will leak a Document ref.\n     *\n     * @constructor\n     *\n     * @param {!Document} document\n     * @param {!boolean} makeMasterEditor  If true, this Editor will set itself as the (secret) \"master\"\n     *          Editor for the Document. If false, this Editor will attach to the Document as a \"slave\"/\n     *          secondary editor.\n     * @param {!jQueryObject|DomNode} container  Container to add the editor to.\n     * @param {{startLine: number, endLine: number}=} range If specified, range of lines within the document\n     *          to display in this editor. Inclusive.\n     * @param {!Object} options If specified, contains editor options that can be passed to CodeMirror\n     */\n    function Editor(document, makeMasterEditor, container, range, options) {\n        var self = this;\n\n        var isReadOnly = (options && options.isReadOnly) || !document.editable;\n\n        _instances.push(this);\n\n        // Attach to document: add ref & handlers\n        this.document = document;\n        document.addRef();\n\n        if (container.jquery) {\n            // CodeMirror wants a DOM element, not a jQuery wrapper\n            container = container.get(0);\n        }\n\n        let $container = $(container);\n        $container.addClass(\"editor-holder\");\n\n        if (range) {    // attach this first: want range updated before we process a change\n            this._visibleRange = new TextRange(document, range.startLine, range.endLine);\n        }\n\n        // store this-bound version of listeners so we can remove them later\n        this._handleDocumentChange = this._handleDocumentChange.bind(this);\n        this._handleDocumentDeleted = this._handleDocumentDeleted.bind(this);\n        this._handleDocumentLanguageChanged = this._handleDocumentLanguageChanged.bind(this);\n        this._doWorkingSetSync = this._doWorkingSetSync.bind(this);\n        document.on(\"change\", this._handleDocumentChange);\n        document.on(\"deleted\", this._handleDocumentDeleted);\n        document.on(\"languageChanged\", this._handleDocumentLanguageChanged);\n        // To sync working sets if the view is for same doc across panes\n        document.on(\"_dirtyFlagChange\", this._doWorkingSetSync);\n\n        var mode = this._getModeFromDocument();\n\n        // (if makeMasterEditor, we attach the Doc back to ourselves below once we're fully initialized)\n\n        this._inlineWidgets = [];\n        this._inlineWidgetQueues = {};\n        this._hideMarks = [];\n        this._lastEditorWidth = null;\n\n        this._markTypesMap = {};\n\n        this._$messagePopover = null;\n\n        // To track which pane the editor is being attached to if it's a full editor\n        this._paneId = null;\n\n        // To track the parent editor ( host editor at that time of creation) of an inline editor\n        this._hostEditor = null;\n\n        // Editor supplies some standard keyboard behavior extensions of its own\n        var codeMirrorKeyMap = {\n            \"Tab\": function () { self._handleTabKey(); },\n            \"Shift-Tab\": \"indentLess\",\n\n            \"Left\": function (instance) {\n                self._handleSoftTabNavigation(-1, \"moveH\");\n            },\n            \"Right\": function (instance) {\n                self._handleSoftTabNavigation(1, \"moveH\");\n            },\n            \"Backspace\": function (instance) {\n                self._handleSoftTabNavigation(-1, \"deleteH\");\n            },\n            \"Delete\": function (instance) {\n                self._handleSoftTabNavigation(1, \"deleteH\");\n            },\n            \"Esc\": function (_instance) {\n                if (!self.canConsumeEscapeKeyEvent()) {\n                    return;\n                }\n                if (self.getSelections().length > 1) { // multi cursor\n                    self.clearSelection();\n                } else if (self.hasSelection()) {\n                    self.clearSelection();\n                } else {\n                    self.removeAllInlineWidgets();\n                }\n            },\n            \"Home\": \"goLineLeftSmart\",\n            \"Cmd-Left\": \"goLineLeftSmart\",\n            \"End\": \"goLineRight\",\n            \"Cmd-Right\": \"goLineRight\"\n        };\n\n        var currentOptions = this._currentOptions = _.zipObject(\n            editorOptions,\n            _.map(editorOptions, function (prefName) {\n                return self._getOption(prefName);\n            })\n        );\n\n        //cm: CodeMirror, repeat: \"single\" | \"double\" | \"triple\", event: Event\n        // The function is called when the left mouse button is pressed in codemirror\n        function _mouseHandlerOverride(_cm, _repeat, event) {\n            if (event.ctrlKey || event.metaKey) {\n                setTimeout(() => {\n                    CommandManager.execute(Commands.NAVIGATE_JUMPTO_DEFINITION);\n                    Metrics.countEvent(Metrics.EVENT_TYPE.EDITOR, \"ctrlClick\", _cm.getMode().name);\n                }, 100);\n            }\n            return {\n                addNew: event.altKey // alt key will init multi cursor instead of ctrl-key\n            };\n        }\n\n        // When panes are created *after* the showLineNumbers option has been turned off\n        //  we need to apply the show-line-padding class or the text will be juxtaposed\n        //  to the edge of the editor which makes it not easy to read.  The code below to handle\n        //  that the option change only applies the class to panes that have already been created\n        // This line ensures that the class is applied to any editor created after the fact\n        $container.toggleClass(\"show-line-padding\", Boolean(!this._getOption(\"showLineNumbers\")));\n\n        // Create the CodeMirror instance\n        // (note: CodeMirror doesn't actually require using 'new', but jslint complains without it)\n        this._codeMirror = new CodeMirror(container, {\n            autoCloseBrackets: currentOptions[CLOSE_BRACKETS],\n            autoCloseTags: currentOptions[CLOSE_TAGS],\n            coverGutterNextToScrollbar: true,\n            continueComments: true,\n            cursorScrollMargin: 3,\n            dragDrop: currentOptions[DRAG_DROP],\n            electricChars: true,\n            configureMouse: _mouseHandlerOverride,\n            extraKeys: codeMirrorKeyMap,\n            highlightSelectionMatches: currentOptions[HIGHLIGHT_MATCHES],\n            indentUnit: currentOptions[USE_TAB_CHAR] ? currentOptions[TAB_SIZE] : currentOptions[SPACE_UNITS],\n            indentWithTabs: currentOptions[USE_TAB_CHAR],\n            inputStyle: currentOptions[INPUT_STYLE],\n            lineNumbers: currentOptions[SHOW_LINE_NUMBERS],\n            lineWiseCopyCut: currentOptions[LINEWISE_COPY_CUT],\n            lineWrapping: currentOptions[WORD_WRAP],\n            matchBrackets: { maxScanLineLength: 50000, maxScanLines: 1000 },\n            matchTags: { bothTags: true },\n            scrollPastEnd: !range && currentOptions[SCROLL_PAST_END],\n            showCursorWhenSelecting: currentOptions[SHOW_CURSOR_SELECT],\n            smartIndent: currentOptions[SMART_INDENT],\n            styleActiveLine: currentOptions[STYLE_ACTIVE_LINE],\n            tabSize: currentOptions[TAB_SIZE],\n            readOnly: isReadOnly\n        });\n\n        // Override default drag image in Safari (and harmless in others):\n        // Safari shows a text image by default when dragging from CodeMirror,\n        // which can be visually distracting. Use a 1x1 transparent image instead.\n        // Note: The CodeMirror \"wrapper\" element (returned by getWrapperElement()) is NOT the same\n        // as the \"container\" we pass to new CodeMirror(container, ...). CodeMirror creates its own\n        // wrapper inside that container. We attach the drag listener to the wrapper so it captures\n        // drags originating from the editor surface reliably across browsers.\n        try {\n            const wrapperEl = self._codeMirror.getWrapperElement();\n            if (wrapperEl) {\n                // Create once per editor instance\n                const transparentImg = new Image();\n                transparentImg.src = \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==\";\n                function handleCMDragStart(e) {\n                    if (e && e.dataTransfer && typeof e.dataTransfer.setDragImage === \"function\") {\n                        e.dataTransfer.setDragImage(transparentImg, 0, 0);\n                    }\n                }\n                wrapperEl.addEventListener(\"dragstart\", handleCMDragStart);\n                // No explicit removal necessary since the wrapper element is removed on editor.destroy().\n            }\n        } catch (err) {\n            // Fail silently; drag image override is non-critical.\n        }\n\n        // Can't get CodeMirror's focused state without searching for\n        // CodeMirror-focused. Instead, track focus via onFocus and onBlur\n        // options and track state with this._focused\n        this._focused = false;\n\n        this._installEditorListeners();\n\n        this._renderGutters();\n\n        this.on(\"cursorActivity\", function (event, editor) {\n            self._handleCursorActivity(event);\n        });\n        this.on(\"keypress\", function (event, editor, domEvent) {\n            self._handleKeypressEvents(domEvent);\n        });\n        this.on(\"change\", function (event, editor, changeList) {\n            self._handleEditorChange(changeList);\n        });\n        this.on(\"focus\", function (event, editor) {\n            if (self._hostEditor) {\n                // Mark the host editor as the master editor for the hosting document\n                self._hostEditor.document._toggleMasterEditor(self._hostEditor);\n            } else {\n                // Set this full editor as master editor for the document\n                self.document._toggleMasterEditor(self);\n            }\n        });\n\n        // Set code-coloring mode BEFORE populating with text, to avoid a flash of uncolored text\n        this._codeMirror.setOption(\"mode\", mode);\n\n        // Initially populate with text. This will send a spurious change event, so need to make\n        // sure this is understood as a 'sync from document' case, not a genuine edit\n        this._duringSync = true;\n        this._resetText(document.getText());\n        this._duringSync = false;\n\n        if (range) {\n            this._updateHiddenLines();\n            this.setCursorPos(range.startLine, 0);\n        }\n\n        // Now that we're fully initialized, we can point the document back at us if needed\n        if (makeMasterEditor) {\n            document._makeEditable(this);\n        }\n\n        // Add scrollTop property to this object for the scroll shadow code to use\n        Object.defineProperty(this, \"scrollTop\", {\n            get: function () {\n                return this._codeMirror.getScrollInfo().top;\n            }\n        });\n\n        // Add an $el getter for Pane Views\n        Object.defineProperty(this, \"$el\", {\n            get: function () {\n                return $(this.getRootElement());\n            }\n        });\n\n        const $cmElement = this.$el;\n        $cmElement[0].addEventListener(\"wheel\", (event) => {\n            const $editor = $cmElement.find(\".CodeMirror-scroll\");\n            // we need to slow down the scroll by the factor of line height. else the scrolling is too fast.\n            // this became a problem after we added the custom line height feature causing jumping scrolls esp in safari\n            // and mac if we dont do this scroll scaling.\n            const lineHeight = parseFloat(getComputedStyle($editor[0]).lineHeight);\n            const defaultHeight = 14, scrollScaleFactor = lineHeight/defaultHeight;\n\n            // when user is pressing the 'Shift' key, we need to convert the vertical scroll to horizontal scroll\n            if (event.shiftKey) {\n                let horizontalDelta = event.deltaX;\n\n                if (event.deltaY !== 0) {\n                    horizontalDelta = event.deltaY;\n                }\n\n                // apply the horizontal scrolling\n                if (horizontalDelta !== 0) {\n                    $editor[0].scrollLeft += horizontalDelta;\n                    event.preventDefault();\n                    return;\n                }\n            }\n\n            // apply horizontal scrolling if present. for the diagonal scrolling\n            if (event.deltaX !== 0) {\n                $editor[0].scrollLeft += event.deltaX;\n            }\n\n            // apply the vertical scrolling normally\n            if (event.deltaY !== 0) {\n                const scrollDelta = event.deltaY;\n                $editor[0].scrollTop += (scrollDelta/scrollScaleFactor);\n                event.preventDefault();\n            }\n        });\n    }\n\n    EventDispatcher.makeEventDispatcher(Editor.prototype);\n    EventDispatcher.markDeprecated(Editor.prototype, \"keyEvent\", \"'keydown/press/up'\");\n\n    IndentHelper.addHelpers(Editor);\n    ChangeHelper.addHelpers(Editor);\n    InlineWidgetHelper.addHelpers(Editor);\n\n    Editor.prototype.markPaneId = function (paneId) {\n        this._paneId = paneId;\n\n        // Also add this to the pool of full editors\n        this.document._associateEditor(this);\n\n        // In case this Editor is initialized not as the first full editor for the document\n        // and the document is already dirty and present in another working set, make sure\n        // to add this documents to the new panes working set.\n        this._doWorkingSetSync(null, this.document);\n    };\n\n    /**\n     * Gets the inline widgets below the current cursor position or null.\n     * @return {boolean}\n     */\n    Editor.prototype.getInlineWidgetsBelowCursor = function () {\n        let self = this;\n        let cursor = self.getCursorPos();\n        let line = cursor.line;\n        return self.getAllInlineWidgetsForLine(line);\n    };\n\n    /**\n     * returns true if the editor can do something an escape key event. Eg. Disable multi cursor escape\n     */\n    Editor.prototype.canConsumeEscapeKeyEvent = function () {\n        let self = this;\n        return (self.getSelections().length > 1) // multi cursor should go away on escape\n            || (self.hasSelection()) // selection should go away on escape\n            || self.getInlineWidgetsBelowCursor() // inline widget is below cursor\n            || self.getFocusedInlineWidget(); // inline widget\n    };\n\n    Editor.prototype._doWorkingSetSync = function (event, doc) {\n        if (doc === this.document && this._paneId && this.document.isDirty) {\n            MainViewManager.addToWorkingSet(this._paneId, this.document.file, -1, false);\n        }\n    };\n\n    /**\n     * Removes this editor from the DOM and detaches from the Document. If this is the \"master\"\n     * Editor that is secretly providing the Document's backing state, then the Document reverts to\n     * a read-only string-backed mode.\n     */\n    Editor.prototype.destroy = function () {\n        this.trigger(\"beforeDestroy\", this);\n\n        // CodeMirror docs for getWrapperElement() say all you have to do is \"Remove this from your\n        // tree to delete an editor instance.\"\n        $(this.getRootElement()).remove();\n\n        _instances.splice(_instances.indexOf(this), 1);\n\n        // Disconnect from Document\n        this.document.releaseRef();\n        this.document.off(\"change\", this._handleDocumentChange);\n        this.document.off(\"deleted\", this._handleDocumentDeleted);\n        this.document.off(\"languageChanged\", this._handleDocumentLanguageChanged);\n        this.document.off(\"_dirtyFlagChange\", this._doWorkingSetSync);\n\n        if (this._visibleRange) {   // TextRange also refs the Document\n            this._visibleRange.dispose();\n        }\n\n        // If we're the Document's master editor, disconnecting from it has special meaning\n        if (this.document._masterEditor === this) {\n            this.document._makeNonEditable();\n        } else {\n            this.document._disassociateEditor(this);\n        }\n\n        // Destroying us destroys any inline widgets we're hosting. Make sure their closeCallbacks\n        // run, at least, since they may also need to release Document refs\n        var self = this;\n        this._inlineWidgets.forEach(function (inlineWidget) {\n            self._removeInlineWidgetInternal(inlineWidget);\n        });\n    };\n\n    /**\n     * @private\n     * Handle any cursor movement in editor, including selecting and unselecting text.\n     * @param {!Event} event\n     */\n    Editor.prototype._handleCursorActivity = function (event) {\n        this._updateStyleActiveLine();\n    };\n\n    /**\n     * @private\n     * Removes any whitespace after one of ]{}) to prevent trailing whitespace when auto-indenting\n     */\n    Editor.prototype._handleWhitespaceForElectricChars = function () {\n        var self = this,\n            instance = this._codeMirror,\n            selections,\n            lineStr;\n\n        selections = this.getSelections().map(function (sel) {\n            lineStr = instance.getLine(sel.end.line);\n\n            if (lineStr && !/\\S/.test(lineStr)) {\n                // if the line is all whitespace, move the cursor to the end of the line\n                // before indenting so that embedded whitespace such as indents are not\n                // orphaned to the right of the electric char being inserted\n                sel.end.ch = self.document.getLine(sel.end.line).length;\n            }\n            return sel;\n        });\n        this.setSelections(selections);\n    };\n\n    /**\n     * @private\n     * Handle CodeMirror key events.\n     * @param {!Event} event\n     */\n    Editor.prototype._handleKeypressEvents = function (event) {\n        var keyStr = String.fromCharCode(event.which || event.keyCode);\n\n        if (/[\\]\\{\\}\\)]/.test(keyStr)) {\n            this._handleWhitespaceForElectricChars();\n        }\n    };\n\n    /**\n     * Determine the mode to use from the document's language\n     * Uses \"text/plain\" if the language does not define a mode\n     * @private\n     * @return {string} The mode to use\n     */\n    Editor.prototype._getModeFromDocument = function () {\n        // We'd like undefined/null/\"\" to mean plain text mode. CodeMirror defaults to plaintext for any\n        // unrecognized mode, but it complains on the console in that fallback case: so, convert\n        // here so we're always explicit, avoiding console noise.\n        return this.document.getLanguage().getMode() || \"text/plain\";\n    };\n\n\n    /**\n     * Selects all text and maintains the current scroll position.\n     */\n    Editor.prototype.selectAllNoScroll = function () {\n        var cm = this._codeMirror,\n            info = this._codeMirror.getScrollInfo();\n\n        // Note that we do not have to check for the visible range here. This\n        // concern is handled internally by code mirror.\n        cm.operation(function () {\n            cm.scrollTo(info.left, info.top);\n            cm.execCommand(\"selectAll\");\n        });\n    };\n\n    /**\n     * @return {boolean} True if editor is not showing the entire text of the document (i.e. an inline editor)\n     */\n    Editor.prototype.isTextSubset = function () {\n        return Boolean(this._visibleRange);\n    };\n\n    /**\n     * Ensures that the lines that are actually hidden in the inline editor correspond to\n     * the desired visible range.\n     * @private\n     */\n    Editor.prototype._updateHiddenLines = function () {\n        if (this._visibleRange) {\n            var cm = this._codeMirror,\n                self = this;\n            cm.operation(function () {\n                self._hideMarks.forEach(function (mark) {\n                    if (mark) {\n                        mark.clear();\n                    }\n                });\n                self._hideMarks = [];\n                self._hideMarks.push(self._hideLines(0, self._visibleRange.startLine));\n                self._hideMarks.push(self._hideLines(self._visibleRange.endLine + 1, self.lineCount()));\n            });\n        }\n    };\n\n    /**\n     * Sets the contents of the editor, clears the undo/redo history and marks the document clean. Dispatches a change event.\n     * Semi-private: only Document should call this.\n     * @private\n     * @param {!string} text\n     */\n    Editor.prototype._resetText = function (text) {\n        var currentText = this._codeMirror.getValue();\n\n        // compare with ignoring line-endings, issue #11826\n        var textLF = text ? text.replace(/(\\r\\n|\\r|\\n)/g, \"\\n\") : null;\n        var currentTextLF = currentText ? currentText.replace(/(\\r\\n|\\r|\\n)/g, \"\\n\") : null;\n        if (textLF === currentTextLF) {\n            // there's nothing to reset\n            return;\n        }\n\n        var perfTimerName = PerfUtils.markStart(\"Editor._resetText()\\t\" + (!this.document || this.document.file.fullPath));\n\n        var cursorPos = this.getCursorPos(),\n            scrollPos = this.getScrollPos();\n\n        // This *will* fire a change event, but we clear the undo immediately afterward\n        this._codeMirror.setValue(text);\n        this._codeMirror.refresh();\n\n        // Make sure we can't undo back to the empty state before setValue(), and mark\n        // the document clean.\n        this._codeMirror.clearHistory();\n        this._codeMirror.markClean();\n\n        // restore cursor and scroll positions\n        this.setCursorPos(cursorPos);\n        this.setScrollPos(scrollPos.x, scrollPos.y);\n\n        PerfUtils.addMeasurement(perfTimerName);\n    };\n\n    /**\n     * Gets the file associated with this editor\n     * This is a required Pane-View interface method\n     * @return {!File} the file associated with this editor\n     */\n    Editor.prototype.getFile = function () {\n        return this.document.file;\n    };\n\n    /**\n     * Gets the current cursor position within the editor.\n     *\n     * Cursor positions can be converted to index(0 based character offsets in editor text string)\n     * using `editor.indexFromPos` API.\n     * @param {boolean} [expandTabs]  If true, return the actual visual column number instead of the character offset in\n     *      the \"ch\" property.\n     * @param {string} [which] Optional string indicating which end of the\n     *  selection to return. It may be \"start\", \"end\", \"head\" (the side of the\n     *  selection that moves when you press shift+arrow), or \"anchor\" (the\n     *  fixed side of the selection). Omitting the argument is the same as\n     *  passing \"head\". A {'line', 'ch'} object will be returned.)\n     * @return {{line:number, ch:number}}\n     */\n    Editor.prototype.getCursorPos = function (expandTabs, which) {\n        // Translate \"start\" and \"end\" to the official CM names (it actually\n        // supports them as-is, but that isn't documented and we don't want to\n        // rely on it).\n        if (which === \"start\") {\n            which = \"from\";\n        } else if (which === \"end\") {\n            which = \"to\";\n        }\n        var cursor = _copyPos(this._codeMirror.getCursor(which));\n\n        if (expandTabs) {\n            cursor.ch = this.getColOffset(cursor);\n        }\n        return cursor;\n    };\n\n    /**\n     * Gets the cursor position of the last charected in the editor.\n     * @param {boolean} [expandTabs]  If true, return the actual visual column number instead of the character offset in\n     *      the \"ch\" property.\n     * @return {{line:number, ch:number}}\n     */\n    Editor.prototype.getEndingCursorPos = function (expandTabs) {\n        let lastLine = this._codeMirror.lastLine();\n        let cursor = {\n            line: lastLine,\n            ch: this._codeMirror.getLine(lastLine).length\n        };\n\n        if (expandTabs) {\n            cursor.ch = this.getColOffset(cursor);\n        }\n        return cursor;\n    };\n\n    /**\n     * Returns the display column (zero-based) for a given string-based pos. Differs from pos.ch only\n     * when the line contains preceding \\t chars. Result depends on the current tab size setting.\n     * @param {!{line:number, ch:number}} pos\n     * @return {number}\n     */\n    Editor.prototype.getColOffset = function (pos) {\n        var line = this._codeMirror.getRange({ line: pos.line, ch: 0 }, pos),\n            tabSize = null,\n            column = 0,\n            i;\n\n        for (i = 0; i < line.length; i++) {\n            if (line[i] === '\\t') {\n                if (tabSize === null) {\n                    tabSize = Editor.getTabSize();\n                }\n                if (tabSize > 0) {\n                    column += (tabSize - (column % tabSize));\n                }\n            } else {\n                column++;\n            }\n        }\n        return column;\n    };\n\n    /**\n     * Returns the string-based pos for a given display column (zero-based) in given line. Differs from column\n     * only when the line contains preceding \\t chars. Result depends on the current tab size setting.\n     * @param {number} lineNum Line number\n     * @param {number} column Display column number\n     * @return {number}\n     */\n    Editor.prototype.getCharIndexForColumn = function (lineNum, column) {\n        var line = this._codeMirror.getLine(lineNum),\n            tabSize = null,\n            iCol = 0,\n            i;\n\n        for (i = 0; iCol < column; i++) {\n            if (line[i] === '\\t') {\n                if (tabSize === null) {\n                    tabSize = Editor.getTabSize();\n                }\n                if (tabSize > 0) {\n                    iCol += (tabSize - (iCol % tabSize));\n                }\n            } else {\n                iCol++;\n            }\n        }\n        return i;\n    };\n\n    /**\n     * Sets the cursor position within the editor. Removes any selection.\n     * @param {number} line  The 0 based line number.\n     * @param {number} ch  The 0 based character position; treated as 0 if unspecified.\n     * @param {boolean=} center  True if the view should be centered on the new cursor position.\n     * @param {boolean=} expandTabs  If true, use the actual visual column number instead of the character offset as\n     *      the \"ch\" parameter.\n     */\n    Editor.prototype.setCursorPos = function (line, ch, center, expandTabs) {\n        if (expandTabs) {\n            ch = this.getColOffset({ line: line, ch: ch });\n        }\n        this._codeMirror.setCursor(line, ch);\n        if (center) {\n            this.centerOnCursor();\n        }\n    };\n\n    /**\n     * Set the editor size in pixels or percentage\n     * @param {(number|string)} width\n     * @param {(number|string)} height\n     */\n    Editor.prototype.setSize = function (width, height) {\n        this._codeMirror.setSize(width, height);\n    };\n\n\n    /**\n     * Returns a {'from', 'to'} object indicating the start (inclusive) and end (exclusive) of the currently rendered\n     * part of the document. In big documents, when most content is scrolled out of view, Editor will only render\n     * the visible part, and a margin around it. See also the `viewportChange` event fired on the editor.\n     *\n     * This is combination with `viewportChange` event can be used to selectively redraw visual elements in code\n     * like syntax analyze only parts of code instead of the full code everytime.\n     * @return {{from: number, to: number}}\n     */\n    Editor.prototype.getViewport = function () {\n        return this._codeMirror.getViewport();\n    };\n\n    /** @const */\n    var CENTERING_MARGIN = 0.15;\n\n    /**\n     * Scrolls the editor viewport to vertically center the line with the cursor,\n     * but only if the cursor is currently near the edges of the viewport or\n     * entirely outside the viewport.\n     *\n     * This does not alter the horizontal scroll position.\n     *\n     * @param {number} centerOptions Option value, or 0 for no options; one of the BOUNDARY_* constants above.\n     */\n    Editor.prototype.centerOnCursor = function (centerOptions) {\n        let $scrollerElement = $(this.getScrollerElement());\n        let editorHeight = $scrollerElement.height();\n\n        // we need to make adjustments for the statusbar's padding on the bottom and the menu bar on top.\n        let statusBarHeight = $(\"#status-bar\").height();\n\n        let documentCursorPosition = this._codeMirror.cursorCoords(null, \"local\").bottom;\n        let screenCursorPosition = this._codeMirror.cursorCoords(null, \"page\").bottom;\n\n        if (centerOptions === BOUNDARY_BULLSEYE) {\n            let pos = documentCursorPosition - editorHeight / 2 + statusBarHeight;\n            this.setScrollPos(null, pos);\n            return;\n        }\n        // If the cursor is already reasonably centered, we won't\n        // make any change. \"Reasonably centered\" is defined as\n        // not being within CENTERING_MARGIN of the top or bottom\n        // of the editor (where CENTERING_MARGIN is a percentage\n        // of the editor height).\n        // For finding the first item (i.e. find while typing), do\n        // not center if hit is in first half of screen because this\n        // appears to be an unnecesary scroll.\n        if ((_checkTopBoundary(centerOptions) && (screenCursorPosition < editorHeight * CENTERING_MARGIN)) ||\n            (_checkBottomBoundary(centerOptions) && (screenCursorPosition > editorHeight * (1 - CENTERING_MARGIN)))) {\n\n            var pos = documentCursorPosition - editorHeight / 2 + statusBarHeight;\n            var info = this._codeMirror.getScrollInfo();\n            pos = Math.min(Math.max(pos, 0), (info.height - info.clientHeight));\n            this.setScrollPos(null, pos);\n        }\n    };\n\n    /**\n     * Given a position, returns its index within the text (assuming \\n newlines)\n     * @param {{line:number, ch:number}} cursorPos\n     * @return {number}\n     */\n    Editor.prototype.indexFromPos = function (cursorPos) {\n        return this._codeMirror.indexFromPos(cursorPos);\n    };\n\n    /**\n     * Given a position, returns its index within the text (assuming \\n newlines)\n     * @param {number} index\n     * @return {{line:number, ch:number}}\n     */\n    Editor.prototype.posFromIndex = function (index) {\n        return this._codeMirror.posFromIndex(index);\n    };\n\n    /**\n     * Returns true if pos is between start and end (INclusive at start; EXclusive at end by default,\n     * but overridable via the endInclusive flag).\n     * @param {{line:number, ch:number}} pos\n     * @param {{line:number, ch:number}} start\n     * @param {{line:number, ch:number}} end\n     * @param {boolean} endInclusive\n     *\n     */\n    Editor.prototype.posWithinRange = function (pos, start, end, endInclusive) {\n        if (start.line <= pos.line && end.line >= pos.line) {\n            if (endInclusive) {\n                return (start.line < pos.line || start.ch <= pos.ch) &&  // inclusive\n                    (end.line > pos.line || end.ch >= pos.ch);      // inclusive\n            }\n            return (start.line < pos.line || start.ch <= pos.ch) &&  // inclusive\n                (end.line > pos.line || end.ch > pos.ch);       // exclusive\n\n\n        }\n        return false;\n    };\n\n    /**\n     * @return {boolean} True if there's a text selection; false if there's just an insertion point\n     */\n    Editor.prototype.hasSelection = function () {\n        return this._codeMirror.somethingSelected();\n    };\n\n    /**\n     * Takes an anchor/head pair and returns a start/end pair where the start is guaranteed to be <= end,\n     * and a \"reversed\" flag indicating if the head is before the anchor.\n     * @private\n     * @typedef {Object} Position\n     * @property {number} line - Line number\n     * @property {number} ch - Character position\n     *\n     * @typedef {Object} NormalizedRange\n     * @property {Position} start - Start position\n     * @property {Position} end - End position\n     * @property {boolean} reversed - Whether the range is reversed\n     *\n     * @param {Position} anchorPos - The anchor position\n     * @param {Position} headPos - The head position\n     * @return {NormalizedRange} The normalized range with start <= end\n     */\n    function _normalizeRange(anchorPos, headPos) {\n        if (headPos.line < anchorPos.line || (headPos.line === anchorPos.line && headPos.ch < anchorPos.ch)) {\n            return { start: _copyPos(headPos), end: _copyPos(anchorPos), reversed: true };\n        }\n        return { start: _copyPos(anchorPos), end: _copyPos(headPos), reversed: false };\n\n    }\n\n    /**\n     * Gets the current selection; if there is more than one selection, returns the primary selection\n     * (generally the last one made). Start is inclusive, end is exclusive. If there is no selection,\n     * returns the current cursor position as both the start and end of the range (i.e. a selection\n     * of length zero). If `reversed` is set, then the head of the selection (the end of the selection\n     * that would be changed if the user extended the selection) is before the anchor.\n     * @return {{start:{line:number, ch:number}, end:{line:number, ch:number}, reversed:boolean}}\n     */\n    Editor.prototype.getSelection = function () {\n        return _normalizeRange(this.getCursorPos(false, \"anchor\"), this.getCursorPos(false, \"head\"));\n    };\n\n    /**\n     * Returns an array of current selections, nonoverlapping and sorted in document order.\n     * Each selection is a start/end pair, with the start guaranteed to come before the end.\n     * Cursors are represented as a range whose start is equal to the end.\n     * If `reversed` is set, then the head of the selection\n     * (the end of the selection that would be changed if the user extended the selection)\n     * is before the anchor.\n     * If `primary` is set, then that selection is the primary selection.\n     * @return {{start:{line:number, ch:number}, end:{line:number, ch:number}, reversed:boolean, primary:boolean[]}}\n     */\n    Editor.prototype.getSelections = function () {\n        var primarySel = this.getSelection();\n        return _.map(this._codeMirror.listSelections(), function (sel) {\n            var result = _normalizeRange(sel.anchor, sel.head);\n            if (result.start.line === primarySel.start.line && result.start.ch === primarySel.start.ch &&\n                result.end.line === primarySel.end.line && result.end.ch === primarySel.end.ch) {\n                result.primary = true;\n            } else {\n                result.primary = false;\n            }\n            return result;\n        });\n    };\n\n    /**\n     * Check if the editor has multiple cursors or selections\n     * @returns {boolean}\n     */\n    Editor.prototype.hasMultipleCursors = function () {\n        const selections = this._codeMirror.listSelections();\n        return selections.length > 1;\n    };\n\n    /**\n     * Takes the given selections, and expands each selection so it encompasses whole lines. Merges\n     * adjacent line selections together. Keeps track of each original selection associated with a given\n     * line selection (there might be multiple if individual selections were merged into a single line selection).\n     * Useful for doing multiple-selection-aware line edits.\n     *\n     * @param {{start:{line:number, ch:number}, end:{line:number, ch:number}, reversed:boolean, primary:boolean}} selections\n     *      The selections to expand.\n     * @param {{expandEndAtStartOfLine: boolean, mergeAdjacent: boolean}} options\n     *      expandEndAtStartOfLine: true if a range selection that ends at the beginning of a line should be expanded\n     *          to encompass the line. Default false.\n     *      mergeAdjacent: true if adjacent line ranges should be merged. Default true.\n     * @return {{selectionForEdit: {start: {line: number, ch: number}, end: {line: number, ch: number}, reversed: boolean, primary: boolean}, selectionsToTrack: {start: {line: number, ch: number}, end: {line: number, ch: number}, reversed: boolean, primary: boolean}}}\n     *      The combined line selections. For each selection, `selectionForEdit` is the line selection, and `selectionsToTrack` is\n     *      the set of original selections that combined to make up the given line selection. Note that the selectionsToTrack will\n     *      include the original objects passed in `selections`, so if it is later mutated the original passed-in selections will be\n     *      mutated as well.\n     */\n    Editor.prototype.convertToLineSelections = function (selections, options) {\n        var self = this;\n        options = options || {};\n        _.defaults(options, { expandEndAtStartOfLine: false, mergeAdjacent: true });\n\n        // Combine adjacent lines with selections so they don't collide with each other, as they would\n        // if we did them individually.\n        var combinedSelections = [], prevSel;\n        _.each(selections, function (sel) {\n            var newSel = _.cloneDeep(sel);\n\n            // Adjust selection to encompass whole lines.\n            newSel.start.ch = 0;\n            // The end of the selection becomes the start of the next line, if it isn't already\n            // or if expandEndAtStartOfLine is set.\n            var hasSelection = (newSel.start.line !== newSel.end.line) || (newSel.start.ch !== newSel.end.ch);\n            if (options.expandEndAtStartOfLine || !hasSelection || newSel.end.ch !== 0) {\n                newSel.end = { line: newSel.end.line + 1, ch: 0 };\n            }\n\n            // If the start of the new selection is within the range of the previous (expanded) selection, merge\n            // the two selections together, but keep track of all the original selections that were related to this\n            // selection, so they can be properly adjusted. (We only have to check for the start being inside the previous\n            // range - it can't be before it because the selections started out sorted.)\n            if (prevSel && self.posWithinRange(newSel.start, prevSel.selectionForEdit.start, prevSel.selectionForEdit.end, options.mergeAdjacent)) {\n                prevSel.selectionForEdit.end.line = newSel.end.line;\n                prevSel.selectionsToTrack.push(sel);\n            } else {\n                prevSel = { selectionForEdit: newSel, selectionsToTrack: [sel] };\n                combinedSelections.push(prevSel);\n            }\n        });\n        return combinedSelections;\n    };\n\n    /**\n     * Returns the currently selected text, or \"\" if no selection. Includes \\n if the\n     * selection spans multiple lines (does NOT reflect the Document's line-endings style). By\n     * default, returns only the contents of the primary selection, unless `allSelections` is true.\n     * @param {boolean=} allSelections Whether to return the contents of all selections (separated\n     *     by newlines) instead of just the primary selection. Default false.\n     * @return {!string} The selected text.\n     */\n    Editor.prototype.getSelectedText = function (allSelections) {\n        if (allSelections) {\n            return this._codeMirror.getSelection();\n        }\n        var sel = this.getSelection();\n        return this.document.getRange(sel.start, sel.end);\n\n    };\n\n    /**\n     * Given an {'left', 'top'} object (e.g. coordinates of a mouse event) returns the {'line', 'ch'} position that\n     * corresponds to it. The optional mode parameter determines relative to what the coordinates are interpreted.\n     *\n     * @param {{left: number, top:number}} coordinates can be obtained from Eg. coordinates of a mouse event\n     * @param {string} [mode] It may be \"window\", \"page\" (the default), or \"local\".\n     * @return {{line:number, ch: number}} for the given coordinates\n     */\n    Editor.prototype.coordsChar = function (coordinates, mode) {\n        return this._codeMirror.coordsChar(coordinates, mode);\n    };\n\n    /**\n     * Returns the position and dimensions of an arbitrary character given a cursor (Eg. from getCursorPos()).\n     * It'll give the size of the whole character, rather than just the position that the cursor would have\n     * when it would sit at that position.\n     *\n     * @param {{line:number, ch: number}} pos A cursor, can be obtained from Eg. getCursorPos()\n     * @param {string} [mode] It may be \"window\", \"page\" (the default), or \"local\".\n     * @return {{left:number, right:number, top:number, bottom:number}} coordinates for the given character position\n     */\n    Editor.prototype.charCoords = function (pos, mode) {\n        return this._codeMirror.charCoords(pos, mode);\n    };\n\n\n    /**\n     * Get the token at the given cursor position, or at the current cursor\n     * if none is given.\n     *\n     * @param {?{line: number, ch: number}} [cursor] - Optional cursor position\n     *      at which to retrieve a token. If not provided, the current position will be used.\n     * @param {boolean} [precise] If given, results in more current results. Suppresses caching.\n     * @return {{end: number, start:number, line: number, string: string, type: string|null}} -\n     * the CodeMirror token at the given cursor position\n     */\n    Editor.prototype.getToken = function (cursor, precise) {\n        let cm = this._codeMirror;\n        cursor = Object.assign({}, cursor || this.getCursorPos());\n\n        let token = TokenUtils.getTokenAt(cm, cursor, precise);\n        token.line = cursor.line;\n        return token;\n    };\n\n    /**\n     * Retrieves a single character from the specified position in the editor.\n     * x|y where `|` is the cursor, will return y\n     * @param {CodeMirror.Position} pos - The position from which to retrieve the character.\n     *                                    This should be an object with `line` and `ch` properties.\n     * @returns {string|null} The character at the given position if within bounds,\n     *                        otherwise `null` if the position is out of range.\n     */\n    Editor.prototype.getCharacterAtPosition = function (pos) {\n        const cm = this._codeMirror;\n        let lineText = cm.getLine(pos.line);\n        if (pos.ch >= lineText.length || pos.line >= cm.lineCount()) {\n            return null;\n        }\n\n        return cm.getRange(pos, { line: pos.line, ch: pos.ch + 1 });\n    };\n\n    /**\n     * Retrieves a single line text\n     * @param {number} lineNumber - The lineNumber to extract text from\n     * @returns {string|null} The text at the given position if within bounds,\n     *                        otherwise `null` if the position is out of range.\n     */\n    Editor.prototype.getLine = function (lineNumber) {\n        const retrievedText = this._codeMirror.getLine(lineNumber);\n        return retrievedText === undefined ? null : retrievedText;\n    };\n\n    /**\n     * Retrieves a single character previous to the specified position in the editor in the same line if possible.\n     * x|y where `|` is the cursor, will return x\n     *\n     * @param {CodeMirror.Position} pos - The position from which to retrieve the character.\n     *                                    This should be an object with `line` and `ch` properties.\n     * @returns {string|null} The character previous to the given position if within bounds,\n     *                        otherwise `null` if the position is out of range.\n     */\n    Editor.prototype.getPrevCharacterAtPosition = function (pos) {\n        if (pos.ch === 0) {\n            return null;\n        }\n        return this.getCharacterAtPosition({ line: pos.line, ch: pos.ch - 1 });\n    };\n\n    /**\n     * Get the token after the one at the given cursor position\n     *\n     * @param {{line: number, ch: number}} [cursor] - Optional cursor position after\n     *      which a token should be retrieved\n     * @param {boolean} [skipWhitespace] - true if this should skip over whitespace tokens. Default is true.\n     * @param {boolean} [precise] If given, results in more current results. Suppresses caching.\n     * @return {{end: number, start:number, line: number,string: string, type: string}} -\n     * the CodeMirror token after the one at the given cursor position\n     */\n    Editor.prototype.getNextToken = function (cursor, skipWhitespace = true, precise) {\n        cursor = Object.assign({}, cursor || this.getCursorPos());\n        let token = this.getToken(cursor, precise),\n            next = token,\n            doc = this.document;\n        next.line = cursor.line;\n\n        do {\n            if (next.end < doc.getLine(cursor.line).length) {\n                cursor.ch = next.end + 1;\n            } else if (doc.getLine(cursor.line + 1)) {\n                cursor.ch = 0;\n                cursor.line++;\n            } else {\n                next = null;\n                break;\n            }\n            next = this.getToken(cursor, precise);\n            next.line = cursor.line;\n        } while (skipWhitespace && !/\\S/.test(next.string));\n\n        return next;\n    };\n\n    /**\n     * Get the token before the one at the given cursor position\n     *\n     * @param {{line: number, ch: number}} [cursor] - Optional cursor position before\n     *      which a token should be retrieved\n     * @param {boolean} [skipWhitespace] - true if this should skip over whitespace tokens. Default is true.\n     * @param {boolean} [precise] If given, results in more current results. Suppresses caching.\n     * @return {{end: number, start:number, line: number,string: string, type: string}} - the CodeMirror token before\n     * the one at the given cursor position\n     */\n    Editor.prototype.getPreviousToken = function (cursor, skipWhitespace = true, precise) {\n        cursor = Object.assign({}, cursor || this.getCursorPos());\n        let token = this.getToken(cursor, precise),\n            prev = token,\n            doc = this.document;\n        prev.line = cursor.line;\n\n        do {\n            if (prev.start < cursor.ch) {\n                cursor.ch = prev.start;\n            } else if (cursor.line > 0) {\n                cursor.ch = doc.getLine(cursor.line - 1).length;\n                cursor.line--;\n            } else {\n                break;\n            }\n            prev = this.getToken(cursor, precise);\n            prev.line = cursor.line;\n        } while (skipWhitespace && !/\\S/.test(prev.string));\n\n        return prev;\n    };\n\n    /**\n     * Use This if you are making large number of editor changes in a single workflow to improve performance.\n     * The editor internally buffers changes and only updates its DOM structure after it has finished performing\n     * some operation. If you need to perform a lot of operations on a CodeMirror instance, you can call this method\n     * with a function argument. It will call the function, buffering up all changes, and only doing the expensive\n     * update after the function returns. This can be a lot faster. The return value from this method will be the\n     * return value of your function.\n     * @param execFn The function that will be called to make all editor changes.\n     * @return {*}\n     */\n    Editor.prototype.operation = function (execFn) {\n        return this._codeMirror.operation(execFn);\n    };\n\n    function getMarkOptionUnderlineError() {\n        return {\n            className: \"editor-text-fragment-error\"\n        };\n    }\n\n    function getMarkOptionUnderlineWarn() {\n        return {\n            className: \"editor-text-fragment-warn\"\n        };\n    }\n\n    function getMarkOptionUnderlineInfo() {\n        return {\n            className: \"editor-text-fragment-info\"\n        };\n    }\n\n    function getMarkOptionUnderlineSpellcheck() {\n        return {\n            className: \"editor-text-fragment-spell-error\"\n        };\n    }\n\n    function getMarkOptionHyperlinkText() {\n        return {\n            className: \"editor-text-fragment-hover\"\n        };\n    }\n\n    function getMarkOptionMatchingRefs() {\n        return {\n            className: \"editor-text-fragment-matching-refs\"\n        };\n    }\n\n    function getMarkOptionRenameOutline() {\n        return {\n            className: \"editor-text-rename-outline\",\n            startStyle: \"editor-text-rename-outline-left\",\n            endStyle: \"editor-text-rename-outline-right\",\n            clearWhenEmpty: false,\n            inclusiveLeft: true,\n            inclusiveRight: true\n        };\n    }\n\n    /**\n     * Mark option to underline errors.\n     */\n    Editor.getMarkOptionUnderlineError = getMarkOptionUnderlineError;\n\n    /**\n     * Mark option to underline warnings.\n     */\n    Editor.getMarkOptionUnderlineWarn = getMarkOptionUnderlineWarn;\n\n    /**\n     * Mark option to underline informational text.\n     */\n    Editor.getMarkOptionUnderlineInfo = getMarkOptionUnderlineInfo;\n\n    /**\n     * Mark option to underline spelling errors.\n     */\n    Editor.getMarkOptionUnderlineSpellcheck = getMarkOptionUnderlineSpellcheck;\n\n    /**\n     * Mark option to highlight hyperlinks.\n     */\n    Editor.getMarkOptionHyperlinkText = getMarkOptionHyperlinkText;\n\n    /**\n     * Mark option for matching references.\n     */\n    Editor.getMarkOptionMatchingRefs = getMarkOptionMatchingRefs;\n\n    /**\n     * Mark option for renaming outlines.\n     */\n    Editor.getMarkOptionRenameOutline = getMarkOptionRenameOutline;\n\n    /**\n     * Can be used to mark a range of text with a specific CSS class name. cursorFrom and cursorTo should be {line, ch}\n     * objects. The options parameter is optional.\n     *\n     * @param {string} markType - A String that can be used to label the mark type.\n     * @param {{line: number, ch: number}} cursorFrom - Mark start position\n     * @param {{line: number, ch: number}} cursorTo - Mark end position\n     * @param {Object} [options] - When given, it should be  one of the predefined `Editor.MARK_OPTION_UNDERLINE*` or\n     * it should be an object that may contain the following configuration options:\n     *\n     * @param {string} [options.metadata] - If you want to store any metadata object with the mark, use this.\n     * @param {string} [options.className] -Assigns a CSS class to the marked stretch of text.\n     * @param {string} [options.css] -A string of CSS to be applied to the covered text. For example \"color: #fe3\".\n     * @param {string} [options.startStyle] -Can be used to specify an extra CSS class to be applied to the leftmost\n     * span that is part of the marker.\n     * @param {string} [options.endStyle] -Equivalent to startStyle, but for the rightmost span.\n     * @param {object} [options.attributes] -When given, add the attributes in the given object to the elements created\n     * for the marked text. Adding class or style attributes this way is not supported.\n     * @param {boolean} [options.inclusiveLeft] - Determines whether text inserted on the left of the marker will end\n     * up inside or outside of it.\n     * @param {boolean} [options.inclusiveRight] - Like inclusiveLeft, but for the right side.\n     * @param {boolean} [options.atomic] -Atomic ranges act as a single unit when cursor movement is concernedi.e.\n     * it is impossible to place the cursor inside of them. You can control whether the cursor is allowed to be placed\n     * directly before or after them using selectLeft or selectRight. If selectLeft (or right) is not provided, then\n     * inclusiveLeft (or right) will control this behavior.\n     * @param {boolean} [options.selectLeft] -For atomic ranges, determines whether the cursor is allowed to be placed\n     * directly to the left of the range. Has no effect on non-atomic ranges.\n     * @param {boolean} [options.selectRight] - Like selectLeft, but for the right side.\n     * @param {boolean} [options.collapsed] - Collapsed ranges do not show up in the display.\n     * Setting a range to be collapsed will automatically make it atomic.\n     * @param {boolean} [options.clearOnEnter] - When enabled, will cause the mark to clear itself whenever the cursor\n     * enters its range. This is mostly useful for text-replacement widgets that need to 'snap open' when the user\n     * tries to edit them. The \"clear\" event fired on the range handle can be used to be notified when this happens.\n     * @param {boolean} [options.clearWhenEmpty] - Determines whether the mark is automatically cleared when it becomes\n     * empty. Default is true.\n     * @param {Element} [options.replacedWith] - Use a given node to display this range. Implies both collapsed and\n     * atomic. The given DOM node must be an inline element (as opposed to a block element).\n     * @param {boolean} [options.handleMouseEvents] - When replacedWith is given, this determines whether the editor\n     * will capture mouse and drag events occurring in this widget. Default is falsethe events will be left alone\n     * for the default browser handler, or specific handlers on the widget, to capture.\n     * @param {boolean} [options.readOnly] - A read-only span can, as long as it is not cleared, not be modified except\n     * by calling setValue to reset the whole document. Note: adding a read-only span currently clears the undo history\n     * of the editor, because existing undo events being partially nullified by read-only spans would corrupt the\n     * history (in the current implementation).\n     * @param {boolean} [options.addToHistory] - When set to true (default is false), adding this marker will create an\n     * event in the undo history that can be individually undone (clearing the marker).\n     *\n     * @return {{clear, find, changed}} TextMarker - The method will return an object(TextMarker) that represents\n     * the marker which exposes three methods:\n     * clear(), to remove the mark, find(), which returns a {from, to} object (both holding document positions),\n     * indicating the current position of the marked range, or undefined if the marker is no longer in the document,\n     * and finally changed(), which you can call if you've done something that might change the size of the marker\n     * (for example changing the content of a replacedWith node), and want to cheaply update the display.\n     *\n     * The Returned TextMarker emits the following events that can be listened with the on and off methods.\n     * @event beforeCursorEnter Fired on TextMarker when the cursor enters the marked range. From this event handler,\n     * the editor state may be inspected but not modified, with the exception that the range on which the event\n     * fires may be cleared.\n     * @event clear (from: {line, ch}, to: {line, ch}) Fired when the range is cleared, either through cursor movement\n     * in combination with clearOnEnter or through a call to its clear() method. Will only be fired once per handle.\n     * Note that deleting the range through text editing does not fire this event, because an undo action might\n     * bring the range back into existence. from and to give the part of the document that the range spanned\n     * when it was cleared.\n     * @event hide Fired when the last part of the marker is removed from the document by editing operations.\n     * @event unhide Fired when, after the marker was removed by editing, a undo operation brought the marker back.\n     */\n    Editor.prototype.markText = function (markType, cursorFrom, cursorTo, options) {\n        let newMark = this._codeMirror.markText(cursorFrom, cursorTo, options);\n        newMark.markType = markType;\n        newMark.metadata = options && options.metadata;\n        return newMark;\n    };\n\n    /**\n     * Same as markText, but will apply to the token at the given position or current position\n     * @param {string} markType - A String that can be used to label the mark type.\n     * @param {{line: number, ch: number}} cursor - The position of the token\n     * @param [options] same as markText\n     * @return {Object} TextMarker\n     */\n    Editor.prototype.markToken = function (markType, cursor, options) {\n        let token = this.getToken(cursor);\n        return this.markText(markType, { line: cursor.line, ch: token.start },\n            { line: cursor.line, ch: token.end }, options);\n    };\n\n    /**\n     * Inserts a bookmark, a handle that follows the text around it as it is being edited, at the given position.\n     * Similar to mark text, but for just a point instead of range.\n     * @param {string} markType - A String that can be used to label the mark type.\n     * @param {{line: number, ch: number}} [cursorPos] - Where to place the mark. Optional, if not specified, will\n     * use current pos\n     * @param {Object} [options] - When given, it should be an object that may contain the following\n     * configuration options:\n     * @param {Element} [options.widget] - Can be used to display a DOM node at the current location of the bookmark\n     * (analogous to the replacedWith option to markText).\n     * @param {boolean} [options.insertLeft] - By default, text typed when the cursor is on top of the bookmark will\n     * end up to the right of the bookmark. Set this option to true to make it go to the left instead.\n     * @param {boolean} [options.handleMouseEvents] - As with markText, this determines whether mouse events on the\n     * widget inserted for this bookmark are handled by CodeMirror. The default is false.\n     *\n     * @return {{clear, find}} TextMarker- A bookmark has two methods find() and clear(). `find` returns the current\n     * position of the bookmark, if it is still in the document, and `clear` explicitly removes the bookmark.\n     */\n    Editor.prototype.setBookmark = function (markType, cursorPos, options) {\n        cursorPos = cursorPos || this.getCursorPos();\n        let newMark = this._codeMirror.setBookmark(cursorPos, options);\n        newMark.markType = markType;\n        return newMark;\n    };\n\n    /**\n     * Returns an array of all the bookmarks and marked ranges found between the given positions (non-inclusive).\n     * @param {{line: number, ch: number}} cursorFrom - Mark start position\n     * @param {{line: number, ch: number}} cursorTo - Mark end position\n     * @param {string} [markType] - Optional, if given will only return marks of that type. Else returns everything.\n     * @returns {TextMarker[]} TextMarker - A text marker array\n     */\n    Editor.prototype.findMarks = function (cursorFrom, cursorTo, markType) {\n        let marks = this._codeMirror.findMarks(cursorFrom, cursorTo) || [];\n        return marks.filter(function (mark) {\n            return markType ? mark.markType === markType : true;\n        });\n    };\n\n    /**\n     * Returns an array of all the bookmarks and marked ranges present at the given position.\n     * @param {{line: number, ch: number}} cursorPos - cursor position\n     * @param {string} [markType] - Optional, if given will only return marks of that type. Else returns everything.\n     * @returns {TextMarker[]} TextMarker - A text marker array\n     */\n    Editor.prototype.findMarksAt = function (cursorPos, markType) {\n        let marks = this._codeMirror.findMarksAt(cursorPos) || [];\n        return marks.filter(function (mark) {\n            return markType ? mark.markType === markType : true;\n        });\n    };\n\n    /**\n     * Returns the first mark of a specific type found after the given position.\n     * @param {{line: number, ch: number}} position - The starting position to search from.\n     * @param {string} markType - The type of mark to look for.\n     * @returns {TextMarker[]} The array of text markers found, or an empty array if none are found.\n     */\n    Editor.prototype.getMarksAfter = function (position, markType) {\n        return this.findMarks(position, { line: this.lineCount(), ch: 0 }, markType) || [];\n    };\n\n    /**\n     * Returns the first mark of a specific type found before the given position.\n     * @param {{line: number, ch: number}} position - The ending position to search up to.\n     * @param {string} markType - The type of mark to look for.\n     * @returns {TextMarker[]} The array of text markers found, or an empty array if none are found.\n     */\n    Editor.prototype.getMarksBefore = function (position, markType) {\n        return this.findMarks({ line: 0, ch: 0 }, position, markType) || [];\n    };\n\n    /**\n     * Returns an array containing all marked ranges in the document.\n     * @param {string} [markType] - Optional, if given will only return marks of that type. Else returns everything.\n     * @returns {TextMarker[]} TextMarker - A text marker array\n     */\n    Editor.prototype.getAllMarks = function (markType) {\n        let marks = this._codeMirror.getAllMarks() || [];\n        return marks.filter(function (mark) {\n            return markType ? mark.markType === markType : true;\n        });\n    };\n\n    /**\n     * Clears all marks of the given type. If a lineNumbers array is given, only clears marks on those lines.\n     * If no markType or lineNumbers are given, clears all marks (use cautiously).\n     * @param {string} [markType] - Optional, if given will only delete marks of that type. Else delete everything.\n     * @param {number[]} [lineNumbers] - Optional, array of line numbers where marks should be cleared.\n     */\n    Editor.prototype.clearAllMarks = function (markType, lineNumbers) {\n        const self = this;\n\n        self._codeMirror.operation(function () {\n            let marks = self.getAllMarks(markType);\n\n            if (lineNumbers && Array.isArray(lineNumbers)) {\n                // Filter marks to only those within the specified line numbers\n                marks = marks.filter(function (mark) {\n                    const range = mark.find(); // Get the range of the mark\n                    if (!range) {\n                        return false;\n                    }\n\n                    const startLine = range.from.line;\n                    const endLine = range.to.line;\n\n                    // Check if the mark overlaps with any of the specified lines\n                    return lineNumbers.some(line => line >= startLine && line <= endLine);\n                });\n            }\n\n            // Clear the filtered marks\n            for (let mark of marks) {\n                mark.clear();\n            }\n        });\n    };\n\n    /**\n     * Checks if two positions in the editor are the same.\n     *\n     * @param {{line: number, ch: number}} position1 - cursor position\n     * @param {{line: number, ch: number}} position2 - cursor position\n     * @returns {boolean} True if both positions are the same, false otherwise.\n     */\n    Editor.prototype.isSamePosition = function (position1, position2) {\n        return position1.line === position2.line && position1.ch === position2.ch;\n    };\n\n    /**\n     * Get a (JSON-serializable) representation of the undo history.\n     *\n     * @returns {Array} The history of the editor.\n     */\n    Editor.prototype.getHistory = function () {\n        return this._codeMirror.getHistory();\n    };\n\n    /**\n     * Replace the editor's undo history with the one provided, which must be a value\n     * as returned by getHistory. Note that this will have entirely undefined results\n     * if the editor content isn't also the same as it was when getHistory was called.\n     */\n    Editor.prototype.setHistory = function () {\n        return this._codeMirror.setHistory();\n    };\n\n    /**\n     * Creates a named restore point in undo history. this can be later be restored to undo all\n     * changed till the named restore point in one go.\n     * @param {string} restorePointName - The name of the restore point to revert to.\n     */\n    Editor.prototype.createHistoryRestorePoint = function (restorePointName) {\n        const history = this.getHistory();\n        if (history.done && history.done.length) {\n            history.done[history.done.length - 1].restorePointName = restorePointName;\n        }\n        // the current history event should be closed, meaning it can't be combined with further changes\n        // (rapid typing or deleting events are typically combined) as we need to effectively snapshot this history\n        // point at this time.\n        this._codeMirror.changeGeneration(true);\n    };\n\n    /**\n     * To restore the editor to a named restore point\n     * if the restore point is found, it reverts all changes made after that point.\n     *\n     * @param {string} restorePointName - The name of the restore point to revert to.\n     */\n    Editor.prototype.restoreHistoryPoint = function (restorePointName) {\n        const history = this.getHistory();\n        if (!history.done && !history.done.length) {\n            return;\n        }\n        let canRestore = false;\n        for (let i = history.done.length - 1; i >= 0; i--) {\n            // history is a stack\n            const historyEntry = history.done[i];\n            if (historyEntry.restorePointName === restorePointName) {\n                canRestore = true;\n                break;\n            }\n        }\n        if (!canRestore) {\n            return;\n        }\n        const cm = this._codeMirror;\n        const self = this;\n        cm.operation(function () {\n            let newHistory = self.getHistory(), historyLength;\n            let lastHistoryItem = newHistory.done && newHistory.done.length\n                && history.done[history.done.length - 1];\n            while (lastHistoryItem && lastHistoryItem.restorePointName !== restorePointName) {\n                newHistory = self.getHistory();\n                historyLength = newHistory.done.length;\n                cm.undoSelection();\n                newHistory = self.getHistory();\n                if (historyLength === newHistory.done.length) {\n                    // undo selection didnt do anything, try undo\n                    cm.undo();\n                    newHistory = self.getHistory();\n                    if (historyLength === newHistory.done.length) {\n                        // we cant undo, and this will go into an infinite loop if we continue.\n                        console.error(\"Could not undo history to restore snapshot!\");\n                        break;\n                    }\n                }\n                lastHistoryItem = newHistory.done && newHistory.done.length\n                    && newHistory.done[newHistory.done.length - 1];\n            }\n        });\n    };\n\n    /**\n     * Sets the current selection. Start is inclusive, end is exclusive. Places the cursor at the\n     * end of the selection range. Optionally centers around the cursor after\n     * making the selection\n     *\n     * @param {{line:number, ch:number}} start\n     * @param {{line:number, ch:number}} [end] If not specified, defaults to start.\n     * @param {boolean} [center] true to center the viewport\n     * @param {number} [centerOptions] Option value, or 0 for no options; one of the BOUNDARY_* constants above.\n     * @param {?string} [origin] An optional string that describes what other selection or edit operations this\n     *      should be merged with for the purposes of undo. See {@link Document::Document#replaceRange} for more details.\n     */\n    Editor.prototype.setSelection = function (start, end, center, centerOptions, origin) {\n        this.setSelections([{ start: start, end: end || start }], center, centerOptions, origin);\n    };\n\n    /**\n     * Replace the selection with the given string.\n     * @param {string} replacement the text to replace the current selection\n     * @param {string} [select] The optional select argument can be used to change selection. Passing \"around\"\n     * will cause the new text to be selected, passing \"start\" will collapse the selection to the start\n     * of the inserted text.\n     */\n    Editor.prototype.replaceSelection = function (replacement, select) {\n        this._codeMirror.replaceSelection(replacement, select);\n    };\n\n    /**\n     * Replaces the content of multiple selections with the strings in the array. The length of the given\n     * array should be the same as the number of active selections.\n     * @param {Array<string>} replacement the text array to replace the current selections with\n     * @param {string} [select] The optional select argument can be used to change selection. Passing \"around\"\n     * will cause the new text to be selected, passing \"start\" will collapse the selection to the start\n     * of the inserted text.\n     */\n    Editor.prototype.replaceSelections = function (replacement, select) {\n        this._codeMirror.replaceSelections(replacement, select);\n    };\n\n    /**\n     * Replace the part of the document between from and to with the given string.\n     * @param {string} replacement the text to replace the current selection\n     * @param {{line:number, ch:number}} from the strat position to replace\n     * @param {{line:number, ch:number}} [to] the end position to replace. to can be left off to simply\n     * insert the string at position from.\n     * @param {string} origin When origin is given, it will be passed on to \"change\" events, and its first\n     * letter will be used to determine whether this change can be merged with previous history events\n     * of the inserted text.\n     */\n    Editor.prototype.replaceRange = function (replacement, from, to, origin) {\n        this._codeMirror.replaceRange(replacement, from, to, origin);\n    };\n\n\n    /**\n     * Replaces multiple ranges in the editor with the specified texts.\n     *\n     * @method\n     * @param {Array} ranges - An array of range objects, each containing `from`, `to`, and `text` properties.\n     * @param {Object} ranges[].from - The start position of the range to be replaced. It should have `line` and `ch` properties.\n     * @param {Object} ranges[].to - The end position of the range to be replaced. It should have `line` and `ch` properties.\n     * @param {string} ranges[].text - The text to replace the specified range.\n     * @param {string} [origin] - An optional origin identifier to be associated with the changes.\n     * @example\n     * editor.replaceMultipleRanges([\n     *   { from: { line: 0, ch: 0 }, to: { line: 0, ch: 5 }, text: 'Hello' },\n     *   { from: { line: 1, ch: 0 }, to: { line: 1, ch: 4 }, text: 'World' }\n     * ], 'exampleOrigin');\n     */\n    Editor.prototype.replaceMultipleRanges = function (ranges, origin) {\n        // Sort ranges in descending order by start position so that they dont step over each other\n        let self = this;\n        self.operation(() => {\n            ranges.sort((a, b) => {\n                if (a.from.line === b.from.line) {\n                    return b.from.ch - a.from.ch;\n                }\n                return b.from.line - a.from.line;\n            });\n\n            // Replace each range with its corresponding replacement text\n            ranges.forEach(range => {\n                self.replaceRange(range.text, range.from, range.to, origin);\n            });\n        });\n    };\n\n    /**\n     * Clears any active selection if present.\n     */\n    Editor.prototype.clearSelection = function () {\n        let pos = this.getCursorPos();\n        this.setCursorPos(pos.line, pos.ch);\n    };\n\n    /**\n     * Sets a multiple selection, with the \"primary\" selection (the one returned by\n     * getSelection() and getCursorPos()) defaulting to the last if not specified.\n     * Overlapping ranges will be automatically merged, and the selection will be sorted.\n     * Optionally centers around the primary selection after making the selection.\n     * @param {!{start:{line:number, ch:number}, end:{line:number, ch:number}, primary:boolean, reversed: boolean}} selections\n     *      The selection ranges to set. If the start and end of a range are the same, treated as a cursor.\n     *      If reversed is true, set the anchor of the range to the end instead of the start.\n     *      If primary is true, this is the primary selection. Behavior is undefined if more than\n     *      one selection has primary set to true. If none has primary set to true, the last one is primary.\n     * @param {boolean} center true to center the viewport around the primary selection.\n     * @param {number} centerOptions Option value, or 0 for no options; one of the BOUNDARY_* constants above.\n     * @param {?string} origin An optional string that describes what other selection or edit operations this\n     *      should be merged with for the purposes of undo. See {@link Document::Document#replaceRange} for more details.\n     */\n    Editor.prototype.setSelections = function (selections, center, centerOptions, origin) {\n        var primIndex = selections.length - 1, options;\n        if (origin) {\n            options = { origin: origin };\n        }\n        this._codeMirror.setSelections(_.map(selections, function (sel, index) {\n            if (sel.primary) {\n                primIndex = index;\n            }\n            return { anchor: sel.reversed ? sel.end : sel.start, head: sel.reversed ? sel.start : sel.end };\n        }), primIndex, options);\n        if (center) {\n            this.centerOnCursor(centerOptions);\n        }\n    };\n\n    /**\n     * Sets the editors overwrite mode state. If null is passed, the state is toggled.\n     *\n     * @param {?boolean} start\n     */\n    Editor.prototype.toggleOverwrite = function (state) {\n        this._codeMirror.toggleOverwrite(state);\n    };\n\n    /**\n     * Selects word that the given pos lies within or adjacent to. If pos isn't touching a word\n     * (e.g. within a token like \"//\"), moves the cursor to pos without selecting a range.\n     * @param {!{line:number, ch:number}}\n     */\n    Editor.prototype.selectWordAt = function (pos) {\n        var word = this._codeMirror.findWordAt(pos);\n        this.setSelection(word.anchor, word.head);\n    };\n\n    /**\n     * To get the text between the starting position and the ending position\n     * @param {!{line:number, ch:number}} startPos | The starting position\n     * @param {!{line:number, ch:number}} endPos | The ending position\n     * @returns {string} The text between the starting position and the ending position\n     */\n    Editor.prototype.getTextBetween = function (startPos, endPos) {\n        const text = this._codeMirror.getRange(startPos, endPos);\n        return text;\n    };\n\n    /**\n     * Gets word at the given pos lies within or adjacent to. If pos isn't touching a word\n     * (e.g. within a token like \"//\"), returns null\n     * @param pos\n     * @return {{text:string, startPos:{line:number, ch:number}, endPos: {line:number, ch:number}}}\n     */\n    Editor.prototype.getWordAt = function (pos) {\n        const wordRange = this._codeMirror.findWordAt(pos);\n        const text = this._codeMirror.getRange(wordRange.anchor, wordRange.head);\n        return {\n            text,\n            startPos: wordRange.anchor,\n            endPos: wordRange.head\n        };\n    };\n\n    /**\n     * Gets number string of (upto 10 digits default) at the given pos lies within or adjacent to.\n     * If pos isn't touching a number, returns null. If the number in string is greater than max digits\n     *  returns null.\n     * @param pos\n     * @param {number} maxDigits - number of digits allowed. This is to prevent massive digit strings.\n     * @return {{text:string, startPos:{line:number, ch:number}, endPos: {line:number, ch:number}}}\n     */\n    Editor.prototype.getNumberAt = function (pos, maxDigits = 10) {\n        // Eg: string \"margin:1.4em;\" the position maybe at the location 4, . or 1\n        const token = this._codeMirror.getTokenAt(pos);\n        const maxDigitsOverflow = maxDigits + 1;\n\n        if (token.type === \"string\" || token.type === \"number\") {\n            const str = token.string;\n            let left = pos.ch - token.start; // Start scanning from the given position\n            let right = left;\n            let decimalAlreadyFound = false,\n                digitCount = 0;\n\n            // Scan left to find the start of the number\n            while (left - 1 >= 0 && (/\\d|\\.|-/).test(str[left - 1]) && digitCount < maxDigitsOverflow) {\n                // Make sure not to count multiple decimal points in a number\n                if (str[left - 1] === '.' && !decimalAlreadyFound) {\n                    decimalAlreadyFound = true;\n                } else if (str[left - 1] === '.' && decimalAlreadyFound) {\n                    break;\n                } else if (str[left - 1] === '-') {\n                    left--;\n                    break;\n                }\n                digitCount++;\n                left--;\n            }\n\n            // Scan right to find the end of the number\n            while (right < str.length && (/\\d|\\./).test(str[right]) && digitCount < maxDigitsOverflow) {\n                // Make sure not to count multiple decimal points in a number\n                if (str[right] === '.' && !decimalAlreadyFound) {\n                    decimalAlreadyFound = true;\n                } else if (str[right] === '.' && decimalAlreadyFound) {\n                    break;\n                }\n                digitCount++;\n                right++;\n            }\n\n            // If we found a number, and it is withing the original max digit count, return the result\n            if (left !== right && digitCount !== maxDigitsOverflow) {\n                const text = str.substring(left, right);\n                if (text !== \".\" && text !== \"-\") {\n                    return {\n                        text: str.substring(left, right),\n                        startPos: { line: pos.line, ch: token.start + left },\n                        endPos: { line: pos.line, ch: token.start + right }\n                    };\n                }\n            }\n        }\n\n        return null;\n    };\n\n    /**\n     * Gets the total number of lines in the document (includes lines not visible in the viewport)\n     * @return {!number}\n     */\n    Editor.prototype.lineCount = function () {\n        return this._codeMirror.lineCount();\n    };\n\n    /**\n     * Deterines if line is fully visible.\n     * @param {number} zero-based index of the line to test\n     * @return {boolean} true if the line is fully visible, false otherwise\n     */\n    Editor.prototype.isLineVisible = function (line) {\n        var coords = this._codeMirror.charCoords({ line: line, ch: 0 }, \"local\"),\n            scrollInfo = this._codeMirror.getScrollInfo(),\n            top = scrollInfo.top,\n            bottom = scrollInfo.top + scrollInfo.clientHeight;\n\n        // Check top and bottom and return false for partially visible lines.\n        return (coords.top >= top && coords.bottom <= bottom);\n    };\n\n    /**\n     * Gets the number of the first visible line in the editor.\n     * @return {number} The 0-based index of the first visible line.\n     */\n    Editor.prototype.getFirstVisibleLine = function () {\n        return (this._visibleRange ? this._visibleRange.startLine : 0);\n    };\n\n    /**\n     * Gets the number of the last visible line in the editor.\n     * @return {number} The 0-based index of the last visible line.\n     */\n    Editor.prototype.getLastVisibleLine = function () {\n        return (this._visibleRange ? this._visibleRange.endLine : this.lineCount() - 1);\n    };\n\n    /**\n     * Hides the specified line number in the editor\n     * @private\n     * @param {!from} line to start hiding from (inclusive)\n     * @param {!to} line to end hiding at (exclusive)\n     * @return {TextMarker} The CodeMirror mark object that's hiding the lines\n     */\n    Editor.prototype._hideLines = function (from, to) {\n        if (to <= from) {\n            return;\n        }\n\n        // We set clearWhenEmpty: false so that if there's a blank line at the beginning or end of\n        // the document, and that's the only hidden line, we can still actually hide it. Doing so\n        // requires us to create a 0-length marked span, which would ordinarily be cleaned up by CM\n        // if clearWithEmpty is true. See https://groups.google.com/forum/#!topic/codemirror/RB8VNF8ow2w\n        var value = this._codeMirror.markText(\n            { line: from, ch: 0 },\n            { line: to - 1, ch: this._codeMirror.getLine(to - 1).length },\n            { collapsed: true, inclusiveLeft: true, inclusiveRight: true, clearWhenEmpty: false }\n        );\n\n        return value;\n    };\n\n    /**\n     * Gets the total height of the document in pixels (not the viewport)\n     * @return {!number} height in pixels\n     */\n    Editor.prototype.totalHeight = function () {\n        return this.getScrollerElement().scrollHeight;\n    };\n\n    /**\n     * Gets the scroller element from the editor.\n     * @return {!HTMLDivElement} scroller\n     */\n    Editor.prototype.getScrollerElement = function () {\n        return this._codeMirror.getScrollerElement();\n    };\n\n    /**\n     * Gets the root DOM node of the editor.\n     * @return {!HTMLDivElement} The editor's root DOM node.\n     */\n    Editor.prototype.getRootElement = function () {\n        return this._codeMirror.getWrapperElement();\n    };\n\n\n    /**\n     * Gets the lineSpace element within the editor (the container around the individual lines of code).\n     * FUTURE: This is fairly CodeMirror-specific. Logic that depends on this may break if we switch\n     * editors.\n     * @private\n     * @return {!HTMLDivElement} The editor's lineSpace element.\n     */\n    Editor.prototype._getLineSpaceElement = function () {\n        return $(\".CodeMirror-lines\", this.getScrollerElement()).children().get(0);\n    };\n\n    /**\n     * Returns the current scroll position of the editor.\n     * @return {{x:number, y:number}} The x,y scroll position in pixels\n     */\n    Editor.prototype.getScrollPos = function () {\n        var scrollInfo = this._codeMirror.getScrollInfo();\n        return { x: scrollInfo.left, y: scrollInfo.top };\n    };\n\n    /**\n     * Restores and adjusts the current scroll position of the editor.\n     * @param {{x:number, y:number}} scrollPos - The x,y scroll position in pixels\n     * @param {!number} heightDelta - The amount of delta H to apply to the scroll position\n     */\n    Editor.prototype.adjustScrollPos = function (scrollPos, heightDelta) {\n        this._codeMirror.scrollTo(scrollPos.x, scrollPos.y + heightDelta);\n    };\n\n    /**\n     * Sets the current scroll position of the editor.\n     * @param {number} x scrollLeft position in pixels\n     * @param {number} y scrollTop position in pixels\n     */\n    Editor.prototype.setScrollPos = function (x, y) {\n        this._codeMirror.scrollTo(x, y);\n    };\n\n    /**\n     * Returns the current text height of the editor.\n     * @return {number} Height of the text in pixels\n     */\n    Editor.prototype.getTextHeight = function () {\n        return this._codeMirror.defaultTextHeight();\n    };\n\n    /**\n     * Adds an inline widget below the given line. If any inline widget was already open for that\n     * line, it is closed without warning.\n     * @param {!{line:number, ch:number}} pos  Position in text to anchor the inline.\n     * @param {!InlineWidget} inlineWidget The widget to add.\n     * @param {boolean=} scrollLineIntoView Scrolls the associated line into view. Default true.\n     * @return {$.Promise} A promise object that is resolved when the widget has been added (but might\n     *     still be animating open). Never rejected.\n     */\n    Editor.prototype.addInlineWidget = InlineWidgetHelper.addInlineWidget;\n\n    /**\n     * Removes all inline widgets\n     */\n    Editor.prototype.removeAllInlineWidgets = InlineWidgetHelper.removeAllInlineWidgets;\n\n    /**\n     * Removes the given inline widget.\n     * @param {number} inlineWidget The widget to remove.\n     * @return {$.Promise} A promise that is resolved when the inline widget is fully closed and removed from the DOM.\n     */\n    Editor.prototype.removeInlineWidget = InlineWidgetHelper.removeInlineWidget;\n\n    /**\n     * Removes all inline widgets for a given line\n     * @param {number} lineNum The line number to modify\n     */\n    Editor.prototype.removeAllInlineWidgetsForLine = InlineWidgetHelper.removeAllInlineWidgetsForLine;\n\n    /**\n     * ****** Update actual public API doc in Editor.js *****\n     * Gets all inline widgets for a given line\n     * @param {number} lineNum The line number to modify\n     */\n    Editor.prototype.getAllInlineWidgetsForLine = InlineWidgetHelper.getAllInlineWidgetsForLine;\n\n    /**\n     * Returns a list of all inline widgets currently open in this editor. Each entry contains the\n     * inline's id, and the data parameter that was passed to addInlineWidget().\n     * @return {!{id:number, data:Object[]}}\n     */\n    Editor.prototype.getInlineWidgets = InlineWidgetHelper.getInlineWidgets;\n\n    /**\n     * Returns the currently focused inline widget, if any.\n     * @return {?InlineWidget}\n     */\n    Editor.prototype.getFocusedInlineWidget = InlineWidgetHelper.getFocusedInlineWidget;\n\n    /**\n     * Sets the height of an inline widget in this editor.\n     * @param {!InlineWidget} inlineWidget The widget whose height should be set.\n     * @param {!number} height The height of the widget.\n     * @param {boolean=} ensureVisible Whether to scroll the entire widget into view. Default false.\n     */\n    Editor.prototype.setInlineWidgetHeight = InlineWidgetHelper.setInlineWidgetHeight;\n\n    /**\n     * Display temporary popover message at current cursor position. Display message above\n     * cursor if space allows, otherwise below.\n     *\n     * @param {string} errorMsg Error message to display\n     * @function\n     */\n    Editor.prototype.displayErrorMessageAtCursor = ErrorPopupHelper.displayErrorMessageAtCursor;\n\n    /**\n     * Returns the offset of the top of the virtual scroll area relative to the browser window (not the editor\n     * itself). Mainly useful for calculations related to scrollIntoView(), where you're starting with the\n     * offset() of a child widget (relative to the browser window) and need to figure out how far down it is from\n     * the top of the virtual scroll area (excluding the top padding).\n     * @return {number}\n     */\n    Editor.prototype.getVirtualScrollAreaTop = function () {\n        var topPadding = this._getLineSpaceElement().offsetTop, // padding within mover\n            scroller = this.getScrollerElement();\n        return $(scroller).offset().top - scroller.scrollTop + topPadding;\n    };\n\n    /** Gives focus to the editor control */\n    Editor.prototype.focus = function () {\n        // Focusing an editor synchronously triggers focus/blur handlers. If a blur handler attemps to focus\n        // another editor, we'll put CM in a bad state (because CM assumes programmatically focusing itself\n        // will always succeed, and if you're in the middle of another focus change that appears to be untrue).\n        // So instead, we simply ignore reentrant focus attempts.\n        // See bug #2951 for an example of this happening and badly hosing things.\n        if (_duringFocus) {\n            return;\n        }\n\n        _duringFocus = true;\n        try {\n            this._codeMirror.focus();\n        } finally {\n            _duringFocus = false;\n        }\n    };\n\n    /** Returns true if the editor has focus */\n    Editor.prototype.hasFocus = function () {\n        return this._focused;\n    };\n\n    /*\n     * @typedef {scrollPos:{x:number, y:number},{start:{line:number, ch:number},end:{line:number, ch:number}}} EditorViewState\n     */\n\n    /**\n     * returns the view state for the editor\n     * @return {!EditorViewState}\n     */\n    Editor.prototype.getViewState = function () {\n        return {\n            selections: this.getSelections(),\n            scrollPos: this.getScrollPos()\n        };\n\n    };\n\n    /**\n     * Restores the view state\n     * @param {!EditorViewState} viewState - the view state object to restore\n     */\n    Editor.prototype.restoreViewState = function (viewState) {\n        if (viewState.selection) {\n            // We no longer write out single-selection, but there might be some view state\n            // from an older version.\n            this.setSelection(viewState.selection.start, viewState.selection.end);\n        }\n        if (viewState.selections) {\n            this.setSelections(viewState.selections);\n        }\n        if (viewState.scrollPos) {\n            this.setScrollPos(viewState.scrollPos.x, viewState.scrollPos.y);\n        }\n    };\n\n    /**\n     * Re-renders the editor UI\n     * @param {boolean=} handleResize true if this is in response to resizing the editor. Default false.\n     */\n    Editor.prototype.refresh = function (handleResize) {\n        // If focus is currently in a child of the CodeMirror editor (e.g. in an inline widget), but not in\n        // the CodeMirror input field itself, remember the focused item so we can restore focus after the\n        // refresh (which might cause the widget to be removed from the display list temporarily).\n        var focusedItem = window.document.activeElement,\n            restoreFocus = $.contains(this._codeMirror.getScrollerElement(), focusedItem);\n        this._codeMirror.refresh();\n        if (restoreFocus) {\n            focusedItem.focus();\n        }\n    };\n\n    /**\n     * Re-renders the editor, and all children inline editors.\n     * @param {boolean=} handleResize true if this is in response to resizing the editor. Default false.\n     */\n    Editor.prototype.refreshAll = function (handleResize) {\n        this.refresh(handleResize);\n        this.getInlineWidgets().forEach(function (inlineWidget) {\n            inlineWidget.refresh();\n        });\n    };\n\n    /** Undo the last edit. */\n    Editor.prototype.undo = function () {\n        this._codeMirror.undo();\n    };\n\n    /** Redo the last un-done edit. */\n    Editor.prototype.redo = function () {\n        this._codeMirror.redo();\n    };\n\n    /**\n     * View API Visibility Change Notification handler.  This is also\n     * called by the native \"setVisible\" API which refresh can be optimized\n     * @param {boolean} show true to show the editor, false to hide it\n     * @param {boolean} refresh true (default) to refresh the editor, false to skip refreshing it\n     */\n    Editor.prototype.notifyVisibilityChange = function (show, refresh) {\n        if (show && (refresh || refresh === undefined)) {\n            this.refresh();\n        }\n        if (show) {\n            this._inlineWidgets.forEach(function (inlineWidget) {\n                inlineWidget.onParentShown();\n            });\n        }\n    };\n\n    /**\n     * Shows or hides the editor within its parent. Does not force its ancestors to\n     * become visible.\n     * @param {boolean} show true to show the editor, false to hide it\n     * @param {boolean} refresh true (default) to refresh the editor, false to skip refreshing it\n     */\n    Editor.prototype.setVisible = function (show, refresh) {\n        this.$el.css(\"display\", (show ? \"\" : \"none\"));\n        this.notifyVisibilityChange(show, refresh);\n    };\n\n    /**\n     * Returns true if the editor is fully visible--i.e., is in the DOM, all ancestors are\n     * visible, and has a non-zero width/height.\n     */\n    Editor.prototype.isFullyVisible = function () {\n        return $(this.getRootElement()).is(\":visible\");\n    };\n\n    /**\n     * Gets the syntax-highlighting mode for the given range.\n     * Returns null if the mode at the start of the selection differs from the mode at the end -\n     * an *approximation* of whether the mode is consistent across the whole range (a pattern like\n     * A-B-A would return A as the mode, not null).\n     *\n     * @param {!{line: number, ch: number}} start The start of the range to check.\n     * @param {!{line: number, ch: number}} end The end of the range to check.\n     * @param {boolean=} knownMixed Whether we already know we're in a mixed mode and need to check both\n     *     the start and end.\n     * @return {?(Object|string)} Name of syntax-highlighting mode, or object containing a \"name\" property\n     *     naming the mode along with configuration options required by the mode.\n     * @see {@link LanguageManager::#getLanguageForPath} and {@link LanguageManager::Language#getMode}.\n     */\n    Editor.prototype.getModeForRange = function (start, end, knownMixed) {\n        var outerMode = this._codeMirror.getMode(),\n            startMode = TokenUtils.getModeAt(this._codeMirror, start),\n            endMode = TokenUtils.getModeAt(this._codeMirror, end);\n        if (!knownMixed && outerMode.name === startMode.name) {\n            // Mode does not vary: just use the editor-wide mode name\n            return this._codeMirror.getOption(\"mode\");\n        } else if (!startMode || !endMode || startMode.name !== endMode.name) {\n            return null;\n        }\n        return startMode;\n\n    };\n\n    /**\n     * Gets the syntax-highlighting mode for the current selection or cursor position. (The mode may\n     * vary within one file due to embedded languages, e.g. JS embedded in an HTML script block). See\n     * `getModeForRange()` for how this is determined for a single selection.\n     *\n     * If there are multiple selections, this will return a mode only if all the selections are individually\n     * consistent and resolve to the same mode.\n     *\n     * @param {{start:{line:number, ch:number}, end:{line:number, ch:number}, reversed:boolean}} selection\n     * @return {?(Object|string)} Name of syntax-highlighting mode, or object containing a \"name\" property\n     *     naming the mode along with configuration options required by the mode.\n     * @see {@link LanguageManager::#getLanguageForPath} and {@link LanguageManager::Language#getMode}.\n     */\n    Editor.prototype.getModeForSelection = function (selection) {\n        // Check for mixed mode info\n        var self = this,\n            sels = selection ? [selection] : this.getSelections(),\n            primarySel = selection || this.getSelection(),\n            outerMode = this._codeMirror.getMode(),\n            startMode = TokenUtils.getModeAt(this._codeMirror, primarySel.start),\n            isMixed = (outerMode.name !== startMode.name);\n\n        if (isMixed) {\n            // This is the magic code to let the code view know that we are in 'css' context\n            // if the CodeMirror outermode is 'htmlmixed' and we are in 'style' attributes\n            // value context. This has to be done as CodeMirror doesn't yet think this as 'css'\n            // This magic is executed only when user is having a cursor and not selection\n            // We will enable selection handling one we figure a way out to handle mixed scope selection\n            if (outerMode.name === 'htmlmixed' && primarySel.start.line === primarySel.end.line && primarySel.start.ch === primarySel.end.ch) {\n                var tagInfo = HTMLUtils.getTagInfo(this, primarySel.start, true),\n                    tokenType = tagInfo.position.tokenType;\n\n                if (tokenType === HTMLUtils.ATTR_VALUE && tagInfo.attr.name.toLowerCase() === 'style') {\n                    return 'css';\n                }\n            }\n            // Shortcut the first check to avoid getModeAt(), which can be expensive\n            if (primarySel.start.line !== primarySel.end.line || primarySel.start.ch !== primarySel.end.ch) {\n                var endMode = TokenUtils.getModeAt(this._codeMirror, primarySel.end);\n\n                if (startMode.name !== endMode.name) {\n                    return null;\n                }\n            }\n\n            // If mixed mode, check that mode is the same at start & end of each selection\n            var hasMixedSel = _.some(sels, function (sel) {\n                if (sels === primarySel) {\n                    // We already checked this before, so we know it's not mixed.\n                    return false;\n                }\n\n                var rangeMode = self.getModeForRange(sel.start, sel.end, true);\n                return (!rangeMode || rangeMode.name !== startMode.name);\n            });\n            if (hasMixedSel) {\n                return null;\n            }\n\n            return startMode.name;\n        }\n        // Mode does not vary: just use the editor-wide mode\n        return this._codeMirror.getOption(\"mode\");\n\n    };\n\n    /**\n     * gets the language for the selection. (Javascript selected from an HTML document or CSS selected from an HTML\n     * document, etc...)\n     * @return {!Language}\n     */\n    Editor.prototype.getLanguageForSelection = function () {\n        return this.document.getLanguage().getLanguageForMode(this.getModeForSelection());\n    };\n\n    /**\n     * gets the language for the selection. (Javascript selected from an HTML document or CSS selected from an HTML\n     * document, etc...)\n     * @return {!Language}\n     */\n    Editor.prototype.getLanguageForPosition = function (pos) {\n        let self = this;\n        pos = pos || self.getCursorPos();\n        return this.document.getLanguage().getLanguageForMode(self.getModeForSelection({ start: pos, end: pos }));\n    };\n\n    /**\n     * Gets the syntax-highlighting mode for the document.\n     *\n     * @return {Object|String} Object or Name of syntax-highlighting mode\n     * @see {@link LanguageManager::#getLanguageForPath|LanguageManager.getLanguageForPath} and {@link LanguageManager::Language#getMode|Language.getMode}.\n     */\n    Editor.prototype.getModeForDocument = function () {\n        return this._codeMirror.getOption(\"mode\");\n    };\n\n    /**\n     * The Document we're bound to\n     * @type {!Document}\n     */\n    Editor.prototype.document = null;\n\n\n    /**\n     * The Editor's last known width.\n     * Used in conjunction with updateLayout to recompute the layout\n     * if the parent container changes its size since our last layout update.\n     * @private\n     * @type {?number}\n     */\n    Editor.prototype._lastEditorWidth = null;\n\n\n    /**\n     * If true, we're in the middle of syncing to/from the Document. Used to ignore spurious change\n     * events caused by us (vs. change events caused by others, which we need to pay attention to).\n     * @private\n     * @type {!boolean}\n     */\n    Editor.prototype._duringSync = false;\n\n    /**\n     * @private\n     * NOTE: this is actually \"semi-private\": EditorManager also accesses this field... as well as\n     * a few other modules. However, we should try to gradually move most code away from talking to\n     * CodeMirror directly.\n     * @type {!CodeMirror}\n     */\n    Editor.prototype._codeMirror = null;\n\n    /**\n     * @private\n     * @type {!{id:number, data:Object[]}}\n     */\n    Editor.prototype._inlineWidgets = null;\n\n    /**\n     * @private\n     * @type {?TextRange}\n     */\n    Editor.prototype._visibleRange = null;\n\n    /**\n     * @private\n     * @type {Object}\n     * Promise queues for inline widgets being added to a given line.\n     */\n    Editor.prototype._inlineWidgetQueues = null;\n\n    /**\n     * @private\n     * @type {Array}\n     * A list of objects corresponding to the markers that are hiding lines in the current editor.\n     */\n    Editor.prototype._hideMarks = null;\n\n    /**\n     * @private\n     *\n     * Retrieve the value of the named preference for this document.\n     *\n     * @param {string} prefName Name of preference to retrieve.\n     * @return {*} current value of that pref\n     */\n    Editor.prototype._getOption = function (prefName) {\n        return PreferencesManager.get(prefName, PreferencesManager._buildContext(this.document.file.fullPath, this.document.getLanguage().getId()));\n    };\n\n\n    const SPACING_OPTIONS = new Set([\n        AUTO_TAB_SPACES,\n        USE_TAB_CHAR,\n        SPACE_UNITS,\n        TAB_SIZE\n    ]);\n    /**\n     * @private\n     *\n     * Updates the editor to the current value of prefName for the file being edited.\n     *\n     * @param {string} prefName Name of the preference to visibly update\n     */\n    Editor.prototype._updateOption = function (prefName) {\n        let oldValue = this._currentOptions[prefName],\n            newValue = this._getOption(prefName);\n\n        const fullPath = this.document.file.fullPath;\n        if (SPACING_OPTIONS.has(prefName)) {\n            const newUseAutoTabs = Editor.getAutoTabSpaces(fullPath);\n            if (newUseAutoTabs) {\n                _computeTabSpaces(this);\n            }\n            const newUseTabCharCfg = Editor.getUseTabChar(fullPath);\n            const newSpaceUnits = Editor.getSpaceUnits(fullPath);\n            const newTabSize = Editor.getTabSize(fullPath);\n            const newTabUnits = Editor.getAutoTabUnits(fullPath);\n            if (this._currentOptions[AUTO_TAB_SPACES] === newUseAutoTabs &&\n                this._currentOptions[USE_TAB_CHAR] === newUseTabCharCfg &&\n                this._currentOptions[SPACE_UNITS] === newSpaceUnits &&\n                this._currentOptions[TAB_SIZE] === newTabSize) {\n                // no change\n                const currentIndentUnit = this._codeMirror.getOption(\"indentUnit\");\n                let expectedIndentUnit;\n                if (newUseAutoTabs) {\n                    expectedIndentUnit = newUseTabCharCfg ?\n                        newTabUnits * this._currentOptions[TAB_SIZE] :\n                        this._currentOptions[SPACE_UNITS];\n                } else {\n                    expectedIndentUnit = newUseTabCharCfg ?\n                        this._currentOptions[TAB_SIZE] :\n                        this._currentOptions[SPACE_UNITS];\n                }\n                if (currentIndentUnit === expectedIndentUnit) {\n                    return;\n                }\n            }\n            this._currentOptions[AUTO_TAB_SPACES] = newUseAutoTabs;\n            this._currentOptions[USE_TAB_CHAR] = newUseTabCharCfg;\n            this._currentOptions[SPACE_UNITS] = newSpaceUnits;\n            this._currentOptions[TAB_SIZE] = newTabSize;\n            this._codeMirror.setOption(cmOptions[USE_TAB_CHAR], newUseTabCharCfg);\n            if (newUseAutoTabs) {\n                if (newUseTabCharCfg) {\n                    this._codeMirror.setOption(cmOptions[TAB_SIZE], this._currentOptions[TAB_SIZE]);\n                    this._codeMirror.setOption(\"indentUnit\", newTabUnits * this._currentOptions[TAB_SIZE]);\n                } else {\n                    this._codeMirror.setOption(cmOptions[TAB_SIZE], this._currentOptions[TAB_SIZE]);\n                    this._codeMirror.setOption(\"indentUnit\", this._currentOptions[SPACE_UNITS]);\n                }\n            } else {\n                this._codeMirror.setOption(\"indentUnit\", newUseTabCharCfg === true ?\n                    this._currentOptions[TAB_SIZE] :\n                    this._currentOptions[SPACE_UNITS]\n                );\n                this._codeMirror.setOption(cmOptions[TAB_SIZE], this._currentOptions[TAB_SIZE]);\n            }\n            this._codeMirror.setOption(cmOptions[USE_TAB_CHAR], newUseTabCharCfg);\n            this.trigger(\"optionChange\", AUTO_TAB_SPACES, newUseAutoTabs);\n            this.trigger(\"optionChange\", USE_TAB_CHAR, newUseTabCharCfg);\n            return;\n        }\n\n        if (oldValue !== newValue) {\n            this._currentOptions[prefName] = newValue;\n\n            if (prefName === STYLE_ACTIVE_LINE) {\n                this._updateStyleActiveLine();\n            } else if (prefName === SCROLL_PAST_END && this._visibleRange) {\n                // Do not apply this option to inline editors\n                return;\n            } else if (prefName === SHOW_LINE_NUMBERS) {\n                Editor._toggleLinePadding(!newValue);\n                this._codeMirror.setOption(cmOptions[SHOW_LINE_NUMBERS], newValue);\n                if (newValue) {\n                    Editor.registerGutter(LINE_NUMBER_GUTTER, LINE_NUMBER_GUTTER_PRIORITY);\n                } else {\n                    Editor.unregisterGutter(LINE_NUMBER_GUTTER);\n                }\n                this.refreshAll();\n            } else {\n                this._codeMirror.setOption(cmOptions[prefName], newValue);\n            }\n\n            this.trigger(\"optionChange\", prefName, newValue);\n        }\n    };\n\n    /**\n     * @private\n     *\n     * Used to ensure that \"style active line\" is turned off when there is a selection.\n     */\n    Editor.prototype._updateStyleActiveLine = function () {\n        if (this.hasSelection()) {\n            if (this._codeMirror.getOption(\"styleActiveLine\")) {\n                this._codeMirror.setOption(\"styleActiveLine\", false);\n            }\n        } else {\n            this._codeMirror.setOption(\"styleActiveLine\", this._currentOptions[STYLE_ACTIVE_LINE]);\n        }\n    };\n\n    /**\n     * resizes the editor to fill its parent container\n     * should not be used on inline editors\n     * @param {boolean=} forceRefresh - forces the editor to update its layout\n     *                                   even if it already matches the container's height / width\n     */\n    Editor.prototype.updateLayout = function (forceRefresh) {\n        var curRoot = this.getRootElement(),\n            curWidth = $(curRoot).width(),\n            $editorHolder = this.$el.parent(),\n            editorAreaHt = $editorHolder.height();\n\n        if (!curRoot.style.height || $(curRoot).height() !== editorAreaHt) {\n            // Call setSize() instead of $.height() to allow CodeMirror to\n            // check for options like line wrapping\n            this.setSize(null, editorAreaHt);\n            if (forceRefresh === undefined) {\n                forceRefresh = true;\n            }\n        } else if (curWidth !== this._lastEditorWidth) {\n            if (forceRefresh === undefined) {\n                forceRefresh = true;\n            }\n        }\n        this._lastEditorWidth = curWidth;\n\n        if (forceRefresh) {\n            this.refreshAll(forceRefresh);\n        }\n    };\n\n    Editor.prototype._getRegisteredGutters = function () {\n        const languageId = this.document.getLanguage().getId();\n\n        function _filterByLanguages(gutter) {\n            return !gutter.languages || gutter.languages.indexOf(languageId) > -1;\n        }\n\n        function _sortByPriority(a, b) {\n            return a.priority - b.priority;\n        }\n\n        function _getName(gutter) {\n            return gutter.name;\n        }\n\n        // If the line numbers gutter has not been explicitly registered and the CodeMirror lineNumbes option is\n        // set to true, we explicitly add the line numbers gutter. This case occurs the first time the editor loads\n        // and showLineNumbers is set to true in preferences\n        const gutters = registeredGutters.map(_getName);\n        if (gutters.indexOf(LINE_NUMBER_GUTTER) < 0 && this._codeMirror.getOption(cmOptions[SHOW_LINE_NUMBERS])) {\n            registeredGutters.push({ name: LINE_NUMBER_GUTTER, priority: LINE_NUMBER_GUTTER_PRIORITY });\n        }\n\n        return  registeredGutters.sort(_sortByPriority)\n            .filter(_filterByLanguages)\n            .map(_getName);\n    };\n\n    /**\n     * Renders all registered gutters\n     * @private\n     */\n    Editor.prototype._renderGutters = function () {\n        const rootElement = this.getRootElement();\n        const gutters = this._getRegisteredGutters();\n\n        this._codeMirror.setOption(\"gutters\", gutters);\n        this._codeMirror.refresh();\n\n        if (gutters.indexOf(LINE_NUMBER_GUTTER) < 0) {\n            $(rootElement).addClass(\"linenumber-disabled\");\n        } else {\n            $(rootElement).removeClass(\"linenumber-disabled\");\n        }\n    };\n\n    /**\n     * Sets the marker for the specified gutter on the specified line number\n     * @param   {number}   lineNumber The line number for the inserted gutter marker\n     * @param   {string}   gutterName The name of the gutter\n     * @param   {object}   marker     The dom element representing the marker to the inserted in the gutter\n     * @returns {{lineNo : function}}   lineHandle   this can be used to track the gutter line as the line number\n     *                                  changes as the user edits code.\n     */\n    Editor.prototype.setGutterMarker = function (lineNumber, gutterName, marker) {\n        if (!Editor.isGutterRegistered(gutterName)) {\n            console.warn(\"Gutter name must be registered before calling editor.setGutterMarker\");\n            return;\n        }\n\n        return this._codeMirror.setGutterMarker(lineNumber, gutterName, marker);\n    };\n\n    /**\n     * Gets the gutter marker of the given name if found on the current line, else returns undefined.\n     * @param   {number}   lineNumber The line number for the inserted gutter marker\n     * @param   {string}   gutterName The name of the gutter\n     */\n    Editor.prototype.getGutterMarker = function (lineNumber, gutterName) {\n        if (!Editor.isGutterRegistered(gutterName)) {\n            console.warn(\"Gutter name must be registered before calling editor.getGutterMarker\");\n            return;\n        }\n        let lineInfo = this._codeMirror.lineInfo(lineNumber);\n        let gutterMarkers = lineInfo && lineInfo.gutterMarkers || {};\n        return gutterMarkers[gutterName];\n    };\n\n    /**\n     * Clears the marker for the specified gutter on the specified line number. Does nothing if there was no marker\n     * on the line.\n     * @param   {number}   lineNumber The line number for the inserted gutter marker\n     * @param   {string}   gutterName The name of the gutter\n     */\n    Editor.prototype.clearGutterMarker = function (lineNumber, gutterName) {\n        this.setGutterMarker(lineNumber, gutterName, null);\n    };\n\n    /**\n     * Returns true if this editor has the named gutter activated. gutters are considered active if the gutter is\n     * registered for the language of the file currently shown in the editor.\n     * @param {string} gutterName The name of the gutter to check\n     */\n    Editor.prototype.isGutterActive = function (gutterName) {\n        const gutters = this._getRegisteredGutters();\n        return gutters.includes(gutterName);\n    };\n\n    /**\n     * Clears all marks from the gutter with the specified name.\n     * @param {string} gutterName The name of the gutter to clear.\n     */\n    Editor.prototype.clearGutter = function (gutterName) {\n        if (!Editor.isGutterRegistered(gutterName)) {\n            console.warn(\"Gutter name must be registered before calling editor.clearGutter\");\n            return;\n        }\n        this._codeMirror.clearGutter(gutterName);\n    };\n\n    /**\n     * Tries to uncomment the current selection, and if that fails, line-comments it.\n     * This is internal private api used by phoenix line toggle command\n     * @private\n     */\n    Editor.prototype._toggleComment = function () {\n        const indentLineComment = Editor.getIndentLineComment(this.document.file.fullPath);\n        this._codeMirror.toggleComment({\n            indent: indentLineComment\n        });\n    };\n\n    /**\n     * Returns the list of gutters current registered on all editors.\n     * @return {!{name: string, priority: number}}\n     */\n    Editor.getRegisteredGutters = function () {\n        return registeredGutters;\n    };\n\n    /**\n     * Return true if gutter of the given name is registered\n     * @param   {string}   gutterName The name of the gutter\n     * @return {boolean}\n     */\n    Editor.isGutterRegistered = function (gutterName) {\n        return registeredGutters.some(function (gutter) {\n            return gutter.name === gutterName;\n        });\n    };\n\n    /**\n     * Registers the gutter with the specified name at the given priority.\n     * @param {string} name    The name of the gutter.\n     * @param {number} priority  A number denoting the priority of the gutter. Priorities higher than LINE_NUMBER_GUTTER_PRIORITY appear after the line numbers. Priority less than LINE_NUMBER_GUTTER_PRIORITY appear before.\n     * @param {?Array<string>} [languageIds] A list of language ids that this gutter is valid for. If no language ids are passed, then the gutter is valid in all languages.\n     */\n    Editor.registerGutter = function (name, priority, languageIds) {\n        if (isNaN(priority)) {\n            console.warn(\"A non-numeric priority value was passed to registerGutter. The value will default to 0.\");\n            priority = 0;\n        }\n\n        if (!name || typeof name !== \"string\") {\n            console.error(\"The name of the registered gutter must be a string.\");\n            return;\n        }\n\n        var gutter = { name: name, priority: priority, languages: languageIds },\n            gutterExists = registeredGutters.some(function (gutter) {\n                return gutter.name === name;\n            });\n\n        if (!gutterExists) {\n            registeredGutters.push(gutter);\n        }\n\n        Editor.forEveryEditor(function (editor) {\n            editor._renderGutters();\n        });\n    };\n\n    /**\n     * Unregisters the gutter with the specified name and removes it from the UI.\n     * @param {string} name The name of the gutter to be unregistered.\n     */\n    Editor.unregisterGutter = function (name) {\n        var i, gutter;\n        registeredGutters = registeredGutters.filter(function (gutter) {\n            return gutter.name !== name;\n        });\n\n        Editor.forEveryEditor(function (editor) {\n            editor._renderGutters();\n        });\n    };\n\n    // Global settings that affect Editor instances that share the same preference locations\n    let computedTabSpaces = new Map();\n    function _getCachedSpaceCfg(key) {\n        // there are two storages for auto detected spaces for files. IF the user has explicitly set the spacing\n        // through the status bar, its stored permanently. else its computed on the fly\n        let cachedCfg = tabSpacesStateManager.get(key);\n        if (cachedCfg) {\n            return cachedCfg;\n        }\n        return computedTabSpaces.get(key);\n    }\n\n    /**\n     * Sets whether to use tab characters (vs. spaces) when inserting new text.\n     * Affects any editors that share the same preference location.\n     * @param {boolean} value\n     * @param {string=} fullPath Path to file to get preference for\n     * @return {boolean} true if value was valid\n     */\n    Editor.setUseTabChar = function (value, fullPath) {\n        let computedValues = _getCachedSpaceCfg(fullPath);\n        if (Editor.getAutoTabSpaces(fullPath) && computedValues) {\n            computedValues.useTabChar = value;\n            // persist explicitly user set values to storage\n            tabSpacesStateManager.set(fullPath, computedValues);\n            Editor.forEveryEditor(editor => {\n                editor._updateOption(USE_TAB_CHAR);\n            }, fullPath);\n            return true;\n        }\n        var options = fullPath && { context: fullPath };\n        return PreferencesManager.set(USE_TAB_CHAR, value, options);\n    };\n\n    /**\n     * Gets whether the specified or current file uses tab characters (vs. spaces) when inserting new text\n     * @param {string=} fullPath Path to file to get preference for\n     * @return {boolean}\n     */\n    Editor.getUseTabChar = function (fullPath) {\n        let computedValues = _getCachedSpaceCfg(fullPath);\n        if (Editor.getAutoTabSpaces(fullPath) && computedValues) {\n            return computedValues.useTabChar;\n        }\n        return PreferencesManager.get(USE_TAB_CHAR, _buildPreferencesContext(fullPath));\n    };\n\n    /**\n     * Sets tab character width.\n     * Affects any editors that share the same preference location.\n     * @param {number} value\n     * @param {string=} fullPath Path to file to get preference for\n     * @return {boolean} true if value was valid\n     */\n    Editor.setTabSize = function (value, fullPath) {\n        let computedValues = _getCachedSpaceCfg(fullPath);\n        if (Editor.getAutoTabSpaces(fullPath) && computedValues) {\n            if (EditorPreferences.isValidTabSize(value)) {\n                computedValues.tabSize = value;\n                // persist explicitly user set values to storage\n                tabSpacesStateManager.set(fullPath, computedValues);\n                Editor.forEveryEditor(editor => {\n                    editor._updateOption(TAB_SIZE);\n                }, fullPath);\n            }\n            return true;\n        }\n        var options = fullPath && { context: fullPath };\n        return PreferencesManager.set(TAB_SIZE, value, options);\n    };\n\n    /**\n     * Get indent unit\n     * @param {string=} fullPath Path to file to get preference for\n     * @return {number}\n     */\n    Editor.getTabSize = function (fullPath) {\n        let computedValues = _getCachedSpaceCfg(fullPath);\n        if (Editor.getAutoTabSpaces(fullPath) && computedValues && computedValues.tabSize) {\n            return computedValues.tabSize;\n        }\n        return PreferencesManager.get(TAB_SIZE, _buildPreferencesContext(fullPath));\n    };\n\n    /**\n     * Gets the number of tabs for the file. Will\n     * @param fullPath\n     * @returns {number|*}\n     */\n    Editor.getAutoTabUnits = function (fullPath) {\n        let computedValues = _getCachedSpaceCfg(fullPath);\n        if (Editor.getAutoTabSpaces(fullPath) && computedValues && computedValues.tabUnits) {\n            return computedValues.tabUnits;\n        }\n        return EditorPreferences.MIN_SPACE_UNITS;\n    };\n\n    const MAX_LINES_TO_SCAN_FOR_INDENT = 700; // this is high to account for any js docs/ file comments\n    function _computeTabSpaces(editor, scanFullFile, recompute) {\n        const fullPath = editor.document.file.fullPath;\n        if (_getCachedSpaceCfg(fullPath) && !recompute) {\n            return;\n        }\n        // we only scan the first 200 lines of text to determine the spaces.\n        const detectedVals = editor._detectIndent(scanFullFile ? undefined : MAX_LINES_TO_SCAN_FOR_INDENT);\n        const useTabChar = (detectedVals.type === \"tab\");\n        let amount = detectedVals.amount;\n        if (!detectedVals.type || !amount) {\n            // this happens if the util cant find out the tab/spacing config\n            amount = EditorPreferences.DEFAULT_SPACE_UNITS;\n        }\n        tabSpacesStateManager.set(fullPath, null); // we dont have a remove api, so just nulling for now\n        computedTabSpaces.set(fullPath, {\n            useTabChar,\n            tabSize: EditorPreferences.DEFAULT_TAB_SIZE,\n            spaceUnits: useTabChar ? 0 : Math.min(amount, EditorPreferences.MAX_SPACE_UNITS),\n            tabUnits: useTabChar ? Math.min(amount, EditorPreferences.MAX_AUTO_TAB_UNITS) : 0\n        });\n    }\n    Editor._autoDetectTabSpaces = function (editor, scanFullFile, recompute) {\n        if (!editor) {\n            return;\n        }\n        const fullPath = editor.document.file.fullPath;\n        if (!Editor.getAutoTabSpaces(fullPath)) {\n            return; // auto detect is disabled\n        }\n        if (_getCachedSpaceCfg(fullPath) && !recompute) {\n            editor._updateOption(AUTO_TAB_SPACES);\n            return;\n        }\n        _computeTabSpaces(editor, scanFullFile, recompute);\n        editor._updateOption(AUTO_TAB_SPACES);\n    };\n\n    /**\n     * When set, the tabs and spaces to be used will be auto detected from the current file or fall back to defaults.\n     * Affects any editors that share the same preference location.\n     * @param {boolean} value\n     * @param {string=} fullPath Path to file to get preference for\n     * @return {boolean} true if value was valid\n     */\n    Editor.setAutoTabSpaces = function (value, fullPath) {\n        const options = fullPath && { context: fullPath };\n        return PreferencesManager.set(AUTO_TAB_SPACES, value, options);\n    };\n\n    /**\n     * Get auto tabbing/spacing option\n     * @param {string=} fullPath Path to file to get preference for\n     * @return {number}\n     */\n    Editor.getAutoTabSpaces = function (fullPath) {\n        return PreferencesManager.get(AUTO_TAB_SPACES, _buildPreferencesContext(fullPath));\n    };\n\n    /**\n     * Sets indentation width.\n     * Affects any editors that share the same preference location.\n     * @param {number} value\n     * @param {string=} fullPath Path to file to get preference for\n     * @return {boolean} true if value was valid\n     */\n    Editor.setSpaceUnits = function (value, fullPath) {\n        let computedValues = _getCachedSpaceCfg(fullPath);\n        if (Editor.getAutoTabSpaces(fullPath) && computedValues) {\n            if (EditorPreferences.isValidSpaceUnit(value)) {\n                computedValues.spaceUnits = value;\n                // persist explicitly user set values to storage\n                tabSpacesStateManager.set(fullPath, computedValues);\n                Editor.forEveryEditor(editor => {\n                    editor._updateOption(SPACE_UNITS);\n                }, fullPath);\n            }\n            return true;\n        }\n        var options = fullPath && { context: fullPath };\n        return PreferencesManager.set(SPACE_UNITS, value, options);\n    };\n\n    /**\n     * Get indentation width\n     * @param {string=} fullPath Path to file to get preference for\n     * @return {number}\n     */\n    Editor.getSpaceUnits = function (fullPath) {\n        let computedValues = _getCachedSpaceCfg(fullPath);\n        if (Editor.getAutoTabSpaces(fullPath) && computedValues && computedValues.spaceUnits) {\n            return computedValues.spaceUnits;\n        }\n        return PreferencesManager.get(SPACE_UNITS, _buildPreferencesContext(fullPath));\n    };\n\n    /**\n     * Sets the auto close brackets.\n     * Affects any editors that share the same preference location.\n     * @param {boolean} value\n     * @param {string=} fullPath Path to file to get preference for\n     * @return {boolean} true if value was valid\n     */\n    Editor.setCloseBrackets = function (value, fullPath) {\n        var options = fullPath && { context: fullPath };\n        return PreferencesManager.set(CLOSE_BRACKETS, value, options);\n    };\n\n    /**\n     * Gets whether the specified or current file uses auto close brackets\n     * @param {string=} fullPath Path to file to get preference for\n     * @return {boolean}\n     */\n    Editor.getCloseBrackets = function (fullPath) {\n        return PreferencesManager.get(CLOSE_BRACKETS, _buildPreferencesContext(fullPath));\n    };\n\n    /**\n     * Sets show line numbers option.\n     * Affects any editors that share the same preference location.\n     * @param {boolean} value\n     * @param {string=} fullPath Path to file to get preference for\n     * @return {boolean} true if value was valid\n     */\n    Editor.setShowLineNumbers = function (value, fullPath) {\n        var options = fullPath && { context: fullPath };\n        return PreferencesManager.set(SHOW_LINE_NUMBERS, value, options);\n    };\n\n    /**\n     * Returns true if show line numbers is enabled for the specified or current file\n     * @param {string=} fullPath Path to file to get preference for\n     * @return {boolean}\n     */\n    Editor.getShowLineNumbers = function (fullPath) {\n        return PreferencesManager.get(SHOW_LINE_NUMBERS, _buildPreferencesContext(fullPath));\n    };\n\n    /**\n     * Sets show active line option.\n     * Affects any editors that share the same preference location.\n     * @param {boolean} value\n     * @param {string=} fullPath Path to file to get preference for\n     * @return {boolean} true if value was valid\n     */\n    Editor.setShowActiveLine = function (value, fullPath) {\n        return PreferencesManager.set(STYLE_ACTIVE_LINE, value);\n    };\n\n    /**\n     * Returns true if show active line is enabled for the specified or current file\n     * @param {string=} fullPath Path to file to get preference for\n     * @return {boolean}\n     */\n    Editor.getShowActiveLine = function (fullPath) {\n        return PreferencesManager.get(STYLE_ACTIVE_LINE, _buildPreferencesContext(fullPath));\n    };\n\n    /**\n     * Sets word wrap option.\n     * Affects any editors that share the same preference location.\n     * @param {boolean} value\n     * @param {string=} fullPath Path to file to get preference for\n     * @return {boolean} true if value was valid\n     */\n    Editor.setWordWrap = function (value, fullPath) {\n        var options = fullPath && { context: fullPath };\n        return PreferencesManager.set(WORD_WRAP, value, options);\n    };\n\n    /**\n     * Returns true if word wrap is enabled for the specified or current file\n     * @param {string=} fullPath Path to file to get preference for\n     * @return {boolean}\n     */\n    Editor.getWordWrap = function (fullPath) {\n        return PreferencesManager.get(WORD_WRAP, _buildPreferencesContext(fullPath));\n    };\n\n    /**\n     * Sets indentLineComment option.\n     * Affects any editors that share the same preference location.\n     * @param {boolean} value\n     * @param {string=} fullPath Path to file to get preference for\n     * @return {boolean} true if value was valid\n     */\n    Editor.setIndentLineComment = function (value, fullPath) {\n        var options = fullPath && { context: fullPath };\n        return PreferencesManager.set(INDENT_LINE_COMMENT, value, options);\n    };\n\n    /**\n     * Returns true if indentLineComment is enabled for the specified or current file\n     * @param {string=} fullPath Path to file to get preference for\n     * @return {boolean}\n     */\n    Editor.getIndentLineComment = function (fullPath) {\n        return PreferencesManager.get(INDENT_LINE_COMMENT, _buildPreferencesContext(fullPath));\n    };\n\n    /**\n     * Runs callback for every Editor instance that currently exists or only the editors matching the given fullPath.\n     * @param {!function(!Editor)} callback\n     * @param {string} [fullPath] an optional second argument, if given will only callback for all editors\n     *  that is editing the file for the given fullPath\n     */\n    Editor.forEveryEditor = function (callback, fullPath) {\n        _instances.forEach(function (editor) {\n            if (!fullPath) {\n                callback(editor);\n            } else if (editor.document.file.fullPath === fullPath) {\n                callback(editor);\n            }\n        });\n    };\n\n    /**\n     * @private\n     * Toggles the left padding of all code editors.  Used to provide more\n     * space between the code text and the left edge of the editor when\n     * line numbers are hidden.\n     * @param {boolean} showLinePadding\n     */\n    Editor._toggleLinePadding = function (showLinePadding) {\n        // apply class to all pane DOM nodes\n        var $holders = [];\n        _instances.forEach(function (editor) {\n            var $editorHolder = editor.$el.parent();\n            if ($holders.indexOf($editorHolder) === -1) {\n                $holders.push($editorHolder);\n            }\n        });\n\n        _.each($holders, function ($holder) {\n            $holder.toggleClass(\"show-line-padding\", Boolean(showLinePadding));\n        });\n    };\n\n    Editor.LINE_NUMBER_GUTTER_PRIORITY = LINE_NUMBER_GUTTER_PRIORITY;\n    Editor.CODE_FOLDING_GUTTER_PRIORITY = CODE_FOLDING_GUTTER_PRIORITY;\n\n    /**\n     * @private\n     * Each Editor instance object dispatches the following events:\n     *    - keydown, keypress, keyup -- When any key event happens in the editor (whether it changes the\n     *      text or not). Handlers are passed `(BracketsEvent, Editor, KeyboardEvent)`. The 3nd arg is the\n     *      raw DOM event. Note: most listeners will only want to listen for \"keypress\".\n     *    - change - Triggered with an array of change objects. Parameters: (editor, changeList)\n     *    - beforeChange - (self, changeObj)\n     *    - beforeSelectionChange - (selectionObj)\n     *    - focus - Fired when an editor is focused\n     *    - blur - Fired when an editor loses focused\n     *    - update - Will be fired whenever Editor updates its DOM display.\n     *    - cursorActivity -- When the user moves the cursor or changes the selection, or an edit occurs.\n     *      Note: do not listen to this in order to be generally informed of edits--listen to the\n     *      \"change\" event on Document instead.\n     *    - scroll -- When the editor is scrolled, either by user action or programmatically.\n     *    - viewportChange - (from: number, to: number) Fires whenever the view port of the editor changes\n     *      (due to scrolling, editing, or any other factor). The from and to arguments give the new start\n     *      and end of the viewport. This is combination with `editorInstance.getViewPort()` can be used to\n     *      selectively redraw visual elements in code like syntax analyze only parts of code instead\n     *      of the full code everytime.\n     *    - lostContent -- When the backing Document changes in such a way that this Editor is no longer\n     *      able to display accurate text. This occurs if the Document's file is deleted, or in certain\n     *      Document->editor syncing edge cases that we do not yet support (the latter cause will\n     *      eventually go away).\n     *    - optionChange -- Triggered when an option for the editor is changed. The 2nd arg to the listener\n     *      is a string containing the editor option that is changing. The 3rd arg, which can be any\n     *      data type, is the new value for the editor option.\n     *    - beforeDestroy - Triggered before the object is about to dispose of all its internal state data\n     *      so that listeners can cache things like scroll pos, etc...\n     */\n    Editor.EVENT_BEFORE_CHANGE = \"beforeChange\";\n    Editor.EVENT_CHANGE = \"change\";\n    Editor.EVENT_BEFORE_SELECTION_CHANGE = \"beforeSelectionChange\";\n    Editor.EVENT_CURSOR_ACTIVITY = \"cursorActivity\";\n    Editor.EVENT_KEY_PRESS = \"keypress\";\n    Editor.EVENT_KEY_DOWN = \"keydown\";\n    Editor.EVENT_KEY_UP = \"keyup\";\n    Editor.EVENT_FOCUS = \"focus\";\n    Editor.EVENT_BLUR = \"blur\";\n    Editor.EVENT_UPDATE = \"update\";\n    Editor.EVENT_SCROLL = \"scroll\";\n    Editor.EVENT_VIEW_PORT_CHANGE = \"viewportChange\";\n    Editor.EVENT_LOST_CONTENT = \"lostContent\";\n    Editor.EVENT_OPTION_CHANGE = \"optionChange\";\n\n    // Set up listeners for preference changes\n    editorOptions.forEach(function (prefName) {\n        PreferencesManager.on(\"change\", prefName, function () {\n            _instances.forEach(function (editor) {\n                editor._updateOption(prefName);\n            });\n        });\n    });\n\n    // Define public API\n    exports.Editor = Editor;\n    exports.BOUNDARY_CHECK_NORMAL = BOUNDARY_CHECK_NORMAL;\n    exports.BOUNDARY_IGNORE_TOP = BOUNDARY_IGNORE_TOP;\n    exports.BOUNDARY_BULLSEYE = BOUNDARY_BULLSEYE;\n});\n"],"file":"Editor.js"}