{"version":3,"sources":["phoenix/init_vfs.js"],"names":["extensionDIR","appSupportDIR","tauriAssetServeDir","tauriAssetServeBaseURL","documentsDIR","tempDIR","userProjectsDir","_setupVFS","fsLib","pathLib","Phoenix","VFS","getRootDir","getMountDir","getTauriDir","getAppSupportDir","getExtensionDir","getUserExtensionDir","getDevExtensionDir","getDevTempExtensionDir","getTempDir","getTauriAssetServeDir","getUserDocumentsDirectory","getUserProjectsDirectory","_getVirtualDocumentsDirectory","getDefaultProjectDir","ensureTrailingSlash","path","endsWith","getTauriVirtualPath","fs","isLocalDiscPath","fullPath","startsWith","ensureExistsDir","cb","exists","mkdirs","err","code","ensureExistsDirAsync","async","Promise","resolve","reject","getPathForVirtualServingURL","fullURL","isNativeApp","assetRelativePath","decodeURIComponent","replace","window","fsServerUrl","getVirtualServingURLForPath","platformPath","getTauriPlatformPath","__TAURI__","tauri","convertFileSrc","slice","stat","stats","existsAsync","unlinkAsync","filePath","unlink","unlinkResolves","error","readFileResolves","encoding","readFile","data","readFileAsync","writeFileAsync","content","writeFile","setupAppSupportAndExtensionsDir","_tauriBootVars","appLocalDir","catch","console","all","setupDocumentsDir","documentDir","appName","appname","log","setupTempDir","tempDir","_createAppDirs","_tauriBootVarsPromise","CORE_LIB_GUARD_INTERVAL","_FS_ERROR_MESSAGE","platform","initVFS","alert","Error","savedfs","savedPath","setInterval","_phoenixfsAppDirsCreatePromise"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Acknowledgements: https://github.com/bpedro/node-fs\n *\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU Affero General Public License as published by the Free\n * Software Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along\n * with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n// jshint ignore: start\n/*global fs, Phoenix, logger*/\n/*eslint no-console: 0*/\n/*eslint strict: [\"error\", \"global\"]*/\n\n/** Setup virtual file system. This happens before any code of phoenix is loaded.\n * The virtual file system is rooted at /\n * Application support folder that stores app data is /app/\n * Local user storage space is mounted at path /local/\n * Trash storage space is mounted at path /trash/\n *\n * This module should be functionally as light weight as possible with minimal deps as it is a shell component.\n * **/\n\nlet extensionDIR,\n    appSupportDIR,\n    tauriAssetServeDir,\n    tauriAssetServeBaseURL,\n    documentsDIR,\n    tempDIR,\n    userProjectsDir;\n\nfunction _setupVFS(fsLib, pathLib){\n    Phoenix.VFS = {\n        getRootDir: () => '/fs/',\n        getMountDir: () => '/mnt/',\n        getTauriDir: () => '/tauri/',\n        getAppSupportDir: () => appSupportDIR,\n        getExtensionDir: () => extensionDIR,\n        getUserExtensionDir: () => `${extensionDIR}user`,\n        getDevExtensionDir: () => `${extensionDIR}dev`,\n        getDevTempExtensionDir: () => `${extensionDIR}devTemp`,\n        getTempDir: () => tempDIR,\n        getTauriAssetServeDir: () => tauriAssetServeDir,\n        getUserDocumentsDirectory: () => documentsDIR,\n        getUserProjectsDirectory: () => userProjectsDir,\n        _getVirtualDocumentsDirectory: () => '/fs/local/',\n        getDefaultProjectDir: () => `${userProjectsDir}default project/`,\n        ensureTrailingSlash: function (path) {\n            if(!path.endsWith(\"/\")) {\n                return `${path}/`;\n            }\n            return path;\n        },\n        /**\n         * Gets the tauri virtual path given a platform path.\n         * @throws Error If the system path cannot be converted to virtualPath\n         */\n        getTauriVirtualPath: fs.getTauriVirtualPath,\n        /**\n         * Check if a given full path is located in the users local machine drive. For eg. fs access paths are accounted\n         * as local disc path, as well as tauri fs paths.\n         * @param fullPath\n         */\n        isLocalDiscPath: function (fullPath) {\n            if(fullPath &&\n                (fullPath.startsWith(Phoenix.VFS.getTauriDir()) || fullPath.startsWith(Phoenix.VFS.getMountDir()) )){\n                return true;\n            }\n            return false;\n        },\n        ensureExistsDir: function (path, cb) {\n            Phoenix.VFS.exists(path, (exists) =>{\n                // We have to do the exists check explicitly here instead of only using fs.mkdir call check EEXIST code\n                // as trying to call mkdir on `/mnt/someFolder` will throw an error even if the mount point exists.\n                // mount points can only be created by the mount call.\n                if(exists){\n                    cb();\n                    return;\n                }\n                Phoenix.fs.mkdirs(path, 0o755, true, function(err) {\n                    if (err && err.code !== 'EEXIST') {\n                        cb(err);\n                    }\n                    cb();\n                });\n            });\n        },\n        ensureExistsDirAsync: async function (path) {\n            return new Promise((resolve, reject)=>{\n                Phoenix.VFS.ensureExistsDir(path, (err) =>{\n                    if(err){\n                        reject(err);\n                    } else {\n                        resolve();\n                    }\n                });\n            });\n        },\n        /**\n         * Converts a phoenix virtual serving url to absolute path in file system or null\n         * http://localhost:8000/src/phoenix/vfs/fs/app/extensions/user/themesforbrackets/requirejs-config.json\n         * to /fs/app/extensions/user/themesforbrackets/requirejs-config.json\n         * @param fullURL\n         * @returns {string|null}\n         */\n        getPathForVirtualServingURL: function (fullURL) {\n            if(Phoenix.isNativeApp) {\n                if(fullURL.startsWith(tauriAssetServeBaseURL)){\n                    const assetRelativePath = decodeURIComponent(fullURL.replace(tauriAssetServeBaseURL, \"\"))\n                        .replace(/\\\\/g, \"/\"); // replace windows path forward slashes \\ to /\n                    return `${tauriAssetServeDir}${assetRelativePath}`;\n                }\n                return null;\n            }\n            if(window.fsServerUrl && fullURL.startsWith(window.fsServerUrl)){\n                return fullURL.replace(window.fsServerUrl, \"/\");\n            }\n            return null;\n        },\n        getVirtualServingURLForPath: function (fullPath) {\n            if(Phoenix.isNativeApp) {\n                if(fullPath.startsWith(tauriAssetServeDir)){\n                    const platformPath = fs.getTauriPlatformPath(fullPath)\n                        .replace(/\\\\/g, \"/\"); // windows style paths to unix style c:\\x\\y to c:/x/y\n                    return decodeURIComponent(window.__TAURI__.tauri.convertFileSrc(platformPath));\n                }\n                return null;\n            }\n            return window.fsServerUrl.slice(0, -1) + fullPath;\n        },\n        exists: function (path, cb) {\n            fs.stat(path, function (err, stats){\n                if (stats && !err) {\n                    cb(true);\n                } else {\n                    cb(false);\n                }\n            });\n        },\n        existsAsync: async function (path) {\n            return new Promise((resolve)=>{\n                Phoenix.VFS.exists(path, (exists) =>{\n                    resolve(exists);\n                });\n            });\n        },\n        /**\n         * Deletes a file/dir asynchronously. resolves on success or rejects on error.\n         *\n         * @function\n         * @param {string} filePath - The path of the file/dir to be deleted.\n         * @returns {Promise<Object>} A promise that resolves on success or rejects on error.\n         */\n        unlinkAsync: async function (filePath) {\n            return new Promise((resolve, reject)=>{\n                fs.unlink(filePath, (err)=>{\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve();\n                    }\n                });\n            });\n        },\n        /**\n         * deletes a file/dir asynchronously, always resolves, never rejects.\n         *\n         * @function\n         * @param {string} filePath - The path of the file/dir to be deleted.\n         * @returns {Promise<Object>} A promise that resolves to an object containing either\n         * an `error` property if there is an error, or just {} on success.\n         */\n        unlinkResolves: async function (filePath) {\n            return new Promise((resolve)=>{\n                fs.unlink(filePath, (error)=>{\n                    if(error){\n                        resolve({error: error});\n                        return;\n                    }\n                    resolve({});\n                });\n            });\n        },\n        /**\n         * Reads the contents of a file asynchronously, always resolves, never rejects.\n         * Mainly use to read config and other files.\n         * This should not be used for reading project files that are being edited, for that use file system APIs\n         * as that apis will be able to deal with files being edited in the editor.\n         *\n         * @function\n         * @param {string} filePath - The path of the file to be read.\n         * @param {string} encoding - The encoding to use for reading the file.\n         * @returns {Promise<Object>} A promise that resolves to an object containing either\n         * an `error` property if there is an error, or a `data` property with the file contents.\n         */\n        readFileResolves: function (filePath, encoding) {\n            return new Promise((resolve)=>{\n                fs.readFile(filePath, encoding, function (error, data) {\n                    if(error){\n                        resolve({error: error});\n                        return;\n                    }\n                    resolve({data: data});\n                });\n            });\n        },\n        /**\n         * Reads the contents of a file asynchronously, resolves with content or rejects with error.\n         * Mainly use to read config and other files.\n         * This should not be used for reading project files that are being edited, for that use file system APIs\n         * as that apis will be able to deal with files being edited in the editor.\n         *\n         * @param {string} filePath - The path to the file to be read.\n         * @param {string} encoding - The encoding format to use when reading the file.\n         * @returns {Promise<string>} A promise that resolves with the file data when the read is successful,\n         * or rejects with an error if the read operation fails.\n         */\n        readFileAsync: function (filePath, encoding) {\n            return new Promise((resolve, reject)=>{\n                fs.readFile(filePath, encoding, function (error, data) {\n                    if(error){\n                        reject(error);\n                        return;\n                    }\n                    resolve(data);\n                });\n            });\n        },\n        /**\n         * Asynchronously writes data to a file, replacing the file if it already exists.\n         * Mainly use to write config and other files.\n         * This should not be used for write project files that are being edited, for that use file system APIs\n         * as that apis will be able to deal with files being edited in the editor.\n         *\n         * @param {string} filePath - The path of the file where the data should be written.\n         * @param {string} content - The data to write into the file.\n         * @param {string} encoding - The character encoding to use when writing the file.\n         * @returns {Promise<void>} A promise that resolves when the file has been successfully written,\n         *  or rejects with an error if the operation fails.\n         */\n        writeFileAsync: function (filePath, content, encoding) {\n            return new Promise((resolve, reject) => {\n                fs.writeFile(filePath, content, encoding, (err) => {\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve();\n                    }\n                });\n            });\n        },\n        fs: fsLib,\n        path: pathLib\n    };\n    Phoenix.fs = fsLib;\n    Phoenix.path = pathLib;\n\n    return Phoenix.VFS;\n}\n\nasync function setupAppSupportAndExtensionsDir() {\n    if(Phoenix.isNativeApp) {\n        appSupportDIR = fs.getTauriVirtualPath(window._tauriBootVars.appLocalDir);\n        if(!appSupportDIR.endsWith(\"/\")){\n            appSupportDIR = `${appSupportDIR}/`;\n        }\n        tauriAssetServeDir = `${appSupportDIR}assets/`;\n        tauriAssetServeBaseURL = decodeURIComponent(window.__TAURI__.tauri.convertFileSrc(\n            fs.getTauriPlatformPath(tauriAssetServeDir)))\n            .replace(/\\\\/g, \"/\"); // windows style paths to unix style c:\\x\\y to c:/x/y\n        extensionDIR = `${tauriAssetServeDir}extensions/`;\n        // in tauri, the /fs/ folder is not a requirement for boot, so we won't fait for it.\n        // also this creates wired indexed db lock bugs in tauri where the boot leads to a blank screen.\n        Phoenix.VFS.ensureExistsDirAsync(Phoenix.VFS.getRootDir())\n            .catch(console.error);\n    } else {\n        appSupportDIR = '/fs/app/';\n        extensionDIR = `${appSupportDIR}extensions/`;\n        await Phoenix.VFS.ensureExistsDirAsync(Phoenix.VFS.getRootDir());\n    }\n    await Promise.all([\n        Phoenix.VFS.ensureExistsDirAsync(Phoenix.VFS.getAppSupportDir()),\n        Phoenix.VFS.ensureExistsDirAsync(Phoenix.VFS.getExtensionDir()),\n        Phoenix.VFS.ensureExistsDirAsync(Phoenix.VFS.getUserExtensionDir()),\n        Phoenix.VFS.ensureExistsDirAsync(Phoenix.VFS.getDevExtensionDir()),\n        Phoenix.VFS.ensureExistsDirAsync(Phoenix.VFS.getDevTempExtensionDir())\n    ]);\n}\n\nasync function setupDocumentsDir() {\n    if(Phoenix.isNativeApp) {\n        documentsDIR = fs.getTauriVirtualPath(window._tauriBootVars.documentDir);\n        if(!documentsDIR.endsWith(\"/\")){\n            documentsDIR = `${documentsDIR}/`;\n        }\n        const appName = window._tauriBootVars.appname;\n        userProjectsDir = `${documentsDIR}${appName}/`;\n    } else {\n        documentsDIR = Phoenix.VFS._getVirtualDocumentsDirectory();\n        userProjectsDir = documentsDIR;\n    }\n    await Phoenix.VFS.ensureExistsDirAsync(documentsDIR);\n    console.log(\"Documents dir setup done\");\n}\n\nasync function setupTempDir() {\n    if(Phoenix.isNativeApp) {\n        tempDIR = fs.getTauriVirtualPath(window._tauriBootVars.tempDir);\n        if(!tempDIR.endsWith(\"/\")){\n            tempDIR = `${tempDIR}/`;\n        }\n        const appName = window._tauriBootVars.appname;\n        tempDIR = `${tempDIR}${appName}/`;\n    } else {\n        tempDIR = '/temp/';\n    }\n    await Phoenix.VFS.ensureExistsDirAsync(tempDIR);\n    console.log(\"Temp dir setup done\");\n}\n\nconst _createAppDirs = async function () {\n    console.log(\"Waiting for tauri boot variables...\");\n    if(window._tauriBootVarsPromise) {\n        await window._tauriBootVarsPromise;\n    }\n    console.log(\"Creating appdirs...\");\n    // Create phoenix app dirs\n    await Promise.all([\n        setupAppSupportAndExtensionsDir(),\n        setupDocumentsDir(),\n        setupTempDir()\n    ]);\n    console.log(\"Appdirs created...\");\n};\n\n\nconst CORE_LIB_GUARD_INTERVAL = 5000;\nconst _FS_ERROR_MESSAGE = (Phoenix.isNativeApp && Phoenix.platform === \"mac\") ?\n    'Oops. Could not start due to missing file system library.\\n\\nPhoenix Code requires `macOS 12 Monterey` or higher' :\n    'Oops. Could not start due to missing file system library.' +\n    '\\n\\nPlease use a modern browser (released within the last 4 years).';\nexport default function initVFS() {\n    if(!window.fs || !window.path || !window.Phoenix){\n        window.alert(_FS_ERROR_MESSAGE);\n        throw new Error(_FS_ERROR_MESSAGE);\n    }\n    const savedfs = window.fs, savedPath = window.path;\n    setInterval(()=>{\n        if(window.fs !== savedfs){\n            console.error(\"window.fs overwrite detected!! Some extension may have corrupted this.\" +\n                \" attempting to revert to original lib.\");\n            window.fs=savedfs;\n        }\n        if(window.path !== savedPath){\n            console.error(\"window.path overwrite detected!! Some extension may have corrupted this.\" +\n                \" attempting to revert to original lib.\");\n            window.path=savedPath;\n        }\n\n    }, CORE_LIB_GUARD_INTERVAL);\n\n    _setupVFS(window.fs, window.path);\n    window._phoenixfsAppDirsCreatePromise = _createAppDirs();\n}\n\n"],"file":"init_vfs.js"}