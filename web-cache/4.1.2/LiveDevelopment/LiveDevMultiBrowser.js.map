{"version":3,"sources":["LiveDevelopment/LiveDevMultiBrowser.js"],"names":["define","require","exports","module","STATUS_INACTIVE","STATUS_CONNECTING","STATUS_ACTIVE","STATUS_OUT_OF_SYNC","STATUS_SYNC_ERROR","STATUS_RELOADING","STATUS_RESTARTING","EVENT_OPEN_PREVIEW_URL","EVENT_CONNECTION_CLOSE","EVENT_STATUS_CHANGE","Dialogs","DefaultDialogs","DocumentManager","EditorManager","EventDispatcher","MainViewManager","ProjectManager","Strings","LiveDevelopmentUtils","LiveDevServerManager","LivePreviewTransport","LiveDevProtocol","Metrics","PageLoaderWorkerScript","LiveCSSDocument","LiveHTMLDocument","_liveDocument","livePreviewUrlPinned","currentPreviewFilePath","_relatedDocuments","_protocol","_server","_classForDocument","doc","getLanguage","getId","isHtmlFileExt","file","fullPath","isActive","status","getLiveDocForPath","path","get","_closeDocument","liveDocument","off","close","_handleRelatedDocumentDeleted","url","liveDoc","remove","_setStatus","closeReason","reason","trigger","_closeDocuments","undefined","Object","keys","forEach","clear","_resolveUrl","pathToUrl","_createLiveDocument","editor","roots","DocClass","on","event","hasErrors","_docIsOutOfSync","isLiveEditingEnabled","isDirty","_styleSheetAdded","urlToPath","alreadyAdded","docPromise","getDocumentForPath","done","_masterEditor","add","_updateBrowser","_close","doCloseWindow","closeAllConnections","stop","$","Deferred","resolve","promise","_showLiveDevServerNotReadyError","showModalDialog","DIALOG_ID_ERROR","LIVE_DEVELOPMENT_ERROR_TITLE","LIVE_DEV_SERVER_NOT_READY_MESSAGE","_createLiveDocumentForFrame","_ensureMasterEditor","addVirtualContentAtPath","parentPath","LIVE_DEV_REMOTE_SCRIPTS_FILE_NAME","getRemoteScriptContents","LIVE_DEV_REMOTE_WORKER_SCRIPTS_FILE_NAME","_launch","_open","msg","getConnectionIds","length","URL","urlString","origin","pathname","countEvent","EVENT_TYPE","LIVE_PREVIEW","clientId","window","logger","livePreview","log","relatedDocs","related","docs","stylesheets","href","EVENT_LIVE_PREVIEW_CLICKED","EVENT_LIVE_PREVIEW_RELOAD","clients","console","error","_prepareServer","deferred","initialServePath","getProjectRoot","readyPromise","getServer","readyToServe","then","reject","_onFileChange","getCurrentDocument","docUrl","isViewable","canServe","open","async","jsPromise","start","fail","_onDocumentSaved","absolutePath","liveEditingEnabled","isRelated","reload","_onDirtyFlagChange","setTransport","transport","init","config","getLiveDocForEditor","document","showHighlight","getActiveEditor","updateHighlight","hideHighlight","evaluate","redrawHighlight","hasVisibleLivePreviewBoxes","dismissLivePreviewBoxes","dismissImageRibbonGallery","registerHandlers","updateConfig","configJSON","reconnect","setLivePreviewPinned","urlPinned","currentPinnedFilePath","getCurrentLiveDoc","getLivePreviewDetails","makeEventDispatcher"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/**\n * LiveDevelopment allows Brackets to launch a browser with a \"live preview\" that's\n * connected to the current editor.\n *\n * # STARTING\n *\n * To start a session call `open`. This will read the currentDocument from brackets,\n * launch it in the default browser, and connect to it for live editing.\n *\n * # STOPPING\n *\n * To stop a session call `close`. This will close the connection to the browser\n * (but will not close the browser tab).\n *\n * # STATUS\n *\n * Status updates are dispatched as `statusChange` jQuery events. The status\n * is passed as the first parameter and the reason for the change as the second\n * parameter. Currently only the \"Inactive\" status supports the reason parameter.\n * The status codes are:\n *\n *  0: Inactive\n *  1: Connecting (waiting for a browser connection)\n *  2: Active\n *  3: Out of sync\n *  4: Sync error\n *  5: Reloading (after saving JS changes)\n *  6: Restarting (switching context to a new HTML live doc)\n *\n * The reason codes are:\n * - null (Unknown reason)\n * - \"explicit_close\" (LiveDevelopment.close() was called)\n * - \"navigated_away\" (The browser changed to a location outside of the project)\n * - \"detached_target_closed\" (The tab or window was closed)\n */\n\n/*global jsPromise */\n\ndefine(function (require, exports, module) {\n\n\n    // Status Codes\n    const STATUS_INACTIVE      = exports.STATUS_INACTIVE       =  0;\n    const STATUS_CONNECTING    = exports.STATUS_CONNECTING     =  1;\n    const STATUS_ACTIVE        = exports.STATUS_ACTIVE         =  2;\n    const STATUS_OUT_OF_SYNC   = exports.STATUS_OUT_OF_SYNC    =  3;\n    const STATUS_SYNC_ERROR    = exports.STATUS_SYNC_ERROR     =  4;\n    const STATUS_RELOADING     = exports.STATUS_RELOADING      =  5;\n    const STATUS_RESTARTING    = exports.STATUS_RESTARTING     =  6;\n\n    // events\n    const EVENT_OPEN_PREVIEW_URL = \"openPreviewURL\",\n        EVENT_CONNECTION_CLOSE = \"ConnectionClose\",\n        EVENT_STATUS_CHANGE = \"statusChange\";\n\n    const Dialogs              = require(\"widgets/Dialogs\"),\n        DefaultDialogs       = require(\"widgets/DefaultDialogs\"),\n        DocumentManager      = require(\"document/DocumentManager\"),\n        EditorManager        = require(\"editor/EditorManager\"),\n        EventDispatcher      = require(\"utils/EventDispatcher\"),\n        MainViewManager      = require(\"view/MainViewManager\"),\n        ProjectManager       = require(\"project/ProjectManager\"),\n        Strings              = require(\"strings\"),\n        LiveDevelopmentUtils = require(\"LiveDevelopment/LiveDevelopmentUtils\"),\n        LiveDevServerManager = require(\"LiveDevelopment/LiveDevServerManager\"),\n        LivePreviewTransport  = require(\"LiveDevelopment/MultiBrowserImpl/transports/LivePreviewTransport\"),\n        LiveDevProtocol      = require(\"LiveDevelopment/MultiBrowserImpl/protocol/LiveDevProtocol\"),\n        Metrics              = require(\"utils/Metrics\"),\n        PageLoaderWorkerScript = require(\"text!LiveDevelopment/BrowserScripts/pageLoaderWorker.js\");\n\n    // Documents\n    const LiveCSSDocument      = require(\"LiveDevelopment/MultiBrowserImpl/documents/LiveCSSDocument\"),\n        LiveHTMLDocument     = require(\"LiveDevelopment/MultiBrowserImpl/documents/LiveHTMLDocument\");\n\n    /**\n     * @private\n     * The live HTML document for the currently active preview.\n     * @type {LiveHTMLDocument}\n     */\n    var _liveDocument;\n\n    /**\n     * Live preview only tracks the pinned document.\n     * @type {boolean}\n     */\n    let livePreviewUrlPinned = false;\n    let currentPreviewFilePath;\n\n    /**\n     * @private\n     * Live documents related to the active HTML document - for example, CSS files\n     * that are used by the document.\n     * @type {Object.<string: {LiveHTMLDocument|LiveCSSDocument}>}\n     */\n    var _relatedDocuments = {};\n\n    /**\n     * @private\n     * Protocol handler that provides the actual live development API on top of the current transport.\n     */\n    var _protocol = LiveDevProtocol;\n\n    /**\n     * @private\n     * Current live preview server\n     * @type {BaseServer}\n     */\n    var _server;\n\n    /**\n     * @private\n     * Determine which live document class should be used for a given document\n     * @param {Document} document The document we want to create a live document for.\n     * @return {function} The constructor for the live document class; will be a subclass of LiveDocument.\n     */\n    function _classForDocument(doc) {\n        if (doc.getLanguage().getId() === \"css\") {\n            return LiveCSSDocument;\n        }\n\n        if (LiveDevelopmentUtils.isHtmlFileExt(doc.file.fullPath)) {\n            return LiveHTMLDocument;\n        }\n\n        return null;\n    }\n\n    /**\n     * Returns true if the global Live Development mode is on (might be in the middle of connecting).\n     * @return {boolean}\n     */\n    function isActive() {\n        return exports.status > STATUS_INACTIVE;\n    }\n\n    /**\n     * Returns the live document for a given path, or null if there is no live document for it.\n     * @param {string} path\n     * @return {?LiveDocument}\n     */\n    function getLiveDocForPath(path) {\n        if (!_server) {\n            return null;\n        }\n\n        return _server.get(path);\n    }\n\n    /**\n     * @private\n     * Close a live document.\n     * @param {LiveDocument}\n     */\n    function _closeDocument(liveDocument) {\n        liveDocument.off(\".livedev\");\n        _protocol.off(\".livedev\");\n        liveDocument.close();\n    }\n\n    /**\n     * Removes the given CSS/JSDocument from _relatedDocuments. Signals that the\n     * given file is no longer associated with the HTML document that is live (e.g.\n     * if the related file has been deleted on disk).\n     * @param {string} url Absolute URL of the related document\n     */\n    function _handleRelatedDocumentDeleted(url) {\n        var liveDoc = _relatedDocuments[url];\n        if (liveDoc) {\n            delete _relatedDocuments[url];\n        }\n\n        if (_server) {\n            _server.remove(liveDoc);\n        }\n        _closeDocument(liveDoc);\n    }\n\n    /**\n     * Update the status. Triggers a statusChange event.\n     * @param {number} status new status\n     * @param {?string} closeReason Optional string key suffix to display to\n     *     user when closing the live development connection (see LIVE_DEV_* keys)\n     */\n    function _setStatus(status, closeReason) {\n        // Don't send a notification when the status didn't actually change\n        if (status === exports.status) {\n            return;\n        }\n\n        exports.status = status;\n\n        var reason = status === STATUS_INACTIVE ? closeReason : null;\n        exports.trigger(EVENT_STATUS_CHANGE, status, reason);\n    }\n\n    /**\n     * @private\n     * Close all live documents.\n     */\n    function _closeDocuments() {\n        if (_liveDocument) {\n            _closeDocument(_liveDocument);\n            _liveDocument = undefined;\n        }\n\n        Object.keys(_relatedDocuments).forEach(function (url) {\n            _closeDocument(_relatedDocuments[url]);\n            delete _relatedDocuments[url];\n        });\n\n        // Clear all documents from request filtering\n        if (_server) {\n            _server.clear();\n        }\n    }\n\n    /**\n     * @private\n     * Returns the URL that we would serve the given path at.\n     * @param {string} path\n     * @return {string}\n     */\n    function _resolveUrl(path) {\n        return _server && _server.pathToUrl(path);\n    }\n\n    /**\n     * @private\n     * Create a LiveDocument for a Brackets editor/document to manage communication between the\n     * editor and the browser.\n     * @param {Document} doc\n     * @param {Editor} editor\n     * @param {roots} roots\n     * @return {?LiveDocument} The live document, or null if this type of file doesn't support live editing.\n     */\n    function _createLiveDocument(doc, editor, roots) {\n        var DocClass = _classForDocument(doc),\n            liveDocument;\n\n        if (!DocClass) {\n            return null;\n        }\n\n        liveDocument = new DocClass(_protocol, _resolveUrl, doc, editor, roots);\n\n        liveDocument.on(\"errorStatusChanged.livedev\", function (event, hasErrors) {\n            if (isActive()) {\n                _setStatus(hasErrors ? STATUS_SYNC_ERROR : STATUS_ACTIVE);\n            }\n        });\n\n        return liveDocument;\n    }\n\n    /**\n     * Documents are considered to be out-of-sync if they are dirty and\n     * do not have \"update while editing\" support\n     * @param {Document} doc\n     * @return {boolean}\n     */\n    function _docIsOutOfSync(doc) {\n        var liveDoc = _server && _server.get(doc.file.fullPath),\n            isLiveEditingEnabled = liveDoc && liveDoc.isLiveEditingEnabled();\n\n        return doc.isDirty && !isLiveEditingEnabled;\n    }\n\n    /**\n     * Handles a notification from the browser that a stylesheet was loaded into\n     * the live HTML document. If the stylesheet maps to a file in the project, then\n     * creates a live document for the stylesheet and adds it to _relatedDocuments.\n     * @param {$.Event} event\n     * @param {string} url The URL of the stylesheet that was added.\n     * @param {array} roots The URLs of the roots of the stylesheet (the css files loaded through <link>)\n     */\n    function _styleSheetAdded(event, url, roots) {\n        var path = _server && _server.urlToPath(url),\n            alreadyAdded = !!_relatedDocuments[url];\n\n        // path may be null if loading an external stylesheet.\n        // Also, the stylesheet may already exist and be reported as added twice\n        // due to Chrome reporting added/removed events after incremental changes\n        // are pushed to the browser\n        if (!path || alreadyAdded) {\n            return;\n        }\n\n        var docPromise = DocumentManager.getDocumentForPath(path);\n\n        docPromise.done(function (doc) {\n            if ((_classForDocument(doc) === LiveCSSDocument) &&\n                    (!_liveDocument || (doc !== _liveDocument.doc))) {\n                var liveDoc = _createLiveDocument(doc, doc._masterEditor, roots);\n                if (liveDoc) {\n                    _server.add(liveDoc);\n                    _relatedDocuments[doc.url] = liveDoc;\n                    liveDoc.on(\"updateDoc\", function (event, url) {\n                        var path = _server.urlToPath(url),\n                            doc = getLiveDocForPath(path);\n                        doc._updateBrowser();\n                    });\n                }\n            }\n        });\n    }\n\n    /**\n     * @private\n     * Close the connection and the associated window\n     * @param {boolean} doCloseWindow Use true to close the window/tab in the browser\n     * @param {?string} reason Optional string key suffix to display to user (see LIVE_DEV_* keys)\n     */\n    function _close(doCloseWindow, reason) {\n        if (exports.status !== STATUS_INACTIVE) {\n            // Close live documents\n            _closeDocuments();\n            // Close all active connections\n            _protocol.closeAllConnections();\n\n            if (_server) {\n                // Stop listening for requests when disconnected\n                _server.stop();\n\n                // Dispose server\n                _server = null;\n            }\n        }\n    //TODO: implement closeWindow together with launchers.\n//        if (doCloseWindow) {\n//\n//        }\n        _setStatus(STATUS_INACTIVE, reason || \"explicit_close\");\n    }\n\n    /**\n     * Closes all active connections.\n     * Returns a resolved promise for API compatibility.\n     * @return {$.Promise} A resolved promise\n     */\n    function close() {\n        _close(true);\n        return new $.Deferred().resolve().promise();\n    }\n\n    /**\n     * @private\n     * Displays an error when the server for live development files can't be started.\n     */\n    function _showLiveDevServerNotReadyError() {\n        Dialogs.showModalDialog(\n            DefaultDialogs.DIALOG_ID_ERROR,\n            Strings.LIVE_DEVELOPMENT_ERROR_TITLE,\n            Strings.LIVE_DEV_SERVER_NOT_READY_MESSAGE\n        );\n    }\n\n    /**\n     * @private\n     * Creates the main live document for a given HTML document and notifies the server it exists.\n     * TODO: we should really maintain the list of live documents, not the server.\n     * @param {Document} doc\n     */\n    function _createLiveDocumentForFrame(doc) {\n        // create live document\n        doc._ensureMasterEditor();\n        _liveDocument = _createLiveDocument(doc, doc._masterEditor);\n        if(!_liveDocument){\n            return;\n        }\n        _server.add(_liveDocument);\n        _server.addVirtualContentAtPath(\n            `${_liveDocument.doc.file.parentPath}${LiveDevProtocol.LIVE_DEV_REMOTE_SCRIPTS_FILE_NAME}`,\n            _protocol.getRemoteScriptContents());\n        _server.addVirtualContentAtPath(\n            `${_liveDocument.doc.file.parentPath}${LiveDevProtocol.LIVE_DEV_REMOTE_WORKER_SCRIPTS_FILE_NAME}`,\n            PageLoaderWorkerScript);\n    }\n\n\n     /**\n     * Launches the given URL in the default browser.\n     * @param {string} url\n      * @param {string} fullPath\n     * TODO: launchers for multiple browsers\n     */\n    function _launch(url, fullPath) {\n        exports.trigger(EVENT_OPEN_PREVIEW_URL, {\n            url,\n            fullPath\n        });\n    }\n\n    /**\n     * @private\n     * Launches the given document in the browser, given that a live document has already\n     * been created for it.\n     * @param {Document} doc\n     */\n    function _open(doc) {\n        if (doc && _liveDocument && doc === _liveDocument.doc) {\n            if (_server) {\n                // Launch the URL in the browser. If it's the first one to connect back to us,\n                // our status will transition to ACTIVE once it does so.\n                if (exports.status < STATUS_ACTIVE) {\n                    _launch(_resolveUrl(doc.file.fullPath), doc.file.fullPath);\n                }\n\n                _protocol\n                    // TODO: timeout if we don't get a connection within a certain time\n                    .on(\"ConnectionConnect.livedev\", function (event, msg) {\n                        if (_protocol.getConnectionIds().length >= 1) {\n                            // check the page that connection comes from matches the current live document session\n                            const url = new URL(msg.url);\n                            const urlString = `${url.origin}${url.pathname}`;\n                            if (_liveDocument &&  urlString === _resolveUrl(_liveDocument.doc.file.fullPath)) {\n                                _setStatus(STATUS_ACTIVE);\n                            }\n                        }\n                        Metrics.countEvent(Metrics.EVENT_TYPE.LIVE_PREVIEW, \"connect\",\n                            `${_protocol.getConnectionIds().length}-preview`);\n                    })\n                    .on(\"ConnectionClose.livedev\", function (event, {clientId}) {\n                        exports.trigger(EVENT_CONNECTION_CLOSE, {clientId});\n                        window.logger.livePreview.log(\n                            \"Live Preview: Phoenix received ConnectionClose, live preview left: \",\n                            _protocol.getConnectionIds().length, clientId);\n                    })\n                    // extract stylesheets and create related LiveCSSDocument instances\n                    .on(\"DocumentRelated.livedev\", function (event, msg) {\n                        var relatedDocs = msg.related;\n                        var docs = Object.keys(relatedDocs.stylesheets);\n                        docs.forEach(function (url) {\n                            _styleSheetAdded(null, url, relatedDocs.stylesheets[url]);\n                        });\n                    })\n                    // create new LiveCSSDocument if a new stylesheet is added\n                    .on(\"StylesheetAdded.livedev\", function (event, msg) {\n                        _styleSheetAdded(null, msg.href, msg.roots);\n                    })\n                    // remove LiveCSSDocument instance when stylesheet is removed\n                    .on(\"StylesheetRemoved.livedev\", function (event, msg) {\n                        _handleRelatedDocumentDeleted(msg.href);\n                    })\n                    .on(LiveDevProtocol.EVENT_LIVE_PREVIEW_CLICKED + \".livedev\", function (event, msg) {\n                        exports.trigger(LiveDevProtocol.EVENT_LIVE_PREVIEW_CLICKED, msg);\n                    })\n                    .on(LiveDevProtocol.EVENT_LIVE_PREVIEW_RELOAD + \".livedev\", function (event, clients) {\n                        exports.trigger(LiveDevProtocol.EVENT_LIVE_PREVIEW_RELOAD, clients);\n                    });\n            } else {\n                console.error(\"LiveDevelopment._open(): No server active\");\n            }\n        } else {\n            // a connection is in process but there is no current\n            // document, Eg. A project that has only markdown or images that doesnt have a live html/css document\n        }\n    }\n\n    /**\n     * @private\n     * Create the server in preparation for opening a live preview.\n     * @param {Document} doc The document we want the server for. Different servers handle\n     * different types of project (a static server for when no app server is configured,\n     * vs. a user server when there is an app server set in File > Project Settings).\n     */\n    function _prepareServer(doc) {\n        const deferred = new $.Deferred();\n        let initialServePath = doc && doc.file.fullPath;\n        if(!initialServePath){\n            initialServePath = `${ProjectManager.getProjectRoot().fullPath}index.html`;\n        }\n\n        _server = LiveDevServerManager.getServer(initialServePath);\n\n        // Startup the server\n        const readyPromise = _server.readyToServe();\n        if (!readyPromise) {\n            _showLiveDevServerNotReadyError();\n            deferred.reject();\n        } else {\n            readyPromise.then(deferred.resolve, function () {\n                _showLiveDevServerNotReadyError();\n                deferred.reject();\n            });\n        }\n\n        return deferred.promise();\n    }\n\n    /**\n     * @private\n     * MainViewManager.currentFileChange event handler.\n     * When switching documents, close the current preview and open a new one.\n     */\n    function _onFileChange() {\n        let doc = DocumentManager.getCurrentDocument();\n        if (!isActive() || !doc || livePreviewUrlPinned) {\n            return;\n        }\n\n        // close the current session and begin a new session\n        let docUrl = _resolveUrl(doc.file.fullPath),\n            isViewable = _server && _server.canServe(doc.file.fullPath);\n\n        if (_liveDocument && _liveDocument.doc.url !== docUrl && isViewable) {\n            open();\n        }\n    }\n\n\n    /**\n     * Open a live preview on the current docuemnt.\n     */\n    async function open() {\n        let doc = DocumentManager.getCurrentDocument();\n        if(livePreviewUrlPinned){\n            doc = await jsPromise(DocumentManager.getDocumentForPath(currentPreviewFilePath));\n        }\n\n        // wait for server (StaticServer, Base URL or file:)\n        _prepareServer(doc)\n            .done(function () {\n                if(!_server){\n                    return;\n                }\n                _setStatus(STATUS_CONNECTING);\n                // clear live doc and related docs\n                _closeDocuments();\n                // create new live doc\n                doc && _createLiveDocumentForFrame(doc);\n                if(_server.isActive()){\n                    doc && _open(doc);\n                    return;\n                }\n\n                // start server and listen for requests\n                _server.start()\n                    .then(()=>{\n                        // open browser to the url\n                        doc && _open(doc);\n                    });\n            })\n            .fail(function () {\n                console.log(\"Live preview: no document to preview.\");\n            });\n    }\n\n    /**\n     * For files that don't support as-you-type live editing, but are loaded by live HTML documents\n     * (e.g. JS files), we want to reload the full document when they're saved.\n     * @param {$.Event} event\n     * @param {Document} doc\n     */\n    function _onDocumentSaved(event, doc) {\n        if (!isActive() || !_server || !_liveDocument) {\n            return;\n        }\n\n        var absolutePath            = doc.file.fullPath,\n            liveDocument            = absolutePath && _server.get(absolutePath),\n            liveEditingEnabled      = liveDocument && liveDocument.isLiveEditingEnabled  && liveDocument.isLiveEditingEnabled();\n\n        // Skip reload if the saved document has live editing enabled\n        if (liveEditingEnabled) {\n            return;\n        }\n\n        // reload the page if the given document is a JS file related\n        // to the current live document.\n        if (_liveDocument.isRelated && _liveDocument.isRelated(absolutePath)) {\n            if (doc.getLanguage().getId() === \"javascript\") {\n                _setStatus(STATUS_RELOADING);\n                _protocol.reload();\n            }\n        }\n    }\n\n    /**\n     * For files that don't support as-you-type live editing, but are loaded by live HTML documents\n     * (e.g. JS files), we want to show a dirty indicator on the live development icon when they\n     * have unsaved changes, so the user knows s/he needs to save in order to have the page reload.\n     * @param {$.Event} event\n     * @param {Document} doc\n     */\n    function _onDirtyFlagChange(event, doc) {\n        if (!isActive() || !_server || !_liveDocument || !_liveDocument.isRelated) {\n            return;\n        }\n\n        var absolutePath = doc.file.fullPath;\n\n        if (_liveDocument.isRelated && _liveDocument.isRelated(absolutePath)) {\n            // Set status to out of sync if dirty. Otherwise, set it to active status.\n            _setStatus(_docIsOutOfSync(doc) ? STATUS_OUT_OF_SYNC : STATUS_ACTIVE);\n        }\n    }\n\n    /**\n     * Sets the current transport mechanism to be used by the live development protocol\n     * (e.g. socket server, iframe postMessage, etc.)\n     * The low-level transport. Must provide the following methods:\n     *\n     * - start(): Initiates transport (eg. creates Web Socket server).\n     * - send(idOrArray, string): Dispatches the given protocol message (provided as a JSON string) to the given client ID\n     *   or array of client IDs. (See the \"connect\" message for an explanation of client IDs.)\n     * - close(id): Closes the connection to the given client ID.\n     * - getRemoteScript(): Returns a script that should be injected into the page's HTML in order to handle the remote side\n     *   of the transport. Should include the \"<script>\" tags. Should return null if no injection is necessary.\n     *\n     * It must also dispatch the following jQuery events:\n     *\n     * - \"connect\": When a target browser connects back to the transport. Must provide two parameters:\n     *   - clientID - a unique number representing this connection\n     *   - url - the URL of the page in the target browser that's connecting to us\n     * - \"message\": When a message is received by the transport. Must provide two parameters:\n     *   - clientID - the ID of the client sending the message\n     *   - message - the text of the message as a JSON string\n     * - \"close\": When the remote browser closes the connection. Must provide one parameter:\n     *   - clientID - the ID of the client closing the connection\n     *\n     * @param {{launch: function(string), send: function(number|Array.<number>, string), close: function(number), getRemoteScript: function(): ?string}} transport\n     */\n    function setTransport(transport) {\n        _protocol.setTransport(transport);\n    }\n\n    /**\n     * Initialize the LiveDevelopment module.\n     */\n    function init(config) {\n        exports.config = config;\n        MainViewManager\n            .on(\"currentFileChange\", _onFileChange);\n        DocumentManager\n            .on(\"documentSaved\", _onDocumentSaved)\n            .on(\"dirtyFlagChange\", _onDirtyFlagChange);\n\n        // Default transport for live connection messages - can be changed\n        setTransport(LivePreviewTransport);\n\n        // Initialize exports.status\n        _setStatus(STATUS_INACTIVE);\n    }\n\n    function getLiveDocForEditor(editor) {\n        if (!editor) {\n            return null;\n        }\n        return getLiveDocForPath(editor.document.file.fullPath);\n    }\n\n    /**\n     *  Enable highlighting\n     */\n    function showHighlight() {\n        var doc = getLiveDocForEditor(EditorManager.getActiveEditor());\n\n        if (doc && doc.updateHighlight) {\n            doc.updateHighlight();\n        }\n    }\n\n    /**\n     * Hide any active highlighting\n     */\n    function hideHighlight() {\n        if (_protocol) {\n            _protocol.evaluate(\"_LD.hideHighlight()\");\n        }\n    }\n\n    /**\n     * Redraw highlights\n     */\n    function redrawHighlight() {\n        if (_protocol) {\n            _protocol.evaluate(\"_LD.redrawHighlights()\");\n        }\n    }\n\n    /**\n     * Check if live preview boxes are currently visible\n     */\n    function hasVisibleLivePreviewBoxes() {\n        if (_protocol) {\n            return _protocol.evaluate(\"_LD.hasVisibleLivePreviewBoxes()\");\n        }\n        return false;\n    }\n\n    /**\n     * Dismiss live preview boxes like info box, options box, AI box\n     */\n    function dismissLivePreviewBoxes() {\n        if (_protocol) {\n            _protocol.evaluate(\"_LD.dismissUIAndCleanupState()\");\n            _protocol.evaluate(\"_LD.dismissImageRibbonGallery()\");\n        }\n    }\n\n    /**\n     * Dismiss image ribbon gallery if it's open\n     */\n    function dismissImageRibbonGallery() {\n        if (_protocol) {\n            _protocol.evaluate(\"_LD.dismissImageRibbonGallery()\");\n        }\n    }\n\n    /**\n     * Register event handlers in the remote browser for live preview functionality\n     */\n    function registerHandlers() {\n        if (_protocol) {\n            _protocol.evaluate(\"_LD.registerHandlers()\");\n        }\n    }\n\n    /**\n     * Update configuration in the remote browser\n     */\n    function updateConfig(configJSON) {\n        if (_protocol) {\n            _protocol.evaluate(\"_LD.updateConfig('\" + configJSON + \"')\");\n        }\n    }\n\n    /**\n     * Originally unload and reload agents. It doesn't apply for this new implementation.\n     * @return {jQuery.Promise} Already resolved promise.\n     */\n    function reconnect() {\n        return $.Deferred().resolve();\n    }\n\n    /**\n     * Reload current page in all connected browsers.\n     */\n    function reload() {\n        if (_protocol) {\n            _protocol.reload();\n        }\n    }\n\n    /**\n     * @param urlPinned {boolean}\n     */\n    function setLivePreviewPinned(urlPinned, currentPinnedFilePath) {\n        livePreviewUrlPinned = urlPinned;\n        currentPreviewFilePath = currentPinnedFilePath;\n    }\n\n    // for unit testing only\n    function getCurrentLiveDoc() {\n        return _liveDocument;\n    }\n\n    /**\n     * Returns an array of the client IDs that are being managed by this live document.\n     * @return {Array.<number>}\n     */\n    function getConnectionIds() {\n        return _protocol.getConnectionIds();\n    }\n\n    function getLivePreviewDetails() {\n        return {\n            liveDocument: _liveDocument,\n            URL: _liveDocument ? _resolveUrl(_liveDocument.doc.file.fullPath) : null\n        };\n    }\n\n    EventDispatcher.makeEventDispatcher(exports);\n\n    // For unit testing\n    exports._server                   = _server;\n\n    // Events\n    exports.EVENT_OPEN_PREVIEW_URL = EVENT_OPEN_PREVIEW_URL;\n    exports.EVENT_CONNECTION_CLOSE = EVENT_CONNECTION_CLOSE;\n    exports.EVENT_STATUS_CHANGE = EVENT_STATUS_CHANGE;\n    exports.EVENT_LIVE_PREVIEW_CLICKED = LiveDevProtocol.EVENT_LIVE_PREVIEW_CLICKED;\n    exports.EVENT_LIVE_PREVIEW_RELOAD = LiveDevProtocol.EVENT_LIVE_PREVIEW_RELOAD;\n\n    // Export public functions\n    exports.open                = open;\n    exports.close               = close;\n    exports.reconnect           = reconnect;\n    exports.reload              = reload;\n    exports.getLiveDocForPath   = getLiveDocForPath;\n    exports.showHighlight       = showHighlight;\n    exports.hideHighlight       = hideHighlight;\n    exports.redrawHighlight     = redrawHighlight;\n    exports.hasVisibleLivePreviewBoxes = hasVisibleLivePreviewBoxes;\n    exports.dismissLivePreviewBoxes = dismissLivePreviewBoxes;\n    exports.dismissImageRibbonGallery = dismissImageRibbonGallery;\n    exports.registerHandlers    = registerHandlers;\n    exports.updateConfig        = updateConfig;\n    exports.init                = init;\n    exports.isActive            = isActive;\n    exports.setLivePreviewPinned= setLivePreviewPinned;\n    exports.getCurrentLiveDoc   = getCurrentLiveDoc;\n    exports.getLivePreviewDetails = getLivePreviewDetails;\n    exports.getConnectionIds = getConnectionIds;\n    exports.setTransport        = setTransport;\n});\n"],"file":"LiveDevMultiBrowser.js"}