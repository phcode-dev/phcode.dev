{"version":3,"sources":["LiveDevelopment/BrowserScripts/pageLoaderWorker.js"],"names":["_livePreviewBroadcastChannel","_livePreviewWebSocket","_livePreviewWebSocketOpen","livePreviewDebugModeEnabled","_debugLog","args","console","log","mergeMetadataAndArrayBuffer","metadata","bufferData","ArrayBuffer","hasBufferData","Error","metadataString","JSON","stringify","metadataUint8Array","TextEncoder","encode","metadataBuffer","buffer","sizePrefixLength","byteLength","concatenatedBuffer","concatenatedUint8Array","Uint8Array","DataView","setUint32","set","splitMetadataAndBuffer","buffer1Length","getUint32","buffer1","slice","parse","TextDecoder","decode","buffer2","messageQueue","_sendMessage","message","send","postMessage","warn","push","flushPendingMessages","savedMessageQueue","_setupHearbeatMessenger","clientID","_sendOnlineHeartbeat","type","URL","location","href","setInterval","_setupBroadcastChannel","broadcastChannel","BroadcastChannel","onmessage","event","data","_setupWebsocketChannel","wssEndpoint","WebSocket","binaryType","addEventListener","channelName","pageLoaderID","error","updateTitleAndFavicon","title","faviconBase64","websocketChannelURL"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/**\n * We need to set this up in a worker as if the user is debugging a live preview page, the heartbeat messages will\n * be blocked in main thread, but fine in isolated worker thread.\n * @private\n */\n\n\nlet _livePreviewBroadcastChannel;\nlet _livePreviewWebSocket, _livePreviewWebSocketOpen = false;\nlet livePreviewDebugModeEnabled = false;\nfunction _debugLog(...args) {\n    if(livePreviewDebugModeEnabled) {\n        console.log(...args);\n    }\n}\n\n/**\n *\n * @param metadata {Object} Max size can be 4GB\n * @param bufferData {ArrayBuffer?} [optional]\n * @return {ArrayBuffer}\n * @private\n */\nfunction mergeMetadataAndArrayBuffer(metadata, bufferData) {\n    if (bufferData instanceof ArrayBuffer) {\n        metadata.hasBufferData = true;\n    }\n    bufferData = bufferData || new ArrayBuffer(0);\n    if (typeof metadata !== 'object') {\n        throw new Error(\"metadata should be an object, but was \" + typeof metadata);\n    }\n    if (!(bufferData instanceof ArrayBuffer)) {\n        throw new Error(\"Expected bufferData to be an instance of ArrayBuffer, but was \" + typeof bufferData);\n    }\n\n    const metadataString = JSON.stringify(metadata);\n    const metadataUint8Array = new TextEncoder().encode(metadataString);\n    const metadataBuffer = metadataUint8Array.buffer;\n    const sizePrefixLength = 4; // 4 bytes for a 32-bit integer\n\n    if (metadataBuffer.byteLength > 4294000000) {\n        throw new Error(\"metadata too large. Should be below 4,294MB, but was \" + metadataBuffer.byteLength);\n    }\n\n    const concatenatedBuffer = new ArrayBuffer(sizePrefixLength + metadataBuffer.byteLength + bufferData.byteLength);\n    const concatenatedUint8Array = new Uint8Array(concatenatedBuffer);\n\n    // Write the length of metadataBuffer as a 32-bit integer\n    new DataView(concatenatedBuffer).setUint32(0, metadataBuffer.byteLength, true);\n\n    // Copy the metadataUint8Array and bufferData (if provided) to the concatenatedUint8Array\n    concatenatedUint8Array.set(metadataUint8Array, sizePrefixLength);\n    if (bufferData.byteLength > 0) {\n        concatenatedUint8Array.set(new Uint8Array(bufferData), sizePrefixLength + metadataBuffer.byteLength);\n    }\n\n    return concatenatedBuffer;\n}\n\nfunction splitMetadataAndBuffer(concatenatedBuffer) {\n    if(!(concatenatedBuffer instanceof ArrayBuffer)){\n        throw new Error(\"Expected ArrayBuffer message from websocket\");\n    }\n    const sizePrefixLength = 4;\n    const buffer1Length = new DataView(concatenatedBuffer).getUint32(0, true); // Little endian\n\n    const buffer1 = concatenatedBuffer.slice(sizePrefixLength, sizePrefixLength + buffer1Length);\n    const metadata = JSON.parse(new TextDecoder().decode(buffer1));\n    let buffer2;\n    if (concatenatedBuffer.byteLength > sizePrefixLength + buffer1Length) {\n        buffer2 = concatenatedBuffer.slice(sizePrefixLength + buffer1Length);\n    }\n    if(!buffer2 && metadata.hasBufferData) {\n        // This happens if the sender is sending 0 length buffer. So we have to create an empty buffer here\n        buffer2 = new ArrayBuffer(0);\n    }\n\n    return {\n        metadata,\n        bufferData: buffer2\n    };\n}\n\nlet messageQueue = [];\n\nfunction _sendMessage(message) {\n    if(_livePreviewWebSocket && _livePreviewWebSocketOpen) {\n        _livePreviewWebSocket.send(mergeMetadataAndArrayBuffer(message));\n    } else if(_livePreviewBroadcastChannel){\n        _livePreviewBroadcastChannel.postMessage(message);\n    } else {\n        livePreviewDebugModeEnabled && console.warn(\"No Channels available for live preview worker messaging,\" +\n            \" queueing request, waiting for channel..\");\n        messageQueue.push(message);\n    }\n}\n\nfunction flushPendingMessages() {\n    const savedMessageQueue = messageQueue;\n    messageQueue = [];\n    for(let message of savedMessageQueue){\n        _sendMessage(message);\n    }\n}\n\nfunction _setupHearbeatMessenger(clientID) {\n    function _sendOnlineHeartbeat() {\n        _sendMessage({\n            type: 'TAB_ONLINE',\n            clientID,\n            URL: location.href\n        });\n    }\n    _sendOnlineHeartbeat();\n    setInterval(()=>{\n        _sendOnlineHeartbeat();\n    }, 3000);\n}\n\nfunction _setupBroadcastChannel(broadcastChannel, clientID) {\n    _livePreviewBroadcastChannel=new BroadcastChannel(broadcastChannel);\n    _livePreviewBroadcastChannel.onmessage = (event) => {\n        const type = event.data.type;\n        switch (type) {\n        case 'TAB_ONLINE': break; // do nothing. This is a loopback message from another live preview tab\n        default: postMessage(event.data); break;\n        }\n    };\n    _setupHearbeatMessenger(clientID);\n}\n\nfunction _setupWebsocketChannel(wssEndpoint, clientID) {\n    _debugLog(\"live preview worker websocket url: \", wssEndpoint);\n    _livePreviewWebSocket = new WebSocket(wssEndpoint);\n    _livePreviewWebSocket.binaryType = 'arraybuffer';\n    _livePreviewWebSocket.addEventListener(\"open\", () =>{\n        _debugLog(\"live preview worker websocket opened\", wssEndpoint);\n        _livePreviewWebSocketOpen = true;\n        _sendMessage({\n            type: 'CHANNEL_TYPE',\n            channelName: 'livePreviewChannel',\n            pageLoaderID: clientID\n        });\n        flushPendingMessages();\n        _setupHearbeatMessenger(clientID);\n    });\n\n    _livePreviewWebSocket.addEventListener('message', function (event) {\n        const message = event.data;\n        const {metadata} = splitMetadataAndBuffer(message);\n        _debugLog(\"Live Preview worker socket channel: Browser received event from Phoenix: \", metadata);\n        const type = metadata.type;\n        switch (type) {\n        case 'TAB_ONLINE': break; // do nothing. This is a loopback message from another live preview tab\n        default: postMessage(metadata); break;\n        }\n    });\n\n    _livePreviewWebSocket.addEventListener('error', function (event) {\n        console.error(\"Live Preview worker socket channel: error event: \", event);\n    });\n\n    _livePreviewWebSocket.addEventListener('close', function () {\n        _livePreviewWebSocketOpen = false;\n        _debugLog(\"Live Preview worker websocket closed\");\n    });\n}\n\nfunction updateTitleAndFavicon(event) {\n    _sendMessage({\n        type: 'UPDATE_TITLE_AND_ICON',\n        title: event.data.title,\n        faviconBase64: event.data.faviconBase64,\n        URL: location.href\n    });\n}\n\nonmessage = (event) => {\n    const type = event.data.type;\n    switch (type) {\n    case 'setupPhoenixComm':\n        livePreviewDebugModeEnabled = event.data.livePreviewDebugModeEnabled;\n        if(event.data.broadcastChannel) {\n            _setupBroadcastChannel(event.data.broadcastChannel, event.data.clientID);\n        } else if(event.data.websocketChannelURL) {\n            _setupWebsocketChannel(event.data.websocketChannelURL, event.data.clientID);\n        } else {\n            console.error(\"No live preview worker communication channels! \", event.data);\n        }\n        break;\n    case 'updateTitleIcon': updateTitleAndFavicon(event); break;\n    case 'livePreview': _sendMessage(event.data.message); break;\n    default: console.error(\"Live Preview page worker: received unknown event:\", event);\n    }\n};\n"],"file":"pageLoaderWorker.js"}