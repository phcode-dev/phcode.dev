{"version":3,"sources":["LiveDevelopment/BrowserScripts/LivePreviewTransportRemote.js"],"names":["global","TRANSPORT_CONFIG","_debugLog","args","window","LIVE_PREVIEW_DEBUG_ENABLED","console","log","createLRU","max","map","Map","set","key","value","has","delete","size","oldestKey","keys","next","val","get","processedMessageIDs","clientID","Math","round","random","worker","Worker","LIVE_DEV_REMOTE_WORKER_SCRIPTS_FILE_NAME","_workerMessageProcessor","sentTitle","sentFavIconURL","_postLivePreviewMessage","message","postMessage","type","convertImgToBase64","url","callback","canvas","document","createElement","ctx","getContext","img","Image","crossOrigin","onload","height","width","drawImage","dataURL","toDataURL","src","getAbsoluteUrl","test","absoluteUrl","URL","location","href","alertPatch","titleText","modal","style","position","top","left","backgroundColor","display","justifyContent","alignItems","zIndex","modalContent","padding","borderRadius","minWidth","margin","textAlign","title","textContent","marginBottom","text","button","border","color","cursor","onclick","body","removeChild","appendChild","unsupportedConfirm","STRINGS","UNSUPPORTED_DOM_APIS_CONFIRM","unsupportedPrompt","onmessage","event","data","error","livePreviewDebugModeEnabled","broadcastChannel","LIVE_PREVIEW_BROADCAST_CHANNEL_ID","websocketChannelURL","LIVE_PREVIEW_WEBSOCKET_CHANNEL_URL","setInterval","favIcon","querySelector","faviconUrl","base64","faviconBase64","_Brackets_LiveDev_Transport","_channelOpen","_callbacks","setCallbacks","callbacks","this","connect","self","JSON","stringify","clientIDs","messageID","includes","length","close","addEventListener","send","msgStr","crypto","randomUUID","enable","targetElement","target","tagName","parentElement","__PHOENIX_EMBED_INFO","isTauri","getAttribute","defaultPrevented","parent","handlerName","eventName","stopImmediatePropagation","preventDefault","activeElement","focus","currentUrl","queryParams","URLSearchParams","search","isExternalBrowser","IS_NATIVE_APP","platform","PLATFORM","alertQueue","confirmCalled","promptCalled","addToQueue","shouldPatchAlert","drainAlertQueues","i","alert","confirm","prompt","push","TRUSTED_ORIGINS_EMBED","origin"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2014 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n// This is a transport injected into the browser via a script that handles the low\n// level communication between the live development protocol handlers on both sides.\n// The actual communication to phoenix is done via the loaded web worker below. We just post/receive all\n// messages that should be sent/received by live preview to the worker. The worker will use broadcast\n// channels in browser and web sockets in desktop builds to rely on the message to phoenix.\n/**\n * Communication Architecture in PHCode.dev Browser Environment\n * ------------------------------------------------------------\n *\n * First of all I like to apologize for this complexity, it is how it is due to the browser standards security\n * policy, intelligent tracking prevention in browsers and the inherent multiprocess communication problem.\n * The dining philosophers can however take rest as the mechanism is fully lockless thanks to how js handles events.\n *\n * Overview:\n * PHCode.dev operates with a multi-iframe setup to facilitate communication between different components\n * within the same domain(phcode.dev) and cross domain(phcode.dev<>phcode.live). Live previews have to be domain\n * isolated to phcode.live domain so that malicious project live previews doesn't steal phcode.dev cookies and\n * take control of the users account by just opening a live preview.\n * This setup includes a preview page(phcode.dev/live-preview-loader.html), a server iframe (phcode.live), and an actual\n * preview iframe where the user's code is rendered(phcode.live/user/projoject/live/preview.html).\n *\n * Components:\n * 1. Preview Page (phcode.dev):\n *    - Serves as the primary interface for the user. The actual tab.\n *    - Hosts two iframes: the server iframe and the actual preview iframe.\n *\n * 2. Server Iframe (phcode.live):\n *    - Responsible for installing a service worker for virtual server, sandboxed to its specific tab.\n *    - Acts as an intermediary in the communication chain.\n *\n * 3. Actual Preview Iframe: (phcode.live/user/projoject/live/preview.html)\n *    - Renders the user's code.\n *    - Utilizes a broadcast channel within the web worker to send messages. We use a web worker so\n *      that live preview tab hearbeat messages are sent to the editor even if the user is debugging\n *      the page causing js execution to halt in the debugging thread but not the worker thread.\n *\n * Communication Flow:\n * 1. Messages originate from the Actual Preview Iframe, where the user's script is loaded.\n * 2. These messages are sent to the Live Preview Server Iframe via a broadcast channel in the service worker.\n * 3. The Server Iframe then relays these messages to the parent PHCode.dev frame.\n * 4. Finally, the PHCode.dev frame forwards these messages to the PHCode.dev editor page.\n *    - This step occurs if the editor page is loaded in a different tab and not as an in-editor live preview panel.\n *\n * Note on Communication Constraints and Solutions:\n * ------------------------------------------------\n *  Cross-Domain Communication Limitations:\n *  - The default security model of web browsers restricts cross-domain communication as a measure to preserve security.\n *  - This means that iframes from different domains cannot freely communicate with each other due to\n *    browser-enforced sandboxing.\n *\n *  Use of Broadcast Channels within the Same Domain:\n *  - To circumvent these cross-domain communication restrictions, PHCode.dev employs broadcast channels within\n *    the same domain.\n *\n *  Solution for Cross-Domain Communication:\n *  - The architecture is designed to avoid direct cross-domain communication, which is restricted by\n *    the browser's security model.\n *  - Instead, a 'hoola hoop' method is used where the server Iframe (phcode.live) relays broadcast channel\n *    messages in phcode.live to its cross domain parent window phcode.dev through window post message apis.\n *  - The parent PHCode.dev frame further communicates with the PHCode.dev editor page, if its in a different tab.\n *\n *  Working within Browser Security Framework:\n *  - This approach allows the system to operate within the browser's security constraints.\n *  - It eliminates the need for server-side assistance, thus enabling instant live preview\n *    feedback in a purely client-side setting.\n **/\n\n\n(function (global) {\n\n    // The below line will be replaced with the transport scripts provided by the static server at\n    // LivePreviewTransport.js:getRemoteScript() This is so that the actual live preview page doesnt get hold of\n    // any phoenix web socket or broadcast channel ids from this closure programatically for security.\n\n    //Replace dynamic section start\n    const TRANSPORT_CONFIG={};\n    //Replace dynamic section end\n\n    function _debugLog(...args) {\n        if(window.LIVE_PREVIEW_DEBUG_ENABLED) {\n            console.log(...args);\n        }\n    }\n\n    function createLRU(max = 100) {\n        const map = new Map();\n\n        return {\n            set: function (key, value = true) {\n                if (map.has(key)) {\n                    map.delete(key); // refresh order\n                }\n                map.set(key, value);\n                if (map.size > max) {\n                    const oldestKey = map.keys().next().value;\n                    map.delete(oldestKey);\n                }\n            },\n            has: function (key) {\n                if (!map.has(key)) {\n                    return false;\n                }\n                const val = map.get(key);\n                map.delete(key);   // refresh order\n                map.set(key, val);\n                return true;\n            },\n            size: function() {\n                return map.size;\n            }\n        };\n    }\n\n    const processedMessageIDs = createLRU(1000);\n\n    const clientID = \"\" + Math.round( Math.random()*1000000000);\n\n    const worker = new Worker(TRANSPORT_CONFIG.LIVE_DEV_REMOTE_WORKER_SCRIPTS_FILE_NAME);\n    let _workerMessageProcessor;\n    worker.onmessage = (event) => {\n        const type = event.data.type;\n        switch (type) {\n        case 'REDIRECT_PAGE': location.href = event.data.URL; break;\n        default:\n            if(_workerMessageProcessor){\n                return _workerMessageProcessor(event);\n            }\n            console.error(\"Live Preview page loader: received unknown message from worker:\", event);\n        }\n    };\n    // message channel to phoenix connect on load itself. The channel id is injected from phoenix\n    // via LivePreviewTransport.js while serving the instrumented html file\n    worker.postMessage({\n        type: \"setupPhoenixComm\",\n        livePreviewDebugModeEnabled: TRANSPORT_CONFIG.LIVE_PREVIEW_DEBUG_ENABLED,\n        broadcastChannel: TRANSPORT_CONFIG.LIVE_PREVIEW_BROADCAST_CHANNEL_ID, // in browser this will be present, but not in tauri\n        websocketChannelURL: TRANSPORT_CONFIG.LIVE_PREVIEW_WEBSOCKET_CHANNEL_URL, // in tauri this will be present. not in browser\n        clientID\n    });\n    function _postLivePreviewMessage(message) {\n        worker.postMessage({type: \"livePreview\", message});\n    }\n    let sentTitle, sentFavIconURL;\n\n    function convertImgToBase64(url, callback) {\n        if(!url){\n            callback(null);\n            return;\n        }\n        let canvas = document.createElement('CANVAS');\n        const ctx = canvas.getContext('2d');\n        const img = new Image();\n        img.crossOrigin = 'Anonymous';\n        img.onload = function() {\n            canvas.height = img.height;\n            canvas.width = img.width;\n            ctx.drawImage(img, 0, 0);\n            const dataURL = canvas.toDataURL();\n            callback(dataURL);\n            canvas = null;\n        };\n        img.src = url;\n    }\n\n    setInterval(()=>{\n        const favIcon = document.querySelector(\"link[rel~='icon']\");\n        const faviconUrl = favIcon && favIcon.href;\n        if(sentFavIconURL !== faviconUrl){\n            sentFavIconURL = faviconUrl;\n            convertImgToBase64(faviconUrl, function(base64) {\n                if(!base64){\n                    base64 = \"favicon.ico\";\n                }\n                worker.postMessage({\n                    type: \"updateTitleIcon\",\n                    faviconBase64: base64\n                });\n            });\n        }\n\n        if(sentTitle!== document.title) {\n            sentTitle = document.title;\n            worker.postMessage({\n                type: \"updateTitleIcon\",\n                title: document.title\n            });\n        }\n    }, 1000);\n\n    global._Brackets_LiveDev_Transport = {\n        _channelOpen: false,\n\n        /**\n         * @private\n         * An object that contains callbacks to handle various transport events. See `setCallbacks()`.\n         * @type {?{connect: ?function, message: ?function(string), close: ?function}}\n         */\n        _callbacks: null,\n\n        /**\n         * Sets the callbacks that should be called when various transport events occur. All callbacks\n         * are optional, but you should at least implement \"message\" or nothing interesting will happen :)\n         * @param {?{connect: ?function, message: ?function(string), close: ?function}} callbacks\n         *      The callbacks to set.\n         *      connect - called when a connection is established to Brackets\n         *      message(msgStr) - called with a string message sent from Brackets\n         *      close - called when Brackets closes the connection\n         */\n        setCallbacks: function (callbacks) {\n            this._callbacks = callbacks;\n        },\n\n        /**\n         * Connects to the LivePreviewTransport in Brackets.\n         */\n        connect: function () {\n            const self = this;\n\n            // Listen to the response\n            _workerMessageProcessor = (event) => {\n                // Print the result\n                _debugLog(\"Live Preview: Browser received event from Phoenix: \", JSON.stringify(event.data));\n                const type = event.data.type;\n                switch (type) {\n                case 'BROWSER_CONNECT': break; // do nothing. This is a loopback message from another live preview tab\n                case 'BROWSER_MESSAGE': break; // do nothing. This is a loopback message from another live preview tab\n                case 'BROWSER_CLOSE': break; // do nothing. This is a loopback message from another live preview tab\n                case 'MESSAGE_FROM_PHOENIX':\n                    if (self._callbacks && self._callbacks.message) {\n                        const clientIDs = event.data.clientIDs,\n                            message = event.data.message,\n                            messageID = event.data.messageID;\n                        if(messageID && processedMessageIDs.has(messageID)){\n                            return; // we have already processed this message.\n                        }\n                        processedMessageIDs.set(messageID, true);\n                        if(clientIDs.includes(clientID) || clientIDs.length === 0){\n                            // clientIDs.length = 0 if the message is intended for all clients\n                            self._callbacks.message(message);\n                        }\n                    }\n                    break;\n                case 'PHOENIX_CLOSE':\n                    self._channelOpen = false;\n                    if (self._callbacks && self._callbacks.close) {\n                        self._callbacks.close();\n                    }\n                    break;\n                }\n            };\n            _postLivePreviewMessage({\n                type: 'BROWSER_CONNECT',\n                url: global.location.href,\n                clientID: clientID\n            });\n            self._channelOpen = true;\n            if (self._callbacks && self._callbacks.connect) {\n                self._callbacks.connect();\n            }\n\n            // attach to browser tab/window closing event so that we send a cleanup request\n            // to the service worker for the comm ports\n            addEventListener( 'beforeunload', function() {\n                if(self._channelOpen){\n                    self._channelOpen = false;\n                    _postLivePreviewMessage({\n                        type: 'BROWSER_CLOSE',\n                        clientID: clientID\n                    });\n                }\n            });\n        },\n\n        /**\n         * Sends a message over the transport.\n         * @param {string} msgStr The message to send.\n         */\n        send: function (msgStr) {\n            _postLivePreviewMessage({\n                type: 'BROWSER_MESSAGE',\n                clientID: clientID,\n                messageID: crypto.randomUUID(),\n                message: msgStr\n            });\n        },\n\n        /**\n         * Establish web socket connection.\n         */\n        enable: function () {\n            this.connect();\n        }\n    };\n\n    function getAbsoluteUrl(url) {\n        // Check if the URL is already absolute\n        if (/^(?:[a-z]+:)?\\/\\//i.test(url)) {\n            return url; // The URL is already absolute\n        }\n\n        // If not, create an absolute URL using the current page's location as the base\n        const absoluteUrl = new URL(url, window.location.href);\n        return absoluteUrl.href;\n    }\n\n    // This is only for tauri builds where the live preview is embedded in the phoenix editor iframe. on clicking\n    // any urls that needs to be open in a browser window, we execute this. In browser, this is no-op as there is\n    // no corresponding listener attached in phoenix browser server.\n    document.addEventListener('click', function(event) {\n        let targetElement = event.target;\n        // Traverse one level up the DOM to find an anchor element if the target is not the anchor itself\n        // eg when image inside anchor elements etc..: <a><img></img></a>\n        if (targetElement !== null && targetElement.tagName !== 'A') {\n            targetElement = targetElement.parentElement;\n        }\n\n        if (window.__PHOENIX_EMBED_INFO && window.__PHOENIX_EMBED_INFO.isTauri &&\n            targetElement && targetElement.tagName === 'A' && (targetElement.target === '_blank')) {\n            // in desktop phoenix builds, tauri will not open anchor tags in browser if it is in\n            // an iframe(except for the intel mac bug)\n            // in normal browsers, we dont need to do this and the borwser will do its thing.\n            const href = getAbsoluteUrl(targetElement.getAttribute('href'));\n            if (!event.defaultPrevented) {\n                window.parent.postMessage({\n                    handlerName: \"ph-liveServer\",\n                    eventName: 'embeddedIframeHrefClick',\n                    href: href\n                }, \"*\");\n                // in intel mac desktop, tauri seems to open in browser\n                // causing 2 tabs to open. in m1 macs its not there. so we prevent default behavior.\n                event.stopImmediatePropagation();\n                event.preventDefault();\n            }\n        }\n    });\n    document.addEventListener('contextmenu', function(event) {\n        (document.activeElement || document.body).focus();\n    });\n    document.addEventListener('keydown', function(event) {\n        if (window.__PHOENIX_EMBED_INFO &&\n            (event.key === 'Escape' || event.key === 'Esc')) { // Check for Escape key\n            // Perform the desired action for the Escape key only if its within iframe inside phoenix\n            window.parent.postMessage({\n                handlerName: \"ph-liveServer\",\n                eventName: 'embeddedEscapeKeyPressed'\n            }, \"*\");\n        }\n    });\n\n    function alertPatch(message, titleText) {\n        // Create the modal container\n        const modal = document.createElement('div');\n        modal.style.position = 'fixed';\n        modal.style.top = '0';\n        modal.style.left = '0';\n        modal.style.width = '100%';\n        modal.style.height = '100vh';\n        modal.style.backgroundColor = 'rgba(0,0,0,0.5)';\n        modal.style.display = 'flex';\n        modal.style.justifyContent = 'center';\n        modal.style.alignItems = 'center';\n        modal.style.zIndex = '1000000000';\n\n        // Create the modal content box\n        const modalContent = document.createElement('div');\n        modalContent.style.backgroundColor = 'white';\n        modalContent.style.padding = '20px';\n        modalContent.style.borderRadius = '5px';\n        modalContent.style.minWidth = '300px';\n        modalContent.style.margin = 'auto';\n        modalContent.style.textAlign = 'center';\n\n        // Add title to the modal with the current page URL\n        const title = document.createElement('h3');\n        title.textContent = titleText || \"alert\"; // not translated as window.alert is same in all languages.\n        title.style.marginBottom = '10px';\n\n        // Add text to the modal\n        const text = document.createElement('p');\n        text.textContent = message;\n        text.style.marginBottom = '20px';\n\n        // Create OK button to close the modal\n        const button = document.createElement('button');\n        button.textContent = 'OK';\n        button.style.padding = '10px 20px';\n        button.style.border = 'none';\n        button.style.backgroundColor = '#007BFF';\n        button.style.color = 'white';\n        button.style.borderRadius = '5px';\n        button.style.cursor = 'pointer';\n\n        button.onclick = function() {\n            document.body.removeChild(modal);\n        };\n\n        // Append elements\n        modalContent.appendChild(title);\n        modalContent.appendChild(text);\n        modalContent.appendChild(button);\n        modal.appendChild(modalContent);\n        document.body.appendChild(modal);\n    }\n\n    function unsupportedConfirm() {\n        alertPatch(TRANSPORT_CONFIG.STRINGS.UNSUPPORTED_DOM_APIS_CONFIRM, \"window.confirm\");\n    }\n    function unsupportedPrompt() {\n        alertPatch(TRANSPORT_CONFIG.STRINGS.UNSUPPORTED_DOM_APIS_CONFIRM, \"window.prompt\");\n    }\n\n    // all externally opened live previews have the phcodeLivePreview=\"true\" query string parameter set.\n    const currentUrl = new URL(window.location.href);\n    const queryParams = new URLSearchParams(currentUrl.search);\n    const isExternalBrowser = queryParams.get(\"phcodeLivePreview\") === \"true\";\n    const isTauri = TRANSPORT_CONFIG.IS_NATIVE_APP;\n    const platform = TRANSPORT_CONFIG.PLATFORM;\n\n    let alertQueue = [], confirmCalled = false, promptCalled = false;\n    let addToQueue = true;\n    if(!isExternalBrowser){\n        // this is an embedded iframe we always take hold of the alert api for better ux within the live preivew frame.\n        window.__PHOENIX_EMBED_INFO = {isTauri, platform};\n        const shouldPatchAlert = (isTauri && platform === \"mac\");\n        if(shouldPatchAlert){\n            // In Mac embedded live preview iframe in tauri, alert, prompt, and confirm apis\n            // are not available, so we need to patch the other apis in mac\n            window.alert = function (...args) {\n                // at this time, we cant add our html alert as body is not loaded yet. So we queue alerts.\n                addToQueue && alertQueue.push(...args);\n            };\n            window.confirm = function () {\n                // confirm and prompt is no-op in mac, we just need to show that the api is not supported, so we just\n                // keep a flag.\n                confirmCalled = true;\n            };\n            window.prompt = function () {\n                promptCalled = true;\n            };\n            function drainAlertQueues() {\n                addToQueue = false;\n                if(confirmCalled) {\n                    unsupportedConfirm();\n                }\n                if(promptCalled) {\n                    unsupportedPrompt();\n                }\n                for(let i=0; i<alertQueue.length; i++) {\n                    alertPatch(alertQueue[i]);\n                }\n                alertQueue = [];\n                window.alert = alertPatch;\n                window.confirm = unsupportedConfirm;\n                window.prompt = unsupportedPrompt;\n            }\n\n            document.addEventListener('DOMContentLoaded', function() {\n                drainAlertQueues();\n            });\n        }\n    }\n\n    // this is for managing who am i context in iframes embedded in phoenix to have special handling.\n    window.addEventListener('message', function(event) {\n        if (!TRANSPORT_CONFIG.TRUSTED_ORIGINS_EMBED[event.origin]) {\n            return; // Ignore messages from unexpected origins\n        }\n        if(event.data.type === \"WHO_AM_I_RESPONSE\") {\n            if(!window.__PHOENIX_EMBED_INFO){\n                // this is set from transport config. We should be here\n                console.error(\"Expected window.__PHOENIX_EMBED_INFO to be set, but not???\");\n            }\n        }\n    });\n    if(window.self !== window.parent){\n        // in an iframe\n        window.parent.postMessage({\n            handlerName: \"ph-liveServer\",\n            eventName: 'whoAmIframePhoenix',\n            href: location.href\n        }, \"*\");\n    }\n}(this));\n"],"file":"LivePreviewTransportRemote.js"}