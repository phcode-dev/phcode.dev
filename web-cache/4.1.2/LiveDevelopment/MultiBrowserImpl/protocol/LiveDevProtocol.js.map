{"version":3,"sources":["LiveDevelopment/MultiBrowserImpl/protocol/LiveDevProtocol.js"],"names":["define","require","exports","module","EventDispatcher","LiveDevProtocolRemote","DocumentObserver","LanguageManager","RemoteFunctions","EditorManager","LiveDevMultiBrowser","PreferencesManager","HTMLInstrumentation","StringUtils","FileViewController","MainViewManager","LivePreviewEdit","LIVE_DEV_REMOTE_SCRIPTS_FILE_NAME","randomString","LIVE_DEV_REMOTE_WORKER_SCRIPTS_FILE_NAME","EVENT_LIVE_PREVIEW_CLICKED","EVENT_LIVE_PREVIEW_RELOAD","_connections","_transport","_nextMsgId","_responseDeferreds","getConnectionIds","Object","keys","_focusEditorIfNeeded","editor","tagName","contentEditable","focusShouldBeInLivePreview","includes","focus","cssLangIDS","lessLangIDS","_isLessOrSCSS","language","getLanguageForPath","document","file","fullPath","getId","_searchAndCursorIfCSS","allSelectors","nodeName","codeMirror","_codeMirror","length","selector","cursor","getSearchCursor","found","findNext","setCursorPos","from","line","ch","htmlTagSearch","RegExp","_tagSelectedInLivePreview","tagId","highlightPref","getViewState","liveDoc","getCurrentLiveDoc","activeEditor","getActiveEditor","activeFullEditor","getCurrentFullEditor","liveDocPath","doc","activeEditorPath","activeFullEditorPath","allOpenFileCount","getWorkingSetSize","ALL_PANES","selectInHTMLEditor","fullHtmlEditor","positionResult","getPositionFromTagId","parseInt","position","masterEditor","_masterEditor","isRelated","openAndSelectDocument","WORKING_SET_VIEW","ACTIVE_PANE","done","processedMessageIDs","Phoenix","libs","LRUCache","max","_receive","clientId","msgStr","messageID","msg","JSON","parse","event","method","deferred","has","set","livePreviewEditEnabled","handleLivePreviewEditOperation","id","error","reject","resolve","clicked","trigger","_send","clients","result","$","Deferred","send","stringify","promise","_connect","url","_close","setTransport","transport","off","on","start","_getRemoteFunctionsScript","script","config","getRemoteScriptContents","transportScript","getRemoteScript","remoteFunctionsScript","evaluate","params","expression","setStylesheetText","text","getStylesheetText","reload","ignoreCache","close","closeAllConnections","forEach","makeEventDispatcher"],"mappings":"AAsCAA,OAAO,SAAUC,QAASC,QAASC,QAG/B,MAAMC,gBAAkBH,QAAQ,yBAG1BI,sBAAwBJ,QAAQ,gEAClCK,iBAAwBL,QAAQ,2DAChCM,gBAAsBN,QAAQ,4BAC9BO,gBAAwBP,QAAQ,0DAChCQ,cAAwBR,QAAQ,wBAChCS,oBAAwBT,QAAQ,uCAChCU,mBAAsBV,QAAQ,kCAC9BW,oBAAwBX,QAAQ,iEAChCY,YAAcZ,QAAQ,qBACtBa,mBAAwBb,QAAQ,8BAChCc,gBAAsBd,QAAQ,wBAC9Be,gBAAsBf,QAAQ,mCAE5BgB,+EAAiFJ,YAAYK,aAAa,QAC1GC,6DAA+DN,YAAYK,aAAa,QAExFE,2BAA6B,qBAC/BC,0BAA4B,oBAOhC,IAAIC,aAAe,GAOfC,WAAa,KAObC,WAAa,EAObC,mBAAqB,GAMzB,SAASC,mBACL,OAAOC,OAAOC,KAAKN,cAQvB,SAASO,qBAAqBC,OAAQC,QAASC,iBAC3C,MAAMC,2BAA6B,CAAC,QAAS,YAAYC,SAASH,UAAYC,gBAC3EC,4BAGHH,OAAOK,QAGX,MAAMC,WAAa,CAAC,MAAO,OAAQ,OAAQ,QACrCC,YAAc,CAAC,OAAQ,OAAQ,QACrC,SAASC,cAAcR,QACnB,IAAIA,OACA,OAAO,EAEX,MAAMS,SAAWhC,gBAAgBiC,mBAAmBV,OAAOW,SAASC,KAAKC,UACzE,OAAOJ,UAAYF,YAAYH,SAASK,SAASK,SAGrD,SAASC,sBAAsBf,OAAQgB,aAAcC,UACjD,MAAMC,WAAclB,OAAOmB,YACrBV,SAAWhC,gBAAgBiC,mBAAmBV,OAAOW,SAASC,KAAKC,UACzE,IAAIJ,WAAaH,WAAWF,SAASK,SAASK,SAC1C,OAIJ,GAAGE,cAAgBA,aAAaI,OAE5B,IAAI,IAAIC,YAAYL,aAAa,CAC7B,MAAMM,OAASJ,WAAWK,gBAAgBF,UACpCG,MAAQF,OAAOG,WACrB,GAAID,MAEA,YADAxB,OAAO0B,aAAaJ,OAAOK,OAAOC,KAAMN,OAAOK,OAAOE,IAAI,GAMtE,MAAMC,cAAgB,IAAIC,OAAOd,SAAU,KACrCK,OAASJ,WAAWK,gBAAgBO,eACpCN,MAAQF,OAAOG,WACjBD,OACAxB,OAAO0B,aAAaJ,OAAOK,OAAOC,KAAMN,OAAOK,OAAOE,IAAI,GAIlE,SAASG,0BAA0BC,MAAOhB,SAAUf,gBAAiBc,cACjE,MAAMkB,cAAgBrD,mBAAmBsD,aAAa,oBACtD,IAAID,cAEA,OAEJ,MAAME,QAAUxD,oBAAoByD,oBAChCC,aAAe3D,cAAc4D,kBAC7BC,iBAAmB7D,cAAc8D,uBAC/BC,YAAcN,QAAUA,QAAQO,IAAI/B,KAAKC,SAAW,KACtD+B,iBAAmBN,aAAeA,aAAa3B,SAASC,KAAKC,SAAW,KACxEgC,qBAAuBL,iBAAmBA,iBAAiB7B,SAASC,KAAKC,SAAW,KACxF,IAAI6B,YAEA,YADAJ,cAAgBA,aAAajC,SAGjC,MAAMyC,iBAAmB7D,gBAAgB8D,kBAAkB9D,gBAAgB+D,WAC3E,SAASC,mBAAmBC,gBACxB,MAAMC,eAAiBrE,oBAAoBsE,qBAAqBF,eAAgBG,SAASpB,MAAO,KAChG,GAAGkB,gBAAkBA,eAAexB,MAAQuB,eAAgB,CACxD,MAAMI,SAAWH,eAAexB,KAC1B4B,aAAeL,eAAevC,SAAS6C,eAAiBN,eAC9DK,aAAa7B,aAAa4B,SAAS1B,KAAM0B,SAASzB,IAAI,GACtD9B,qBAAqBwD,aAActC,SAAUf,kBAGlDwC,cAAgBG,qBAEfI,mBAAmBT,kBACbJ,QAAQqB,UAAUb,mBAAqBpC,cAAc8B,eAI3DvC,qBAAqBuC,aAAcrB,SAAUf,iBAC7Ca,sBAAsBuB,aAActB,aAAcC,WAE3C6B,kBAEP9D,mBAAmB0E,sBAAsBhB,YACrC1D,mBAAmB2E,iBAAkB1E,gBAAgB2E,aACpDC,KAAK,KACFZ,mBAAmBtE,cAAc4D,qBAKjD,MAAMuB,oBAAsB,IAAIC,QAAQC,KAAKC,SAAS,CAClDC,IAAK,MAuBT,SAASC,SAASC,SAAUC,OAAQC,WAChC,IAAIC,IAAMC,KAAKC,MAAMJ,QACjBK,MAAQH,IAAII,QAAU,QACtBC,SACDN,WAAaR,oBAAoBe,IAAIP,aAE7BA,WACPR,oBAAoBgB,IAAIR,WAAW,GAEnCC,IAAIQ,wBACJ7F,gBAAgB8F,+BAA+BT,KAG/CA,IAAIU,IACJL,SAAWjF,mBAAmB4E,IAAIU,cAEvBtF,mBAAmB4E,IAAIU,IAC1BV,IAAIW,MACJN,SAASO,OAAOZ,KAEhBK,SAASQ,QAAQb,MAGlBA,IAAIc,SAAWd,IAAItC,OAC1BD,0BAA0BuC,IAAItC,MAAOsC,IAAItD,SAAUsD,IAAIrE,gBAAiBqE,IAAIvD,cAC5E5C,QAAQkH,QAAQhG,2BAA4BiF,OAG5CA,IAAIH,SAAWA,SACfhG,QAAQkH,QAAQZ,MAAOH,OAa/B,SAASgB,MAAMhB,IAAKiB,SAChB,IAAIP,GAAKvF,aACL+F,OAAS,IAAIC,EAAEC,SAOnB,OAJAH,QAAUA,SAAW5F,mBACrB2E,IAAIU,GAAKA,GACTtF,mBAAmBsF,IAAMQ,OACzBhG,WAAWmG,KAAKJ,QAAShB,KAAKqB,UAAUtB,MACjCkB,OAAOK,UAWlB,SAASC,SAAS3B,SAAU4B,KAGxBxG,aAAa4E,WAAY,EAEzBhG,QAAQkH,QAAQ,oBAAqB,CACjClB,SAAUA,SACV4B,IAAKA,MASb,SAASC,OAAO7B,UACR5E,aAAa4E,mBAGV5E,aAAa4E,UACpBhG,QAAQkH,QAAQ,kBAAmB,CAC/BlB,SAAUA,YAUlB,SAAS8B,aAAaC,WACd1G,YACAA,WAAW2G,IAAI,aAEnB3G,WAAa0G,WAGRE,GAAG,kBAAmB,SAAU3B,MAAOH,KACpCwB,SAASxB,IAAI,GAAIA,IAAI,MAExB8B,GAAG,kBAAmB,SAAU3B,MAAOH,KACpCJ,SAASI,IAAI,GAAIA,IAAI,GAAIA,IAAI,MAEhC8B,GAAG,gBAAiB,SAAU3B,MAAOH,KAClC0B,OAAO1B,IAAI,MAEnB9E,WAAW6G,QAUf,SAASC,4BACL,IAAIC,OAAS,GAKb,OAHAA,QAAUhI,iBAGH,MADPgI,QAAU,iBAAmB9H,gBAAkB,IAAM8F,KAAKqB,UAAUjH,oBAAoB6H,QAAU,MAC3E,KAS3B,SAASC,0BACL,MAAMC,gBAAkBlH,WAAWmH,mBAAqB,GAClDC,sBAAwBN,6BAA+B,GAC7D,OAAOI,gBACH,KAAOpI,sBAAwB,KAC/BsI,sBASR,SAASD,kBAEL,4BAA6BzH,gDAYjC,SAAS2H,SAASN,OAAQhB,SACtB,OAAOD,MACH,CACIZ,OAAQ,mBACRoC,OAAQ,CACJC,WAAYR,SAGpBhB,SAaR,SAASyB,kBAAkBjB,IAAKkB,KAAM1B,SAClC,OAAOD,MACH,CACIZ,OAAQ,wBACRoC,OAAQ,CACJf,IAAKA,IACLkB,KAAMA,QAatB,SAASC,kBAAkBnB,IAAKR,SAC5B,OAAOD,MACH,CACIZ,OAAQ,wBACRoC,OAAQ,CACJf,IAAKA,MAGbR,SAWR,SAAS4B,OAAOC,YAAa7B,SAEzB,OADApH,QAAQkH,QAAQ/F,0BAA2BiG,SACpCD,MACH,CACIZ,OAAQ,cACRoC,OAAQ,CACJM,aAAa,IAGrB7B,SAQR,SAAS8B,MAAMlD,UACX3E,WAAW6H,MAAMlD,UAGrB,SAASmD,sBACL3H,mBAAmB4H,QAAQ,SAAUpD,UACjCkD,MAAMlD,YAEV5E,aAAe,GAGnBlB,gBAAgBmJ,oBAAoBrJ,SAGpCA,QAAQ8H,aAAeA,aACvB9H,QAAQwI,gBAAkBA,gBAC1BxI,QAAQsI,wBAA0BA,wBAClCtI,QAAQ0I,SAAWA,SACnB1I,QAAQ6I,kBAAoBA,kBAC5B7I,QAAQ+I,kBAAoBA,kBAC5B/I,QAAQgJ,OAASA,OACjBhJ,QAAQkJ,MAAQA,MAChBlJ,QAAQwB,iBAAmBA,iBAC3BxB,QAAQmJ,oBAAsBA,oBAC9BnJ,QAAQe,kCAAoCA,kCAC5Cf,QAAQiB,yCAA2CA,yCACnDjB,QAAQkB,2BAA6BA,2BACrClB,QAAQmB,0BAA4BA","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2014 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/**\n * Provides the protocol that Brackets uses to talk to a browser instance for live development.\n * Protocol methods are converted to a JSON message format, which is then sent over a provided\n * low-level transport and interpreted in the browser. For messages that expect a response, the\n * response is returned through a promise as an object. Scripts that implement remote logic are\n * provided during the instrumentation stage by \"getRemoteFunctions()\".\n *\n * Events raised by the remote browser are dispatched as jQuery events which type is equal to the 'method'\n * property. The received message object is dispatched as the first parameter and enriched with a\n * 'clientId' property being the client ID of the remote browser.\n *\n * It keeps active connections which are  updated when receiving \"connect\" and \"close\" from the\n * underlying transport. Events \"Connection.connect\"/\"Connection.close\" are triggered as\n * propagation of transport's \"connect\"/\"close\".\n *\n */\n\ndefine(function (require, exports, module) {\n\n\n    const EventDispatcher = require(\"utils/EventDispatcher\");\n\n    // Text of the script we'll inject into the browser that handles protocol requests.\n    const LiveDevProtocolRemote = require(\"text!LiveDevelopment/BrowserScripts/LiveDevProtocolRemote.js\"),\n        DocumentObserver      = require(\"text!LiveDevelopment/BrowserScripts/DocumentObserver.js\"),\n        LanguageManager     = require(\"language/LanguageManager\"),\n        RemoteFunctions       = require(\"text!LiveDevelopment/BrowserScripts/RemoteFunctions.js\"),\n        EditorManager         = require(\"editor/EditorManager\"),\n        LiveDevMultiBrowser   = require(\"LiveDevelopment/LiveDevMultiBrowser\"),\n        PreferencesManager  = require(\"preferences/PreferencesManager\"),\n        HTMLInstrumentation   = require(\"LiveDevelopment/MultiBrowserImpl/language/HTMLInstrumentation\"),\n        StringUtils = require(\"utils/StringUtils\"),\n        FileViewController    = require(\"project/FileViewController\"),\n        MainViewManager     = require(\"view/MainViewManager\"),\n        LivePreviewEdit     = require(\"LiveDevelopment/LivePreviewEdit\");\n\n    const LIVE_DEV_REMOTE_SCRIPTS_FILE_NAME = `phoenix_live_preview_scripts_instrumented_${StringUtils.randomString(8)}.js`;\n    const LIVE_DEV_REMOTE_WORKER_SCRIPTS_FILE_NAME = `pageLoaderWorker_${StringUtils.randomString(8)}.js`;\n\n    const EVENT_LIVE_PREVIEW_CLICKED = \"livePreviewClicked\",\n        EVENT_LIVE_PREVIEW_RELOAD = \"livePreviewReload\";\n\n    /**\n     * @private\n     * Active connections.\n     * @type {Object}\n     */\n    var _connections = {};\n\n    /**\n     * @private\n     * The low-level transport we're communicating over, set by `setTransport()`.\n     * @type {{start: function(), send: function(number|Array.<number>, string), close: function(number), getRemoteScript: function(): ?string}}\n     */\n    var _transport = null;\n\n    /**\n     * @private\n     * A unique message serial number, used to match up responses with request messages.\n     * @type {number}\n     */\n    var _nextMsgId = 1;\n\n    /**\n     * @private\n     * A map of response IDs to deferreds, for messages that are awaiting responses.\n     * @type {Object}\n     */\n    var _responseDeferreds = {};\n\n    /**\n     * Returns an array of the client IDs that are being managed by this live document.\n     * @return {Array.<number>}\n     */\n    function getConnectionIds() {\n        return Object.keys(_connections);\n    }\n\n    /**\n     * When user clicks on text boxes or other focusable keyboard elements in live preview, we should not\n     * set focus to editor\n     * @private\n     */\n    function _focusEditorIfNeeded(editor, tagName, contentEditable) {\n        const focusShouldBeInLivePreview = ['INPUT', 'TEXTAREA'].includes(tagName) || contentEditable;\n        if(focusShouldBeInLivePreview){\n            return;\n        }\n        editor.focus();\n    }\n\n    const cssLangIDS = [\"css\", \"scss\", \"sass\", \"less\"];\n    const lessLangIDS = [\"scss\", \"sass\", \"less\"];\n    function _isLessOrSCSS(editor) {\n        if(!editor){\n            return false;\n        }\n        const language = LanguageManager.getLanguageForPath(editor.document.file.fullPath);\n        return language && lessLangIDS.includes(language.getId());\n    }\n\n    function _searchAndCursorIfCSS(editor, allSelectors, nodeName) {\n        const codeMirror =  editor._codeMirror;\n        const language = LanguageManager.getLanguageForPath(editor.document.file.fullPath);\n        if(!language || !cssLangIDS.includes(language.getId())){\n            return;\n        }\n\n        // this is a css file\n        if(allSelectors && allSelectors.length){\n            // check if we can find a class selector\n            for(let selector of allSelectors){\n                const cursor = codeMirror.getSearchCursor(selector);\n                const found = cursor.findNext();\n                if (found) {\n                    editor.setCursorPos(cursor.from().line, cursor.from().ch, true);\n                    return;\n                }\n            }\n        }\n        // check if we can do tag matching, html tag selectors are not case-sensitive\n        const htmlTagSearch = new RegExp(nodeName, \"i\");\n        const cursor = codeMirror.getSearchCursor(htmlTagSearch);\n        const found = cursor.findNext();\n        if (found) {\n            editor.setCursorPos(cursor.from().line, cursor.from().ch, true);\n        }\n    }\n\n    function _tagSelectedInLivePreview(tagId, nodeName, contentEditable, allSelectors) {\n        const highlightPref = PreferencesManager.getViewState(\"livedevHighlight\");\n        if(!highlightPref){\n            // live preview highlight and reverse highlight feature is disabled\n            return;\n        }\n        const liveDoc = LiveDevMultiBrowser.getCurrentLiveDoc(),\n            activeEditor = EditorManager.getActiveEditor(), // this can be an inline editor\n            activeFullEditor = EditorManager.getCurrentFullEditor();\n        const liveDocPath = liveDoc ? liveDoc.doc.file.fullPath : null,\n            activeEditorPath = activeEditor ? activeEditor.document.file.fullPath : null,\n            activeFullEditorPath = activeFullEditor ? activeFullEditor.document.file.fullPath : null;\n        if(!liveDocPath){\n            activeEditor && activeEditor.focus(); // restore focus from live preview\n            return;\n        }\n        const allOpenFileCount = MainViewManager.getWorkingSetSize(MainViewManager.ALL_PANES);\n        function selectInHTMLEditor(fullHtmlEditor) {\n            const positionResult = HTMLInstrumentation.getPositionFromTagId(fullHtmlEditor, parseInt(tagId, 10));\n            if(positionResult && positionResult.from && fullHtmlEditor) {\n                const position = positionResult.from;\n                const masterEditor = fullHtmlEditor.document._masterEditor || fullHtmlEditor;\n                masterEditor.setCursorPos(position.line, position.ch, true);\n                _focusEditorIfNeeded(masterEditor, nodeName, contentEditable);\n            }\n        }\n        if(liveDocPath === activeFullEditorPath) {\n            // if the active pane is the html being live previewed, select that.\n            selectInHTMLEditor(activeFullEditor);\n        } else if(liveDoc.isRelated(activeEditorPath) || _isLessOrSCSS(activeEditor)) {\n            // the active editor takes the priority in the workflow. If a css related file is active,\n            // then we dont need to open the html live doc. For less files, we dont check if its related as\n            // its not directly linked usually and needs a compile step. so we just do a fuzzy search.\n            _focusEditorIfNeeded(activeEditor, nodeName, contentEditable);\n            _searchAndCursorIfCSS(activeEditor, allSelectors, nodeName);\n            // in this case, see if we need to do any css reverse highlight magic here\n        } else if(!allOpenFileCount){\n            // no open editor in any panes, then open the html file directly.\n            FileViewController.openAndSelectDocument(liveDocPath,\n                FileViewController.WORKING_SET_VIEW, MainViewManager.ACTIVE_PANE)\n                .done(()=>{\n                    selectInHTMLEditor(EditorManager.getActiveEditor());\n                });\n        }\n    }\n\n    const processedMessageIDs = new Phoenix.libs.LRUCache({\n        max: 1000\n        // we dont need to set a ttl here as message ids are unique throughout lifetime. And old ids will\n        // start getting evited from the cache. the message ids are only an issue within a fraction of a seconds when\n        // a series of messages are sent in quick succession. Eg. user click on a div and there are 3 tabs and due to\n        // the reflection bug, we almost immediately get 3 messages with the same id. So that will be in this cache\n        // for a fraction of a second. so a size of 1000 should be more than enough.\n    });\n\n    /**\n     * @private\n     * Handles a message received from the remote protocol handler via the transport.\n     * If the message has an `id` field, it's assumed to be a response to a previous\n     * request, and will be passed along to the original promise returned by `_send()`.\n     * Otherwise, it's treated as an event and dispatched.\n     * TODO: we should probably have a way of returning the results from all clients, not just the first?\n     *\n     * @param {number} clientId ID of the client that sent the message\n     * @param {string} msgStr The message that was sent, in JSON string format\n     * @param {string} messageID The messageID uniquely identifying a message. in browsers, since we use broadcast\n     *      channels, we get reflections echoes when there are multiple tabs open. Ideally those reflections need to\n     *      be fixed, but that was too complex to fix, so we just reply on the message id to guarantee that a message is\n     *      only processed once and not from any reflections.\n     */\n    function _receive(clientId, msgStr, messageID) {\n        var msg = JSON.parse(msgStr),\n            event = msg.method || \"event\",\n            deferred;\n        if(messageID && processedMessageIDs.has(messageID)){\n            return; // this message is already processed.\n        } else if (messageID) {\n            processedMessageIDs.set(messageID, true);\n        }\n        if (msg.livePreviewEditEnabled) {\n            LivePreviewEdit.handleLivePreviewEditOperation(msg);\n        }\n\n        if (msg.id) {\n            deferred = _responseDeferreds[msg.id];\n            if (deferred) {\n                delete _responseDeferreds[msg.id];\n                if (msg.error) {\n                    deferred.reject(msg);\n                } else {\n                    deferred.resolve(msg);\n                }\n            }\n        } else if (msg.clicked && msg.tagId) {\n            _tagSelectedInLivePreview(msg.tagId, msg.nodeName, msg.contentEditable, msg.allSelectors);\n            exports.trigger(EVENT_LIVE_PREVIEW_CLICKED, msg);\n        } else {\n            // enrich received message with clientId\n            msg.clientId = clientId;\n            exports.trigger(event, msg);\n        }\n    }\n\n    /**\n     * @private\n     * Dispatches a message to the remote protocol handler via the transport.\n     *\n     * @param {Object} msg The message to send.\n     * @param {number|Array.<number>} idOrArray ID or IDs of the client(s) that should\n     *     receive the message.\n     * @return {$.Promise} A promise that's fulfilled when the response to the message is received.\n     */\n    function _send(msg, clients) {\n        var id = _nextMsgId++,\n            result = new $.Deferred();\n\n        // broadcast if there are no specific clients\n        clients = clients || getConnectionIds();\n        msg.id = id;\n        _responseDeferreds[id] = result;\n        _transport.send(clients, JSON.stringify(msg));\n        return result.promise();\n    }\n\n     /**\n     * @private\n     * Handles when a connection is made to the live development protocol handler.\n     * Injects the RemoteFunctions script in order to provide highlighting and live DOM editing functionality.\n     * Records the connection's client ID and triggers the \"Coonnection.connect\" event.\n     * @param {number} clientId\n     * @param {string} url\n     */\n    function _connect(clientId, url) {\n        // add new connections\n        // TODO: check URL\n        _connections[clientId] = true;\n\n        exports.trigger(\"ConnectionConnect\", {\n            clientId: clientId,\n            url: url\n        });\n    }\n\n    /**\n     * @private\n     * Handles when a connection is closed.\n     * @param {number} clientId\n     */\n    function _close(clientId) {\n        if(!_connections[clientId]){\n            return;\n        }\n        delete _connections[clientId];\n        exports.trigger(\"ConnectionClose\", {\n            clientId: clientId\n        });\n    }\n\n\n    /**\n     * Sets the transport that should be used by the protocol. See `LiveDevelopment.setTransport()`\n     * for more detail on the transport.\n     * @param {{start: function(string), send: function(number|Array.<number>, string), close: function(number), getRemoteScript: function(): ?string}} transport\n     */\n    function setTransport(transport) {\n        if (_transport) {\n            _transport.off(\".livedev\");\n        }\n        _transport = transport;\n\n        _transport\n            .on(\"connect.livedev\", function (event, msg) {\n                _connect(msg[0], msg[1]);\n            })\n            .on(\"message.livedev\", function (event, msg) {\n                _receive(msg[0], msg[1], msg[2]);\n            })\n            .on(\"close.livedev\", function (event, msg) {\n                _close(msg[0]);\n            });\n        _transport.start();\n    }\n\n\n    /**\n     * Returns a script that should be injected into the HTML that's launched in the\n     * browser in order to implement remote commands that handle protocol requests.\n     * Includes the <script> tags.\n     * @return {string}\n     */\n    function _getRemoteFunctionsScript() {\n        let script = \"\";\n        // Inject DocumentObserver into the browser (tracks related documents)\n        script += DocumentObserver;\n        // Inject remote functions into the browser.\n        script += \"\\nwindow._LD=(\" + RemoteFunctions + \"(\" + JSON.stringify(LiveDevMultiBrowser.config) + \"))\";\n        return \"\\n\" + script + \"\\n\";\n    }\n\n    /**\n     * Returns a script that should be injected into the HTML that's launched in the\n     * browser in order to handle protocol requests. Includes the <script> tags.\n     * This script will also include the script required by the transport, if any.\n     * @return {string}\n     */\n    function getRemoteScriptContents() {\n        const transportScript = _transport.getRemoteScript() || \"\";\n        const remoteFunctionsScript = _getRemoteFunctionsScript() || \"\";\n        return transportScript +\n            \"\\n\" + LiveDevProtocolRemote + \"\\n\" +\n            remoteFunctionsScript;\n    }\n\n    /**\n     * Returns a script that should be injected into the HTML that's launched in the\n     * browser in order to handle protocol requests. Includes the <script> tags.\n     * This script will also include the script required by the transport, if any.\n     * @return {string}\n     */\n    function getRemoteScript() {\n        // give a wrong random file name that wont have a possibility of an actual file name\n        return `\\n\\t\\t<script src=\"${LIVE_DEV_REMOTE_SCRIPTS_FILE_NAME}\"></script>`;\n    }\n\n    /**\n     * Protocol method. Evaluates the given script in the browser (in global context), and returns a promise\n     * that will be fulfilled with the result of the script, if any.\n     * @param {number|Array.<number>} clients A client ID or array of client IDs that should evaluate\n     *      the script.\n     * @param {string} script The script to evaluate.\n     * @return {$.Promise} A promise that's resolved with the return value from the first client that responds\n     *      to the evaluation.\n     */\n    function evaluate(script, clients) {\n        return _send(\n            {\n                method: \"Runtime.evaluate\",\n                params: {\n                    expression: script\n                }\n            },\n            clients\n        );\n    }\n\n    /**\n     * Protocol method. Reloads a CSS styleseet in the browser (by replacing its text) given its url.\n     * @param {string} url Absolute URL of the stylesheet\n     * @param {string} text The new text of the stylesheet\n     * @param {number|Array.<number>} clients A client ID or array of client IDs that should evaluate\n     *      the script.\n     * @return {$.Promise} A promise that's resolved with the return value from the first client that responds\n     *      to the evaluation.\n     */\n    function setStylesheetText(url, text, clients) {\n        return _send(\n            {\n                method: \"CSS.setStylesheetText\",\n                params: {\n                    url: url,\n                    text: text\n                }\n            }\n        );\n    }\n\n     /**\n     * Protocol method. Rretrieves the content of a given stylesheet (for unit testing)\n     * @param {number|Array.<number>} clients A client ID or array of client IDs that should navigate to the given URL.\n     * @param {string} url Absolute URL that identifies the stylesheet.\n     * @return {$.Promise} A promise that's resolved with the return value from the first client that responds\n     *      to the method.\n     */\n    function getStylesheetText(url, clients) {\n        return _send(\n            {\n                method: \"CSS.getStylesheetText\",\n                params: {\n                    url: url\n                }\n            },\n            clients\n        );\n    }\n\n    /**\n     * Protocol method. Reloads the page that is currently loaded into the browser, optionally ignoring cache.\n     * @param {number|Array.<number>} clients A client ID or array of client IDs that should reload the page.\n     * @param {boolean} ignoreCache If true, browser cache is ignored.\n     * @return {$.Promise} A promise that's resolved with the return value from the first client that responds\n     *      to the method.\n     */\n    function reload(ignoreCache, clients) {\n        exports.trigger(EVENT_LIVE_PREVIEW_RELOAD, clients);\n        return _send(\n            {\n                method: \"Page.reload\",\n                params: {\n                    ignoreCache: true\n                }\n            },\n            clients\n        );\n    }\n\n    /**\n     * Closes the connection to the given client. Proxies to the transport.\n     * @param {number} clientId\n     */\n    function close(clientId) {\n        _transport.close(clientId);\n    }\n\n    function closeAllConnections() {\n        getConnectionIds().forEach(function (clientId) {\n            close(clientId);\n        });\n        _connections = {};\n    }\n\n    EventDispatcher.makeEventDispatcher(exports);\n\n    // public API\n    exports.setTransport = setTransport;\n    exports.getRemoteScript = getRemoteScript;\n    exports.getRemoteScriptContents = getRemoteScriptContents;\n    exports.evaluate = evaluate;\n    exports.setStylesheetText = setStylesheetText;\n    exports.getStylesheetText = getStylesheetText;\n    exports.reload = reload;\n    exports.close = close;\n    exports.getConnectionIds = getConnectionIds;\n    exports.closeAllConnections = closeAllConnections;\n    exports.LIVE_DEV_REMOTE_SCRIPTS_FILE_NAME = LIVE_DEV_REMOTE_SCRIPTS_FILE_NAME;\n    exports.LIVE_DEV_REMOTE_WORKER_SCRIPTS_FILE_NAME = LIVE_DEV_REMOTE_WORKER_SCRIPTS_FILE_NAME;\n    exports.EVENT_LIVE_PREVIEW_CLICKED = EVENT_LIVE_PREVIEW_CLICKED;\n    exports.EVENT_LIVE_PREVIEW_RELOAD = EVENT_LIVE_PREVIEW_RELOAD;\n});\n"],"file":"LiveDevProtocol.js"}