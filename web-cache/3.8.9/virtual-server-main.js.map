{"version":3,"sources":["virtual-server-main.js"],"names":["importScripts","_debugSWCacheLogs","workbox","setConfig","debug","Route","routing","cacheFirst","strategies","CacheFirst","StaleWhileRevalidate","ExpirationPlugin","expiration","DAYS_30_IN_SEC","CACHE_NAME_EVERYTHING","CACHE_NAME_CORE_SCRIPTS","CACHE_NAME_EXTERNAL","WEB_CACHE_FILE_PATH","_debugCacheLog","args","console","log","_removeParams","url","indexOf","substring","location","href","self","_debugLivePreviewLog","_debugSWLivePreviewLogs","baseURL","lastIndexOf","endsWith","virtualServerBaseURL","Config","route","wwwRegex","RegExp","_isVirtualServing","startsWith","_shouldVirtualServe","request","_isCacheableExternalUrl","EXTERNAL_URLS","start","registerRoute","path","pathname","match","download","phoenixInstanceID","decodeURI","pathSplit","split","replace","shift","join","Serve","serve","Promise","resolve","Response","redirect","addEventListener","event","eventType","data","type","skipWaiting","debugMode","logLivePreview","__WB_DISABLE_DEV_LOGS","ports","postMessage","setInstrumentedURLs","msgProcessed","processVirtualServerMessage","error","DONT_CACHE_BASE_URLS","origin","_isNotCacheableUrl","CORE_SCRIPTS_URLS","_isCoreScript","coreScript","_belongsToEverythingCache","destination","disAllowedExtensions","test","_everythingCache","_version","_everythingCacheName","_getLatestCacheName","fs","readFile","err","version","async","_updateEverythingCache","cacheToUse","caches","open","_getEverythingCache","watchAsync","then","watcher","on","WATCH_EVENTS","ADD_FILE","CHANGE","catch","everythingCacheHandler","cache","cachedResponse","URL","versionedBase","versionedURL","shouldCache","fetchResponse","fetch","method","ok","responseToCache","clone","responseBlob","blob","newResponse","status","statusText","headers","waitUntil","put","allCachedRoutes","freshnessPreferredRoutes","cacheName","plugins","maxAgeSeconds","purgeOnQuotaError","externalCachedRoutes","core","clientsClaim"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * modified by core.ai, based on work by David Humphrey <david.humphrey@senecacolleage.ca> (@humphd)\n *\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU Affero General Public License as published by the Free\n * Software Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along\n * with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/* global workbox, importScripts, Serve, HtmlFormatter, Config*/\nimportScripts('phoenix/virtualfs.js');\nimportScripts('phoenix/virtualServer/mime-types.js');\nimportScripts('phoenix/virtualServer/config.js');\nimportScripts('phoenix/virtualServer/content-type.js');\nimportScripts('phoenix/virtualServer/webserver.js');\nimportScripts('https://storage.googleapis.com/workbox-cdn/releases/6.4.1/workbox-sw.js');\n\nconst _debugSWCacheLogs = false; // change debug to true to see more logs\n\nworkbox.setConfig({debug: _debugSWCacheLogs});\n\nconst Route = workbox.routing.Route;\n// other strategies include CacheFirst, NetworkFirst Etc..\nconst cacheFirst = workbox.strategies.CacheFirst;\nconst StaleWhileRevalidate = workbox.strategies.StaleWhileRevalidate;\nconst ExpirationPlugin = workbox.expiration.ExpirationPlugin;\nconst DAYS_30_IN_SEC = 60 * 60 * 24 * 30;\nconst CACHE_NAME_EVERYTHING = \"everythingV2\"; // this is used in index.html as well, if changing the cache name.\nconst CACHE_NAME_CORE_SCRIPTS = \"coreScripts\";\nconst CACHE_NAME_EXTERNAL = \"external\";\nconst WEB_CACHE_FILE_PATH = \"/webCacheVersion.txt\";\n\nfunction _debugCacheLog(...args) {\n    if(_debugSWCacheLogs){\n        console.log(...args);\n    }\n}\n\nself._debugLivePreviewLog = function (...args) {\n    if(self._debugSWLivePreviewLogs){ // this is set from the debug menu\n        console.log(...args);\n    }\n}\n\nfunction _removeParams(url) {\n    if(url.indexOf( \"?\")>-1){\n        url = url.substring( 0, url.indexOf( \"?\")); // remove query string params\n    }\n    if(location.href.indexOf( \"#\")>-1){\n        url = url.substring( 0, url.indexOf( \"#\")); // remove hrefs in page\n    }\n    return url;\n}\n\n// service worker controlling route base url. This will be something like https://phcode.dev/ or http://localhost:8000/\nlet baseURL = location.href;\nbaseURL = _removeParams(location.href);\nif(location.href.indexOf( \"/\")>-1){\n    // http://phcode.dev/index.html -> http://phcode.dev\n    baseURL = baseURL.substring( 0, baseURL.lastIndexOf( \"/\"));\n}\nif(!baseURL.endsWith('/')){\n    baseURL = baseURL + '/';\n}\nconsole.log(\"Service worker: base URL is: \", baseURL);\n\n// this is the base url where our file system virtual server lives. http://phcode.dev/phoenix/vfs in phoenix or\n// http://localhost:8000/phoenix/vfs in dev builds\nconst virtualServerBaseURL = `${baseURL}${Config.route}`;\nconsole.log(\"Service worker: Virtual server base URL is: \", virtualServerBaseURL);\n\n// Route with trailing slash (i.e., /path/into/filesystem)\nconst wwwRegex = new RegExp(`${Config.route}(/.*)`);\n// Route minus the trailing slash\n\nfunction _isVirtualServing(url) {\n    return url.startsWith(virtualServerBaseURL);\n}\n\nfunction _shouldVirtualServe(request) {\n    return _isVirtualServing(request.url.href);\n}\n\nworkbox.routing.registerRoute(\n    _shouldVirtualServe,\n    ({url}) => {\n        // Pull the filesystem path off the url\n        let path = url.pathname.match(wwwRegex)[1];\n        // Deal with encoding in the filename (e.g., spaces as %20)\n        path = decodeURI(path);\n\n        const download = false;\n        // commented Allow passing `?download` or `dl` to have the file downloaded vs. displayed\n        // url.searchParams.get('download') !== null ||\n        // url.searchParams.get('dl') !== null;\n        let phoenixInstanceID;\n        if(path.startsWith(\"/PHOENIX_LIVE_PREVIEW_\")){\n            let pathSplit = path.split(\"/\");\n            phoenixInstanceID = pathSplit[1].replace(\"PHOENIX_LIVE_PREVIEW_\",\"\");\n            pathSplit.shift();pathSplit.shift();\n            path = `/${pathSplit.join(\"/\")}`;\n        }\n\n        return Serve.serve(path, download, phoenixInstanceID);\n    },\n    'GET'\n);\n\n// Redirect if missing the / on our expected route\nworkbox.routing.registerRoute(\n    _shouldVirtualServe,\n    ({url}) => {\n        url.pathname = `${Config.route}/`;\n        return Promise.resolve(Response.redirect(url, 302));\n    },\n    'GET'\n);\n\naddEventListener('message', (event) => {\n    // NB: Do not expect anything to persist in the service worker variables, the service worker may be reset at\n    // any time by the browser if it is not in use, and only load it when required. This means that if there is a\n    // long inactivity in the page, even if the tab is opened, the service worker will be unloaded by chrome. Then will\n    // be re-enabled when needed. Hens some of our stored variables transferred from browser tabs was being erased\n    // leading to live preview failures before. Use indexDB persistent storage only inside worker is you want to keep\n    // track of data transferred from the main browser tabs, never hold it in variables here!\n    let eventType = event.data && event.data.type;\n    switch (eventType) {\n        case 'SKIP_WAITING': self.skipWaiting(); break;\n        case 'INIT_PHOENIX_CONFIG':\n            Config.debug = event.data.debugMode;\n            self._debugSWLivePreviewLogs = event.data.logLivePreview;\n            self.__WB_DISABLE_DEV_LOGS = Config.debug && _debugSWCacheLogs;\n            event.ports[0].postMessage({baseURL}); break;\n        case 'setInstrumentedURLs': self.Serve.setInstrumentedURLs(event); return true;\n        default:\n            let msgProcessed = self.Serve && self.Serve.processVirtualServerMessage &&\n                self.Serve.processVirtualServerMessage(event);\n            if(!msgProcessed){\n                console.error(\"Service worker cannot process, received unknown message: \", event);\n            }\n    }\n});\n\nfunction _isCacheableExternalUrl(url) {\n    let EXTERNAL_URLS = [\n        'https://storage.googleapis.com/workbox-cdn/'\n    ];\n    for(let start of EXTERNAL_URLS){\n        if(url.startsWith(start)){\n            return true;\n        }\n    }\n    return false;\n}\n\n// queue cache update\n\nconst DONT_CACHE_BASE_URLS = [\n    `${location.origin}/src/`, `${location.origin}/test/`, `${location.origin}/dist/`, // https://phcode.dev/src or other\n    `${location.origin}/cacheManifest.json`, `${location.origin}/web-cache/`,\n    // https://phcode.dev/subfolder/src/ or other when phoenix is loaded from https://phcode.dev/subfolder/index.html\n    `${baseURL}src/`, `${baseURL}test/`, `${baseURL}dist/`,\n    `${baseURL}cacheManifest.json`, `${baseURL}web-cache/`,\n];\nfunction _isNotCacheableUrl(url) {\n    for(let start of DONT_CACHE_BASE_URLS){\n        if(url.startsWith(start)){\n            return true;\n        }\n    }\n    return false;\n}\n\n// we always try to load main worker scripts and index html from core scripts cache which uses stale while revalidate\n// to get aggressive updates.\nconst CORE_SCRIPTS_URLS = [`${location.origin}/index.html`, `${location.origin}/`, // https://phcode.dev/src or other\n    `${location.origin}/virtual-server-main.js`, `${location.origin}/phoenix/virtual-server-loader.js`,\n    // https://phcode.dev/subfolder/src/ or other when phoenix is loaded from https://phcode.dev/subfolder/index.html\n    `${baseURL}index.html`, `${baseURL}`,\n    `${baseURL}virtual-server-main.js`, `${baseURL}phoenix/virtual-server-loader.js`];\nfunction _isCoreScript(url) {\n    for(let coreScript of CORE_SCRIPTS_URLS){\n        if(url === coreScript){\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction _belongsToEverythingCache(request) {\n    // now do url checks, Remove # ,http://localhost:9000/dist/styles/images/sprites.svg#leftArrowDisabled.\n    // we cache entries with query string parameters in static pages with base url starting with phoenix base\n    let href = request.url.split(\"#\")[0];\n    if(request.destination === 'video' || request.destination === 'audio'){\n        _debugCacheLog(\"Not Caching audio/video URL: \", request);\n        return false;\n    }\n    if(_isNotCacheableUrl(href)){\n        _debugCacheLog(\"Not Caching un cacheable URL in everything cache: \", request);\n        return false;\n    }\n    if(_isCoreScript(href)){\n        _debugCacheLog(\"Not Caching core scripts in everything cache: \", request);\n        return false;\n    }\n    if(!href.startsWith(baseURL)){\n        _debugCacheLog(\"Not Caching external url in everything cache: \", request);\n        return false;\n    }\n    let disAllowedExtensions =  /.zip$|.map$/i;\n    if(href.startsWith(baseURL) && !disAllowedExtensions.test(href)) {\n        return true;\n    }\n    _debugCacheLog(\"Not Caching URL: \", request);\n    return false;\n}\n\n// handle all document caches\n\n/**\n * The everything cache holds as the name indicates, every web asset that is not external urls and core scripts.\n * Also excluded are vfs locations and `/web-cache` paths.\n * When phoenix is started afresh, the default cache CACHE_NAME_EVERYTHING is used. When phoenix is updated,\n * the latest cache name to use will be updated in WEB_CACHE_FILE_PATH file.\n */\n\nlet _everythingCache, _version, _everythingCacheName;\nfunction _getLatestCacheName() {\n    return new Promise(resolve=>{\n        fs.readFile(WEB_CACHE_FILE_PATH, \"utf8\", (err, version)=>{\n            if(err || !version){\n                resolve(CACHE_NAME_EVERYTHING);\n                return;\n            }\n            _version = version;\n            resolve(version);\n        });\n    });\n}\n\nasync function _updateEverythingCache() {\n    const cacheToUse = await _getLatestCacheName();\n    if(_everythingCacheName === cacheToUse && _everythingCache) {\n        return _everythingCache;\n    }\n    console.log(\"Service Worker: Using cache\", cacheToUse);\n    _everythingCache = await caches.open(cacheToUse);\n    _everythingCacheName = cacheToUse;\n    return _everythingCache;\n}\n\nfs.watchAsync(WEB_CACHE_FILE_PATH)\n    .then(watcher=>{\n        watcher.on(fs.WATCH_EVENTS.ADD_FILE, _updateEverythingCache);\n        watcher.on(fs.WATCH_EVENTS.CHANGE, _updateEverythingCache);\n    }).catch(console.error);\n\nasync function _getEverythingCache() {\n    if(_everythingCache){\n        return _everythingCache;\n    }\n    return await _updateEverythingCache();\n}\nconst everythingCacheHandler = async ({request, event}) => {\n    let cache = await _getEverythingCache();\n    let cachedResponse = await cache.match(new URL(request.url));\n\n    if (cachedResponse) {\n        return cachedResponse;\n    }\n\n    const versionedBase = `${baseURL}web-cache/${_version}`;\n    _debugCacheLog(\"cache miss, fetching\", request.url, \"versioned base is\", versionedBase);\n\n    // Modify request URL if it matches the updated version\n    let versionedURL = request.url;\n    // if the url we got starts with versionedBase, then it means that if from a fetch request from this handler\n    // itself during a cache miss, in which case, we should service the request without redirecting again\n    let shouldCache = false;\n    if (_version && !versionedURL.startsWith(versionedBase) && versionedURL.startsWith(baseURL)) {\n        shouldCache = true;\n        versionedURL = versionedURL.replace(baseURL, `${baseURL}web-cache/${_version}/`);\n    }\n\n    // Fetch the updated URL\n    let fetchResponse = await fetch(versionedURL, {method: 'GET'});\n    if(fetchResponse.ok && shouldCache){\n        const responseToCache = fetchResponse.clone();\n        // Cache the response under the original request URL\n        const responseBlob = await responseToCache.blob();\n        const newResponse = new Response(responseBlob, {\n            status: responseToCache.status,\n            statusText: responseToCache.statusText,\n            headers: responseToCache.headers\n        });\n        event.waitUntil(cache.put(new URL(request.url), newResponse));\n    } else if(!fetchResponse.ok){\n        fetchResponse = await fetch(request.url, {method: 'GET'});\n        // we don't cache this as CDN might not deliver build consistency without version.\n    }\n\n    return fetchResponse;\n};\n\nconst allCachedRoutes = new Route(({ request }) => {\n    return (request.method === 'GET'\n        && _belongsToEverythingCache(request) && !_isVirtualServing(request.url));\n}, everythingCacheHandler);\n\n// core scripts route\nconst freshnessPreferredRoutes = new Route(({ request }) => {\n    return request.method === 'GET' && _isCoreScript(request.url) && !_isVirtualServing(request.url);\n}, new StaleWhileRevalidate({\n    cacheName: CACHE_NAME_CORE_SCRIPTS,\n    plugins: [\n        new ExpirationPlugin({\n            maxAgeSeconds: DAYS_30_IN_SEC,\n            purgeOnQuotaError: true\n        })\n    ]\n}));\n\n// scripts with a different origin like third party libs\nconst externalCachedRoutes = new Route(({ request }) => {\n    return request.method === 'GET' && _isCacheableExternalUrl(request.url) && !_isVirtualServing(request.url);\n}, new StaleWhileRevalidate({\n    cacheName: CACHE_NAME_EXTERNAL,\n    plugins: [\n        new ExpirationPlugin({\n            maxAgeSeconds: DAYS_30_IN_SEC,\n            purgeOnQuotaError: true\n        })\n    ]\n}));\n\nworkbox.routing.registerRoute(allCachedRoutes);\nworkbox.routing.registerRoute(freshnessPreferredRoutes);\nworkbox.routing.registerRoute(externalCachedRoutes);\n\nworkbox.core.clientsClaim();\n"],"file":"virtual-server-main.js"}