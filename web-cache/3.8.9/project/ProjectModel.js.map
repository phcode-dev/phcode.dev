{"version":3,"sources":["project/ProjectModel.js"],"names":["define","require","exports","module","InMemoryFile","EventDispatcher","FileUtils","_","FileSystem","DocumentManager","FileSystemError","FileTreeViewModel","Async","PerfUtils","EVENT_CHANGE","EVENT_SHOULD_SELECT","EVENT_SHOULD_FOCUS","EVENT_FS_RENAME_STARTED","EVENT_FS_RENAME_END","ERROR_CREATION","ERROR_INVALID_FILENAME","ERROR_NOT_IN_PROJECT","_exclusionListRegEx","_cacheExcludeFileNameRegEx","defaultIgnoreGlobs","_invalidChars","_illegalFilenamesRegEx","isValidFilename","filename","match","isValidPath","path","_shouldShowName","name","test","shouldShow","entry","shouldIndex","setFileTreeFilter","FILE_RENAMING","FILE_CREATING","RENAME_CANCELLED","_pathIsFile","last","_getFSObject","getFileForPath","getDirectoryForPath","_getPathFromFSObject","fsobj","fullPath","doCreate","isFolder","d","$","Deferred","getBaseName","resolve","err","directory","create","reject","file","writeText","then","ALREADY_EXISTS","promise","ProjectModel","initial","projectRoot","this","undefined","focused","_focused","_viewModel","on","trigger","bind","_selections","_getGitIgnoreFileContent","Promise","getDocumentForPath","done","doc","getText","fail","_gitIgnores","gitIgnoreFilters","filter","relativePath","relative","basePath","startsWith","gitIgnore","ignores","e","console","error","async","_updateGitIgnoreFromPath","gitIgnorePath","parentFullPath","gitIgnoreSearchedInDir","gitIgnoreContent","push","fs","utils","ignore","add","_updateGitIgnore","siblingEntries","dirname","sibling","isFile","_ensureTrailingSlash","_addWelcomeProjectPath","currentProjects","pathNoSlash","stripTrailingSlash","newProjects","clone","indexOf","_isWelcomeProjectPath","welcomeProjectPath","welcomeProjects","makeEventDispatcher","prototype","_projectBaseUrl","_currentPath","_allFilesCachePromise","_allFilesScopeCachePromise","_allFilesScope","setFocused","setSelected","setSelectionWidth","width","setScrollerInfo","scrollWidth","scrollTop","scrollLeft","offsetTop","setSelectionScrollerInfo","getBaseUrl","setBaseUrl","projectBaseUrl","length","isWithinProject","absPathOrEntry","absPath","makeProjectRelativeIfPossible","slice","getDirectoryInProject","isDirectory","computeProjectGitIgnoreAsync","self","jsPromise","_getAllFilesCache","catch","finally","sort","_gitIgnoreFiltersOut","deferred","allFiles","allFilesVisitor","projectIndexTimer","markStart","options","sortList","visit","finalizeMeasurement","addMeasurement","_getAllFilesInScopeCache","scope","Error","scopeTimer","getAllFiles","additionalFiles","filteredFilesDeferred","getAllFilesFn","result","forEach","stack","_resetCache","setProjectRoot","_rootChanged","getContents","contents","setDirectoryContents","_getDirectoryContents","setDirectoryOpen","open","projectRelative","needsLoading","isPathLoaded","onSuccess","openPath","currentPathInProject","isFilePathVisible","selected","relativeSelected","parentDirectory","getDirectoryPath","showInTree","Phoenix","app","openPathInFileBrowser","doNotOpen","oldProjectPath","pathInProject","performRename","moveMarker","context","previousSelection","previousPath","hadFocus","getSelected","setCurrentFile","curFile","selectInWorkingSet","setContext","_doNotRename","_saveContext","previousContext","currentContext","restoreContext","getContext","startRename","isMoved","rename","type","projectRelativePath","newPath","setRenameValue","cancelRename","renameInfo","_cancelCreating","_renameItem","oldPath","newName","oldName","viewModel","createAtPath","finalizeRename","deleteAtPath","errorType","errorInfo","renameItem","startCreating","basedir","createPlaceholder","setSortDirectoriesFirst","sortDirectoriesFirst","getOpenNodes","reopenNodes","nodesByDepth","doSequentially","toOpenPaths","doInParallel","refresh","openNodes","selections","handleFSEvent","added","removed","changes","changed","map","find","processChanges","closeSubtree","toggleSubdirectories","openOrClose","childNodes","getChildDirectories","node"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2014 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/* unittests: ProjectModel */\n\n/*global fs, path, jsPromise*/\n\n/**\n * Provides the data source for a project and manages the view model for the FileTreeView.\n */\ndefine(function (require, exports, module) {\n\n\n    var InMemoryFile        = require(\"document/InMemoryFile\"),\n        EventDispatcher     = require(\"utils/EventDispatcher\"),\n        FileUtils           = require(\"file/FileUtils\"),\n        _                   = require(\"thirdparty/lodash\"),\n        FileSystem          = require(\"filesystem/FileSystem\"),\n        DocumentManager     = require(\"document/DocumentManager\"),\n        FileSystemError     = require(\"filesystem/FileSystemError\"),\n        FileTreeViewModel   = require(\"project/FileTreeViewModel\"),\n        Async               = require(\"utils/Async\"),\n        PerfUtils           = require(\"utils/PerfUtils\");\n\n    // Constants\n    var EVENT_CHANGE            = \"change\",\n        EVENT_SHOULD_SELECT     = \"select\",\n        EVENT_SHOULD_FOCUS      = \"focus\",\n        EVENT_FS_RENAME_STARTED = \"mvStart\",\n        EVENT_FS_RENAME_END     = \"mvEnd\",\n        ERROR_CREATION          = \"creationError\",\n        ERROR_INVALID_FILENAME  = \"invalidFilename\",\n        ERROR_NOT_IN_PROJECT    = \"notInProject\";\n\n    /**\n     * @private\n     * File and folder names which are not displayed or searched\n     * TODO: We should add the rest of the file names that TAR excludes:\n     *    http://www.gnu.org/software/tar/manual/html_section/exclude.html\n     * TODO: This should be user configurable\n     *    https://github.com/adobe/brackets/issues/6781\n     * @type {RegExp}\n     */\n    var _exclusionListRegEx = /\\.pyc$|^\\.git$|^\\.gitmodules$|^\\.svn$|^\\.DS_Store$|^Icon\\r|^Thumbs\\.db$|^\\.hg$|^CVS$|^\\.hgtags$|^\\.idea$|^\\.c9revisions$|^\\.SyncArchive$|^\\.SyncID$|^\\.SyncIgnore$|\\~$/;\n    var _cacheExcludeFileNameRegEx = /^node_modules$|^bower_components$|^.npm$|^.yarn$|^__pycache__$/;\n\n    /**\n     * Glob definition of files and folders that should be excluded directly\n     * inside node domain watching with chokidar\n     */\n    const defaultIgnoreGlobs = [\n        \"node_modules/**\",\n        \"**/node_modules/**\",\n        \"bower_components/**\",\n        \"**/bower_components/**\",\n        \".npm\",\n        \".yarn\",\n        \"__pycache__\",\n        \".pyc\",\n        \".git\",\n        \".gitmodules\",\n        \".svn\",\n        \".DS_Store\",\n        \"Thumbs.db\",\n        \".hg\",\n        \"CVS\",\n        \".hgtags\",\n        \".idea\",\n        \".c9revisions\",\n        \".SyncArchive\",\n        \".SyncID\",\n        \".SyncIgnore\"\n    ];\n\n    /**\n     * @private\n     * RegEx to validate a file path.\n     */\n    var _invalidChars = /([?\\*\\|\\<\\>\"]+|\\/{2,}|\\.{2,}|\\.$)/i;\n\n    /**\n     * @private\n     * RegEx to validate if a filename is not allowed even if the system allows it.\n     * This is done to prevent cross-platform issues.\n     */\n    var _illegalFilenamesRegEx = /((\\b(com[0-9]+|lpt[0-9]+|nul|con|prn|aux)\\b)|\\.+$|\\/+|\\\\+|\\:)/i;\n\n    /**\n     * Returns true if this matches valid filename specifications.\n     * See http://msdn.microsoft.com/en-us/library/windows/desktop/aa365247(v=vs.85).aspx\n     *\n     * TODO: This likely belongs in FileUtils.\n     *\n     * @param {string} filename to check\n     * @return {boolean} true if the filename is valid\n     */\n    function isValidFilename(filename) {\n        // Fix issue adobe#13099\n        // See https://github.com/adobe/brackets/issues/13099\n        return !(\n            filename.match(_invalidChars)|| filename.match(_illegalFilenamesRegEx)\n        );\n    }\n\n    /**\n     * Returns true if given path is valid.\n     *\n     * @param {string} path to check\n     * @return {boolean} true if the filename is valid\n     */\n    function isValidPath(path) {\n        // Fix issue adobe#13099\n        // See https://github.com/adobe/brackets/issues/13099\n        return !(path.match(_invalidChars));\n    }\n\n    /**\n     * @private\n     * @see #shouldShow\n     */\n    function _shouldShowName(name) {\n        return !_exclusionListRegEx.test(name);\n    }\n\n    FileSystem.setFileTreeFilter(_shouldShowName);\n\n    /**\n     * Returns false for files and directories that are not commonly useful to display.\n     *\n     * @param {!FileSystemEntry} entry File or directory to filter\n     * @return {boolean} true if the file should be displayed\n     */\n    function shouldShow(entry) {\n        return _shouldShowName(entry.name);\n    }\n\n    /**\n     * Returns false for files and directories that should not be indexed for search or code hints.\n     * If the entry is a directory, its children should be indexed too.\n     *\n     * @param {!FileSystemEntry} entry File or directory to filter\n     * @return {boolean} true if the file should be displayed\n     */\n    function shouldIndex(entry) {\n        return shouldShow(entry) && !_cacheExcludeFileNameRegEx.test(entry.name);\n    }\n\n    // Constants used by the ProjectModel\n\n    var FILE_RENAMING     = 0,\n        FILE_CREATING     = 1,\n        RENAME_CANCELLED  = 2;\n\n\n    /**\n     * @private\n     *\n     * Determines if a path string is pointing to a directory (does it have a trailing slash?)\n     *\n     * @param {string} path Path to test.\n     */\n    function _pathIsFile(path) {\n        return _.last(path) !== \"/\";\n    }\n\n    /**\n     * @private\n     *\n     * Gets the FileSystem object (either a File or Directory) based on the path provided.\n     *\n     * @param {string} path Path to retrieve\n     */\n    function _getFSObject(path) {\n        if (!path) {\n            return path;\n        } else if (_pathIsFile(path)) {\n            return FileSystem.getFileForPath(path);\n        }\n        return FileSystem.getDirectoryForPath(path);\n    }\n\n    /**\n     * @private\n     *\n     * Given what is possible a FileSystem object, return its path (if a string path is passed in,\n     * it will be returned as-is).\n     *\n     * @param {FileSystemEntry} fsobj Object from which the path should be extracted\n     */\n    function _getPathFromFSObject(fsobj) {\n        if (fsobj && fsobj.fullPath) {\n            return fsobj.fullPath;\n        }\n        return fsobj;\n    }\n\n    /**\n     * Creates a new file or folder at the given path. The returned promise is rejected if the filename\n     * is invalid, the new path already exists or some other filesystem error comes up.\n     *\n     * @param {string} path path to create\n     * @param {boolean} isFolder true if the new entry is a folder\n     * @return {$.Promise} resolved when the file or directory has been created.\n     */\n    function doCreate(path, isFolder) {\n        const d = new $.Deferred();\n        const filename = FileUtils.getBaseName(path);\n\n        // Check if filename\n        // or Check if fullpath with filename is valid - This check is used to circumvent directory jumps (Like ../..)\n        if (!isValidFilename(filename) || !isValidPath(path)){\n            return d.reject(ERROR_INVALID_FILENAME).promise();\n        }\n\n        FileSystem.resolve(path, function (err) {\n            if (!err) {\n                // Item already exists, fail with error\n                d.reject(FileSystemError.ALREADY_EXISTS);\n                return;\n            }\n            if (isFolder) {\n                const directory = FileSystem.getDirectoryForPath(path);\n\n                directory.create(function (err) {\n                    if (err) {\n                        d.reject(err);\n                    } else {\n                        d.resolve(directory);\n                    }\n                });\n            } else {\n                // Create an empty file\n                const file = FileSystem.getFileForPath(path);\n\n                FileUtils.writeText(file, \"\").then(function () {\n                    d.resolve(file);\n                }, d.reject);\n            }\n        });\n\n        return d.promise();\n    }\n\n    /**\n     * @constructor\n     *\n     * The ProjectModel provides methods for accessing information about the current open project.\n     * It also manages the view model to display a FileTreeView of the project.\n     *\n     * Events:\n     * - EVENT_CHANGE (`change`) - Fired when there's a change that should refresh the UI\n     * - EVENT_SHOULD_SELECT (`select`) - Fired when a selection has been made in the file tree and the file tree should be selected\n     * - EVENT_SHOULD_FOCUS (`focus`)\n     * - ERROR_CREATION (`creationError`) - Triggered when there's a problem creating a file\n     */\n    function ProjectModel(initial) {\n        initial = initial || {};\n        if (initial.projectRoot) {\n            this.projectRoot = initial.projectRoot;\n        }\n\n        if (initial.focused !== undefined) {\n            this._focused = initial.focused;\n        }\n        this._viewModel = new FileTreeViewModel.FileTreeViewModel();\n        this._viewModel.on(FileTreeViewModel.EVENT_CHANGE, function () {\n            this.trigger(EVENT_CHANGE);\n        }.bind(this));\n        this._selections = {};\n    }\n    EventDispatcher.makeEventDispatcher(ProjectModel.prototype);\n\n    /**\n     * @type {Directory}\n     *\n     * The root Directory object for the project.\n     */\n    ProjectModel.prototype.projectRoot = null;\n\n    /**\n     * @private\n     * @type {FileTreeViewModel}\n     *\n     * The view model for this project.\n     */\n    ProjectModel.prototype._viewModel = null;\n\n    /**\n     * @private\n     * @type {string}\n     *\n     * Encoded URL\n     * @see {@link ProjectModel#getBaseUrl}, {@link ProjectModel#setBaseUrl}\n     */\n    ProjectModel.prototype._projectBaseUrl = \"\";\n\n    /**\n     * @private\n     * @type {{selected: ?string, context: ?string, previousContext: ?string, rename: ?Object}}\n     *\n     * Keeps track of selected files, context, previous context and files\n     * that are being renamed or created.\n     */\n    ProjectModel.prototype._selections = null;\n\n    /**\n     * @private\n     * @type {boolean}\n     *\n     * Flag to store whether the file tree has focus.\n     */\n    ProjectModel.prototype._focused = true;\n\n    /**\n     * @private\n     * @type {string}\n     *\n     * Current file path being viewed.\n     */\n    ProjectModel.prototype._currentPath = null;\n\n    /**\n     * @private\n     * @type {?$.Promise.<Array<File>>}\n     *\n     * A promise that is resolved with an array of all project files. Used by\n     * ProjectManager.getAllFiles().\n     */\n    ProjectModel.prototype._allFilesCachePromise = null;\n    ProjectModel.prototype._allFilesScopeCachePromise = null;\n    ProjectModel.prototype._allFilesScope = null;\n\n    /**\n     * Sets whether the file tree is focused or not.\n     *\n     * @param {boolean} focused True if the file tree has the focus.\n     */\n    ProjectModel.prototype.setFocused = function (focused) {\n        this._focused = focused;\n        if (!focused) {\n            this.setSelected(null);\n        }\n    };\n\n    /**\n     * Sets the width of the selection bar.\n     *\n     * @param {int} width New width\n     */\n    ProjectModel.prototype.setSelectionWidth = function (width) {\n        this._viewModel.setSelectionWidth(width);\n    };\n\n    /**\n     * Tracks the scroller position.\n     *\n     * @param {int} scrollWidth Width of the tree container\n     * @param {int} scrollTop Top of scroll position\n     * @param {int} scrollLeft Left of scroll position\n     * @param {int} offsetTop Top of scroller element\n     */\n    ProjectModel.prototype.setScrollerInfo = function (scrollWidth, scrollTop, scrollLeft, offsetTop) {\n        this._viewModel.setSelectionScrollerInfo(scrollWidth, scrollTop, scrollLeft, offsetTop);\n    };\n\n    /**\n     * Returns the encoded Base URL of the currently loaded project, or empty string if no project\n     * is open (during startup, or running outside of app shell).\n     * @return {String}\n     */\n    ProjectModel.prototype.getBaseUrl = function getBaseUrl() {\n        return this._projectBaseUrl;\n    };\n\n    /**\n     * Sets the encoded Base URL of the currently loaded project.\n     * @param {String}\n     */\n    ProjectModel.prototype.setBaseUrl = function setBaseUrl(projectBaseUrl) {\n        // Ensure trailing slash to be consistent with projectRoot.fullPath\n        // so they're interchangable (i.e. easy to convert back and forth)\n        if (projectBaseUrl.length > 0 && projectBaseUrl[projectBaseUrl.length - 1] !== \"/\") {\n            projectBaseUrl += \"/\";\n        }\n\n        this._projectBaseUrl = projectBaseUrl;\n        return projectBaseUrl;\n    };\n\n    /**\n     * Returns true if absPath lies within the project, false otherwise.\n     * Does not support paths containing \"..\"\n     *\n     * @param {string|FileSystemEntry} absPathOrEntry\n     * @return {boolean}\n     */\n    ProjectModel.prototype.isWithinProject = function isWithinProject(absPathOrEntry) {\n        var absPath = absPathOrEntry.fullPath || absPathOrEntry;\n        return (this.projectRoot && absPath.indexOf(this.projectRoot.fullPath) === 0);\n    };\n\n    /**\n     * If absPath lies within the project, returns a project-relative path. Else returns absPath\n     * unmodified.\n     * Does not support paths containing \"..\"\n     *\n     * @param {!string} absPath\n     * @return {!string}\n     */\n    ProjectModel.prototype.makeProjectRelativeIfPossible = function makeProjectRelativeIfPossible(absPath) {\n        if (absPath && this.isWithinProject(absPath)) {\n            return absPath.slice(this.projectRoot.fullPath.length);\n        }\n        return absPath;\n    };\n\n    /**\n     * Returns a valid directory within the project, either the path (or Directory object)\n     * provided or the project root.\n     *\n     * @param {string|Directory} path Directory path to verify against the project\n     * @return {string} A directory path within the project.\n     */\n    ProjectModel.prototype.getDirectoryInProject = function (path) {\n        if (path && typeof path === \"string\") {\n            if (_.last(path) !== \"/\") {\n                path += \"/\";\n            }\n        } else if (path && path.isDirectory) {\n            path = path.fullPath;\n        } else {\n            path = null;\n        }\n\n        if (!path || (typeof path !== \"string\") || !this.isWithinProject(path)) {\n            path = this.projectRoot.fullPath;\n        }\n        return path;\n    };\n\n    function _getGitIgnoreFileContent(fullPath) {\n        return new Promise(resolve=>{\n            DocumentManager.getDocumentForPath(fullPath)\n                .done(function (doc) {\n                    resolve(doc.getText()||\"\");\n                })\n                .fail(function () {\n                    resolve(null);\n                });\n        });\n    }\n\n    function _gitIgnores(entry, gitIgnoreFilters) {\n        try{\n            for(let filter of gitIgnoreFilters) {\n                const relativePath = path.relative(filter.basePath, entry.fullPath);\n                if(relativePath && !relativePath.startsWith(\"..\") &&\n                    filter.gitIgnore.ignores(relativePath)){\n                    return true;\n                }\n            }\n        } catch (e) {\n            console.error(\"Error while filtering get all files: \", e);\n        }\n        return false;\n    }\n\n    async function _updateGitIgnoreFromPath(gitIgnorePath, parentFullPath, gitIgnoreSearchedInDir, gitIgnoreFilters) {\n        const gitIgnoreContent = await _getGitIgnoreFileContent(gitIgnorePath);\n        gitIgnoreSearchedInDir[parentFullPath] = true;\n        if(gitIgnoreContent){\n            gitIgnoreFilters.push({\n                basePath: parentFullPath,\n                gitIgnore: fs.utils.ignore().add(gitIgnoreContent),\n                gitIgnoreContent\n            });\n        }\n    }\n\n    async function _updateGitIgnore(entry, siblingEntries, gitIgnoreSearchedInDir, gitIgnoreFilters) {\n        const parentFullPath = `${path.dirname(entry.fullPath)}/`; // Eg. /path/to/dir/\n        if(!gitIgnoreSearchedInDir[parentFullPath] && siblingEntries) {\n            // we have to check for gitIgnoreFile in this level is present or not.\n            for(let sibling of siblingEntries) {\n                if(sibling.isFile && sibling.name === \".gitignore\") {\n                    await _updateGitIgnoreFromPath(sibling.fullPath, parentFullPath,\n                        gitIgnoreSearchedInDir, gitIgnoreFilters);\n                }\n            }\n        }\n    }\n\n    /**\n     * Scans the whole project folder and computes the project wide git ignore\n     * filters to use. If there are nested .gitignore folders in project, that will also be detected.\n     * @return {Promise<{basePath: string, gitIgnore: object, gitIgnoreContent:string}>} returns an array with\n     *          basePath - the parent directory housing the git ignore file Eg: `/tauri/projectRoot/parent/`\n     *          gitIgnore - the git ignore filter fn that can be used to test if a path is ignored by calling\n     *             gitIgnore.ignores(relativePathToBasePath)\n     *          gitIgnoreContent - the textual content of the git ignore file.\n     */\n    ProjectModel.prototype.computeProjectGitIgnoreAsync = async function () {\n        let self = this;\n        return new Promise(resolve=>{\n            let gitIgnoreFilters = [];\n            jsPromise(self._getAllFilesCache(false, gitIgnoreFilters))\n                .catch(console.error)\n                .finally(()=>{\n                    resolve(gitIgnoreFilters);\n                });\n        });\n    };\n\n    /**\n     * @private\n     *\n     * Returns a promise that resolves with a cached copy of all project files.\n     * Used by ProjectManager.getAllFiles(). Ensures that at most one un-cached\n     * directory traversal is active at a time, which is useful at project load\n     * time when watchers (and hence filesystem-level caching) has not finished\n     * starting up. The cache is cleared on every filesystem change event, and\n     * also on project load and unload.\n     *\n     * @param {boolean} sort true to sort files by their paths\n     * @return {$.Promise.<Array.<File>>}\n     */\n    ProjectModel.prototype._getAllFilesCache = function _getAllFilesCache(sort, _gitIgnoreFiltersOut) {\n        let self = this;\n        if (!this._allFilesCachePromise) {\n            let gitIgnoreFilters = _gitIgnoreFiltersOut || [], gitIgnoreSearchedInDir = {};\n\n            let deferred = new $.Deferred(),\n                allFiles = [],\n                allFilesVisitor = async function (entry, siblingEntries) {\n                    if(entry.isDirectory && self.projectRoot.fullPath === entry.fullPath) {\n                        await _updateGitIgnoreFromPath(`${entry.fullPath}.gitignore`, entry.fullPath,\n                            gitIgnoreSearchedInDir, gitIgnoreFilters);\n                    }\n                    await _updateGitIgnore(entry, siblingEntries, gitIgnoreSearchedInDir, gitIgnoreFilters);\n                    if (shouldIndex(entry) && !_gitIgnores(entry, gitIgnoreFilters)) {\n                        if (entry.isFile) {\n                            allFiles.push(entry);\n                        }\n                        return true;\n                    }\n                    return false;\n                };\n\n            this._allFilesCachePromise = deferred.promise();\n\n            var projectIndexTimer = PerfUtils.markStart(\"Creating project files cache: \" +\n                                                        this.projectRoot.fullPath),\n                options = {\n                    sortList: sort\n                };\n\n            this.projectRoot.visit(allFilesVisitor, options, function (err) {\n                if (err) {\n                    PerfUtils.finalizeMeasurement(projectIndexTimer);\n                    deferred.reject(err);\n                } else {\n                    PerfUtils.addMeasurement(projectIndexTimer);\n                    deferred.resolve(allFiles);\n                }\n            }.bind(this));\n        }\n\n        return this._allFilesCachePromise;\n    };\n\n    ProjectModel.prototype._getAllFilesInScopeCache = function (sort, scope) {\n        let self = this;\n        if(!this.isWithinProject(scope)){\n            return (new $.Deferred()).reject(\n                new Error(`Scope ${scope.fullPath} should be within project root ${self.projectRoot}`)\n            ).promise();\n        }\n        if (!this._allFilesScopeCachePromise || this._allFilesScope !== scope) {\n            this._allFilesScope = scope;\n            let gitIgnoreFilters = [], gitIgnoreSearchedInDir = {};\n            const deferred = new $.Deferred(),\n                allFiles = [],\n                allFilesVisitor = async function (entry, siblingEntries) {\n                    if(entry.isDirectory && self.projectRoot.fullPath === entry.fullPath) {\n                        await _updateGitIgnoreFromPath(`${entry.fullPath}.gitignore`, entry.fullPath,\n                            gitIgnoreSearchedInDir, gitIgnoreFilters);\n                    }\n                    await _updateGitIgnore(entry, siblingEntries, gitIgnoreSearchedInDir, gitIgnoreFilters);\n                    if ((shouldIndex(entry) && !_gitIgnores(entry, gitIgnoreFilters)) ||\n                        entry.fullPath === scope.fullPath) {\n                        if (entry.isFile) {\n                            allFiles.push(entry);\n                        }\n                        return true;\n                    }\n                    return false;\n                };\n\n            this._allFilesScopeCachePromise = deferred.promise();\n\n            const scopeTimer = PerfUtils.markStart(\"Project scope files cache: \" +\n                    scope.fullPath),\n                options = {\n                    sortList: sort\n                };\n\n            scope.visit(allFilesVisitor, options, function (err) {\n                if (err) {\n                    PerfUtils.finalizeMeasurement(scopeTimer);\n                    deferred.reject(err);\n                } else {\n                    PerfUtils.addMeasurement(scopeTimer);\n                    deferred.resolve(allFiles);\n                }\n            }.bind(this));\n        }\n\n        return this._allFilesScopeCachePromise;\n    };\n\n    /**\n     * Returns an Array of all files for this project, optionally including\n     * files additional files provided. Files are filtered out by shouldShow().\n     *\n     * @param {function (File, number):boolean=} filter Optional function to filter\n     *          the file list (does not filter directory traversal). API matches Array.filter().\n     * @param {Array.<File>=} additionalFiles Additional files to include (for example, the WorkingSet)\n     *          Only adds files that are *not* under the project root or untitled documents.\n     * @param {boolean} sort true to sort files by their paths\n     * @param {Object} options optional path within project to narrow down the search\n     * @param {File} options.scope optional path within project to narrow down the search\n     *\n     * @return {$.Promise} Promise that is resolved with an Array of File objects.\n     */\n    ProjectModel.prototype.getAllFiles = function getAllFiles(filter, additionalFiles, sort, options) {\n        // The filter and includeWorkingSet params are both optional.\n        // Handle the case where filter is omitted but includeWorkingSet is\n        // specified.\n        if (typeof (filter) !== \"function\") {\n            options = sort;\n            sort = additionalFiles;\n            additionalFiles = filter;\n            filter = null;\n        }\n        options = options || {};\n\n        var filteredFilesDeferred = new $.Deferred();\n\n        // First gather all files in project proper\n        // Note that with proper promises we may be able to fix this so that we're not doing this\n        // anti-pattern of creating a separate deferred rather than just chaining off of the promise\n        // from _getAllFilesCache\n        const getAllFilesFn = options.scope ?\n            this._getAllFilesInScopeCache.bind(this) : this._getAllFilesCache.bind(this);\n        getAllFilesFn(sort, options.scope).done(function (result) {\n            result = [...result]; // clone it as the above result is cached and we dont want to modify the cache\n            // Add working set entries, if requested\n            if (additionalFiles) {\n                additionalFiles.forEach(function (file) {\n                    if (result.indexOf(file) === -1 && !(file instanceof InMemoryFile)) {\n                        result.push(file);\n                    }\n                });\n            }\n\n            // Filter list, if requested\n            if (filter) {\n                result = result.filter(filter);\n            }\n\n            // If a done handler attached to the returned filtered files promise\n            // throws an exception that isn't handled here then it will leave\n            // _allFilesCachePromise in an inconsistent state such that no\n            // additional done handlers will ever be called!\n            try {\n                filteredFilesDeferred.resolve(result);\n            } catch (e) {\n                console.error(\"Unhandled exception in getAllFiles handler: \" + e, e.stack);\n            }\n        }).fail(function (err) {\n            try {\n                filteredFilesDeferred.reject(err);\n            } catch (e) {\n                console.error(\"Unhandled exception in getAllFiles handler: \" + e, e.stack);\n            }\n        });\n\n        return filteredFilesDeferred.promise();\n    };\n\n    /**\n     * @private\n     *\n     * Resets the all files cache.\n     */\n    ProjectModel.prototype._resetCache = function _resetCache() {\n        this._allFilesCachePromise = null;\n        this._allFilesScopeCachePromise = null;\n        this._allFilesScope = null;\n    };\n\n    /**\n     * Sets the project root (effectively resetting this ProjectModel).\n     *\n     * @param {Directory} projectRoot new project root\n     * @return {$.Promise} resolved when the project root has been updated\n     */\n    ProjectModel.prototype.setProjectRoot = function (projectRoot) {\n        this.projectRoot = projectRoot;\n        this._resetCache();\n        this._viewModel._rootChanged();\n\n        var d = new $.Deferred(),\n            self = this;\n\n        projectRoot.getContents(function (err, contents) {\n            if (err) {\n                d.reject(err);\n            } else {\n                self._viewModel.setDirectoryContents(\"\", contents);\n                d.resolve();\n            }\n        });\n        return d.promise();\n    };\n\n    /**\n     * @private\n     *\n     * Gets the contents of a directory at the given path.\n     *\n     * @param {string} path path to retrieve\n     * @return {$.Promise} Resolved with the directory contents.\n     */\n    ProjectModel.prototype._getDirectoryContents = function (path) {\n        var d = new $.Deferred();\n        FileSystem.getDirectoryForPath(path).getContents(function (err, contents) {\n            if (err) {\n                d.reject(err);\n            } else {\n                d.resolve(contents);\n            }\n        });\n        return d.promise();\n    };\n\n    /**\n     * Opens or closes the given directory in the file tree.\n     *\n     * @param {string} path Path to open\n     * @param {boolean} open `true` to open the path\n     * @return {$.Promise} resolved when the path has been opened.\n     */\n    ProjectModel.prototype.setDirectoryOpen = function (path, open) {\n        var projectRelative = this.makeProjectRelativeIfPossible(path),\n            needsLoading    = !this._viewModel.isPathLoaded(projectRelative),\n            d               = new $.Deferred(),\n            self            = this;\n\n        function onSuccess(contents) {\n            // Update the view model\n            if (contents) {\n                self._viewModel.setDirectoryContents(projectRelative, contents);\n            }\n\n            if (open) {\n                self._viewModel.openPath(projectRelative);\n                if (self._focused) {\n                    var currentPathInProject = self.makeProjectRelativeIfPossible(self._currentPath);\n                    if (self._viewModel.isFilePathVisible(currentPathInProject)) {\n                        self.setSelected(self._currentPath, true);\n                    } else {\n                        self.setSelected(null);\n                    }\n                }\n            } else {\n                self._viewModel.setDirectoryOpen(projectRelative, false);\n                var selected = self._selections.selected;\n                if (selected) {\n                    var relativeSelected = self.makeProjectRelativeIfPossible(selected);\n                    if (!self._viewModel.isFilePathVisible(relativeSelected)) {\n                        self.setSelected(null);\n                    }\n                }\n            }\n\n            d.resolve();\n        }\n\n        // If the view model doesn't have the data it needs, we load it now, otherwise we can just\n        // manage the selection and resovle the promise.\n        if (open && needsLoading) {\n            var parentDirectory = FileUtils.getDirectoryPath(FileUtils.stripTrailingSlash(path));\n            this.setDirectoryOpen(parentDirectory, true).then(function () {\n                self._getDirectoryContents(path).then(onSuccess).fail(function (err) {\n                    d.reject(err);\n                });\n            }, function (err) {\n                d.reject(err);\n            });\n        } else {\n            onSuccess();\n        }\n\n        return d.promise();\n    };\n\n    /**\n     * Shows the given path in the tree and selects it if it's a file. Any intermediate directories\n     * will be opened and a promise is returned to show when the entire operation is complete.\n     *\n     * @param {string|File|Directory} path full path to the file or directory\n     * @return {$.Promise} promise resolved when the path is shown\n     */\n    ProjectModel.prototype.showInTree = function (path) {\n        var d = new $.Deferred();\n        path = _getPathFromFSObject(path);\n\n        if (!this.isWithinProject(path)) {\n            Phoenix.app.openPathInFileBrowser(path)\n                .then(d.resolve)\n                .catch(d.reject);\n            return d.promise();\n        }\n\n        const self = this;\n        this.setDirectoryOpen(FileUtils.getDirectoryPath(path), true).then(function () {\n            if (_pathIsFile(path)) {\n                self.setSelected(path);\n            }\n            d.resolve();\n        }, function (err) {\n            d.reject(err);\n        });\n        return d.promise();\n    };\n\n    /**\n     * Selects the given path in the file tree and opens the file (unless doNotOpen is specified).\n     * Directories will not be selected.\n     *\n     * When the selection changes, any rename operation that is currently underway will be completed.\n     *\n     * @param {string} path full path to the file being selected\n     * @param {boolean} doNotOpen `true` if the file should not be opened.\n     */\n    ProjectModel.prototype.setSelected = function (path, doNotOpen) {\n        path = _getPathFromFSObject(path);\n\n        // Directories are not selectable\n        if (!_pathIsFile(path)) {\n            return;\n        }\n\n        var oldProjectPath = this.makeProjectRelativeIfPossible(this._selections.selected),\n            pathInProject = this.makeProjectRelativeIfPossible(path);\n\n        if (path && !this._viewModel.isFilePathVisible(pathInProject)) {\n            path = null;\n            pathInProject = null;\n        }\n\n        this.performRename();\n\n        this._viewModel.moveMarker(\"selected\", oldProjectPath, pathInProject);\n        if (this._selections.context) {\n            this._viewModel.moveMarker(\"context\", this.makeProjectRelativeIfPossible(this._selections.context), null);\n            delete this._selections.context;\n        }\n\n        var previousSelection = this._selections.selected;\n        this._selections.selected = path;\n\n        if (path) {\n            if (!doNotOpen) {\n                this.trigger(EVENT_SHOULD_SELECT, {\n                    path: path,\n                    previousPath: previousSelection,\n                    hadFocus: this._focused\n                });\n            }\n\n            this.trigger(EVENT_SHOULD_FOCUS);\n        }\n    };\n\n    /**\n     * Gets the currently selected file or directory.\n     *\n     * @return {FileSystemEntry} the filesystem object for the currently selected file\n     */\n    ProjectModel.prototype.getSelected = function () {\n        return _getFSObject(this._selections.selected);\n    };\n\n    /**\n     * Keeps track of which file is currently being edited.\n     *\n     * @param {File|string} curFile Currently edited file.\n     */\n    ProjectModel.prototype.setCurrentFile = function (curFile) {\n        this._currentPath = _getPathFromFSObject(curFile);\n    };\n\n    /**\n     * Adds the file at the given path to the Working Set and selects it there.\n     *\n     * @param {string} path full path of file to open in Working Set\n     */\n    ProjectModel.prototype.selectInWorkingSet = function (path) {\n        this.performRename();\n        this.trigger(EVENT_SHOULD_SELECT, {\n            path: path,\n            add: true\n        });\n    };\n\n    /**\n     * Sets the context (for context menu operations) to the given path. This is independent from the\n     * open/selected file.\n     *\n     * @param {string} path full path of file or directory to which the context should be setBaseUrl\n     * @param {boolean} _doNotRename True if this context change should not cause a rename operation to finish. This is a special case that goes with context menu handling.\n     * @param {boolean} _saveContext True if the current context should be saved (see comment below)\n     */\n    ProjectModel.prototype.setContext = function (path, _doNotRename, _saveContext) {\n        // This bit is not ideal: when the user right-clicks on an item in the file tree\n        // and there is already a context menu up, the FileTreeView sends a signal to set the\n        // context to the new element but the PopupManager follows that with a message that it's\n        // closing the context menu (because it closes the previous one and then opens the new\n        // one.) This timing means that we need to provide some special case handling here.\n        if (_saveContext) {\n            if (!path) {\n                this._selections.previousContext = this._selections.context;\n            } else {\n                this._selections.previousContext = path;\n            }\n        } else {\n            delete this._selections.previousContext;\n        }\n\n        path = _getPathFromFSObject(path);\n\n        if (!_doNotRename) {\n            this.performRename();\n        }\n        var currentContext = this._selections.context;\n        this._selections.context = path;\n        this._viewModel.moveMarker(\"context\", this.makeProjectRelativeIfPossible(currentContext),\n                                   this.makeProjectRelativeIfPossible(path));\n    };\n\n    /**\n     * Restores the context to the last non-null context. This is specifically here to handle\n     * the sequence of messages that we get from the project context menu.\n     */\n    ProjectModel.prototype.restoreContext = function () {\n        if (this._selections.previousContext) {\n            this.setContext(this._selections.previousContext);\n        }\n    };\n\n    /**\n     * Gets the currently selected context.\n     *\n     * @return {FileSystemEntry} filesystem object for the context file or directory\n     */\n    ProjectModel.prototype.getContext = function () {\n        return _getFSObject(this._selections.context);\n    };\n\n    /**\n     * Starts a rename operation for the file or directory at the given path. If the path is\n     * not provided, the current context is used.\n     *\n     * If a rename operation is underway, it will be completed automatically.\n     *\n     * The Promise returned is resolved with an object with a `newPath` property with the renamed path. If the user cancels the operation, the promise is resolved with the value RENAME_CANCELLED.\n     *\n     * @param {string=} path optional path to start renaming\n     * @param {boolean=} isMoved optional flag which indicates whether the entry is being moved instead of renamed\n     * @return {$.Promise} resolved when the operation is complete.\n     */\n    ProjectModel.prototype.startRename = function (path, isMoved) {\n        var d = new $.Deferred();\n        path = _getPathFromFSObject(path);\n        if (!path) {\n            path = this._selections.context;\n            if (!path) {\n                return d.resolve().promise();\n            }\n        }\n\n        if (this._selections.rename && this._selections.rename.path === path) {\n            return d.resolve().promise();\n        }\n\n        if (!this.isWithinProject(path)) {\n            return d.reject({\n                type: ERROR_NOT_IN_PROJECT,\n                isFolder: !_pathIsFile(path),\n                fullPath: path\n            }).promise();\n        }\n\n        var projectRelativePath = this.makeProjectRelativeIfPossible(path);\n\n        if (!this._viewModel.isFilePathVisible(projectRelativePath)) {\n            this.showInTree(path);\n        }\n\n        if (!isMoved) {\n            if (path !== this._selections.context) {\n                this.setContext(path);\n            } else {\n                this.performRename();\n            }\n\n            this._viewModel.moveMarker(\"rename\", null,\n                projectRelativePath);\n        }\n        this._selections.rename = {\n            deferred: d,\n            type: FILE_RENAMING,\n            path: path,\n            newPath: path\n        };\n        return d.promise();\n    };\n\n    /**\n     * Sets the new value for the rename operation that is in progress (started previously with a call\n     * to `startRename`).\n     *\n     * @param {string} newPath new path for the file or directory being renamed\n     */\n    ProjectModel.prototype.setRenameValue = function (newPath) {\n        if (!this._selections.rename) {\n            return;\n        }\n        this._selections.rename.newPath = newPath;\n    };\n\n    /**\n     * Cancels the rename operation that is in progress. This resolves the original promise with\n     * a RENAME_CANCELLED value.\n     */\n    ProjectModel.prototype.cancelRename = function () {\n        var renameInfo = this._selections.rename;\n        if (!renameInfo) {\n            return;\n        }\n\n        // File creation is a special case.\n        if (renameInfo.type === FILE_CREATING) {\n            this._cancelCreating();\n            return;\n        }\n\n        this._viewModel.moveMarker(\"rename\", this.makeProjectRelativeIfPossible(renameInfo.path), null);\n        renameInfo.deferred.resolve(RENAME_CANCELLED);\n        delete this._selections.rename;\n        this.setContext(null);\n    };\n\n    /**\n     * @private\n     *\n     * Renames the item at the old path to the new name provided.\n     *\n     * @param {string} oldPath full path to the current location of file or directory (should include trailing slash for directory)\n     * @param {string} newPath full path to the new location of the file or directory\n     * @param {string} newName new name for the file or directory\n     */\n    ProjectModel.prototype._renameItem = function (oldPath, newPath, newName) {\n        const result = new $.Deferred();\n        const isFolder = !_pathIsFile(oldPath);\n        const self = this;\n\n        if (oldPath === newPath) {\n            result.resolve();\n        } else if (!isValidFilename(newName)) {\n            result.reject(ERROR_INVALID_FILENAME);\n        } else {\n            var entry = isFolder ? FileSystem.getDirectoryForPath(oldPath) : FileSystem.getFileForPath(oldPath);\n            self.trigger(EVENT_FS_RENAME_STARTED);\n            entry.rename(newPath, function (err) {\n                self.trigger(EVENT_FS_RENAME_END);\n                if (err) {\n                    result.reject(err);\n                } else {\n                    result.resolve();\n                }\n            });\n        }\n\n        return result.promise();\n    };\n\n    /**\n     * Completes the rename operation that is in progress.\n     */\n    ProjectModel.prototype.performRename = function () {\n        var renameInfo = this._selections.rename;\n        if (!renameInfo) {\n            return;\n        }\n        var oldPath         = renameInfo.path,\n            isFolder        = renameInfo.isFolder || !_pathIsFile(oldPath),\n            oldProjectPath  = this.makeProjectRelativeIfPossible(oldPath),\n\n            // To get the parent directory, we need to strip off the trailing slash on a directory name\n            parentDirectory = FileUtils.getDirectoryPath(isFolder ? FileUtils.stripTrailingSlash(oldPath) : oldPath),\n            oldName         = FileUtils.getBaseName(oldPath),\n            newPath         = renameInfo.newPath,\n            newName         = FileUtils.getBaseName(newPath),\n            viewModel       = this._viewModel,\n            self            = this;\n\n        if (renameInfo.type !== FILE_CREATING && oldPath === newPath) {\n            this.cancelRename();\n            return;\n        }\n\n        if (isFolder && _.last(newPath) !== \"/\") {\n            newPath += \"/\";\n        }\n\n        delete this._selections.rename;\n        delete this._selections.context;\n\n        viewModel.moveMarker(\"rename\", oldProjectPath, null);\n        viewModel.moveMarker(\"context\", oldProjectPath, null);\n        viewModel.moveMarker(\"creating\", oldProjectPath, null);\n\n        function finalizeRename() {\n            viewModel.renameItem(oldProjectPath, self.makeProjectRelativeIfPossible(newPath));\n            if (self._selections.selected && self._selections.selected.indexOf(oldPath) === 0) {\n                self._selections.selected = newPath + self._selections.selected.slice(oldPath.length);\n                self.setCurrentFile(newPath);\n            }\n        }\n\n        if (renameInfo.type === FILE_CREATING) {\n            this.createAtPath(newPath).done(function (entry) {\n                finalizeRename();\n                renameInfo.deferred.resolve(entry);\n            }).fail(function (error) {\n                self._viewModel.deleteAtPath(self.makeProjectRelativeIfPossible(renameInfo.path));\n                renameInfo.deferred.reject(error);\n            });\n        } else {\n            this._renameItem(oldPath, newPath, newName).then(function () {\n                finalizeRename();\n                renameInfo.deferred.resolve({\n                    newPath: newPath\n                });\n            }).fail(function (errorType) {\n                var errorInfo = {\n                    type: errorType,\n                    isFolder: isFolder,\n                    fullPath: oldPath\n                };\n                renameInfo.deferred.reject(errorInfo);\n            });\n        }\n    };\n\n    /**\n     * Creates a file or folder at the given path. Folder paths should have a trailing slash.\n     *\n     * If an error comes up during creation, the ERROR_CREATION event is triggered.\n     *\n     * @param {string} path full path to file or folder to create\n     * @return {$.Promise} resolved when creation is complete\n     */\n    ProjectModel.prototype.createAtPath = function (path) {\n        var isFolder  = !_pathIsFile(path),\n            name      = FileUtils.getBaseName(path),\n            self      = this;\n\n        return doCreate(path, isFolder).done(function (entry) {\n            if (!isFolder) {\n                self.selectInWorkingSet(entry.fullPath);\n            }\n        }).fail(function (error) {\n            self.trigger(ERROR_CREATION, {\n                type: error,\n                name: name,\n                isFolder: isFolder\n            });\n        });\n    };\n\n    /**\n     * Starts creating a file or folder with the given name in the given directory.\n     *\n     * The Promise returned is resolved with an object with a `newPath` property with the renamed path. If the user cancels the operation, the promise is resolved with the value RENAME_CANCELLED.\n     *\n     * @param {string} basedir directory that should contain the new entry\n     * @param {string} newName initial name for the new entry (the user can rename it)\n     * @param {boolean} isFolder `true` if the entry being created is a folder\n     * @return {$.Promise} resolved when the user is done creating the entry.\n     */\n    ProjectModel.prototype.startCreating = function (basedir, newName, isFolder) {\n        this.performRename();\n        var d = new $.Deferred(),\n            self = this;\n\n        this.setDirectoryOpen(basedir, true).then(function () {\n            self._viewModel.createPlaceholder(self.makeProjectRelativeIfPossible(basedir), newName, isFolder);\n            var promise = self.startRename(basedir + newName);\n            self._selections.rename.type = FILE_CREATING;\n            if (isFolder) {\n                self._selections.rename.isFolder = isFolder;\n            }\n            promise.then(d.resolve).fail(d.reject);\n        }).fail(function (err) {\n            d.reject(err);\n        });\n        return d.promise();\n    };\n\n    /**\n     * Cancels the creation process that is underway. The original promise returned will be resolved with the\n     * RENAME_CANCELLED value. The temporary entry added to the file tree will be deleted.\n     */\n    ProjectModel.prototype._cancelCreating = function () {\n        var renameInfo = this._selections.rename;\n        if (!renameInfo || renameInfo.type !== FILE_CREATING) {\n            return;\n        }\n        this._viewModel.deleteAtPath(this.makeProjectRelativeIfPossible(renameInfo.path));\n        renameInfo.deferred.resolve(RENAME_CANCELLED);\n        delete this._selections.rename;\n        this.setContext(null);\n    };\n\n    /**\n     * Sets the `sortDirectoriesFirst` option for the file tree view.\n     *\n     * @param {boolean} True if directories should appear first\n     */\n    ProjectModel.prototype.setSortDirectoriesFirst = function (sortDirectoriesFirst) {\n        this._viewModel.setSortDirectoriesFirst(sortDirectoriesFirst);\n    };\n\n    /**\n     * Gets an array of arrays where each entry of the top-level array has an array\n     * of paths that are at the same depth in the tree. All of the paths are full paths.\n     *\n     * @return {Array.<Array.<string>>} Array of array of full paths, organized by depth in the tree.\n     */\n    ProjectModel.prototype.getOpenNodes = function () {\n        return this._viewModel.getOpenNodes(this.projectRoot.fullPath);\n    };\n\n    /**\n     * Reopens a set of nodes in the tree by full path.\n     * @param {Array.<Array.<string>>} nodesByDepth An array of arrays of node ids to reopen. The ids within\n     *     each sub-array are reopened in parallel, and the sub-arrays are reopened in order, so they should\n     *     be sorted by depth within the tree.\n     * @return {$.Deferred} A promise that will be resolved when all nodes have been fully\n     *     reopened.\n     */\n    ProjectModel.prototype.reopenNodes = function (nodesByDepth) {\n        var deferred = new $.Deferred();\n\n        if (!nodesByDepth || nodesByDepth.length === 0) {\n            // All paths are opened and fully rendered.\n            return deferred.resolve().promise();\n        }\n        var self = this;\n        return Async.doSequentially(nodesByDepth, function (toOpenPaths) {\n            return Async.doInParallel(\n                    toOpenPaths,\n                    function (path) {\n                        return self._getDirectoryContents(path).then(function (contents) {\n                            var relative = self.makeProjectRelativeIfPossible(path);\n                            self._viewModel.setDirectoryContents(relative, contents);\n                            self._viewModel.setDirectoryOpen(relative, true);\n                        });\n                    },\n                    false\n                );\n        });\n\n    };\n\n    /**\n     * Clears caches and refreshes the contents of the tree.\n     *\n     * @return {$.Promise} resolved when the tree has been refreshed\n     */\n    ProjectModel.prototype.refresh = function () {\n        var projectRoot = this.projectRoot,\n            openNodes   = this.getOpenNodes(),\n            self        = this,\n            selections  = this._selections,\n            viewModel   = this._viewModel,\n            deferred    = new $.Deferred();\n\n        this.setProjectRoot(projectRoot).then(function () {\n            self.reopenNodes(openNodes).then(function () {\n                if (selections.selected) {\n                    viewModel.moveMarker(\"selected\", null, self.makeProjectRelativeIfPossible(selections.selected));\n                }\n\n                if (selections.context) {\n                    viewModel.moveMarker(\"context\", null, self.makeProjectRelativeIfPossible(selections.context));\n                }\n\n                if (selections.rename) {\n                    viewModel.moveMarker(\"rename\", null, self.makeProjectRelativeIfPossible(selections.rename));\n                }\n\n                deferred.resolve();\n            });\n        });\n\n        return deferred.promise();\n    };\n\n    /**\n     * Handles filesystem change events and prepares the update for the view model.\n     *\n     * @param {?(File|Directory)} entry File or Directory changed\n     * @param {Array.<FileSystemEntry>=} added If entry is a Directory, contains zero or more added children\n     * @param {Array.<FileSystemEntry>=} removed If entry is a Directory, contains zero or more removed\n     */\n    ProjectModel.prototype.handleFSEvent = function (entry, added, removed) {\n        this._resetCache();\n\n        if (!entry) {\n            this.refresh();\n            return;\n        }\n\n        if (!this.isWithinProject(entry)) {\n            return;\n        }\n\n        var changes = {},\n            self = this;\n\n        if (entry.isFile) {\n            changes.changed = [\n                this.makeProjectRelativeIfPossible(entry.fullPath)\n            ];\n        } else {\n            // Special case: a directory passed in without added and removed values\n            // needs to be updated.\n            if (!added && !removed) {\n                entry.getContents(function (err, contents) {\n                    if (err) {\n                        console.error(\"Unexpected error refreshing file tree for directory \" + entry.fullPath + \": \" + err, err.stack);\n                        return;\n                    }\n                    self._viewModel.setDirectoryContents(self.makeProjectRelativeIfPossible(entry.fullPath), contents);\n                });\n\n                // Exit early because we can't update the viewModel until we get the directory contents.\n                return;\n            }\n        }\n\n        if (added) {\n            changes.added = added\n                .filter(function(entry) {\n                    return _shouldShowName(entry.name);\n                }).map(function (entry) {\n                    return self.makeProjectRelativeIfPossible(entry.fullPath);\n                });\n        }\n\n        if (removed) {\n            if (this._selections.selected &&\n                    _.find(removed, { fullPath: this._selections.selected })) {\n                this.setSelected(null);\n            }\n\n            if (this._selections.rename &&\n                    _.find(removed, { fullPath: this._selections.rename.path })) {\n                this.cancelRename();\n            }\n\n            if (this._selections.context &&\n                    _.find(removed, { fullPath: this._selections.context })) {\n                this.setContext(null);\n            }\n            changes.removed = removed.map(function (entry) {\n                return self.makeProjectRelativeIfPossible(entry.fullPath);\n            });\n        }\n\n        this._viewModel.processChanges(changes);\n    };\n\n    /**\n     * Closes the directory at path and recursively closes all of its children.\n     *\n     * @param {string} path Path of subtree to close\n     */\n    ProjectModel.prototype.closeSubtree = function (path) {\n        this._viewModel.closeSubtree(this.makeProjectRelativeIfPossible(path));\n    };\n\n    /**\n     * Toggle the open state of subdirectories.\n     * @param {!string}  path        parent directory\n     * @param {boolean} openOrClose  true to open directory, false to close\n     * @return {$.Promise} promise resolved when the directories are open\n     */\n    ProjectModel.prototype.toggleSubdirectories = function (path, openOrClose) {\n        var self = this,\n            d = new $.Deferred();\n\n        this.setDirectoryOpen(path, true).then(function () {\n            var projectRelativePath = self.makeProjectRelativeIfPossible(path),\n                childNodes = self._viewModel.getChildDirectories(projectRelativePath);\n\n            Async.doInParallel(childNodes, function (node) {\n                return self.setDirectoryOpen(path + node, openOrClose);\n            }, true).then(function () {\n                d.resolve();\n            }, function (err) {\n                d.reject(err);\n            });\n        });\n\n        return d.promise();\n    };\n\n    /**\n     * Although Brackets is generally standardized on folder paths with a trailing \"/\", some APIs here\n     * receive project paths without \"/\" due to legacy preference storage formats, etc.\n     * @param {!string} fullPath  Path that may or may not end in \"/\"\n     * @return {!string} Path that ends in \"/\"\n     */\n    function _ensureTrailingSlash(fullPath) {\n        if (_pathIsFile(fullPath)) {\n            return fullPath + \"/\";\n        }\n        return fullPath;\n    }\n\n    /**\n     * @private\n     *\n     * Adds the path to the list of welcome projects we've ever seen, if not on the list already.\n     *\n     * @param {string} path Path to possibly add\n     * @param {Array.<string>=} currentProjects Array of current welcome projects\n     * @return {Array.<string>} New array of welcome projects with the additional project added\n     */\n    function _addWelcomeProjectPath(path, currentProjects) {\n        var pathNoSlash = FileUtils.stripTrailingSlash(path);  // \"welcomeProjects\" pref has standardized on no trailing \"/\"\n\n        var newProjects;\n\n        if (currentProjects) {\n            newProjects = _.clone(currentProjects);\n        } else {\n            newProjects = [];\n        }\n\n        if (newProjects.indexOf(pathNoSlash) === -1) {\n            newProjects.push(pathNoSlash);\n        }\n        return newProjects;\n    }\n\n    /**\n     * Returns true if the given path is the same as one of the welcome projects we've previously opened,\n     * or the one for the current build.\n     *\n     * @param {string} path Path to check to see if it's a welcome project\n     * @param {string} welcomeProjectPath Current welcome project path\n     * @param {Array.<string>=} welcomeProjects All known welcome projects\n     */\n    function _isWelcomeProjectPath(path, welcomeProjectPath, welcomeProjects) {\n        if (path === welcomeProjectPath) {\n            return true;\n        }\n\n        // No match on the current path, and it's not a match if there are no previously known projects\n        if (!welcomeProjects) {\n            return false;\n        }\n\n        var pathNoSlash = FileUtils.stripTrailingSlash(path);  // \"welcomeProjects\" pref has standardized on no trailing \"/\"\n        return welcomeProjects.indexOf(pathNoSlash) !== -1;\n    }\n\n    // private APIs\n    exports._addWelcomeProjectPath  = _addWelcomeProjectPath;\n    exports._isWelcomeProjectPath   = _isWelcomeProjectPath;\n    exports._ensureTrailingSlash    = _ensureTrailingSlash;\n    exports._shouldShowName         = _shouldShowName;\n    exports._invalidChars           = \"? * | : / < > \\\\ | \\\" ..\";\n\n    exports.shouldShow              = shouldShow;\n    exports.shouldIndex             = shouldIndex;\n    exports.defaultIgnoreGlobs      = defaultIgnoreGlobs;\n    exports.isValidFilename         = isValidFilename;\n    exports.isValidPath             = isValidPath;\n    exports.EVENT_CHANGE            = EVENT_CHANGE;\n    exports.EVENT_SHOULD_SELECT     = EVENT_SHOULD_SELECT;\n    exports.EVENT_SHOULD_FOCUS      = EVENT_SHOULD_FOCUS;\n    exports.EVENT_FS_RENAME_STARTED = EVENT_FS_RENAME_STARTED;\n    exports.EVENT_FS_RENAME_END     = EVENT_FS_RENAME_END;\n    exports.ERROR_CREATION          = ERROR_CREATION;\n    exports.ERROR_INVALID_FILENAME  = ERROR_INVALID_FILENAME;\n    exports.ERROR_NOT_IN_PROJECT    = ERROR_NOT_IN_PROJECT;\n    exports.FILE_RENAMING           = FILE_RENAMING;\n    exports.FILE_CREATING           = FILE_CREATING;\n    exports.RENAME_CANCELLED        = RENAME_CANCELLED;\n    exports.doCreate                = doCreate;\n    exports.ProjectModel            = ProjectModel;\n});\n"],"file":"ProjectModel.js"}