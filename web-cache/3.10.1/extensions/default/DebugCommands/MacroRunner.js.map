{"version":3,"sources":["extensions/default/DebugCommands/MacroRunner.js"],"names":["define","require","exports","module","FileViewController","brackets","getModule","CommandManager","EditorManager","KeyEvent","Commands","PreferencesManager","Editor","Dialogs","_","ProjectManager","openFile","filePath","startsWith","jsPromise","openFileAndAddToWorkingSet","projectFilePath","path","join","getProjectRoot","fullPath","setCursors","selections","activeEditor","getActiveEditor","Error","parsedSelections","map","selection","parts","split","length","line","ch","Number","isNaN","start","end","fromLine","fromCh","toLine","toCh","setSelections","computeCursors","editor","addQuotes","getSelections","cursor","expectCursorsToBe","expectedSelections","currentSelections","i","includes","raiseKeyEvent","key","event","element","options","doc","ownerDocument","view","defaultView","bubbles","cancelable","keyIdentifer","keyIdentifier","oEvent","KeyboardEvent","Object","defineProperty","get","this","keyCodeVal","keyCode","console","log","dispatchEvent","keydown","keysArray","modifiers","document","activeElement","typeAtCursor","text","origin","replaceRange","_toPos","posString","pos","validateText","from","to","selectedText","getTextBetween","_getMarkLocations","markType","whichAPI","marks","getAllMarks","marksLocations","mark","loc","find","push","validateAllMarks","validateEqual","obj1","obj2","isEqual","JSON","stringify","validateNotEqual","validateMarks","totalMarkCount","undefined","closeFile","execute","FILE_CLOSE","_forceClose","closeAll","FILE_CLOSE_ALL","execCommand","commandID","arg","undo","EDIT_UNDO","redo","EDIT_REDO","setPreference","value","set","getPreference","EDITING","setEditorSpacing","useTabs","spaceOrTabCount","isAutoMode","file","getAutoTabSpaces","setAutoTabSpaces","_autoDetectTabSpaces","setUseTabChar","setTabSize","setSpaceUnits","awaitsFor","pollFn","_timeoutMessageOrMessageFn","timeoutms","pollInterval","async","_getExpectMessage","Promise","e","stack","_timeoutPromise","promise","ms","timeout","reject","setTimeout","race","resolve","startTime","Date","now","lapsedTime","pollingFn","result","prototype","toString","call","waitForModalDialog","dialogClass","friendlyName","$dlg","$","waitForModalDialogClosed","_clickDialogButtonWithSelector","selectorOrButtonID","isButtonID","$button","prop","click","clickDialogButtonID","buttonID","clickDialogButton","buttonSelector","__PR","runMacro","macroText","errors","AsyncFunction","constructor","macroAsync","error","lineNo","errorCode","errorText","Phoenix","isTestWindow","window"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*global path, jsPromise*/\n\n/**\n *  Utilities functions for running macros.\n *  Eg:\n *  await __PR.openFile(\"a.html\");\n *   __PR.setCursors([\"17:28\", \"17:28-17:30\"])\n * __PR.expectCursorsToBe([\"17:28\", \"17:28-17:30\"])\n * __PR.keydown([\"BACK_SPACE\"])\n * __PR.typeAtCursor(\"hello\")\n * __PR.validateText(`a`, \"16:14-16:15\")\n * __PR.validateAllMarks(\"startTagSyncEdit\", [\"16:14-16:15\"]); // All marks of type startTagSyncEdit should be there\n * __PR.validateMarks(\"startTagSyncEdit\", [\"16:14-16:15\"], 1); // 1 is total marks of type startTagSyncEdit\n *\n *  This can be later extended to run macros. But since this uses eval, the\n *  security posture must be changed. One way is to:\n *  1. create an iframe that contains the macro panel and codemirror surface in a sandboxed or 3rd party context. This\n *     will create origin isolation in browser so that extensions cannot read or write to the ifrmae macro code.\n *  2. The iframe should be created in an extensions and once created, only that iframe should be tested to run evaled\n *     code. So the iframe will post message with code to eval and we will only eval that.\n *  3. The iframe can request to save data to eval which we need to carefully handle.\n *  4. Now this is a problem only when we securely sandbox extensions in the future, as for now an extension can run\n *     eval itself and pretty much all of this is no-op till we have extension sandbox. So this is not the security\n *     model now.\n */\ndefine(function (require, exports, module) {\n    const FileViewController = brackets.getModule(\"project/FileViewController\"),\n        CommandManager = brackets.getModule(\"command/CommandManager\"),\n        EditorManager = brackets.getModule(\"editor/EditorManager\"),\n        KeyEvent = brackets.getModule(\"utils/KeyEvent\"),\n        Commands = brackets.getModule(\"command/Commands\"),\n        PreferencesManager  = brackets.getModule(\"preferences/PreferencesManager\"),\n        Editor = brackets.getModule(\"editor/Editor\"),\n        Dialogs = brackets.getModule(\"widgets/Dialogs\"),\n        _ = brackets.getModule(\"thirdparty/lodash\"),\n        ProjectManager = brackets.getModule(\"project/ProjectManager\");\n\n    /**\n     * Open a project relative file or absolute file path. if no leading slash, path is assumed to be project relative\n     * @param filePath\n     * @returns {Promise<null>}\n     */\n    function openFile(filePath) {\n        if(filePath.startsWith('/')) {\n            return jsPromise(FileViewController.openFileAndAddToWorkingSet(filePath));\n        }\n        const projectFilePath = path.join(ProjectManager.getProjectRoot().fullPath, filePath);\n        return jsPromise(FileViewController.openFileAndAddToWorkingSet(projectFilePath));\n    }\n\n\n    /**\n     * Set cursor positions or text selections in the active CodeMirror editor based on a specified format.\n     * The input should be an array of strings where each string can denote a cursor position (\"line:char\")\n     * or a text selection range (\"line:char-line:char\"). For a selection, the first part is the anchor and\n     * the second is the head of the selection.\n     *\n     * Example usage: [\"1:2\", \"2:2-3:4\"]\n     *\n     * @param {Array<string>} selections - An array of strings defining cursor positions or selection ranges.\n     * @throws {Error} Throws an error if no active editor is found or if there are parsing issues with the input.\n     */\n    function setCursors(selections) {\n        const activeEditor = EditorManager.getActiveEditor();\n        if(!activeEditor){\n            throw new Error(`No active editor found to set cursor at: ${selections}`);\n        }\n        // Parse the selection strings to CodeMirror positions\n        const parsedSelections = selections.map(selection => {\n            const parts = selection.split('-');\n            if (parts.length === 1) {\n                const [line, ch] = parts[0].split(':').map(Number);\n                if (isNaN(line) || isNaN(ch)) {\n                    throw new Error(`Invalid cursor format: ${parts[0]} for ${selections}`);\n                }\n                return {start: {line: line - 1, ch: ch - 1}, end: {line: line - 1, ch: ch - 1}};\n            } else if (parts.length === 2) {\n                const [fromLine, fromCh] = parts[0].split(':').map(Number);\n                const [toLine, toCh] = parts[1].split(':').map(Number);\n                if (isNaN(fromLine) || isNaN(fromCh) || isNaN(toLine) || isNaN(toCh)) {\n                    throw new Error(`Invalid selection range format: ${selection}`);\n                }\n                return {start: {line: fromLine - 1, ch: fromCh -1}, end: {line: toLine - 1, ch: toCh - 1}};\n            } else {\n                throw new Error(`Invalid format: ${selection}`);\n            }\n        });\n\n        // Set the selections in the editor\n        activeEditor.setSelections(parsedSelections);\n    }\n\n    /**\n     * gets cursor selections array that can be used in the setCursors API\n     * @param editor\n     * @returns {*}\n     */\n    function computeCursors(editor, addQuotes) {\n        const selections = editor.getSelections();\n        return selections.map(selection => {\n            const start = selection.start;\n            const end = selection.end;\n            let cursor;\n\n            // Check if the selection is a cursor (start and end are the same)\n            if (start.line === end.line && start.ch === end.ch) {\n                cursor = `${start.line + 1}:${start.ch + 1}`;\n            } else {\n                cursor = `${start.line + 1}:${start.ch + 1}-${end.line + 1}:${end.ch + 1}`;\n            }\n            return addQuotes ? `\"${cursor}\"` : cursor;\n        });\n    }\n\n    /**\n     * Validates the currently active editor has selections as given here\n     */\n    function expectCursorsToBe(expectedSelections) {\n        const activeEditor = EditorManager.getActiveEditor();\n        if(!activeEditor){\n            throw new Error(`No active editor found for expectCursorsToBe: ${expectedSelections}`);\n        }\n        const currentSelections = computeCursors(activeEditor);\n        if(currentSelections.length !== expectedSelections.length) {\n            throw new Error(`expectCursorsToBe: [${expectedSelections.join(\", \")}] `+\n             `but got [${currentSelections.join(\", \")}]`);\n        }\n        for(let i = 0; i < currentSelections.length; i++) {\n            if(!currentSelections.includes(`${expectedSelections[i]}`) ||\n                !expectedSelections.includes(currentSelections[i])){\n                throw new Error(`expectCursorsToBe: [${expectedSelections.join(\", \")}] `+\n                    `but got [${currentSelections.join(\", \")}]`);\n            }\n        }\n    }\n\n    /**\n     * Simulate a key event.\n     * @param {Number} key Key code available as One of the KeyEvent.DOM_VK_*\n     * @param {String} event Key event to simulate. one of keydown, keyup or keypress\n     * @param {HTMLElement} element Element to receive event\n     * @param {KeyboardEventInit} options Optional arguments for key event\n     */\n    function raiseKeyEvent(key, event, element, options) {\n        const doc = element.ownerDocument;\n\n        if(typeof options === 'undefined') {\n            options = {\n                view: doc.defaultView,\n                bubbles: true,\n                cancelable: true,\n                keyIdentifer: key\n            };\n        } else {\n            options.view = doc.defaultView;\n            options.bubbles = true;\n            options.cancelable = true;\n            options.keyIdentifier = key;\n        }\n        const oEvent = new KeyboardEvent(event, options);\n\n        if (event !== \"keydown\" && event !== \"keyup\" && event !== \"keypress\") {\n            console.log(\"SpecRunnerUtils.simulateKeyEvent() - unsupported keyevent: \" + event);\n            return;\n        }\n\n        // Chromium Hack: need to override the 'which' property.\n        // Note: this code is not designed to work in IE, Safari,\n        // or other browsers. Well, maybe with Firefox. YMMV.\n        Object.defineProperty(oEvent, 'keyCode', {\n            get: function () {\n                return this.keyCodeVal;\n            }\n        });\n        Object.defineProperty(oEvent, 'which', {\n            get: function () {\n                return this.keyCodeVal;\n            }\n        });\n        Object.defineProperty(oEvent, 'charCode', {\n            get: function () {\n                return this.keyCodeVal;\n            }\n        });\n\n        oEvent.keyCodeVal = key;\n        if (oEvent.keyCode !== key) {\n            console.log(\"SpecRunnerUtils.simulateKeyEvent() - keyCode mismatch: \" + oEvent.keyCode);\n        }\n\n        element.dispatchEvent(oEvent);\n    }\n\n    /**\n     * @param {Array<string>} keysArray An array of Key strings available as One of the KeyEvent.DOM_VK_* without the\n     *    `KeyEvent.DOM_VK_` prefix. Eg: use `[\"ESCAPE\"]` instead of fully specifying [`DOM_VK_ESCAPE`]\n     *    E.g: __PR.keydown([\"BACK_SPACE\"]) or __PR.keydown([\"BACK_SPACE\"], {ctrlKey: true})\n     * @param {object} modifiers to modify the key\n     * @param {boolean} modifiers.ctrlKey\n     * @param {boolean} modifiers.altKey\n     * @param {boolean} modifiers.shiftKey\n     * @param {boolean} modifiers.metaKey\n     * @param keysArray\n     */\n    function keydown(keysArray, modifiers) {\n        for(let key of keysArray) {\n            if(typeof key === \"string\"){\n                if(!key.startsWith(\"DOM_VK_\")){\n                    key = \"DOM_VK_\"+key;\n                }\n                key = KeyEvent[key];\n                if(!key){\n                    throw new Error(`Invalid key \"${key}\"`);\n                }\n            }\n            raiseKeyEvent(key, \"keydown\", document.activeElement, modifiers);\n        }\n    }\n\n    function typeAtCursor(text, origin) {\n        const activeEditor = EditorManager.getActiveEditor();\n        if(!activeEditor){\n            throw new Error(`No active editor found to typeAtCursor: ${text}`);\n        }\n        const selections = activeEditor.getSelections();\n        // Insert text at each cursor or the head of each selection.\n        // We perform the insertions in reverse order to avoid affecting the indices of subsequent insertions.\n        for (let selection of selections) {\n            activeEditor.replaceRange(text, selection.start, selection.end, origin);\n        }\n    }\n\n    // converts string of from \"ln:ch\" to pos object\n    function _toPos(posString) {\n        const pos = posString.split(\":\");\n        return {line: Number(pos[0]) - 1, ch: Number(pos[1]) - 1 };\n    }\n\n    /**\n     * Verify if the given text is same as what is in between the given selection.\n     * @param {string} text\n     * @param {string} selection of the form \"ln:ch-ln:ch\"\n     */\n    function validateText(text, selection) {\n        const activeEditor = EditorManager.getActiveEditor();\n        if(!activeEditor){\n            throw new Error(`No active editor found to validateText: ${text} at selection ${selection}`);\n        }\n        const from = selection.split(\"-\")[0], to = selection.split(\"-\")[1];\n        const selectedText = activeEditor.getTextBetween(_toPos(from), _toPos(to));\n        if(selectedText !== text){\n            throw new Error(`validateText: expected text at [${selection}] to be \"${text}\" but got \"${selectedText}\"`);\n        }\n    }\n\n    function _getMarkLocations(markType, whichAPI, selections) {\n        const activeEditor = EditorManager.getActiveEditor();\n        if(!activeEditor){\n            throw new Error(`No active editor found to ${whichAPI}: \"${markType}\" for selection \"${selections}\"`);\n        }\n        const marks = activeEditor.getAllMarks(markType);\n        const marksLocations = [];\n        for(let mark of marks){\n            const loc = mark.find();\n            marksLocations.push(`${loc.from.line+1}:${loc.from.ch+1}-${loc.to.line+1}:${loc.to.ch+1}`);\n        }\n        return marksLocations;\n    }\n\n    /**\n     * validates all marks of the given mark type\n     * @param {string} markType\n     * @param {Array<string>} selections - An array of strings defining cursor positions or selection ranges.\n     */\n    function validateAllMarks(markType, selections) {\n        const marksLocations = _getMarkLocations(markType, \"validateAllMarks\", selections);\n        if(!selections || marksLocations.length !== selections.length){\n            throw new Error(`validateAllMarks expected marks \"${markType}\" at: [${selections&&selections.join(\", \")}] `+\n                `but got marked locations [${marksLocations.join(\", \")}]`);\n        }\n        for(let i = 0; i < selections.length; i++) {\n            if(!selections.includes(`${marksLocations[i]}`) ||\n                !marksLocations.includes(selections[i])){\n                throw new Error(`validateAllMarks expected marks \"${markType}\" at: [${selections.join(\", \")}] `+\n                    `but got marked locations [${marksLocations.join(\", \")}]`);\n            }\n        }\n    }\n\n    function validateEqual(obj1, obj2) {\n        if(!_.isEqual(obj1, obj2)){\n            throw new Error(`validateEqual: expected ${JSON.stringify(obj1)} to equal ${JSON.stringify(obj2)}`);\n        }\n    }\n\n    function validateNotEqual(obj1, obj2) {\n        if(_.isEqual(obj1, obj2)){\n            throw new Error(`validateEqual: expected ${JSON.stringify(obj1)} to NOT equal ${JSON.stringify(obj2)}`);\n        }\n    }\n\n    /**\n     * validates if the given mark type is present in the specified selections\n     * @param {string} markType\n     * @param {Array<string>} selections - An array of strings defining cursor positions or selection ranges.\n     * @param {number} [totalMarkCount] optional to validate against the total number of expected marks of the type\n     */\n    function validateMarks(markType, selections, totalMarkCount) {\n        const marksLocations = _getMarkLocations(markType, \"validateMarks\", selections);\n        if(!selections){\n            return;\n        }\n        if(totalMarkCount !== undefined && marksLocations.length !== totalMarkCount){\n            throw new Error(`validateMarks expected mark count for \"${markType}\" to be: ${totalMarkCount} `+\n                `but got ${marksLocations.length}`);\n        }\n        for(let selection of selections) {\n            if(!marksLocations.includes(selection)){\n                throw new Error(`validateMarks expected marks \"${markType}\" to be at: [${selections.join(\", \")}] `+\n                    `but got marked locations [${marksLocations.join(\", \")}]`);\n            }\n        }\n    }\n\n    function closeFile() {\n        return jsPromise(CommandManager.execute(Commands.FILE_CLOSE, { _forceClose: true }));\n    }\n\n    function closeAll() {\n        return jsPromise(CommandManager.execute(Commands.FILE_CLOSE_ALL, { _forceClose: true }));\n    }\n\n    function execCommand(commandID, arg) {\n        return jsPromise(CommandManager.execute(commandID, arg));\n    }\n\n    function undo() {\n        return execCommand(Commands.EDIT_UNDO);\n    }\n\n    function redo() {\n        return execCommand(Commands.EDIT_REDO);\n    }\n\n    function setPreference(key, value){\n        PreferencesManager.set(key, value);\n    }\n\n    function getPreference(key){\n        return PreferencesManager.get(key);\n    }\n\n    const EDITING = {\n        setEditorSpacing: function (useTabs, spaceOrTabCount, isAutoMode) {\n            const activeEditor = EditorManager.getActiveEditor();\n            if(!activeEditor){\n                throw new Error(`No active editor found to setEditorSpacing`);\n            }\n            const fullPath = activeEditor.document.file.fullPath;\n            if(Editor.Editor.getAutoTabSpaces(fullPath) !== isAutoMode){\n                Editor.Editor.setAutoTabSpaces(isAutoMode, fullPath);\n                isAutoMode && Editor.Editor._autoDetectTabSpaces(activeEditor, true, true);\n            }\n            Editor.Editor.setUseTabChar(useTabs, fullPath);\n            if(useTabs) {\n                Editor.Editor.setTabSize(spaceOrTabCount, fullPath);\n            } else {\n                Editor.Editor.setSpaceUnits(spaceOrTabCount, fullPath);\n            }\n        }\n    };\n\n    /**\n     * Waits for a polling function to succeed or until a timeout is reached.\n     * The polling function is periodically invoked to check for success, and\n     * the function rejects with a timeout message if the timeout duration elapses.\n     *\n     * @param {function} pollFn - A function that returns `true` or a promise resolving to `true`/`false`\n     *                            to indicate success and stop waiting.\n     *                            The function will be called repeatedly until it succeeds or times out.\n     * @param {string|function} _timeoutMessageOrMessageFn - A helpful string message or an async function\n     *                                                       that returns a string message to reject with in case of timeout.\n     *                                                       Example:\n     *                                                       - String: \"Condition not met within the allowed time.\"\n     *                                                       - Function: `async () => \"Timeout while waiting for the process to complete.\"`\n     * @param {number} [timeoutms=2000] - The maximum time to wait in milliseconds before timing out. Defaults to 2 seconds.\n     * @param {number} [pollInterval=10] - The interval in milliseconds at which `pollFn` is invoked. Defaults to 10ms.\n     * @returns {Promise<void>} A promise that resolves when `pollFn` succeeds or rejects with a timeout message.\n     *\n     * @throws {Error} If `timeoutms` or `pollInterval` is not a number.\n     *\n     * @example\n     * // Example 1: Using a string as the timeout message\n     * awaitsFor(\n     *   () => document.getElementById(\"element\") !== null,\n     *   \"Element did not appear within the allowed time.\",\n     *   5000,\n     *   100\n     * ).then(() => {\n     *   console.log(\"Element appeared!\");\n     * }).catch(err => {\n     *   console.error(err.message);\n     * });\n     *\n     * @example\n     * // Example 2: Using a function as the timeout message\n     * awaitsFor(\n     *  () => document.getElementById(\"element\") !== null,\n     *   async () => {\n     *     const el = document.getElementById(\"element\");\n     *     return `expected ${el} to be null`;\n     *   },\n     *   10000,\n     *   500\n     * ).then(() => {\n     *   console.log(\"Element appeared!\");\n     * }).catch(err => {\n     *   console.error(err.message);\n     * });\n     */\n    function awaitsFor(pollFn, _timeoutMessageOrMessageFn, timeoutms = 2000, pollInterval = 10){\n        if(typeof  _timeoutMessageOrMessageFn === \"number\"){\n            timeoutms = _timeoutMessageOrMessageFn;\n            pollInterval = timeoutms;\n        }\n        if(!(typeof  timeoutms === \"number\" && typeof  pollInterval === \"number\")){\n            throw new Error(\"awaitsFor: invalid parameters when awaiting for \" + _timeoutMessageOrMessageFn);\n        }\n\n        async function _getExpectMessage(_timeoutMessageOrMessageFn) {\n            try{\n                if(typeof _timeoutMessageOrMessageFn === \"function\") {\n                    _timeoutMessageOrMessageFn = _timeoutMessageOrMessageFn();\n                    if(_timeoutMessageOrMessageFn instanceof Promise){\n                        _timeoutMessageOrMessageFn = await _timeoutMessageOrMessageFn;\n                    }\n                }\n            } catch (e) {\n                _timeoutMessageOrMessageFn = \"Error executing expected message function:\" + e.stack;\n            }\n            return _timeoutMessageOrMessageFn;\n        }\n\n        function _timeoutPromise(promise, ms) {\n            const timeout = new Promise((_, reject) => {\n                setTimeout(async () => {\n                    _timeoutMessageOrMessageFn = await _getExpectMessage(_timeoutMessageOrMessageFn);\n                    reject(new Error(_timeoutMessageOrMessageFn || `Promise timed out after ${ms}ms`));\n                }, ms);\n            });\n\n            return Promise.race([promise, timeout]);\n        }\n\n        return new Promise((resolve, reject)=>{\n            let startTime = Date.now(),\n                lapsedTime;\n            async function pollingFn() {\n                try{\n                    let result = pollFn();\n\n                    // If pollFn returns a promise, await it\n                    if (Object.prototype.toString.call(result) === \"[object Promise]\") {\n                        // we cant simply check for result instanceof Promise as the Promise may be returned from\n                        // an iframe and iframe has a different instance of Promise than this js context.\n                        result = await _timeoutPromise(result, timeoutms);\n                    }\n\n                    if (result) {\n                        resolve();\n                        return;\n                    }\n                    lapsedTime = Date.now() - startTime;\n                    if(lapsedTime>timeoutms){\n                        _timeoutMessageOrMessageFn = await _getExpectMessage(_timeoutMessageOrMessageFn);\n                        reject(\"awaitsFor timed out waiting for - \" + _timeoutMessageOrMessageFn);\n                        return;\n                    }\n                    setTimeout(pollingFn, pollInterval);\n                } catch (e) {\n                    reject(e);\n                }\n            }\n            pollingFn();\n        });\n    }\n\n    async function waitForModalDialog(dialogClass, friendlyName, timeout = 2000) {\n        dialogClass = dialogClass || \"\";\n        friendlyName = friendlyName || dialogClass || \"Modal Dialog\";\n        await awaitsFor(()=>{\n            let $dlg = $(`.modal.instance${dialogClass}`);\n            return $dlg.length >= 1;\n        }, `Waiting for Modal Dialog to show ${friendlyName}`, timeout);\n    }\n\n    async function waitForModalDialogClosed(dialogClass, friendlyName, timeout = 2000) {\n        dialogClass = dialogClass || \"\";\n        friendlyName = friendlyName || dialogClass || \"Modal Dialog\";\n        await awaitsFor(()=>{\n            let $dlg = $(`.modal.instance${dialogClass}`);\n            return $dlg.length === 0;\n        }, `Waiting for Modal Dialog to not there ${friendlyName}`, timeout);\n    }\n\n    /** Clicks on a button within a specified dialog.\n     * This function identifies a dialog using its class and locates a button either by its selector or button ID.\n     * Validation to ensure the dialog and button exist and that the button is enabled before attempting to click.\n     *\n     * @param {string} selectorOrButtonID - The selector or button ID to identify the button to be clicked.\n     *                                       Example (as selector): \".my-button-class\".\n     *                                       Example (as button ID): \"ok\".\n     * @param {string} dialogClass - The class of the dialog (optional). If omitted, defaults to an empty string.\n     *                               Example: \"my-dialog-class\".\n     * @param {boolean} isButtonID - If `true`, `selectorOrButtonid` is treated as a button ID.\n     *                                If `false`, it is treated as a jQuery selector. Default is `false`.\n     *\n     * @throws {Error} Throws an error if:\n     *   - The specified dialog does not exist.\n     *   - Multiple buttons match the given selector or ID.\n     *   - No button matches the given selector or ID.\n     *   - The button is disabled and cannot be clicked.\n     *\n     */\n    function _clickDialogButtonWithSelector(selectorOrButtonID, dialogClass, isButtonID) {\n        dialogClass = dialogClass || \"\";\n        const $dlg = $(`.modal.instance${dialogClass}`);\n\n        if(!$dlg.length){\n            throw new Error(`No such dialog present: \"${dialogClass}\"`);\n        }\n\n        const $button = isButtonID ?\n            $dlg.find(\".dialog-button[data-button-id='\" + selectorOrButtonID + \"']\") :\n            $dlg.find(selectorOrButtonID);\n        if($button.length > 1){\n            throw new Error(`Multiple button in dialog \"${selectorOrButtonID}\"`);\n        } else if(!$button.length){\n            throw new Error(`No such button in dialog \"${selectorOrButtonID}\"`);\n        }\n\n        if($button.prop(\"disabled\")) {\n            throw new Error(`Cannot click, button is disabled. \"${selectorOrButtonID}\"`);\n        }\n\n        $button.click();\n    }\n\n    /**\n     * Clicks on a button within a specified dialog using its button ID.\n     *\n     * @param {string} buttonID - The unique ID of the button to be clicked. usually One of the\n     *                            __PR.Dialogs.DIALOG_BTN_* symbolic constants or a custom id. You can find the button\n     *                            id in the dialog by inspecting the button and checking its `data-button-id` attribute\n     *                            Example: __PR.Dialogs.DIALOG_BTN_OK.\n     * @param {string} [dialogClass] - The class of the dialog containing the button. Optional, if only one dialog\n     *                               is present, you can omit this.\n     *                               Example: \"my-dialog-class\".\n     * @throws {Error} Throws an error if:\n     *   - The specified dialog does not exist.\n     *   - No button matches the given button ID.\n     *   - Multiple buttons match the given button ID.\n     *   - The button is disabled and cannot be clicked.\n     *\n     * @example\n     * // Example: Click a button by its ID\n     * __PR.clickDialogButtonID(__PR.Dialogs.DIALOG_BTN_OK, \"my-dialog-class\");\n     * __PR.clickDialogButtonID(__PR.Dialogs.DIALOG_BTN_OK); // if only 1 dialog is present, can omit the dialog class\n     * __PR.clickDialogButtonID(\"customBtnID\", \"my-dialog-class\");\n     */\n    function clickDialogButtonID(buttonID, dialogClass) {\n        _clickDialogButtonWithSelector(buttonID, dialogClass, true);\n    }\n\n    /**\n     * Clicks on a button within a specified dialog using a selector.\n     *\n     * @param {string} buttonSelector - A jQuery selector to identify the button to be clicked.\n     *                                   Example: \".showImageBtn\".\n     * @param {string} [dialogClass] - The class of the dialog containing the button. Optional, if only one dialog\n     *                               is present, you can omit this.\n     *                               Example: \"my-dialog-class\".\n     * @throws {Error} Throws an error if:\n     *   - The specified dialog does not exist.\n     *   - No button matches the given selector.\n     *   - Multiple buttons match the given selector.\n     *   - The button is disabled and cannot be clicked.\n     *\n     * @example\n     * // Example: Click a button using a selector\n     * __PR.clickDialogButton(\".showImageBtn\", \"my-dialog-class\");\n     * __PR.clickDialogButton(\".showImageBtn\"); // if only 1 dialog is present, can omit the dialog class\n     */\n    function clickDialogButton(buttonSelector, dialogClass) {\n        _clickDialogButtonWithSelector(buttonSelector, dialogClass, false);\n    }\n\n    const __PR= {\n        openFile, setCursors, expectCursorsToBe, keydown, typeAtCursor, validateText, validateAllMarks, validateMarks,\n        closeFile, closeAll, undo, redo, setPreference, getPreference, validateEqual, validateNotEqual, execCommand,\n        awaitsFor, waitForModalDialog, waitForModalDialogClosed, clickDialogButtonID, clickDialogButton,\n        EDITING, $, Commands, Dialogs\n    };\n\n    async function runMacro(macroText) {\n        let errors = [];\n        try{\n            const AsyncFunction = async function () {}.constructor;\n            const macroAsync = new AsyncFunction(\"__PR\", \"KeyEvent\", macroText);\n            await macroAsync(__PR, KeyEvent);\n        } catch (e) {\n            console.error(\"Error executing macro: \", macroText, e);\n            errors.push({\n                lineNo: 0, line: '',\n                errorCode: `ERROR_EXEC`,\n                errorText: `${e}`\n            });\n        }\n        return errors;\n    }\n\n    if(Phoenix.isTestWindow) {\n        window.__PR = __PR;\n    }\n    exports.computeCursors = computeCursors;\n    exports.runMacro = runMacro;\n});\n"],"file":"MacroRunner.js"}