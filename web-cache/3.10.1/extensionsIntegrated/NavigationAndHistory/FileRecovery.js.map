{"version":3,"sources":["extensionsIntegrated/NavigationAndHistory/FileRecovery.js"],"names":["define","require","exports","module","NativeApp","FileSystem","ProjectManager","MainViewManager","FileSystemError","FileUtils","DocumentManager","NotificationUI","Mustache","Strings","FileViewController","recoveryTemplate","EventDispatcher","Metrics","EventManager","makeEventDispatcher","registerEventHandler","BACKUP_INTERVAL_MS","sessionRestoreDir","getDirectoryForPath","path","normalize","getApplicationSupportDirectory","trackedProjects","simpleHash","str","hash","i","length","char","charCodeAt","Math","abs","createDir","dir","Promise","resolve","reject","create","err","ALREADY_EXISTS","console","error","fullPath","silentlyRemoveFile","getFileForPath","unlink","silentlyRemoveDirectory","getProjectRestoreRoot","projectPath","baseName","basename","restoreRootPath","getRestoreFilePath","projectFilePath","projectRootPath","startsWith","pathWithinProject","replace","restoreRoot","getProjectFilePath","restoreFilePath","project","filePathInProject","async","ensureFolderIsClean","folder","unlinkEmptyDirectoryAsync","integrityCheck","input","parts","split","expectedLength","parseInt","isNaN","actualString","loadLastBackedUpFileContents","currentProjectLoadCount","projectLoadCount","restoreFolder","allEntries","getAllDirectoryContents","backupExists","entry","isDirectory","text","jsPromise","readAsText","lastBackedUpFileContents","lastBackedupLoadInProgress","notificationHTML","render","PROJECT_TO_RECOVER","restoreNotification","close","createToastFromTemplate","RECOVER_UNSAVED_FILES_TITLE","dismissOnClick","toastStyle","NOTIFICATION_STYLES_CSS_CLASS","SUCCESS","countEvent","EVENT_TYPE","PROJECT","currentProjectRoot","projectOpened","_event","projectRoot","firstEditHandled","trackedFileUpdateTimestamps","trackedFileContents","changeErrorReported","catch","writeFileIgnoreFailure","filePath","contents","parentDir","dirname","file","restoreContentsWithIntegrity","writeText","e","backupChangedDocs","trackedFilePaths","Object","keys","trackedFilePath","restorePath","content","cleanupUntrackedFiles","docPathsToTrack","allTrackingPaths","trackedPath","restoreFile","backupInProgress","changeScanner","getProjectRoot","openDocs","getAllOpenDocuments","dirtyDocsExists","doc","isDirty","lastTrackedTimestamp","lastChangeTimestamp","getText","log","$","addClass","logger","reportError","beforeProjectClosed","ensureOpenEditors","pathList","allOpenFiles","getAllOpenFiles","openFilePaths","openFileAndAddToWorkingSet","restoreBtnClicked","projectToRestore","pathsToRestore","isWithinProject","document","getDocumentForPath","setText","discardBtnClicked","initWith","scanIntervalMs","restoreDir","on","EVENT_AFTER_PROJECT_OPEN","EVENT_PROJECT_BEFORE_CLOSE","setInterval","init","window","testEnvironment","_FileRecoveryExtensionForTests"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2016 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*global path, logger, jsPromise*/\n\n/**\n * This file outlines the process phcode follows to restore files if the application crashes or if a user closes\n * the application without saving their files.\n *\n * For each project in phcode, there's a unique 'restore' folder located in the appdata directory.\n * This folder is named according to the pattern <projectName>-<projectPathHash>.\n *\n * The restore folder monitors all files being edited in phcode, and this tracking is updated every 5 seconds\n * by a function called changeScanner. The function backs up changes every 5 seconds, and only unsaved files\n * that have been modified since the last backup are synced again. When files are saved, they're removed from\n * the backup during this changeScanner process because there's no need to restore them.\n *\n * When opening a project, we first check for the existence of a 'restore' folder associated with that project\n * and scan for any files within it. If we find any, these files are marked for potential restoration.\n *\n * During this process, we load all recoverable file data into memory and temporarily halt any writing activity\n * to the 'restore' folder. This safeguard is in place to prevent any accidental overwriting of the restore files'\n * data in case the user edits any files currently marked for restoration.\n *\n * Once we've cached the data from the restore files, we present a notification to the user, asking if they would\n * like these files to be restored. If the user agrees, we then open all of these files in the editor and populate\n * them with the previously cached, restored content.\n */\n\ndefine(function (require, exports, module) {\n    const NativeApp = require(\"utils/NativeApp\"),\n        FileSystem = require(\"filesystem/FileSystem\"),\n        ProjectManager = require(\"project/ProjectManager\"),\n        MainViewManager = require(\"view/MainViewManager\"),\n        FileSystemError = require(\"filesystem/FileSystemError\"),\n        FileUtils = require(\"file/FileUtils\"),\n        DocumentManager = require(\"document/DocumentManager\"),\n        NotificationUI = require(\"widgets/NotificationUI\"),\n        Mustache = require(\"thirdparty/mustache/mustache\"),\n        Strings = require(\"strings\"),\n        FileViewController  = require(\"project/FileViewController\"),\n        recoveryTemplate = require(\"text!./html/recovery-template.html\"),\n        EventDispatcher = require(\"utils/EventDispatcher\"),\n        Metrics = require(\"utils/Metrics\"),\n        EventManager = require(\"utils/EventManager\");\n\n    EventDispatcher.makeEventDispatcher(exports);\n    EventManager.registerEventHandler(\"ph-recovery\", exports);\n\n    const BACKUP_INTERVAL_MS = 5000;\n    let sessionRestoreDir = FileSystem.getDirectoryForPath(\n        path.normalize(NativeApp.getApplicationSupportDirectory() + \"/sessionRestore\"));\n\n    const trackedProjects = {};\n\n    function simpleHash(str) {\n        let hash = 0;\n        for (let i = 0; i < str.length; i++) {\n            let char = str.charCodeAt(i);\n            // eslint-disable-next-line no-bitwise\n            hash = ((hash << 5) - hash) + char;\n            // eslint-disable-next-line no-bitwise\n            hash = hash & hash; // Convert to 32bit integer\n        }\n        return Math.abs(hash) + \"\";\n    }\n\n    function createDir(dir) {\n        return new Promise((resolve, reject)=>{\n            dir.create(function (err) {\n                if (err && err !== FileSystemError.ALREADY_EXISTS) {\n                    console.error(\"[recovery] Error creating project crash restore folder \" + dir.fullPath, err);\n                    reject(err);\n                }\n                resolve();\n            });\n        });\n    }\n\n    function silentlyRemoveFile(path) {\n        return new Promise((resolve)=>{\n            FileSystem.getFileForPath(path).unlink((err)=>{\n                if(err) {\n                    console.error(err);\n                }\n                resolve();\n            });\n        });\n    }\n\n    function silentlyRemoveDirectory(dir) {\n        return new Promise((resolve)=>{\n            dir.unlink((err)=>{\n                if(err) {\n                    console.error(err);\n                }\n                resolve();\n            });\n        });\n    }\n\n    function getProjectRestoreRoot(projectPath) {\n        const baseName = path.basename(projectPath),\n            restoreRootPath = path.normalize(`${sessionRestoreDir.fullPath}/${baseName}_${simpleHash(projectPath)}`);\n        return FileSystem.getDirectoryForPath(restoreRootPath);\n    }\n\n    function getRestoreFilePath(projectFilePath, projectRootPath) {\n        if(!projectFilePath.startsWith(projectRootPath) || !trackedProjects[projectRootPath]){\n            console.error(`[recovery] cannot backed up as ${projectFilePath} is not in project ${projectRootPath}`);\n            return null;\n        }\n        let pathWithinProject = projectFilePath.replace(projectRootPath, \"\");\n        let restoreRoot = trackedProjects[projectRootPath].restoreRoot;\n        return path.normalize(`${restoreRoot.fullPath}/${pathWithinProject}`);\n    }\n\n    // try not to use this\n    function getProjectFilePath(restoreFilePath, projectRootPath) {\n        const project = trackedProjects[projectRootPath];\n        if(!project || !restoreFilePath.startsWith(project.restoreRoot.fullPath)){\n            return null;\n        }\n\n        let filePathInProject = restoreFilePath.replace(project.restoreRoot.fullPath, \"\");\n        return path.normalize(`${projectRootPath}/${filePathInProject}`);\n    }\n\n    /**\n     * the restore folder may have empty folders as files get deleted according to backup algorithm. This fn will\n     * ensure that there are no empty folders and restore folder exists\n     * @param folder\n     * @return {Promise<void>}\n     */\n    async function ensureFolderIsClean(folder) {\n        await createDir(folder);\n        await folder.unlinkEmptyDirectoryAsync();\n        await createDir(folder);\n    }\n\n    function integrityCheck(input) {\n        // The backup is of the form \"length,string_backed_up\" so that we can do integrity checks. ideally we should use\n        // crypto hash functions but that may be expensive. since this is reversible with undo, not doing it for now.\n        if(!input){\n            return null;\n        }\n        const parts = input.split(',', 2);\n\n        if (parts.length !== 2) {\n            return null;\n        }\n\n        // Parse the length part (should be the first part before the comma)\n        const expectedLength = parseInt(parts[0], 10);\n        if (isNaN(expectedLength)) {\n            return null;\n        }\n\n        // The second part is the actual string after the comma\n        const actualString = parts[1];\n        if (actualString.length === expectedLength) {\n            return actualString;\n        }\n        return null;\n    }\n\n    async function loadLastBackedUpFileContents(projectRootPath) {\n        const project = trackedProjects[projectRootPath];\n        if(!project){\n            console.error(\"[recovery] Cannot load backup, no tracking info of project \" + projectRootPath);\n            return;\n        }\n        const currentProjectLoadCount = project.projectLoadCount;\n        let restoreFolder = project.restoreRoot;\n        await ensureFolderIsClean(restoreFolder);\n        let allEntries = await FileSystem.getAllDirectoryContents(restoreFolder);\n        let backupExists = false;\n        for(let entry of allEntries){\n            if(entry.isDirectory){\n                continue;\n            }\n            let text = integrityCheck(await jsPromise(FileUtils.readAsText(entry)));\n            if(!text){\n                continue;\n            }\n            let projectFilePath = getProjectFilePath(entry.fullPath, projectRootPath);\n            if(currentProjectLoadCount !== project.projectLoadCount){\n                // this means that while we were tying to load a project backup, the user switched to another project\n                // and then switched back to this project, all before the first backup load was complete. so\n                // we just return without doing anything here. This function will be eventually called on projectOpened\n                // event handler.\n                return;\n            }\n            project.lastBackedUpFileContents[projectFilePath] = text;\n            backupExists = true;\n        }\n        project.lastBackedupLoadInProgress = false;\n        if(backupExists) {\n            let notificationHTML = Mustache.render(recoveryTemplate, {\n                Strings: Strings,\n                PROJECT_TO_RECOVER: projectRootPath\n            });\n            if(project.restoreNotification){\n                project.restoreNotification.close();\n                project.restoreNotification = null;\n            }\n            project.restoreNotification = NotificationUI.createToastFromTemplate( Strings.RECOVER_UNSAVED_FILES_TITLE,\n                notificationHTML, {\n                    dismissOnClick: false,\n                    toastStyle: NotificationUI.NOTIFICATION_STYLES_CSS_CLASS.SUCCESS\n                });\n            Metrics.countEvent(Metrics.EVENT_TYPE.PROJECT, \"recovery\", \"notified\");\n        } else {\n            Metrics.countEvent(Metrics.EVENT_TYPE.PROJECT, \"recovery\", \"none\");\n        }\n    }\n\n    let currentProjectRoot = null;\n    function projectOpened(_event, projectRoot) {\n        if(projectRoot.fullPath === '/') {\n            console.error(\"[recovery] Backups will not be done for root folder `/`\");\n            return;\n        }\n        if(currentProjectRoot && currentProjectRoot.fullPath === projectRoot.fullPath){\n            // If we get a redundant project open event return. This is because of #SEARCH_THIS_TAG_IN_FILE_1\n            return;\n        }\n        currentProjectRoot = projectRoot;\n        if(trackedProjects[projectRoot.fullPath]){\n            if(trackedProjects[projectRoot.fullPath].restoreNotification){\n                trackedProjects[projectRoot.fullPath].restoreNotification.close();\n                trackedProjects[projectRoot.fullPath].restoreNotification = null;\n            }\n            trackedProjects[projectRoot.fullPath].projectLoadCount++;// we use this to prevent race conditions\n            // on frequent project switch before all project backup files are loaded.\n            trackedProjects[projectRoot.fullPath].lastBackedUpFileContents = {};\n            trackedProjects[projectRoot.fullPath].firstEditHandled = false;\n            trackedProjects[projectRoot.fullPath].lastBackedupLoadInProgress = true;\n            trackedProjects[projectRoot.fullPath].trackedFileUpdateTimestamps = {};\n            trackedProjects[projectRoot.fullPath].trackedFileContents = {};\n            trackedProjects[projectRoot.fullPath].changeErrorReported = false;\n            loadLastBackedUpFileContents(projectRoot.fullPath).catch(err=>{\n                console.error(\"[recovery] loadLastBackedUpFileContents failed \", err);\n            });\n            return;\n        }\n        trackedProjects[projectRoot.fullPath] = {\n            projectLoadCount: 0, // we use this to prevent race conditions on frequent project switch before all\n            // project backup files are loaded.\n            projectRoot: projectRoot,\n            restoreRoot: getProjectRestoreRoot(projectRoot.fullPath),\n            lastBackedUpFileContents: {},\n            firstEditHandled: false, // after a project is loaded, has the first edit by user on any file been handled?\n            lastBackedupLoadInProgress: true, // while the backup is loading, we need to prevent write over the existing\n            // backup with backup info of the current session\n            trackedFileUpdateTimestamps: {},\n            trackedFileContents: {},\n            restoreNotification: null,\n            changeErrorReported: false // we only report change errors once to prevent too many Bugsnag reports\n        };\n        loadLastBackedUpFileContents(projectRoot.fullPath).catch(err=>{\n            console.error(\"[recovery] loadLastBackedUpFileContents failed \", err);\n        });\n    }\n\n    async function writeFileIgnoreFailure(filePath, contents) {\n        try {\n            let parentDir = FileSystem.getDirectoryForPath(path.dirname(filePath));\n            await createDir(parentDir);\n            let file = FileSystem.getFileForPath(filePath);\n            const restoreContentsWithIntegrity = contents.length + \",\" + contents;\n            await jsPromise(FileUtils.writeText(file, restoreContentsWithIntegrity, true));\n        } catch (e) {\n            console.error(e);\n        }\n    }\n\n    async function backupChangedDocs(projectRoot) {\n        const project = trackedProjects[projectRoot.fullPath];\n        let trackedFilePaths =  Object.keys(project.trackedFileContents);\n        for(let trackedFilePath of trackedFilePaths){\n            const restorePath = getRestoreFilePath(trackedFilePath, projectRoot.fullPath);\n            if(restorePath) {\n                const content = project.trackedFileContents[trackedFilePath];\n                await writeFileIgnoreFailure(restorePath, content);\n            }\n            delete project.trackedFileContents[trackedFilePath];\n        }\n    }\n\n    async function cleanupUntrackedFiles(docPathsToTrack, projectRoot) {\n        const project = trackedProjects[projectRoot.fullPath];\n        let allTrackingPaths = Object.keys(project.trackedFileUpdateTimestamps);\n        for(let trackedPath of allTrackingPaths){\n            if(!docPathsToTrack[trackedPath]){\n                const restoreFile = getRestoreFilePath(trackedPath, projectRoot.fullPath);\n                if(restoreFile) {\n                    await silentlyRemoveFile(restoreFile);\n                }\n                delete project.trackedFileUpdateTimestamps[trackedPath];\n            }\n        }\n    }\n\n    let backupInProgress = false;\n\n    /**\n     * This gets executed every 5 seconds and should be as light-weight as possible. If there are no changes to be\n     * backed up, then this function should return as soon as possible without waiting for any async flows.\n     * @return {Promise<void>}\n     */\n    async function changeScanner() {\n        let currentProjectRoot = ProjectManager.getProjectRoot();\n        const project = trackedProjects[currentProjectRoot.fullPath];\n        if(backupInProgress || currentProjectRoot.fullPath === \"/\" || !project || project.lastBackedupLoadInProgress){\n            // trackingProjectRoot can be \"/\" if debug>open virtual file system menu is clicked. Don't track root fs\n            return;\n        }\n        backupInProgress = true;\n        try{\n            // do backup\n            const openDocs = DocumentManager.getAllOpenDocuments();\n            let docPathsToTrack = {}, dirtyDocsExists = false;\n            for(let doc of openDocs){\n                if(doc && doc.isDirty){\n                    dirtyDocsExists = true;\n                    docPathsToTrack[doc.file.fullPath] = true;\n                    const lastTrackedTimestamp = project.trackedFileUpdateTimestamps[doc.file.fullPath];\n                    if(!lastTrackedTimestamp || lastTrackedTimestamp !== doc.lastChangeTimestamp){\n                        // Already backed up, only need to consider it again if its contents changed\n                        project.trackedFileContents[doc.file.fullPath] = doc.getText();\n                        project.trackedFileUpdateTimestamps[doc.file.fullPath] = doc.lastChangeTimestamp;\n                    }\n                }\n            }\n            if(!project.firstEditHandled && dirtyDocsExists) {\n                // this means that the last backup session has been fully loaded in memory and a new edit has been\n                // done by the user. The user may not have yet clicked on the restore backup button. But as the user\n                // made an edit, we should delete the project restore folder to start a new backup session. The user\n                // can still restore the last backup session from the in memory `project.lastBackedUpFileContents`\n                console.log(\"Discarding old backup for restore...\");\n                await silentlyRemoveDirectory(project.restoreRoot);\n                await createDir(project.restoreRoot);\n                await backupChangedDocs(currentProjectRoot);\n                project.firstEditHandled = true;\n                if(project.restoreNotification) {\n                    // this means the user edited a file while the restore dialog was shown. This generally means the\n                    // restore folder has been nuked to make way for the new session, but the old restore contents are still\n                    // available in project.lastBackedUpFileContents. So the contents can be restored, but the restore\n                    // data has already been discarded. We hide the discard option in the case as it's already done.\n                    $(\"#DISCARD_UNSAVED_FILES_RESTORE\").addClass(\"forced-hidden\");\n                }\n            } else {\n                await backupChangedDocs(currentProjectRoot);\n                await cleanupUntrackedFiles(docPathsToTrack, currentProjectRoot);\n            }\n        } catch (e) {\n            console.error(\"[recovery] changeScanner error\", e);\n            if(!project.changeErrorReported){\n                project.changeErrorReported = true;\n                // we only report change errors once to prevent too many Bugsnag reports\n                logger.reportError(e);\n            }\n        }\n        backupInProgress = false;\n    }\n\n    function beforeProjectClosed() {\n        let currentProjectRoot = ProjectManager.getProjectRoot();\n        const project = trackedProjects[currentProjectRoot.fullPath];\n        if(project.restoreNotification) {\n            project.restoreNotification.close();\n            project.restoreNotification = null;\n        }\n        changeScanner().catch(err=>{\n            console.error(\"[recovery] beforeProjectClosed failed which scanning for changes to backup\", err);\n        });\n    }\n\n    async function ensureOpenEditors(pathList) {\n        let allOpenFiles = MainViewManager.getAllOpenFiles();\n        let openFilePaths = {};\n        for(let file of allOpenFiles){\n            openFilePaths[file.fullPath] = true;\n        }\n        for(let path of pathList) {\n            if(!openFilePaths[path]){\n                let file = FileSystem.getFileForPath(path);\n                await jsPromise(FileViewController.openFileAndAddToWorkingSet(file.fullPath));\n            }\n        }\n    }\n\n    async function restoreBtnClicked(_event, projectToRestore) {\n        let currentProjectRoot = ProjectManager.getProjectRoot();\n        const project = trackedProjects[currentProjectRoot.fullPath];\n        Metrics.countEvent(Metrics.EVENT_TYPE.PROJECT, \"recovery\", \"restoreClick\");\n        if(!project || projectToRestore !== currentProjectRoot.fullPath){\n            console.error(`[recovery] current project ${currentProjectRoot.fullPath} != restore ${projectToRestore}`);\n            return;\n        }\n        let pathsToRestore = Object.keys(project.lastBackedUpFileContents);\n        await ensureOpenEditors(pathsToRestore);\n        for(let filePath of pathsToRestore){\n            if(ProjectManager.isWithinProject(filePath)) {\n                console.log(\"restoring\", filePath);\n                let document = await jsPromise(DocumentManager.getDocumentForPath(filePath));\n                document.setText(project.lastBackedUpFileContents[filePath]);\n            } else {\n                console.error(\"[recovery] Skipping restore of non project file: \", filePath);\n            }\n        }\n        if(project.restoreNotification){\n            project.restoreNotification.close();\n            project.restoreNotification = null;\n        }\n    }\n\n    async function discardBtnClicked(_event, projectToRestore) {\n        let currentProjectRoot = ProjectManager.getProjectRoot();\n        const project = trackedProjects[currentProjectRoot.fullPath];\n        Metrics.countEvent(Metrics.EVENT_TYPE.PROJECT, \"recovery\", \"discardClick\");\n        if(!project || projectToRestore !== currentProjectRoot.fullPath){\n            console.error(`[recovery] current project ${currentProjectRoot.fullPath} != restore ${projectToRestore}`);\n            return;\n        }\n        trackedProjects[currentProjectRoot.fullPath].lastBackedUpFileContents = {};\n        // if first edit is handled, the restore directory is nuked and the backup discarded.The discard button will\n        // not be shown so this fn should never get called in the case. We also should mark firstEditHandled to true to\n        // indicate a fresh backup start for the project\n        trackedProjects[currentProjectRoot.fullPath].firstEditHandled = true;\n        if(project.restoreNotification) {\n            project.restoreNotification.close();\n            project.restoreNotification = null;\n        }\n        await silentlyRemoveDirectory(project.restoreRoot);\n        await createDir(project.restoreRoot);\n        await backupChangedDocs(currentProjectRoot);\n    }\n\n    function initWith(scanIntervalMs, restoreDir) {\n        ProjectManager.on(ProjectManager.EVENT_AFTER_PROJECT_OPEN, projectOpened);\n        ProjectManager.on(ProjectManager.EVENT_PROJECT_BEFORE_CLOSE, beforeProjectClosed);\n        exports.on(\"restoreProject\", restoreBtnClicked);\n        exports.on(\"discardProject\", discardBtnClicked);\n        sessionRestoreDir = restoreDir;\n        createDir(sessionRestoreDir);\n        setInterval(changeScanner, scanIntervalMs);\n        let currentProjectRoot = ProjectManager.getProjectRoot();\n        if(currentProjectRoot) {\n            // ##SEARCH_THIS_TAG_IN_FILE_1\n            // At boot, the startup project may be opened and we may never get the projectOpened event triggered\n            // for the startup project. So we call manually.\n            projectOpened(null, currentProjectRoot);\n        }\n    }\n\n    function init() {\n        if(!window.testEnvironment){\n            initWith(BACKUP_INTERVAL_MS, sessionRestoreDir);\n        } else {\n            // this is a test environment, expose functions to test\n            exports.getProjectRestoreRoot = getProjectRestoreRoot;\n            exports.initWith = initWith;\n            window._FileRecoveryExtensionForTests = exports;\n        }\n    }\n\n    exports.init = init;\n});\n"],"file":"FileRecovery.js"}