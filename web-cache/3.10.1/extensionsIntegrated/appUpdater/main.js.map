{"version":3,"sources":["extensionsIntegrated/appUpdater/main.js"],"names":["define","require","exports","module","AppInit","Metrics","FileSystem","FileUtils","Commands","CommandManager","Menus","Dialogs","NodeUtils","DefaultDialogs","Strings","marked","semver","NotificationUI","TaskManager","StringUtils","NativeApp","PreferencesManager","updaterWindow","updateTask","updatePendingRestart","updateFailed","TAURI_UPDATER_WINDOW_LABEL","KEY_LAST_UPDATE_CHECK_TIME","KEY_LAST_UPDATE_DESCRIPTION","KEY_UPDATE_AVAILABLE","PREFS_AUTO_UPDATE","isAutoUpdateFlow","showOrHideUpdateIcon","updateAvailable","window","__TAURI__","WebviewWindow","getByLabel","addNewTask","UPDATING_APP","UPDATING_APP_MESSAGE","noSpinnerNotification","onSelect","showInfoDialog","UPDATE_READY_RESTART_TITLE","UPDATE_READY_RESTART_INSTALL_MESSAGE","UPDATE_FAILED_TITLE","UPDATE_FAILED_MESSAGE","UPDATING_APP_DIALOG_MESSAGE","flashSpinnerForAttention","show","getViewState","$","removeClass","addClass","fetchJSON","url","fetch","then","response","ok","json","createTauriUpdateWindow","downloadURL","countEvent","EVENT_TYPE","UPDATES","Phoenix","platform","config","environment","encodeURIComponent","title","fullscreen","resizable","height","minHeight","width","minWidth","acceptFirstMouse","visible","async","doUpdate","getUpdatePlatformKey","platformArch","app","getPlatformArch","os","brackets","getUpdateDetails","updatePlatformKey","updateDetails","shouldUpdate","currentVersion","metadata","apiVersion","updateVersion","releaseNotesMarkdown","updatePlatform","updateMetadata","app_update_url","phoenixBinaryVersion","getPhoenixBinaryVersion","phoenixLoadedAppVersion","gt","version","console","log","setViewState","notes","platforms","eq","e","error","logger","reportError","isUpgradableLocation","homeDir","path","endsWith","phoenixInstallDir","cliArgs","invoke","phoenixBinLoadedPath","startsWith","_getButtons","isUpgradableLoc","updateLater","className","DIALOG_BTN_CLASS_NORMAL","id","DIALOG_BTN_CANCEL","text","UPDATE_LATER","getItNow","DIALOG_BTN_CLASS_PRIMARY","DIALOG_BTN_OK","GET_IT_NOW","updateOnExit","UPDATE_ON_EXIT","_updateWithConfirmDialog","buttons","markdownHtml","parse","showModalDialog","DIALOG_ID_INFO","UPDATE_AVAILABLE_TITLE","done","option","downloadPage","homepage_url","openURLInDefaultBrowser","checkForUpdates","isAutoUpdate","navigator","onLine","click","UPDATE_NOT_AVAILABLE_TITLE","UPDATE_UP_TO_DATE","autoUpdateEnabled","get","UPDATE_COMMANDS","GET_STATUS","GET_DOWNLOAD_PROGRESS","GET_INSTALLER_LOCATION","UPDATE_EVENT","UPDATE_STATUS","_sendUpdateCommand","command","data","event","emit","_refreshUpdateStatus","launchWindowsInstaller","Promise","resolve","reject","appdataDir","_tauriBootVars","appLocalDir","resolveResource","argsArray","nodeSrcPath","shell","Command","sidecar","on","code","signal","stdout","line","stderr","spawn","launchLinuxUpdater","stageValue","execCommand","runCommand","result","execute","Error","getCurrentMacAppPath","fullPath","normalizedPath","normalize","parts","split","sep","appIndex","findIndex","part","appPathParts","slice","join","_extractMacInstaller","extractPlatformPath","extractCommand","installerLocation","removeAttrCommand","extractedVirtualPath","fs","getTauriVirtualPath","directory","getDirectoryForPath","entries","getContentsAsync","length","includes","stripTrailingSlash","getTauriPlatformPath","_cleanExtractedFolderSilent","logError","unlinkAsync","catch","err","finally","doMacUpdate","currentAppPath","removeCommand","copyCommand","quitTimeAppUpdateHandler","forceUseNodeWSEndpoint","dialog","failUpdateDialogAndExit","close","UPDATE_FAILED_VISIT_SITE_MESSAGE","update_download_page","UPDATE_INSTALLING","UPDATE_INSTALLING_MESSAGE","OK","updateInstalledDialogShown","updateFailedDialogShown","appReady","isNativeApp","isTestWindow","listen","receivedEvent","eventName","payload","setSucceded","setTitle","UPDATE_DONE","setMessage","UPDATE_RESTART_INSTALL","createToastFromTemplate","toastStyle","NOTIFICATION_STYLES_CSS_CLASS","SUCCESS","dismissOnClick","UPDATE_DOWNLOADING","setFailed","progressPercent","fileSize","setProgressPercent","format","UPDATE_DOWNLOAD_PROGRESS","Math","floor","registerQuitTimeAppUpdateHandler","reportErrorMessage","register","CMD_CHECK_FOR_UPDATE","HELP_CHECK_UPDATES","CMD_AUTO_UPDATE","HELP_AUTO_UPDATE","set","helpMenu","getMenu","AppMenuBar","HELP_MENU","addMenuItem","AFTER","HELP_GET_INVOLVED","definePreference","description","DESCRIPTION_AUTO_UPDATE","lastUpdateDetails","UPDATE_WHATS_NEW","lastUpdateCheckTime","currentTime","Date","now","oneDayInMilliseconds"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*global logger, path*/\n\n// this file uses tauri APIs directly and is probably the only place where tauri apis are used outside of the\n// shell.js file. This is app updates are pretty core level even though we do it as an extension here.\n\ndefine(function (require, exports, module) {\n    const AppInit = require(\"utils/AppInit\"),\n        Metrics = require(\"utils/Metrics\"),\n        FileSystem    = require(\"filesystem/FileSystem\"),\n        FileUtils   = require(\"file/FileUtils\"),\n        Commands = require(\"command/Commands\"),\n        CommandManager  = require(\"command/CommandManager\"),\n        Menus = require(\"command/Menus\"),\n        Dialogs = require(\"widgets/Dialogs\"),\n        NodeUtils = require(\"utils/NodeUtils\"),\n        DefaultDialogs  = require(\"widgets/DefaultDialogs\"),\n        Strings     = require(\"strings\"),\n        marked = require('thirdparty/marked.min'),\n        semver = require(\"thirdparty/semver.browser\"),\n        NotificationUI = require(\"widgets/NotificationUI\"),\n        TaskManager = require(\"features/TaskManager\"),\n        StringUtils         = require(\"utils/StringUtils\"),\n        NativeApp           = require(\"utils/NativeApp\"),\n        PreferencesManager  = require(\"preferences/PreferencesManager\");\n    let updaterWindow, updateTask, updatePendingRestart, updateFailed;\n\n    const TAURI_UPDATER_WINDOW_LABEL = \"updater\",\n        KEY_LAST_UPDATE_CHECK_TIME = \"PH_LAST_UPDATE_CHECK_TIME\",\n        KEY_LAST_UPDATE_DESCRIPTION = \"PH_LAST_UPDATE_DESCRIPTION\",\n        KEY_UPDATE_AVAILABLE = \"PH_UPDATE_AVAILABLE\";\n\n    const PREFS_AUTO_UPDATE = \"autoUpdate\";\n    let isAutoUpdateFlow = true;\n\n    function showOrHideUpdateIcon() {\n        if(!updaterWindow){\n            updaterWindow = window.__TAURI__.window.WebviewWindow.getByLabel(TAURI_UPDATER_WINDOW_LABEL);\n        }\n        if(updaterWindow && !updateTask) {\n            updateTask = TaskManager.addNewTask(Strings.UPDATING_APP, Strings.UPDATING_APP_MESSAGE,\n                `<i class=\"fa-solid fa-cogs\"></i>`, {\n                    noSpinnerNotification: isAutoUpdateFlow, // for auto updates, don't get user attention with spinner\n                    onSelect: function () {\n                        if(updatePendingRestart){\n                            Dialogs.showInfoDialog(Strings.UPDATE_READY_RESTART_TITLE,\n                                Strings.UPDATE_READY_RESTART_INSTALL_MESSAGE);\n                        } else if(updateFailed){\n                            Dialogs.showInfoDialog(Strings.UPDATE_FAILED_TITLE, Strings.UPDATE_FAILED_MESSAGE);\n                        } else {\n                            Dialogs.showInfoDialog(Strings.UPDATING_APP, Strings.UPDATING_APP_DIALOG_MESSAGE);\n                        }\n                    }\n                });\n            if(!isAutoUpdateFlow) {\n                updateTask.show();\n            } else {\n                updateTask.flashSpinnerForAttention();\n            }\n        }\n        let updateAvailable = PreferencesManager.getViewState(KEY_UPDATE_AVAILABLE);\n        if(updateAvailable){\n            $(\"#update-notification\").removeClass(\"forced-hidden\");\n        } else {\n            $(\"#update-notification\").addClass(\"forced-hidden\");\n        }\n    }\n\n    function fetchJSON(url) {\n        return fetch(url)\n            .then(response => {\n                if (!response.ok) {\n                    return null;\n                }\n                return response.json();\n            });\n    }\n\n    function createTauriUpdateWindow(downloadURL) {\n        if(updaterWindow){\n            return;\n        }\n        Metrics.countEvent(Metrics.EVENT_TYPE.UPDATES, 'window', \"create\"+Phoenix.platform);\n        // as we are a single instance app, and there can be multiple phoenix windows that comes in and goes out,\n        // the updater lives in its own independent hidden window.\n        const url = downloadURL ?\n            `tauri-updater.html?stage=${Phoenix.config.environment}&downloadURL=${encodeURIComponent(downloadURL)}` :\n            `tauri-updater.html?stage=${Phoenix.config.environment}`;\n        updaterWindow = new window.__TAURI__.window.WebviewWindow(TAURI_UPDATER_WINDOW_LABEL, {\n            url: url,\n            title: \"Desktop App Updater\",\n            fullscreen: false,\n            resizable: false,\n            height: 320,\n            minHeight: 320,\n            width: 240,\n            minWidth: 240,\n            acceptFirstMouse: false,\n            visible: false\n        });\n        if(window.__TAURI__.window.WebviewWindow.getByLabel(TAURI_UPDATER_WINDOW_LABEL)){\n            Metrics.countEvent(Metrics.EVENT_TYPE.UPDATES, 'window', \"okCreate\"+Phoenix.platform);\n        }\n    }\n\n    async function doUpdate(downloadURL) {\n        createTauriUpdateWindow(downloadURL);\n        showOrHideUpdateIcon();\n    }\n\n    async function getUpdatePlatformKey() {\n        const platformArch = await Phoenix.app.getPlatformArch();\n        let os = 'windows';\n        if (brackets.platform === \"mac\") {\n            os = \"darwin\";\n        } else if (brackets.platform === \"linux\") {\n            os = \"linux\";\n        }\n        return `${os}-${platformArch}`;\n    }\n\n    async function getUpdateDetails() {\n        const updatePlatformKey = await getUpdatePlatformKey();\n        const updateDetails = {\n            shouldUpdate: false,\n            updatePendingRestart: false,\n            downloadURL: null,\n            currentVersion: Phoenix.metadata.apiVersion,\n            updateVersion: null,\n            releaseNotesMarkdown: null,\n            updatePlatform: updatePlatformKey\n        };\n        try{\n            if(!updaterWindow){\n                updaterWindow = window.__TAURI__.window.WebviewWindow.getByLabel(TAURI_UPDATER_WINDOW_LABEL);\n            }\n            const updateMetadata = await fetchJSON(brackets.config.app_update_url);\n            const phoenixBinaryVersion = await NodeUtils.getPhoenixBinaryVersion();\n            const phoenixLoadedAppVersion = Phoenix.metadata.apiVersion;\n            if(semver.gt(updateMetadata.version, phoenixBinaryVersion)){\n                console.log(\"Update available: \", updateMetadata, \"Detected platform: \", updatePlatformKey);\n                PreferencesManager.setViewState(KEY_UPDATE_AVAILABLE, true);\n                updateDetails.shouldUpdate = true;\n                updateDetails.updateVersion = updateMetadata.version;\n                updateDetails.releaseNotesMarkdown = updateMetadata.notes;\n                if(updateMetadata.platforms && updateMetadata.platforms[updatePlatformKey]){\n                    updateDetails.downloadURL = updateMetadata.platforms[updatePlatformKey].url;\n                }\n            } else if(semver.eq(updateMetadata.version, phoenixBinaryVersion) &&\n                !semver.eq(phoenixLoadedAppVersion, phoenixBinaryVersion) && updaterWindow){\n                // the updaterWindow check is here so that it only makes sense to show restart dialog if the update\n                // was actually done. We have a version number mismatch of 0.0.1 between phoenix-desktop and phoenix\n                // repo, and that means that this can get triggered on statup on development builds. Wont happen in\n                // actual pipeline generated build tho.\n                console.log(\"Updates applied, waiting for app restart:\", phoenixBinaryVersion, phoenixLoadedAppVersion);\n                updateDetails.updatePendingRestart = true;\n                PreferencesManager.setViewState(KEY_UPDATE_AVAILABLE, true);\n            } else {\n                console.log(\"no updates available for platform: \", updateDetails.updatePlatform);\n                PreferencesManager.setViewState(KEY_UPDATE_AVAILABLE, false);\n            }\n            showOrHideUpdateIcon();\n        } catch (e) {\n            console.error(\"Error getting update metadata\", e);\n            logger.reportError(e, `Error getting app update metadata`);\n            updateFailed = true;\n            Metrics.countEvent(Metrics.EVENT_TYPE.UPDATES, 'fail', \"Unknown\"+Phoenix.platform);\n        }\n        return updateDetails;\n    }\n\n    /**\n     * We should only upgrade if the current binary is at an installed location.\n     */\n    async function isUpgradableLocation() {\n        try {\n            if (brackets.platform === \"linux\") {\n                let homeDir = await window.__TAURI__.path.homeDir(); // Eg. \"/home/home/\"\n                if(!homeDir.endsWith(\"/\")){\n                   homeDir = homeDir + \"/\";\n                }\n                const phoenixInstallDir = `${homeDir}.phoenix-code/`;\n                const cliArgs = await window.__TAURI__.invoke('_get_commandline_args');\n                const phoenixBinLoadedPath = cliArgs[0];\n                // we only upgrade if the install location is created by the installer\n                return phoenixBinLoadedPath.startsWith(phoenixInstallDir);\n            }\n        } catch (e) {\n            logger.reportError(e);\n            console.error(e);\n            return false;\n        }\n        // for mac, this is handled by tauri APIs, so we always say yes.\n        // for win, this is handled by windows installer nsis exe, so we always say yes.\n        return true;\n    }\n\n    function _getButtons(isUpgradableLoc) {\n        const updateLater =\n            {className: Dialogs .DIALOG_BTN_CLASS_NORMAL, id: Dialogs .DIALOG_BTN_CANCEL, text: Strings.UPDATE_LATER };\n        const getItNow =\n            { className: Dialogs .DIALOG_BTN_CLASS_PRIMARY, id: Dialogs .DIALOG_BTN_OK, text: Strings.GET_IT_NOW };\n        const updateOnExit =\n            { className: Dialogs .DIALOG_BTN_CLASS_PRIMARY, id: Dialogs .DIALOG_BTN_OK, text: Strings.UPDATE_ON_EXIT };\n        if(!isUpgradableLoc) {\n            return [updateLater, getItNow];\n        }\n        return [updateLater, updateOnExit];\n    }\n\n    async function _updateWithConfirmDialog(isUpgradableLoc, updateDetails) {\n        const buttons = _getButtons(isUpgradableLoc);\n        let markdownHtml = marked.parse(updateDetails.releaseNotesMarkdown || \"\");\n        Metrics.countEvent(Metrics.EVENT_TYPE.UPDATES, 'dialog', \"shown\"+Phoenix.platform);\n        Dialogs.showModalDialog(DefaultDialogs.DIALOG_ID_INFO, Strings.UPDATE_AVAILABLE_TITLE, markdownHtml, buttons)\n            .done(option=>{\n                if(option === Dialogs.DIALOG_BTN_CANCEL){\n                    Metrics.countEvent(Metrics.EVENT_TYPE.UPDATES, 'dialog', \"cancel\"+Phoenix.platform);\n                    return;\n                }\n                if(!isUpgradableLoc) {\n                    // user installed linux as binary without installer, we just open phcode.io\n                    const downloadPage = brackets.config.homepage_url || \"https://phcode.io\";\n                    NativeApp.openURLInDefaultBrowser(downloadPage);\n                    Metrics.countEvent(Metrics.EVENT_TYPE.UPDATES, 'dialog', \"nonUpgradable\"+Phoenix.platform);\n                    return;\n                }\n                if(option === Dialogs.DIALOG_BTN_OK && !updaterWindow){\n                    Metrics.countEvent(Metrics.EVENT_TYPE.UPDATES, 'dialog', \"okUpdate\"+Phoenix.platform);\n                    doUpdate(updateDetails.downloadURL);\n                }\n            });\n    }\n\n    async function checkForUpdates(isAutoUpdate) {\n        isAutoUpdateFlow = isAutoUpdate;\n        showOrHideUpdateIcon();\n        if(!navigator.onLine) {\n            return;\n        }\n        if(updateTask){\n            $(\"#status-tasks .btn-dropdown\").click();\n            return;\n        }\n        const updateDetails = await getUpdateDetails(); // this will also show update icon if update present\n        if(updateFailed) {\n            if(!isAutoUpdate) {\n                // we dont show auto update errors to user\n                Dialogs.showInfoDialog(Strings.UPDATE_FAILED_TITLE, Strings.UPDATE_FAILED_MESSAGE);\n            }\n            return;\n        }\n        if(updatePendingRestart || updateDetails.updatePendingRestart){\n            if(!isAutoUpdate){\n                Dialogs.showInfoDialog(Strings.UPDATE_READY_RESTART_TITLE,\n                    Strings.UPDATE_READY_RESTART_INSTALL_MESSAGE);\n                // the dialog will only be shown in explicit check for updates, else its annoying that this comes\n                // up at every new window create from app.\n            }\n            return;\n        }\n        if(!updateDetails.shouldUpdate){\n            (!isAutoUpdate) && Dialogs.showInfoDialog(Strings.UPDATE_NOT_AVAILABLE_TITLE, Strings.UPDATE_UP_TO_DATE);\n            return;\n        }\n        const autoUpdateEnabled = PreferencesManager.get(PREFS_AUTO_UPDATE);\n        if(isAutoUpdate && !autoUpdateEnabled){\n            // the update icon is lit at this time for the user to hint that an update is available\n            // but, we don't show the dialog if auto update is off.\n            return;\n        }\n        const isUpgradableLoc = await isUpgradableLocation();\n        if(!isUpgradableLoc || !isAutoUpdate) {\n            _updateWithConfirmDialog(isUpgradableLoc, updateDetails);\n        } else if(!updaterWindow) {\n            Metrics.countEvent(Metrics.EVENT_TYPE.UPDATES, 'auto', \"silent\"+Phoenix.platform);\n            PreferencesManager.setViewState(KEY_LAST_UPDATE_DESCRIPTION, {\n                releaseNotesMarkdown: updateDetails.releaseNotesMarkdown,\n                updateVersion: updateDetails.updateVersion\n            });\n            doUpdate(updateDetails.downloadURL);\n        }\n    }\n\n    const UPDATE_COMMANDS = {\n        GET_STATUS: \"GET_STATUS\",\n        GET_DOWNLOAD_PROGRESS: \"GET_DOWNLOAD_PROGRESS\",\n        GET_INSTALLER_LOCATION: \"GET_INSTALLER_LOCATION\"\n    };\n    const UPDATE_EVENT = {\n        STATUS: \"STATUS\",\n        LOG_ERROR: \"LOG_ERROR\",\n        DOWNLOAD_PROGRESS: \"DOWNLOAD_PROGRESS\",\n        INSTALLER_LOCATION: \"INSTALLER_LOCATION\"\n    };\n    const UPDATE_STATUS = {\n        STARTED: \"STARTED\",\n        DOWNLOADING: \"DOWNLOADING\",\n        INSTALLER_DOWNLOADED: \"INSTALLER_DOWNLOADED\",\n        FAILED: \"FAILED\",\n        FAILED_UNKNOWN_OS: \"FAILED_UNKNOWN_OS\"\n    };\n\n    function _sendUpdateCommand(command, data) {\n        window.__TAURI__.event.emit('updateCommands', {command, data});\n    }\n\n    function _refreshUpdateStatus() {\n        _sendUpdateCommand(UPDATE_COMMANDS.GET_STATUS);\n    }\n\n    async function launchWindowsInstaller() {\n        return new Promise((resolve, reject)=>{\n            const appdataDir = window._tauriBootVars.appLocalDir;\n            window.__TAURI__.path.resolveResource(\"src-node/installer/launch-windows-installer.js\")\n                .then(async nodeSrcPath=>{\n                    // this is not supposed to work in linux.\n                    const argsArray = [nodeSrcPath, appdataDir];\n                    const command = window.__TAURI__.shell.Command.sidecar('phnode', argsArray);\n                    command.on('close', data => {\n                        console.log(`PhNode: command finished with code ${data.code} and signal ${data.signal}`);\n                        if(data.code !== 0) {\n                            console.error(\"Install failed\");\n                            reject();\n                            return;\n                        }\n                        resolve();\n                    });\n                    command.on('error', error => {\n                        console.error(`PhNode: command error: \"${error}\"`);\n                        reject();\n                    });\n                    command.stdout.on('data', line => {\n                        console.log(`PhNode: ${line}`);\n                    });\n                    command.stderr.on('data', line => console.error(`PhNode: ${line}`));\n                    command.spawn();\n                });\n        });\n    }\n\n    async function launchLinuxUpdater() {\n        const stageValue = Phoenix.config.environment;\n        console.log('Stage:', stageValue);\n        let execCommand = 'wget -qO- https://updates.phcode.io/linux/installer.sh | bash -s -- --upgrade';\n        let runCommand = 'run-update-linux-command';\n        if(stageValue === 'dev' || stageValue === 'stage'){\n            runCommand = 'run-update-linux-command-dev';\n            execCommand = \"wget -qO- https://updates.phcode.io/linux/installer-latest-experimental-build.sh | bash -s -- --upgrade\";\n        }\n        const command = new window.__TAURI__.shell\n            .Command(runCommand, ['-e', execCommand]);\n        const result = await command.execute();\n        if(result.code !== 0){\n            throw new Error(\"Update script exit with non-0 exit code: \" + result.code);\n        }\n    }\n\n    async function getCurrentMacAppPath() {\n        const cliArgs = await window.__TAURI__.invoke('_get_commandline_args');\n        let fullPath = cliArgs[0]; // something like /Applications/editor.app/contents/.../Phoenix code\n        const normalizedPath = path.normalize(fullPath);\n        const parts = normalizedPath.split(path.sep);\n        const appIndex = parts.findIndex(part => part.endsWith('.app'));\n\n        // Reconstruct the path up to the .app part\n        if (appIndex !== -1) {\n            const appPathParts = parts.slice(0, appIndex + 1);\n            return appPathParts.join(path.sep); // returns /Applications/editor.app\n        }\n        // .app part is found\n        return null;\n    }\n\n    async function _extractMacInstaller() {\n        const appdataDir = window._tauriBootVars.appLocalDir;\n        let extractPlatformPath = path.join(appdataDir, 'installer', \"extracted\");\n        // extract the .app file\n        const extractCommand = new window.__TAURI__.shell\n            .Command(`tar-unix`, ['-xzf', installerLocation, \"-C\", extractPlatformPath]);\n        let result = await extractCommand.execute();\n        if(result.code !== 0){\n            console.error(\"Could not extract installer at\", installerLocation, \"to\", extractPlatformPath);\n            throw new Error(\"Could not extract installer at \" + installerLocation + \" to \" + extractPlatformPath);\n        }\n        // remove the quarantine flag\n        const removeAttrCommand = new window.__TAURI__.shell\n            .Command(`mac-remove-quarantine`, [\"-rd\", \"com.apple.quarantine\", extractPlatformPath]);\n        result = await removeAttrCommand.execute();\n        if(result.code !== 0){\n            console.error(\"Could not remove quarantine attribute for\", extractPlatformPath, \"ignoring...\");\n            // we can ignore this failure as the user will be asked for permission by os on clicking anyway.\n        }\n        // now get the .app path from extracted path\n        const extractedVirtualPath = window.fs.getTauriVirtualPath(extractPlatformPath);\n        let directory = FileSystem.getDirectoryForPath(extractedVirtualPath);\n        const {entries} = await directory.getContentsAsync();\n        if(entries.length !== 1 || !entries[0].fullPath.includes(\".app\")){\n            throw new Error(\"Could not resolve .app to update from extracted folder\" + extractedVirtualPath);\n        }\n        installerLocation = FileUtils.stripTrailingSlash(\n            window.fs.getTauriPlatformPath(entries[0].fullPath));\n    }\n\n    function _cleanExtractedFolderSilent(logError) {\n        return new Promise(resolve=>{\n            const appdataDir = window._tauriBootVars.appLocalDir;\n            let extractPlatformPath = path.join(appdataDir, 'installer', \"extracted\");\n            const extractedVirtualPath = window.fs.getTauriVirtualPath(extractPlatformPath);\n            let directory = FileSystem.getDirectoryForPath(extractedVirtualPath);\n            directory.unlinkAsync()\n                .catch(err=>{\n                    logError && console.error(`Error cleaning up ${extractedVirtualPath}`, err);\n                })\n                .finally(resolve);\n        });\n    }\n\n    async function doMacUpdate() {\n        await _extractMacInstaller();\n        const currentAppPath = await getCurrentMacAppPath();\n        if(!currentAppPath || !installerLocation || !currentAppPath.endsWith(\".app\") ||\n            !installerLocation.endsWith(\".app\")){\n            throw new Error(\"Cannot resolve .app location to copy.\");\n        }\n        let removeCommand = new window.__TAURI__.shell\n            .Command(`recursive-rm-unix`, ['-r', currentAppPath]);\n        let result = await removeCommand.execute();\n        if(result.code !== 0){\n            console.error(\"Could not remove old app: \", currentAppPath);\n            throw new Error(\"Could not remove old app: \" + currentAppPath);\n        }\n        const copyCommand = new window.__TAURI__.shell\n            .Command(`recursive-copy-unix`, ['-r', installerLocation, currentAppPath]);\n        result = await copyCommand.execute();\n        if(result.code !== 0){\n            throw new Error(\"Update script exit with non-0 exit code: \" + result.code);\n        }\n        // now remove the original .app\n        await _cleanExtractedFolderSilent(true);\n    }\n\n    let installerLocation;\n    async function quitTimeAppUpdateHandler() {\n        if(!installerLocation){\n            return;\n        }\n        // at this time, the node process have exited and we need to force use tauri apis. This would\n        // normally happen as node responds as terminated, but for updates, this is at quit time and we\n        // cant wait any longer.\n        window.fs.forceUseNodeWSEndpoint(false);\n        console.log(\"Installing update from: \", installerLocation);\n        return new Promise(resolve=>{\n            // this should never reject as it happens in app quit. rejecting wont affect quit, but its unnecessary.\n            let dialog;\n            function failUpdateDialogAndExit(err) {\n                console.error(\"error updating: \", err);\n                dialog && dialog.close();\n                Dialogs.showInfoDialog(Strings.UPDATE_FAILED_TITLE, Strings.UPDATE_FAILED_VISIT_SITE_MESSAGE)\n                    .done(()=>{\n                        NativeApp.openURLInDefaultBrowser(Phoenix.config.update_download_page)\n                            .catch(console.error)\n                            .finally(resolve);\n                    });\n            }\n            if (brackets.platform === \"win\") {\n                launchWindowsInstaller()\n                    .then(resolve)\n                    .catch(failUpdateDialogAndExit);\n                return;\n            }\n            dialog = Dialogs.showModalDialog(\n                DefaultDialogs.DIALOG_ID_INFO,\n                Strings.UPDATE_INSTALLING,\n                Strings.UPDATE_INSTALLING_MESSAGE,\n                [\n                    {\n                        className: \"forced-hidden\",\n                        id: Dialogs.DIALOG_BTN_OK,\n                        text: Strings.OK\n                    }\n                ],\n                false\n            );\n            if (brackets.platform === \"linux\") {\n                launchLinuxUpdater()\n                    .then(resolve)\n                    .catch(failUpdateDialogAndExit);\n            } else if (brackets.platform === \"mac\") {\n                doMacUpdate()\n                    .then(resolve)\n                    .catch(failUpdateDialogAndExit);\n            } else {\n                resolve();\n            }\n        });\n    }\n\n    let updateInstalledDialogShown = false, updateFailedDialogShown = false;\n    AppInit.appReady(function () {\n        if(!Phoenix.isNativeApp || Phoenix.isTestWindow) {\n            // app updates are only for desktop builds\n            return;\n        }\n        if (brackets.platform === \"mac\") {\n            // in mac, the `update.app.tar.gz` is downloaded, and only extracted on app quit.\n            // we do this only in mac as the `.app` file is extracted only at app quit and deleted\n            // and if we see the `extracted file` at app boot, it means the update was broken,and we clear\n            // the updated folder. if not, the extracted app may be corrupt, or mac will show that app\n            // too in the finder `open with` section.\n            // in windows, the `setup.exe.zip` is downloaded and extracted to `setup.exe`. The exe is executed\n            // only on app quit. so if we do this in windows, the extracted installer.exe will be\n            // deleted on new widow create and the final update will fail if other windows were opened\n            // after the installer was downloaded and extracted.\n            // in Linux, it is an online installer, nothing is downloaded.\n            _cleanExtractedFolderSilent();\n        }\n        updaterWindow = window.__TAURI__.window.WebviewWindow.getByLabel(TAURI_UPDATER_WINDOW_LABEL);\n        window.__TAURI__.event.listen(\"updater-event\", (receivedEvent)=> {\n            console.log(\"received Event updater-event\", receivedEvent);\n            const {eventName, data} = receivedEvent.payload;\n            if(eventName === UPDATE_EVENT.STATUS) {\n                if(data === UPDATE_STATUS.FAILED_UNKNOWN_OS && !updateFailedDialogShown){\n                    updateFailedDialogShown = true;\n                    Metrics.countEvent(Metrics.EVENT_TYPE.UPDATES, 'fail', \"Unknown\"+Phoenix.platform);\n                    updateFailed = true;\n                    updateTask.setFailed();\n                    updateTask.setMessage(Strings.UPDATE_FAILED_TITLE);\n                } else if(data === UPDATE_STATUS.FAILED && !updateFailedDialogShown){\n                    updateFailedDialogShown = true;\n                    Metrics.countEvent(Metrics.EVENT_TYPE.UPDATES, 'fail', Phoenix.platform);\n                    updateFailed = true;\n                    updateTask.setFailed();\n                    updateTask.setMessage(Strings.UPDATE_FAILED_TITLE);\n                    Dialogs.showInfoDialog(Strings.UPDATE_FAILED_TITLE, Strings.UPDATE_FAILED_MESSAGE);\n                } else if(data === UPDATE_STATUS.INSTALLER_DOWNLOADED){\n                    Metrics.countEvent(Metrics.EVENT_TYPE.UPDATES, 'downloaded', Phoenix.platform);\n                    updatePendingRestart = true;\n                    updateTask.setSucceded();\n                    updateTask.setTitle(Strings.UPDATE_DONE);\n                    updateTask.setMessage(Strings.UPDATE_RESTART_INSTALL);\n                    if(!updateInstalledDialogShown){\n                        NotificationUI.createToastFromTemplate(Strings.UPDATE_READY_RESTART_TITLE,\n                            `<div>${Strings.UPDATE_READY_RESTART_INSTALL_MESSAGE}</div>`, {\n                                toastStyle: NotificationUI.NOTIFICATION_STYLES_CSS_CLASS.SUCCESS,\n                                dismissOnClick: true\n                            });\n                        updateInstalledDialogShown = true;\n                    }\n                    _sendUpdateCommand(UPDATE_COMMANDS.GET_INSTALLER_LOCATION);\n                } else if(data === UPDATE_STATUS.DOWNLOADING){\n                    updateTask.setMessage(Strings.UPDATE_DOWNLOADING);\n                    _sendUpdateCommand(UPDATE_COMMANDS.GET_DOWNLOAD_PROGRESS);\n                }\n                showOrHideUpdateIcon();\n            } else if(eventName === UPDATE_EVENT.DOWNLOAD_PROGRESS) {\n                const {progressPercent, fileSize} = data;\n                updateTask.setProgressPercent(progressPercent);\n                updateTask.setMessage(StringUtils.format(Strings.UPDATE_DOWNLOAD_PROGRESS,\n                    Math.floor(fileSize*progressPercent/100),\n                    fileSize));\n            } else if(eventName === UPDATE_EVENT.INSTALLER_LOCATION) {\n                installerLocation = data;\n                Phoenix.app.registerQuitTimeAppUpdateHandler(quitTimeAppUpdateHandler);\n            } else if(eventName === UPDATE_EVENT.LOG_ERROR) {\n                logger.reportErrorMessage(data);\n            }\n        });\n        $(\"#update-notification\").click(()=>{\n            checkForUpdates();\n        });\n        CommandManager.register(Strings.CMD_CHECK_FOR_UPDATE, Commands.HELP_CHECK_UPDATES, ()=>{\n            checkForUpdates();\n        });\n        CommandManager.register(Strings.CMD_AUTO_UPDATE, Commands.HELP_AUTO_UPDATE, ()=>{\n            PreferencesManager.set(PREFS_AUTO_UPDATE, !PreferencesManager.get(PREFS_AUTO_UPDATE));\n        });\n        const helpMenu = Menus.getMenu(Menus.AppMenuBar.HELP_MENU);\n        helpMenu.addMenuItem(Commands.HELP_CHECK_UPDATES, \"\", Menus.AFTER, Commands.HELP_GET_INVOLVED);\n        // auto update is not added to help menu toggle as it will lead to install base version\n        // fragmentation, and we don't want an android version fragment situation. By default, all platforms\n        // are supported at latest version. User still has option to edit preferences manually to disable the auto\n        // update option.\n        PreferencesManager.definePreference(PREFS_AUTO_UPDATE, \"boolean\", true, {\n            description: Strings.DESCRIPTION_AUTO_UPDATE\n        });\n        showOrHideUpdateIcon();\n        _refreshUpdateStatus();\n        const lastUpdateDetails = PreferencesManager.getViewState(KEY_LAST_UPDATE_DESCRIPTION);\n        if(lastUpdateDetails && (lastUpdateDetails.updateVersion === Phoenix.metadata.apiVersion)) {\n            let markdownHtml = marked.parse(lastUpdateDetails.releaseNotesMarkdown || \"\");\n            Dialogs.showInfoDialog(Strings.UPDATE_WHATS_NEW, markdownHtml);\n            PreferencesManager.setViewState(KEY_LAST_UPDATE_DESCRIPTION, null);\n            PreferencesManager.setViewState(KEY_UPDATE_AVAILABLE, false);\n            // hide the update available icon as we are showing what's new dialog. In edge cases, there can be an update\n            // at this time if the user opened phcode after an update, but a new update was just published or the user\n            // didn't open phcode after last update, which a new update was published.\n            $(\"#update-notification\").addClass(\"forced-hidden\");\n        }\n        // check for updates at boot\n        let lastUpdateCheckTime = PreferencesManager.getViewState(KEY_LAST_UPDATE_CHECK_TIME);\n        const currentTime = Date.now();\n        const oneDayInMilliseconds = 24 * 60 * 60 * 1000; // 24 hours * 60 minutes * 60 seconds * 1000 milliseconds\n        if(lastUpdateCheckTime && ((currentTime - lastUpdateCheckTime) < oneDayInMilliseconds)){\n            console.log(\"Skipping update check: last update check was within one day\");\n            return;\n        }\n        PreferencesManager.setViewState(KEY_LAST_UPDATE_CHECK_TIME, currentTime);\n        checkForUpdates(true);\n    });\n});\n"],"file":"main.js"}