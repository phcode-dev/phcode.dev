{"version":3,"sources":["filesystem/Directory.js"],"names":["define","require","exports","module","FileSystemEntry","FileSystem","Directory","fullPath","fileSystem","this","_isDirectory","call","_applyAllCallbacks","callbacks","args","length","callback","pop","apply","undefined","prototype","Object","create","constructor","parentClass","_contents","_contentsStats","_contentsStatsErrors","_clearCachedData","preserveImmediateChildren","forEach","child","dirPath","_fileSystem","_index","visitAll","entry","parentPath","isEmptyAsync","that","Promise","resolve","reject","getContents","err","contents","unlinkEmptyDirectoryAsync","async","entries","getContentsAsync","isEmpty","isDirectory","unlinkAsync","filterNothing","entriesStats","entriesStatsErrors","_contentsCallbacks","push","_impl","readdir","names","stats","contentsStats","contentsStatsErrors","watched","_isWatched","name","index","entryPath","entryStats","fileTreeFilter","isFile","getFileForPath","getDirectoryForPath","_stat","currentCallbacks","callbackArgs","bind","createAsync","stat","_beginChange","mkdir","_path","_endChange","parent","_handleDirectoryChange","added","removed","_fireChangeEvent"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n// @INCLUDE_IN_API_DOCS\n\n\ndefine(function (require, exports, module) {\n\n\n    const FileSystemEntry = require(\"filesystem/FileSystemEntry\"),\n        FileSystem = require(\"filesystem/FileSystem\");\n\n    /**\n     * Model for a file system Directory.\n     *\n     * This class should *not* be instantiated directly. Use FileSystem.getDirectoryForPath,\n     * FileSystem.resolve, or Directory.getContents to create an instance of this class.\n     *\n     * Note: Directory.fullPath always has a trailing slash.\n     *\n     * See the FileSystem class for more details.\n     *\n     * @constructor\n     * @param {!string} fullPath The full path for this Directory.\n     * @param {!FileSystem} fileSystem The file system associated with this Directory.\n     */\n    function Directory(fullPath, fileSystem) {\n        this._isDirectory = true;\n        FileSystemEntry.call(this, fullPath, fileSystem);\n    }\n\n    Directory.prototype = Object.create(FileSystemEntry.prototype);\n    Directory.prototype.constructor = Directory;\n    Directory.prototype.parentClass = FileSystemEntry.prototype;\n\n    /**\n     * The contents of this directory. This \"private\" property is used by FileSystem.\n     * @private\n     * @type {Array<FileSystemEntry>}\n     */\n    Directory.prototype._contents = null;\n\n    /**\n     * The stats for the contents of this directory, such that this._contentsStats[i]\n     * corresponds to this._contents[i].\n     * @private\n     * @type {Array.<FileSystemStats>}\n     */\n    Directory.prototype._contentsStats = null;\n\n    /**\n     * The stats errors for the contents of this directory.\n     * @private\n     * @type {Object.<string, string>} Full paths are mapped to FileSystemError strings.\n     */\n    Directory.prototype._contentsStatsErrors = null;\n\n    /**\n     * Clear any cached data for this directory. By default, we clear the contents\n     * of immediate children as well, because in some cases file watchers fail\n     * provide precise change notifications. (Sometimes, like after a \"git\n     * checkout\", they just report that some directory has changed when in fact\n     * many of the file within the directory have changed.\n     *\n     * @private\n     * @param {boolean=} preserveImmediateChildren\n     */\n    Directory.prototype._clearCachedData = function (preserveImmediateChildren) {\n        FileSystemEntry.prototype._clearCachedData.apply(this);\n\n        if (!preserveImmediateChildren) {\n            if (this._contents) {\n                this._contents.forEach(function (child) {\n                    child._clearCachedData(true);\n                });\n            } else {\n                // No cached _contents, but child entries may still exist.\n                // Scan the full index to catch all of them.\n                var dirPath = this.fullPath;\n                this._fileSystem._index.visitAll(function (entry) {\n                    if (entry.parentPath === dirPath) {\n                        entry._clearCachedData(true);\n                    }\n                });\n            }\n        }\n\n        this._contents = undefined;\n        this._contentsStats = undefined;\n        this._contentsStatsErrors = undefined;\n    };\n\n    /**\n     * Apply each callback in a list to the provided arguments. Callbacks\n     * can throw without preventing other callbacks from being applied.\n     *\n     * @private\n     * @param {Array.<function>} callbacks The callbacks to apply\n     * @param {Array} args The arguments to which each callback is applied\n     */\n    function _applyAllCallbacks(callbacks, args) {\n        if (callbacks.length > 0) {\n            var callback = callbacks.pop();\n            try {\n                callback.apply(undefined, args);\n            } finally {\n                _applyAllCallbacks(callbacks, args);\n            }\n        }\n    }\n\n    /**\n     * Returns true if is a directory exists and is empty.\n     *\n     * @return {Promise<boolean>} True if directory is empty and it exists, else false.\n     */\n    Directory.prototype.isEmptyAsync = function () {\n        let that = this;\n        return new Promise((resolve, reject) => {\n            that.getContents((err, contents) => {\n                if (err) {\n                    reject(err);\n                    return;\n                }\n                resolve(contents.length === 0);\n            });\n        });\n    };\n\n    /**\n     * Recursively deletes all empty subdirectories within the current directory. If all subdirectories are empty,\n     * the current directory itself will be deleted.\n     * A directory is considered empty if it doesn't contain any files in its subtree.\n     *\n     * If a subtree contains a large number of nested subdirectories and no files, the whole tree will be deleted.\n     * Only branches that contain a file will be retained.\n     *\n     * @returns {Promise<void>} A Promise that resolves when the operation is finished\n     * @throws {FileSystemError} If an error occurs while accessing the filesystem\n     *\n     * @example\n     *\n     * await dir.unlinkEmptyDirectoryAsync();\n     */\n    Directory.prototype.unlinkEmptyDirectoryAsync = async function () {\n        let that = this;\n        let { entries } = await that.getContentsAsync();\n        for (let entry of entries) {\n            if (entry.isDirectory) {\n                await entry.unlinkEmptyDirectoryAsync();\n            }\n        }\n        let isEmpty = await that.isEmptyAsync();\n        if (isEmpty) {\n            await that.unlinkAsync();\n        }\n    };\n\n    /**\n     * Read the contents of a Directory, returns a promise. It filters out all files\n     * that are not shown in the file tree by default, unless the filterNothing option is specified.\n     *\n     * @param {boolean} filterNothing - is specified, will return a true contents of dir as shown in disc,\n     *      weather it is shown in the file tree or not. Can be used for backup/restore flows.\n     *\n     * @return {{entries: FileSystemEntry, contentStats: FileSystemStats, contentsStatsErrors}} An object\n     * with attributes - entries(an array of file system entries), contentStats and contentsStatsErrors(a map from\n     * content name to error if there is any).\n     */\n    Directory.prototype.getContentsAsync = function (filterNothing = false) {\n        let that = this;\n        return new Promise((resolve, reject) => {\n            that.getContents((err, contents, entriesStats, entriesStatsErrors) => {\n                if (err) {\n                    reject(err);\n                    return;\n                }\n                resolve({ entries: contents, entriesStats, entriesStatsErrors });\n            }, filterNothing);\n        });\n    };\n\n    /**\n     * Read the contents of a Directory. It filters out all files\n     * that are not shown in the file tree by default, unless the filterNothing option is specified.\n     *\n     * @param {function (?string, Array.<FileSystemEntry>=, Array.<FileSystemStats>=, Object.<string, string>=)} callback\n     *          Callback that is passed an error code or the stat-able contents\n     *          of the directory along with the stats for these entries and a\n     *          fullPath-to-FileSystemError string map of unstat-able entries\n     *          and their stat errors. If there are no stat errors then the last\n     *          parameter shall remain undefined.\n     * @param {boolean} filterNothing - is specified, will return a true contents of dir as shown in disc,\n     *      weather it is shown in the file tree or not. Can be used for backup/restore flows.\n     */\n    Directory.prototype.getContents = function (callback, filterNothing = false) {\n        if (!filterNothing) {\n            if (this._contentsCallbacks) {\n                // There is already a pending call for this directory's contents.\n                // Push the new callback onto the stack and return.\n                this._contentsCallbacks.push(callback);\n                return;\n            }\n\n            // Return cached contents if the directory is watched\n            // we only cache filtered results, if unfiltered results are needed, do a disc lookup again\n            // as filterNothing is usually used by disc backup flows.\n            if (this._contents) {\n                callback(null, this._contents, this._contentsStats, this._contentsStatsErrors);\n                return;\n            }\n\n            this._contentsCallbacks = [callback];\n        }\n\n        this._impl.readdir(this.fullPath, function (err, names, stats) {\n            var contents = [],\n                contentsStats = [],\n                contentsStatsErrors;\n\n            if (err) {\n                this._clearCachedData();\n            } else {\n                // Use the \"relaxed\" parameter to _isWatched because it's OK to\n                // cache data even while watchers are still starting up\n                var watched = this._isWatched(true);\n\n                names.forEach(function (name, index) {\n                    var entryPath = this.fullPath + name;\n\n                    var entryStats = stats[index];\n                    if (FileSystem.fileTreeFilter(name) || filterNothing) {\n                        var entry;\n\n                        // Note: not all entries necessarily have associated stats.\n                        if (typeof entryStats === \"string\") {\n                            // entryStats is an error string\n                            if (contentsStatsErrors === undefined) {\n                                contentsStatsErrors = {};\n                            }\n                            contentsStatsErrors[entryPath] = entryStats;\n                        } else {\n                            // entryStats is a FileSystemStats object\n                            if (entryStats.isFile) {\n                                entry = this._fileSystem.getFileForPath(entryPath);\n                            } else {\n                                entry = this._fileSystem.getDirectoryForPath(entryPath);\n                            }\n\n                            if (watched) {\n                                entry._stat = entryStats;\n                            }\n\n                            contents.push(entry);\n                            contentsStats.push(entryStats);\n                        }\n                    }\n                }, this);\n\n                if (watched && !filterNothing) {\n                    this._contents = contents;\n                    this._contentsStats = contentsStats;\n                    this._contentsStatsErrors = contentsStatsErrors;\n                }\n            }\n\n            if (!filterNothing) {\n                // Reset the callback list before we begin calling back so that\n                // synchronous reentrant calls are handled correctly.\n                var currentCallbacks = this._contentsCallbacks;\n\n                this._contentsCallbacks = null;\n\n                // Invoke all saved callbacks\n                var callbackArgs = [err, contents, contentsStats, contentsStatsErrors];\n                _applyAllCallbacks(currentCallbacks, callbackArgs);\n            } else {\n                callback(err, contents, contentsStats, contentsStatsErrors);\n            }\n        }.bind(this));\n    };\n\n    /**\n     * Create a directory and returns a promise that will resolve to a stat\n     *\n     * @return {Promise<FileSystemStats>} resolves to the stats of the newly created dir.\n     */\n    Directory.prototype.createAsync = function () {\n        let that = this;\n        return new Promise((resolve, reject) => {\n            that.create((err, stat) => {\n                if (err) {\n                    reject(err);\n                    return;\n                }\n                resolve(stat);\n            });\n        });\n    };\n\n    /**\n     * Create a directory\n     *\n     * @param {function (?string, FileSystemStats=)=} callback Callback resolved with a\n     *      FileSystemError string or the stat object for the created directory.\n     */\n    Directory.prototype.create = function (callback) {\n        callback = callback || function () { };\n\n        // Block external change events until after the write has finished\n        this._fileSystem._beginChange();\n\n        this._impl.mkdir(this._path, function (err, stat) {\n            if (err) {\n                this._clearCachedData();\n                try {\n                    callback(err);\n                    return;\n                } finally {\n                    // Unblock external change events\n                    this._fileSystem._endChange();\n                }\n            }\n\n            var parent = this._fileSystem.getDirectoryForPath(this.parentPath);\n\n            // Update internal filesystem state\n            if (this._isWatched()) {\n                this._stat = stat;\n            }\n\n            this._fileSystem._handleDirectoryChange(parent, function (added, removed) {\n                try {\n                    callback(null, stat);\n                } finally {\n                    if (parent._isWatched()) {\n                        this._fileSystem._fireChangeEvent(parent, added, removed);\n                    }\n                    // Unblock external change events\n                    this._fileSystem._endChange();\n                }\n            }.bind(this));\n        }.bind(this));\n    };\n\n    // Export this class\n    module.exports = Directory;\n});\n"],"file":"Directory.js"}