{"version":3,"sources":["view/WorkspaceManager.js"],"names":["define","require","exports","module","AppInit","EventDispatcher","KeyBindingManager","Resizer","PluginPanelView","PanelView","EditorManager","KeyEvent","EVENT_WORKSPACE_UPDATE_LAYOUT","EVENT_WORKSPACE_PANEL_SHOWN","EVENT_PANEL_SHOWN","EVENT_WORKSPACE_PANEL_HIDDEN","EVENT_PANEL_HIDDEN","MAIN_TOOLBAR_WIDTH","$windowContent","$editorHolder","$mainToolbar","$mainPluginPanel","$pluginIconsBar","panelIDMap","windowResizing","lastHiddenBottomPanelStack","lastShownBottomPanelStack","calcAvailableHeight","availableHt","height","siblings","each","i","elem","$elem","$","css","outerHeight","Math","max","updateResizeLimits","editorAreaHeight","data","window","innerWidth","triggerUpdateLayout","refreshHint","pluginPanelWidth","width","trigger","handleWindowResize","document","one","listenToResize","$panel","on","createBottomPanel","id","minSize","insertBefore","hide","bottomPanel","Panel","makeResizable","DIRECTION_VERTICAL","POSITION_TOP","undefined","createPluginPanel","$toolbarIcon","initialSize","Error","appendChild","pluginPanel","getAllPanelIDs","property","panelIDs","hasOwnProperty","push","getPanelForID","panelID","recomputeLayout","_setMockDOM","$mockWindowContent","$mockEditorHolder","$mockMainToolbar","$mockMainPluginPanel","$mockPluginIconsBar","htmlReady","addEventListener","makeEventDispatcher","event","filter","item","currentlyShownPanel","panelShowInProgress","initialSizeSetOnce","_getInitialSize","panel","setOnce","_showPluginSidePanel","panelBeingShown","DIRECTION_HORIZONTAL","POSITION_LEFT","minWidth","show","_hidePluginSidePanel","removeSizable","isPanelVisible","isVisible","_escapeKeyConsumers","addEscapeKeyEventHandler","consumerName","eventHandler","console","error","removeEscapeKeyEventHandler","_showLastHiddenPanelIfPossible","length","panelToShow","pop","canBeShown","_handleEscapeKey","allPanelsIDs","panelToHide","getPanelType","PANEL_TYPE_BOTTOM_PANEL","_handleShiftEscapeKey","_handleKeydown","keyCode","DOM_VK_ESCAPE","isInOverlayMode","Object","keys","focussedEditor","getFocusedEditor","getFocusedInlineEditor","dropdownOpen","is","canConsumeEscapeKeyEvent","shiftKey","stopPropagation","preventDefault","body","PANEL_TYPE_PLUGIN_PANEL"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2014 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n// @INCLUDE_IN_API_DOCS\n\n/**\n* Manages layout of panels surrounding the editor area, and size of the editor area (but not its contents).\n *\n * Updates panel sizes when the window is resized. Maintains the max resizing limits for panels, based on\n * currently available window size.\n *\n * Events:\n * `workspaceUpdateLayout` When workspace size changes for any reason (including panel show/hide panel resize, or the window resize).\n *              The 2nd arg is the available workspace height.\n *              The 3rd arg is a refreshHint flag for internal use (passed in to recomputeLayout)\n */\ndefine(function (require, exports, module) {\n\n\n    const AppInit                 = require(\"utils/AppInit\"),\n        EventDispatcher         = require(\"utils/EventDispatcher\"),\n        KeyBindingManager = require(\"command/KeyBindingManager\"),\n        Resizer                 = require(\"utils/Resizer\"),\n        PluginPanelView         = require(\"view/PluginPanelView\"),\n        PanelView               = require(\"view/PanelView\"),\n        EditorManager           = require(\"editor/EditorManager\"),\n        KeyEvent                = require(\"utils/KeyEvent\");\n\n\n    /**\n     * Event triggered when the workspace layout updates.\n     * @const\n     */\n    const EVENT_WORKSPACE_UPDATE_LAYOUT = \"workspaceUpdateLayout\";\n\n    /**\n     * Event triggered when a panel is shown.\n     * @const\n     */\n    const EVENT_WORKSPACE_PANEL_SHOWN = PanelView.EVENT_PANEL_SHOWN;\n\n    /**\n     * Event triggered when a panel is hidden.\n     * @const\n     */\n    const EVENT_WORKSPACE_PANEL_HIDDEN = PanelView.EVENT_PANEL_HIDDEN;\n\n    /**\n     * Width of the main toolbar in pixels.\n     * @const\n     * @private\n     */\n    const MAIN_TOOLBAR_WIDTH = 30;\n\n    /**\n     * The \".content\" vertical stack (editor + all header/footer panels)\n     * @type {jQueryObject}\n     * @private\n     */\n    var $windowContent;\n\n    /**\n     * The \"#editor-holder\": has only one visible child, the current CodeMirror instance (or the no-editor placeholder)\n     * @type {jQueryObject}\n     * @private\n     */\n    var $editorHolder;\n\n\n    /**\n     * The \"#main-toolbay\": to the right side holding plugin panels and icons\n     * @type {jQueryObject}\n     * @private\n     */\n    var $mainToolbar;\n\n    /**\n     * The \"#main-plugin-panel\": The plugin panel main container\n     * @type {jQueryObject}\n     * @private\n     */\n    let $mainPluginPanel;\n\n    /**\n     * The \"#plugin-icons-bar\": holding all the plugin icons\n     * @type {jQueryObject}\n     * @private\n     */\n    let $pluginIconsBar;\n\n    /**\n     * A map from panel ID's to all related panels\n     * @private\n     */\n    var panelIDMap = {};\n\n    /**\n     * Have we already started listening for the end of the ongoing window resize?\n     * @private\n     * @type {boolean}\n     */\n    var windowResizing = false;\n\n    let lastHiddenBottomPanelStack = [],\n        lastShownBottomPanelStack = [];\n\n\n    /**\n     * Calculates the available height for the full-size Editor (or the no-editor placeholder),\n     * accounting for the current size of all visible panels, toolbar, & status bar.\n     * @return {number}\n     * @private\n     */\n    function calcAvailableHeight() {\n        var availableHt = $windowContent.height();\n\n        $editorHolder.siblings().each(function (i, elem) {\n            var $elem = $(elem);\n            if ($elem.css(\"display\") !== \"none\" && $elem.css(\"position\") !== \"absolute\") {\n                availableHt -= $elem.outerHeight();\n            }\n        });\n\n        // Clip value to 0 (it could be negative if a panel wants more space than we have)\n        return Math.max(availableHt, 0);\n    }\n\n    /**\n     * Updates panel resize limits to disallow making panels big enough to shrink editor area below 0\n     * @private\n     */\n    function updateResizeLimits() {\n        var editorAreaHeight = $editorHolder.height();\n\n        $editorHolder.siblings().each(function (i, elem) {\n            var $elem = $(elem);\n            if ($elem.css(\"display\") === \"none\") {\n                $elem.data(\"maxsize\", editorAreaHeight);\n            } else {\n                $elem.data(\"maxsize\", editorAreaHeight + $elem.outerHeight());\n            }\n        });\n\n        $mainToolbar.data(\"maxsize\", window.innerWidth*.75);\n    }\n\n\n    /**\n     * Calculates a new size for editor-holder and resizes it accordingly, then and dispatches the \"workspaceUpdateLayout\"\n     * event. (The editors within are resized by EditorManager, in response to that event).\n     * @private\n     * @param {boolean=} refreshHint  true to force a complete refresh\n     */\n    function triggerUpdateLayout(refreshHint) {\n        // Find how much space is left for the editor\n        let editorAreaHeight = calcAvailableHeight();\n\n        $editorHolder.height(editorAreaHeight);  // affects size of \"not-editor\" placeholder as well\n\n        let pluginPanelWidth = $mainToolbar.width() - $pluginIconsBar.width();\n        $mainPluginPanel.width(pluginPanelWidth);\n\n        // Resize editor to fill the space\n        exports.trigger(EVENT_WORKSPACE_UPDATE_LAYOUT, editorAreaHeight, refreshHint);\n    }\n\n\n    /**\n     * Trigger editor area resize whenever the window is resized\n     * @private\n     */\n    function handleWindowResize() {\n        // These are not initialized in Jasmine Spec Runner window until a test\n        // is run that creates a mock document.\n        if (!$windowContent || !$editorHolder) {\n            return;\n        }\n\n        // FIXME (issue #4564) Workaround https://github.com/codemirror/CodeMirror/issues/1787\n        triggerUpdateLayout();\n\n        if (!windowResizing) {\n            windowResizing = true;\n\n            // We don't need any fancy debouncing here - we just need to react before the user can start\n            // resizing any panels at the new window size. So just listen for first mousemove once the\n            // window resize releases mouse capture.\n            $(window.document).one(\"mousemove\", function () {\n                windowResizing = false;\n                updateResizeLimits();\n            });\n        }\n    }\n\n    /** Trigger editor area resize whenever the given panel is shown/hidden/resized\n     * @private\n     * @param {!jQueryObject} $panel the jquery object in which to attach event handlers\n     */\n    function listenToResize($panel) {\n        // Update editor height when shown/hidden, & continuously as panel is resized\n        $panel.on(\"panelCollapsed panelExpanded panelResizeUpdate\", function () {\n            triggerUpdateLayout();\n        });\n        // Update max size of sibling panels when shown/hidden, & at *end* of resize gesture\n        $panel.on(\"panelCollapsed panelExpanded panelResizeEnd\", function () {\n            updateResizeLimits();\n        });\n    }\n\n\n    /**\n     * Creates a new resizable panel beneath the editor area and above the status bar footer. Panel is initially invisible.\n     * The panel's size & visibility are automatically saved & restored as a view-state preference.\n     *\n     * @param {!string} id  Unique id for this panel. Use package-style naming, e.g. \"myextension.feature.panelname\"\n     * @param {!jQueryObject} $panel  DOM content to use as the panel. Need not be in the document yet. Must have an id\n     *      attribute, for use as a preferences key.\n     * @param {number=} minSize  Minimum height of panel in px.\n     * @return {!Panel}\n     */\n    function createBottomPanel(id, $panel, minSize) {\n        $panel.insertBefore(\"#status-bar\");\n        $panel.hide();\n        updateResizeLimits();  // initialize panel's max size\n\n        let bottomPanel = new PanelView.Panel($panel, id);\n        panelIDMap[id] = bottomPanel;\n\n        Resizer.makeResizable($panel[0], Resizer.DIRECTION_VERTICAL, Resizer.POSITION_TOP, minSize,\n            false, undefined, true);\n        listenToResize($panel);\n\n        return bottomPanel;\n    }\n\n    /**\n     * Creates a new resizable plugin panel associated with the given toolbar icon. Panel is initially invisible.\n     * The panel's size & visibility are automatically saved & restored. Only one panel can be associated with a\n     * toolbar icon.\n     *\n     * @param {!string} id  Unique id for this panel. Use package-style naming, e.g. \"myextension.panelname\". will\n     *      overwrite an existing panel id if present.\n     * @param {!jQueryObject} $panel  DOM content to use as the panel. Need not be in the document yet. Must have an id\n     *      attribute, for use as a preferences key.\n     * @param {number=} minSize  Minimum height of panel in px.\n     * @param {!jQueryObject} $toolbarIcon An icon that should be present in main-toolbar to associate this panel to.\n     *      The panel will be shown only if the icon is visible on the toolbar and the user clicks on the icon.\n     * @param {?number=} initialSize  Optional Initial size of panel in px. If not given, panel will use minsize\n     *      or current size.\n     * @return {!Panel}\n     */\n    function createPluginPanel(id, $panel, minSize, $toolbarIcon, initialSize) {\n        if(!$toolbarIcon){\n            throw new Error(\"invalid $toolbarIcon provided to create createPluginPanel\");\n        }\n\n        $mainPluginPanel[0].appendChild($panel[0]);\n\n        let pluginPanel = new PluginPanelView.Panel($panel, id, $toolbarIcon, minSize, initialSize);\n        panelIDMap[id] = pluginPanel;\n        pluginPanel.hide();\n\n        return pluginPanel;\n    }\n\n    /**\n     * Returns an array of all panel ID's\n     * @returns {Array} List of ID's of all bottom panels\n     */\n    function getAllPanelIDs() {\n        var property, panelIDs = [];\n        for (property in panelIDMap) {\n            if (panelIDMap.hasOwnProperty(property)) {\n                panelIDs.push(property);\n            }\n        }\n        return panelIDs;\n    }\n\n    /**\n     * Gets the Panel interface for the given ID. Can return undefined if no panel with the ID is found.\n     * @param   {string} panelID\n     * @returns {Object} Panel object for the ID or undefined\n     */\n    function getPanelForID(panelID) {\n        return panelIDMap[panelID];\n    }\n\n    /**\n     * Called when an external widget has appeared and needs some of the space occupied\n     *  by the mainview manager\n     * @param {boolean} refreshHint true to refresh the editor, false if not\n     */\n    function recomputeLayout(refreshHint) {\n        triggerUpdateLayout(refreshHint);\n        updateResizeLimits();\n    }\n\n\n    /* Attach to key parts of the overall UI, once created */\n    AppInit.htmlReady(function () {\n        $windowContent = $(\".content\");\n        $editorHolder = $(\"#editor-holder\");\n        $mainToolbar = $(\"#main-toolbar\");\n        $mainPluginPanel = $(\"#main-plugin-panel\");\n        $pluginIconsBar = $(\"#plugin-icons-bar\");\n\n        // Sidebar is a special case: it isn't a Panel, and is not created dynamically. Need to explicitly\n        // listen for resize here.\n        listenToResize($(\"#sidebar\"));\n        listenToResize($(\"#main-toolbar\"));\n    });\n\n    /**\n     * Unit test only: allow passing in mock DOM notes, e.g. for use with SpecRunnerUtils.createMockEditor()\n     * @private\n     */\n    function _setMockDOM($mockWindowContent, $mockEditorHolder, $mockMainToolbar, $mockMainPluginPanel, $mockPluginIconsBar) {\n        $windowContent = $mockWindowContent;\n        $editorHolder = $mockEditorHolder;\n        $mainToolbar = $mockMainToolbar;\n        $mainPluginPanel = $mockMainPluginPanel;\n        $pluginIconsBar = $mockPluginIconsBar;\n    }\n\n    /* Add this as a capture handler so we're guaranteed to run it before the editor does its own\n     * refresh on resize.\n     */\n    window.addEventListener(\"resize\", handleWindowResize, true);\n\n\n    EventDispatcher.makeEventDispatcher(exports);\n\n    PanelView.on(PanelView.EVENT_PANEL_SHOWN, (event, panelID)=>{\n        lastHiddenBottomPanelStack = lastHiddenBottomPanelStack.filter(item => item !== panelID);\n        lastShownBottomPanelStack = lastShownBottomPanelStack.filter(item => item !== panelID);\n        lastShownBottomPanelStack.push(panelID);\n        exports.trigger(EVENT_WORKSPACE_PANEL_SHOWN, panelID);\n    });\n    PanelView.on(PanelView.EVENT_PANEL_HIDDEN, (event, panelID)=>{\n        lastHiddenBottomPanelStack = lastHiddenBottomPanelStack.filter(item => item !== panelID);\n        lastHiddenBottomPanelStack.push(panelID);\n        lastShownBottomPanelStack = lastShownBottomPanelStack.filter(item => item !== panelID);\n        exports.trigger(EVENT_WORKSPACE_PANEL_HIDDEN, panelID);\n    });\n\n    let currentlyShownPanel = null,\n        panelShowInProgress = false,\n        initialSizeSetOnce = {};\n\n    function _getInitialSize(panel) {\n        let setOnce = initialSizeSetOnce[panel.panelID];\n        if(setOnce){\n            return undefined; // we haev lalready set the initial size once, let resizer figure out size to apply now.\n        }\n        initialSizeSetOnce[panel.panelID] = true;\n        return panel.initialSize;\n    }\n\n    function _showPluginSidePanel(panelID) {\n        let panelBeingShown = getPanelForID(panelID);\n        Resizer.makeResizable($mainToolbar, Resizer.DIRECTION_HORIZONTAL, Resizer.POSITION_LEFT,\n            panelBeingShown.minWidth, false, undefined, true,\n            undefined, $windowContent, undefined, _getInitialSize(panelBeingShown));\n        Resizer.show($mainToolbar[0]);\n        recomputeLayout(true);\n    }\n\n    function _hidePluginSidePanel() {\n        $mainToolbar.css('width', MAIN_TOOLBAR_WIDTH);\n        $windowContent.css('right', MAIN_TOOLBAR_WIDTH);\n        Resizer.removeSizable($mainToolbar[0]);\n        recomputeLayout(true);\n    }\n\n    PluginPanelView.on(PluginPanelView.EVENT_PANEL_SHOWN, (event, panelID)=>{\n        panelShowInProgress = true;\n        _showPluginSidePanel(panelID);\n        if(currentlyShownPanel){\n            currentlyShownPanel.hide();\n        }\n        currentlyShownPanel = getPanelForID(panelID);\n        exports.trigger(EVENT_WORKSPACE_PANEL_SHOWN, panelID);\n        panelShowInProgress = false;\n    });\n\n    PluginPanelView.on(PluginPanelView.EVENT_PANEL_HIDDEN, (event, panelID)=>{\n        if(!panelShowInProgress){\n            _hidePluginSidePanel();\n            currentlyShownPanel = null;\n        }\n        exports.trigger(EVENT_WORKSPACE_PANEL_HIDDEN, panelID);\n    });\n\n    /**\n     * Responsible to check if the panel is visible or not.\n     * Returns true if visible else false.\n     * @param panelID\n     * @returns {boolean}\n     */\n    function isPanelVisible(panelID) {\n        let panel = getPanelForID(panelID);\n        if(panel && panel.isVisible()){\n            return true;\n        }\n        return false;\n    }\n\n    // Escape key and toggle panel special handling\n    let _escapeKeyConsumers = {};\n\n    /**\n     * If any widgets related to the editor needs to handle the escape key event, add it here. returning true from the\n     * registered handler will prevent primary escape key toggle panel behavior of phoenix. Note that returning true\n     * will no stop the event bubbling, that has to be controlled with the event parameter forwarded to the handler.\n     * @param {string} consumerName a unique name for your consumer\n     * @param {function(event)} eventHandler If the eventHandler returns true for this callback, the escape key event\n     *        will not lead to panel toggle default behavior.\n     * @return {boolean} true if added\n     */\n    function addEscapeKeyEventHandler(consumerName, eventHandler) {\n        if(_escapeKeyConsumers[consumerName]){\n            console.error(\"EscapeKeyEvent consumer of same name already registered: \", consumerName);\n            return false;\n        }\n        if(typeof eventHandler !== 'function'){\n            console.error(`EscapeKeyEvent invalid eventHandler: ${consumerName}, ${eventHandler}`);\n            return false;\n        }\n        _escapeKeyConsumers[consumerName] = eventHandler;\n        return true;\n    }\n\n    /**\n     * Removing the escape key event consumer.\n     * @param {string} consumerName used to register the consumer.\n     * @return {boolean} true if removed\n     */\n    function removeEscapeKeyEventHandler(consumerName) {\n        if(_escapeKeyConsumers[consumerName]){\n            delete _escapeKeyConsumers[consumerName];\n            return true;\n        } else {\n            console.error(\"EscapeKeyEvent no such consumer to remove: \", consumerName);\n        }\n        return false;\n    }\n\n    function _showLastHiddenPanelIfPossible() {\n        while(lastHiddenBottomPanelStack.length > 0){\n            let panelToShow = getPanelForID(lastHiddenBottomPanelStack.pop());\n            if(panelToShow.canBeShown()){\n                panelToShow.show();\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function _handleEscapeKey() {\n        let allPanelsIDs = getAllPanelIDs();\n        // first we see if there is any least recently shown panel\n        if(lastShownBottomPanelStack.length > 0){\n            let panelToHide = getPanelForID(lastShownBottomPanelStack.pop());\n            panelToHide.hide();\n            return true;\n        }\n        // if not, see if there is any open panels that are not yet tracked in the least recently used stacks.\n        for(let panelID of allPanelsIDs){\n            let panel = getPanelForID(panelID);\n            if(panel.getPanelType() === PanelView.PANEL_TYPE_BOTTOM_PANEL && panel.isVisible()){\n                panel.hide();\n                lastHiddenBottomPanelStack.push(panelID);\n                return true;\n            }\n        }\n        // no panels hidden, we will toggle the last hidden panel with succeeding escape key presses\n        return _showLastHiddenPanelIfPossible();\n    }\n\n    function _handleShiftEscapeKey() {\n        // show hidden panels one by one\n        return _showLastHiddenPanelIfPossible();\n    }\n\n    // pressing escape when focused on editor will toggle the last opened bottom panel\n    function _handleKeydown(event) {\n        if(event.keyCode !== KeyEvent.DOM_VK_ESCAPE || KeyBindingManager.isInOverlayMode()){\n            return;\n        }\n\n        for(let consumerName of Object.keys(_escapeKeyConsumers)){\n            if(_escapeKeyConsumers[consumerName](event)){\n                return;\n            }\n        }\n\n        let focussedEditor = EditorManager.getFocusedEditor();\n        if(!focussedEditor || EditorManager.getFocusedInlineEditor()){\n            // if there is no editor in focus, we do no panel toggling\n            // if there is an editor with an inline widget in focus, the escape key will be\n            // handled by the inline widget itself first.\n            return;\n        }\n        const dropdownOpen = $(\".dropdown.open\").is(\":visible\");\n        if(dropdownOpen || focussedEditor.canConsumeEscapeKeyEvent()){\n            return;\n        }\n\n        if (event.keyCode === KeyEvent.DOM_VK_ESCAPE  && event.shiftKey) {\n            _handleShiftEscapeKey();\n        } else if (event.keyCode === KeyEvent.DOM_VK_ESCAPE) {\n            _handleEscapeKey();\n        }\n\n        event.stopPropagation();\n        event.preventDefault();\n    }\n    window.document.body.addEventListener(\"keydown\", _handleKeydown, true);\n\n    // Define public API\n    exports.createBottomPanel               = createBottomPanel;\n    exports.createPluginPanel               = createPluginPanel;\n    exports.isPanelVisible                  = isPanelVisible;\n    exports.recomputeLayout                 = recomputeLayout;\n    exports.getAllPanelIDs                  = getAllPanelIDs;\n    exports.getPanelForID                   = getPanelForID;\n    exports.addEscapeKeyEventHandler        = addEscapeKeyEventHandler;\n    exports.removeEscapeKeyEventHandler     = removeEscapeKeyEventHandler;\n    exports._setMockDOM                     = _setMockDOM;\n    exports.EVENT_WORKSPACE_UPDATE_LAYOUT   = EVENT_WORKSPACE_UPDATE_LAYOUT;\n    exports.EVENT_WORKSPACE_PANEL_SHOWN     = EVENT_WORKSPACE_PANEL_SHOWN;\n    exports.EVENT_WORKSPACE_PANEL_HIDDEN    = EVENT_WORKSPACE_PANEL_HIDDEN;\n\n    /**\n     * Constant representing the type of bottom panel\n     * @type {string}\n     */\n    exports.PANEL_TYPE_BOTTOM_PANEL         = PanelView.PANEL_TYPE_BOTTOM_PANEL;\n\n    /**\n     * Constant representing the type of plugin panel\n     * @type {string}\n     */\n    exports.PANEL_TYPE_PLUGIN_PANEL         = PluginPanelView.PANEL_TYPE_PLUGIN_PANEL;\n});\n"],"file":"WorkspaceManager.js"}