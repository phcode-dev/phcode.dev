{"version":3,"sources":["utils/ZipUtils.js"],"names":["define","require","exports","module","FileSystem","FileSystemError","ignoredFolders","async","_ensureExistsAsync","path","Promise","resolve","reject","Phoenix","VFS","ensureExistsDir","err","_copyZippedItemToFS","item","destProjectDir","flattenFirstLevel","zipControl","destPath","newPath","substr","indexOf","console","log","dir","window","dirname","then","data","continueExtraction","fs","writeFile","Filer","Buffer","from","encoding","BYTE_ARRAY_ENCODING","writeErr","catch","error","e","_isNestedContentDir","zip","keys","Object","files","rootEntries","filePath","endsWith","slice","includes","baseName","split","length","unzipBinDataToLocation","zipData","projectDir","progressControlCallback","JSZip","loadAsync","extractBatchSize","isNestedContent","extractError","totalCount","doneCount","extractPromises","_unzipProgress","_extractFailed","extractPromise","push","allSettled","_readContent","fileEntry","read","content","stat","NOT_FOUND","blob","Blob","type","zipFolder","fullPath","directory","getDirectoryForPath","getAllDirectoryContents","entry","contents","relativePath","relative","isDirectory","folder","file","unzipURLToLocation","url","JSZipUtils","getBinaryContent"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n// @INCLUDE_IN_API_DOCS\n\n/*globals Phoenix, JSZip, Filer, path*/\n\ndefine(function (require, exports, module) {\n    const FileSystem = require(\"filesystem/FileSystem\"),\n        FileSystemError = require(\"filesystem/FileSystemError\");\n\n    const ignoredFolders = [ \"__MACOSX\" ];\n\n    async function _ensureExistsAsync(path) {\n        return new Promise((resolve, reject)=>{\n            Phoenix.VFS.ensureExistsDir(path, (err)=>{\n                if(err){\n                    reject(err);\n                } else {\n                    resolve();\n                }\n            });\n        });\n    }\n\n    function _copyZippedItemToFS(path, item, destProjectDir, flattenFirstLevel, zipControl) {\n        return new Promise(async (resolve, reject) =>{ // eslint-disable-line\n            try {\n                let destPath = `${destProjectDir}${path}`;\n                if(flattenFirstLevel){\n                    // contents/index.html to index.html\n                    let newPath = path.substr(path.indexOf(\"/\") + 1);\n                    destPath = `${destProjectDir}${newPath}`;\n                    console.log(destPath);\n                }\n                if(item.dir){\n                    await _ensureExistsAsync(destPath);\n                    resolve(destPath);\n                } else {\n                    await _ensureExistsAsync(window.path.dirname(destPath));\n                    item.async(\"uint8array\").then(function (data) {\n                        if(zipControl && !zipControl.continueExtraction){\n                            reject(\"aborted\");\n                            return;\n                        }\n                        window.fs.writeFile(destPath, Filer.Buffer.from(data),\n                            {encoding: window.fs.BYTE_ARRAY_ENCODING}, writeErr=>{\n                                if(writeErr){\n                                    reject(writeErr);\n                                } else {\n                                    resolve(destPath);\n                                }\n                            });\n                    }).catch(error=>{\n                        reject(error);\n                    });\n                }\n            } catch (e) {\n                reject(e);\n            }\n        });\n    }\n\n    function _isNestedContentDir(zip) {\n        let keys = Object.keys(zip.files);\n        let rootEntries = {};\n        for(let path of keys){\n            let filePath = path.endsWith(\"/\") ? path.slice(0, -1) : path; // trim last slah if present\n            let item = zip.files[path];\n            if(!item.dir && !filePath.includes(\"/\")) { // file in root folder means not nested zip\n                return false;\n            }\n            let baseName = filePath.split(\"/\")[0];\n            if(!ignoredFolders.includes(baseName)){\n                rootEntries[baseName] = true;\n            }\n        }\n        if(Object.keys(rootEntries).length === 1) {\n            // lone content folder\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Extracts a given binary zip data array to a specified location.\n     * @param {UInt8Array} zipData - Binary zip data.\n     * @param {string} projectDir - Directory to extract to.\n     * @param {boolean} flattenFirstLevel - If set to true, then if zip contents are nested inside a directory,\n     *          the nested directory will be removed in the path structure in the destination. For example,\n     *          some zip may contain a `contents` folder inside the zip which has all the files. If we blindly\n     *          extract the zip, all the contents will be placed inside a `contents` folder in the root instead \n     *          of the root directory itself. \n     *          See a sample zip file here: https://api.github.com/repos/StartBootstrap/startbootstrap-grayscales/zipball\n     * @param {function(number, number): boolean} [progressControlCallback] - A function that can be used\n     *          to view the progress and stop further extraction. The function will be invoked with (doneCount, totalCount).\n     *          The function should return `false` if further extraction needs to be stopped. If nothing or `true` is returned,\n     *          it will continue extraction.\n     * @returns {Promise} - A promise that resolves when extraction is complete.\n     */\n    function unzipBinDataToLocation(zipData, projectDir, flattenFirstLevel = false, progressControlCallback) {\n        if(!projectDir.endsWith('/')){\n            projectDir = projectDir + \"/\";\n        }\n        return new Promise((resolve, reject)=>{\n            JSZip.loadAsync(zipData).then(async function (zip) {\n                let keys = Object.keys(zip.files);\n                try{\n                    const extractBatchSize = 500;\n                    const isNestedContent = _isNestedContentDir(zip);\n                    let extractError;\n                    let totalCount = keys.length,\n                        doneCount = 0,\n                        extractPromises = [],\n                        zipControl = {\n                            continueExtraction: true\n                        };\n                    function _unzipProgress() {\n                        doneCount ++;\n                        if(progressControlCallback){\n                            zipControl.continueExtraction = zipControl.continueExtraction\n                                && progressControlCallback(doneCount, totalCount);\n                        }\n                    }\n                    function _extractFailed(err) {\n                        extractError = err || \"extract failed\";\n                    }\n                    for(let path of keys){\n                        // This is intentionally batched as fs access api hangs on large number of file access\n                        let extractPromise = _copyZippedItemToFS(path, zip.files[path], projectDir,\n                            isNestedContent && flattenFirstLevel, zipControl);\n                        // eslint-disable-next-line no-loop-func\n                        extractPromise.then(_unzipProgress)\n                            .catch(_extractFailed);\n                        extractPromises.push(extractPromise);\n                        if(extractPromises.length === extractBatchSize){\n                            await Promise.allSettled(extractPromises);\n                            extractPromises = [];\n                        }\n                        if(zipControl.continueExtraction === false){\n                            reject(`Extraction cancelled by progress controller`);\n                            return;\n                        }\n                        if(extractError){\n                            reject(extractError);\n                            return;\n                        }\n                    }\n                    if(extractPromises.length) {\n                        await Promise.allSettled(extractPromises);\n                    }\n                    if(extractError){\n                        reject(extractError);\n                        return;\n                    }\n                    console.log(\"Unzip complete: \", projectDir);\n                    resolve();\n                } catch (err) {\n                    console.error('unzip failed', err);\n                    reject(err);\n                }\n            });\n        });\n    }\n\n    function _readContent(fileEntry) {\n        return new Promise((resolve, reject)=>{\n            fileEntry.read({encoding: window.fs.BYTE_ARRAY_ENCODING}, function (err, content, encoding, stat) {\n                if (err){\n                    if(err === FileSystemError.NOT_FOUND){\n                        // this error is ok as the file may have been deleted while we were doing the backup.\n                        resolve(null);\n                        return;\n                    }\n                    reject(err);\n                    return;\n                }\n                let blob = new Blob([content], {type:\"application/octet-stream\"});\n                resolve(blob);\n            });\n        });\n    }\n\n    /**\n     * Zips a given folder located at path to a jsZip object.\n     * @param {string} fullPath to zip\n     * @return {Promise<JSZip>} zip object\n     */\n    function zipFolder(fullPath) {\n        return new Promise((resolve, reject)=>{\n            const zip = new JSZip();\n            let directory = FileSystem.getDirectoryForPath(fullPath);\n            FileSystem.getAllDirectoryContents(directory, true).then(async contents => {\n                for(let entry of contents){\n                    let relativePath = path.relative(fullPath, entry.fullPath);\n                    if(entry.isDirectory){\n                        zip.folder(relativePath);\n                    } else {\n                        let blob = await _readContent(entry);\n                        if(blob){\n                            zip.file(relativePath, blob);\n                        }\n                    }\n                }\n                resolve(zip);\n            }).catch(reject);\n        });\n    }\n\n    /**\n     *\n     * @param url the zip fle URL\n     * @param projectDir To extract to\n     * @param flattenFirstLevel if set to true, then if zip contents are nested inside a directory, the nexted dir will\n     * be removed in the path structure in destination. For Eg. some Zip may contain a `contents` folder inside the zip\n     * which has all the contents. If we blindly extract the zio, all the contents will be placed inside a `contents`\n     * folder in root and not the root dir itself.\n     * See a sample zip file here: https://api.github.com/repos/StartBootstrap/startbootstrap-grayscales/zipball\n     * @returns {Promise}\n     */\n    function unzipURLToLocation(url, projectDir, flattenFirstLevel = false) {\n        return new Promise((resolve, reject)=>{\n            window.JSZipUtils.getBinaryContent(url, async function(err, data) {\n                if(err) {\n                    console.error(`could not load zip from URL: ${url}\\n `, err);\n                    reject();\n                } else {\n                    unzipBinDataToLocation(data, projectDir, flattenFirstLevel)\n                        .then(resolve)\n                        .catch(reject);\n                }\n            });\n        });\n    }\n    exports.unzipBinDataToLocation = unzipBinDataToLocation;\n    exports.unzipURLToLocation = unzipURLToLocation;\n    exports.zipFolder = zipFolder;\n});\n"],"file":"ZipUtils.js"}