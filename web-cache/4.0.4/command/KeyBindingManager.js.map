{"version":3,"sources":["command/KeyBindingManager.js"],"names":["define","require","exports","module","AppInit","Commands","CommandManager","DefaultDialogs","EventDispatcher","FileSystem","FileSystemError","FileUtils","KeyEvent","Strings","Keys","KeyboardOverlayMode","StringUtils","Metrics","Dialogs","Mustache","UrlParams","_","KeyboardPrefs","JSON","parse","KeyboardDialogTemplate","KEYMAP_FILENAME","_userKeyMapFilePath","path","normalize","brackets","app","getApplicationSupportDirectory","EVENT_KEY_BINDING_ADDED","EVENT_KEY_BINDING_REMOVED","EVENT_NEW_PRESET","EVENT_PRESET_CHANGED","KEY","knownBindableCommands","Set","_loadUserKeyMap","debounce","_loadUserKeyMapImmediate","PreferencesManager","_customKeymapIDInUse","_registeredCustomKeyMaps","STATE_CUSTOM_KEY_MAP_ID","PREF_TRIPLE_CTRL_KEY_PRESS_ENABLED","_keyMap","_defaultKeyMap","_originalUserKeyMap","_customKeyMap","_customKeyMapCache","_commandMap","_allCommands","_displayKeyMap","up","down","left","right","-","_specialCommands","EDIT_UNDO","EDIT_REDO","EDIT_SELECT_ALL","EDIT_CUT","EDIT_COPY","EDIT_PASTE","_reservedShortcuts","_macReservedShortcuts","_keyNames","_showErrors","_enabled","_globalKeydownHooks","CtrlDownStates","NOT_YET_DETECTED","DETECTED","DETECTED_AND_IGNORED","_ctrlDown","_altGrDown","_lastTimeStamp","_lastKeyIdentifier","MAX_INTERVAL_FOR_CTRL_ALT_KEYS","_onCtrlUp","_quitAltGrMode","$","window","off","_detectAltGrKeyDown","e","platform","key","altKey","ctrlKey","repeat","timeStamp","on","_reset","_buildKeyDescriptor","hasMacCtrl","hasCtrl","hasAlt","hasShift","console","log","keyDescriptor","push","unshift","join","normalizeKeyDescriptorString","origDescriptor","error","_compareModifierString","trim","toLowerCase","length","split","forEach","parseDescriptor","ele","i","arr","search","indexOf","test","capitalize","replace","match","p1","_mapKeycodeToKeyLegacy","keycode","DOM_VK_0","DOM_VK_9","DOM_VK_A","DOM_VK_Z","String","fromCharCode","DOM_VK_NUMPAD0","DOM_VK_NUMPAD9","DOM_VK_SEMICOLON","DOM_VK_EQUALS","DOM_VK_COMMA","DOM_VK_SUBTRACT","DOM_VK_DASH","DOM_VK_ADD","DOM_VK_DECIMAL","DOM_VK_PERIOD","DOM_VK_DIVIDE","DOM_VK_SLASH","DOM_VK_BACK_QUOTE","DOM_VK_OPEN_BRACKET","DOM_VK_BACK_SLASH","DOM_VK_CLOSE_BRACKET","DOM_VK_QUOTE","_mapKeycodeToKey","event","metaKey","keyCode","codes","ArrowUp","ArrowDown","ArrowLeft","ArrowRight"," ","_translateKeyboardEvent","formatKeyDescriptor","descriptor","displayStr","KEYBOARD_CTRL","KEYBOARD_SHIFT","KEYBOARD_SPACE","KEYBOARD_PAGE_UP","KEYBOARD_PAGE_DOWN","KEYBOARD_HOME","KEYBOARD_END","KEYBOARD_INSERT","KEYBOARD_DELETE","_isKeyAssigned","undefined","removeBinding","normalizedKey","binding","command","get","commandID","bindings","filter","b","trigger","displayKey","getID","_updateCommandAndKeyMaps","newBinding","cloneDeep","_addBinding","keyBinding","userBindings","isMenuShortcut","add","result","normalized","normalizedDisplay","explicitPlatform","explicitBrowserOnly","browserOnly","explicitNativeOnly","nativeOnly","targetPlatform","bindingsToDelete","existing","Phoenix","isNativeApp","isSingleCharAZ","str","keySplit","useWindowsCompatibleBindings","existingBindings","isWindowsCompatible","isReplaceGeneric","ignoreGeneric","getKeymap","defaults","extend","_makeMapFromArray","map","item","which","DOM_VK_CONTROL","UN_SWALLOWED_EVENTS","UN_SWALLOWED_KEYS","concat","_isUnSwallowedKeys","_handleKey","countEvent","EVENT_TYPE","KEYBOARD","logger","leaveTrail","eventDetails","_options","eventSource","SOURCE_KEYBOARD_SHORTCUT","sourceType","promise","execute","state","_sortByPlatform","a","a1","b1","addBinding","keyBindings","options","results","Array","isArray","sort","keyBindingRequest","getKeyBindings","getKeyBindingsDisplay","shortCut","_handledCommands","_handleCommandRegistered","commandId","_initDefaultShortcuts","addGlobalKeydownHook","hook","index","removeGlobalKeydownHook","splice","lastCtrlKeyPressTime","pressCount","doublePressInterval","PRESS_ACTIVATE_COUNT","ctrlKeyCodes","ControlLeft","ControlRight","MetaLeft","MetaRight","Control","Meta","isCtrlDepressed","_detectTripleCtrlKeyPress","isCtrlKeyPressStart","code","currentTime","Date","getTime","shiftKey","startOverlayMode","stopPropagation","preventDefault","dontHideMouseOnKeys","Escape","Home","End","PageUp","PageDown","Shift","Alt","F1","F2","F3","F4","F5","F6","F7","F8","F9","F10","F11","F12","Insert","ContextMenu","NumLock","ScrollLock","CapsLock","mouseCursorHidden","_hideMouseCursonOnTyping","isSpecRunnerWindow","document","body","classList","_handleKeyEvent","isInOverlayMode","processOverlayKeyboardEvent","shortcut","handled","keyboardShortcutCaptureInProgress","updateShortcutSelection","_showErrorsAndOpenKeyMap","err","message","errorMessage","ERROR_KEYMAP_CORRUPT","UNSUPPORTED_ENCODING","ERROR_LOADING_KEYMAP","showModalDialog","DIALOG_ID_ERROR","ERROR_KEYMAP_TITLE","done","FILE_OPEN_KEYMAP","_isSpecialCommand","_isReservedShortcuts","_getBulletList","list","info","_getDisplayKey","substr","_applyUserKeyBindings","remappedCommands","remappedKeys","restrictedCommands","restrictedKeys","invalidKeys","invalidCommands","multipleKeys","duplicateBindings","keybinding","format","ERROR_RESTRICTED_COMMANDS","ERROR_RESTRICTED_SHORTCUTS","ERROR_MULTIPLE_SHORTCUTS","ERROR_DUPLICATE_SHORTCUTS","ERROR_INVALID_SHORTCUTS","ERROR_NONEXISTENT_COMMANDS","_undoPriorUserKeyBindings","find","toArray","defaultCommand","_getUserKeyMapFilePath","isBracketsTestWindow","async","_addToUserKeymapFile","file","getFileForPath","userKeyMap","overrides","keyMapExists","VFS","existsAsync","fullPath","text","deferredToPromise","readAsText","shortcutKey","Object","keys","textContent","stringify","writeText","_readUserKeyMap","Deferred","exists","doesExist","keyMap","json","resolve","reject","fail","registerCustomKeymapPack","packID","packName","packageName","_getNormalisedKeyMap","getAllCustomKeymapPacks","packDetails","structuredClone","getCurrentCustomKeymapPack","_getCustomShortcutOrigin","hasOwnProperty","KEYBOARD_SHORTCUT_SRC_USER","KEYBOARD_SHORTCUT_SRC_PRESET","_setCurrentCustomKeymapPack","Error","stateManager","set","_mixCustomKeyMaps","customKeyMap","userDefinedKeys","userDefinedCommandIDs","values","customKey","customCommand","includes","normalisedKeyMap","normalisedKeyMapCounts","normalisedKey","Promise","then","getAll","resetUserShortcutsAsync","userKeyMapPath","defaultContent","catch","_openUserKeyMap","FILE_OPEN","finally","_initCommandAndKeyMaps","_setUserKeyMapFilePath","_isAnAssignableKey","warn","capturedShortcut","existingBinding","keyboardShortcutDialog","close","html","KEYBOARD_SHORTCUT_CHANGE_DIALOG_DUPLICATE","getName","removeClass","focus","addClass","htmlReady","addEventListener","remove","on_duringInit","register","CMD_OPEN_KEYMAP","DocumentManager","checkKeyMapUpdates","doc","extensionsLoaded","params","globalAPI","definePreference","constructor","description","DESCRIPTION_TRIPLE_CTRL_PALETTE","showShortcutSelectionDialog","panelCommand","HELP_TOGGLE_SHORTCUTS_PANEL","currentShortcutText","KEYBOARD_SHORTCUT_NONE","showModalDialogUsingTemplate","render","KEYBOARD_SHORTCUT_CHANGE_DIALOG_TEXT","getChecked","closeReason","k","DIALOG_BTN_OK","canAssignBinding","_getKnownBindableCommands","makeEventDispatcher"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n// @INCLUDE_IN_API_DOCS\n\n/*globals path, logger*/\n/*jslint regexp: true */\n/*unittests: KeyBindingManager */\n\n/**\n * Manages the mapping of keyboard inputs to commands.\n */\ndefine(function (require, exports, module) {\n\n\n    require(\"utils/Global\");\n\n    let AppInit             = require(\"utils/AppInit\"),\n        Commands            = require(\"command/Commands\"),\n        CommandManager      = require(\"command/CommandManager\"),\n        DefaultDialogs      = require(\"widgets/DefaultDialogs\"),\n        EventDispatcher     = require(\"utils/EventDispatcher\"),\n        FileSystem          = require(\"filesystem/FileSystem\"),\n        FileSystemError     = require(\"filesystem/FileSystemError\"),\n        FileUtils           = require(\"file/FileUtils\"),\n        KeyEvent            = require(\"utils/KeyEvent\"),\n        Strings             = require(\"strings\"),\n        Keys                = require(\"command/Keys\"),\n        KeyboardOverlayMode = require(\"command/KeyboardOverlayMode\"),\n        StringUtils         = require(\"utils/StringUtils\"),\n        Metrics             = require(\"utils/Metrics\"),\n        Dialogs                 = require(\"widgets/Dialogs\"),\n        Mustache            = require(\"thirdparty/mustache/mustache\"),\n        UrlParams           = require(\"utils/UrlParams\").UrlParams,\n        _                   = require(\"thirdparty/lodash\");\n\n    let KeyboardPrefs       = JSON.parse(require(\"text!base-config/keyboard.json\"));\n    let KeyboardDialogTemplate = require(\"text!./ChangeShortcutTemplate.html\");\n\n    let KEYMAP_FILENAME     = \"keymap.json\",\n        _userKeyMapFilePath = path.normalize(brackets.app.getApplicationSupportDirectory() + \"/\" + KEYMAP_FILENAME);\n\n    /**\n     * key binding add event\n     *\n     * @const\n     * @type {string}\n     */\n    const EVENT_KEY_BINDING_ADDED = \"keyBindingAdded\";\n\n    /**\n     * key binding remove event\n     *\n     * @const\n     * @type {string}\n     */\n    const EVENT_KEY_BINDING_REMOVED = \"keyBindingRemoved\";\n\n    /**\n     * new preset event\n     *\n     * @const\n     * @type {string}\n     */\n    const EVENT_NEW_PRESET = \"newPreset\";\n\n    /**\n     * preset change event\n     *\n     * @const\n     * @type {string}\n     */\n    const EVENT_PRESET_CHANGED = \"presetChanged\";\n\n    /**\n     * @const\n     * @type {Object}\n     */\n    const KEY = Keys.KEY;\n\n    const knownBindableCommands = new Set();\n\n    /**\n     * Forward declaration for JSLint.\n     *\n     * @private\n     * @type {Function}\n     */\n    let _loadUserKeyMap = _.debounce(_loadUserKeyMapImmediate, 200);\n    let PreferencesManager;\n    let _customKeymapIDInUse;\n    const _registeredCustomKeyMaps = {};\n\n    const STATE_CUSTOM_KEY_MAP_ID = \"customKeyMapID\";\n    const PREF_TRIPLE_CTRL_KEY_PRESS_ENABLED = \"tripleCtrlPalette\";\n\n    /**\n     * Maps normalized shortcut descriptor to key binding info.\n     *\n     * @private\n     * @type {!Object.<string, {commandID: string, key: string, displayKey: string}>}\n     */\n    let _keyMap            = {},    // For the actual key bindings including user specified ones\n        // For the default factory key bindings, cloned from _keyMap after all extensions are loaded.\n        _defaultKeyMap     = {};\n\n    /**\n     * @typedef {{shortcut: !string,\n     *            commandID: ?string}} UserKeyBinding\n     */\n\n    /**\n     * Maps shortcut descriptor to a command id.\n     *\n     * @private\n     * @type {UserKeyBinding}\n     */\n    let _originalUserKeyMap = {},\n        _customKeyMap      = {},\n        _customKeyMapCache = {};\n\n    /**\n     * Maps commandID to the list of shortcuts that are bound to it.\n     *\n     * @private\n     * @type {!Object.<string, Array.<{key: string, displayKey: string}>>}\n     */\n    let _commandMap  = {};\n\n    /**\n     * An array of command ID for all the available commands including the commands\n     * of installed extensions.\n     *\n     * @private\n     * @type {Array.<string>}\n     */\n    let _allCommands = [];\n\n    /**\n     * Maps key names to the corresponding unicode symbols\n     *\n     * @private\n     * @type {{key: string, displayKey: string}}\n     */\n    let _displayKeyMap        = { \"up\": \"\\u2191\",\n        \"down\": \"\\u2193\",\n        \"left\": \"\\u2190\",\n        \"right\": \"\\u2192\",\n        \"-\": \"\\u2212\" };\n\n    let _specialCommands      = [Commands.EDIT_UNDO, Commands.EDIT_REDO, Commands.EDIT_SELECT_ALL,\n            Commands.EDIT_CUT, Commands.EDIT_COPY, Commands.EDIT_PASTE],\n        _reservedShortcuts    = [\"Ctrl-Z\", \"Ctrl-Y\", \"Ctrl-A\", \"Ctrl-X\", \"Ctrl-C\", \"Ctrl-V\", \"Ctrl-=\", \"Ctrl--\"],\n        _macReservedShortcuts = [\"Cmd-,\", \"Cmd-H\", \"Cmd-Alt-H\", \"Cmd-M\", \"Cmd-Shift-Z\", \"Cmd-Q\", \"Cmd-=\", \"Cmd--\"],\n        _keyNames             = [\"Up\", \"Down\", \"Left\", \"Right\", \"Backspace\", \"Enter\", \"Space\", \"Tab\",\n            \"PageUp\", \"PageDown\", \"Home\", \"End\", \"Insert\", \"Delete\"];\n\n    /**\n     * Flag to show key binding errors in the key map file. Default is true and\n     * it will be set to false when reloading without extensions. This flag is not\n     * used to suppress errors in loading or parsing the key map file. So if the key\n     * map file is corrupt, then the error dialog still shows up.\n     *\n     * @private\n     * @type {boolean}\n     */\n    let _showErrors = true;\n\n    /**\n     * Allow clients to toggle key binding\n     *\n     * @private\n     * @type {boolean}\n     */\n    let _enabled = true;\n\n    /**\n     * Stack of registered global keydown hooks.\n     *\n     * @private\n     * @type {Array.<function(Event): boolean>}\n     */\n    let _globalKeydownHooks = [];\n\n    /**\n     * States of Ctrl key down detection\n     *\n     * @private\n     * @enum {number}\n     */\n    let CtrlDownStates = {\n        \"NOT_YET_DETECTED\": 0,\n        \"DETECTED\": 1,\n        \"DETECTED_AND_IGNORED\": 2   // For consecutive ctrl keydown events while a Ctrl key is being hold down\n    };\n\n    /**\n     * Flags used to determine whether right Alt key is pressed. When it is pressed,\n     * the following two keydown events are triggered in that specific order.\n     *\n     *    1. _ctrlDown - flag used to record { ctrlKey: true, keyIdentifier: \"Control\", ... } keydown event\n     *    2. _altGrDown - flag used to record { ctrlKey: true, altKey: true, keyIdentifier: \"Alt\", ... } keydown event\n     *\n     * @private\n     * @type {CtrlDownStates|boolean}\n     */\n    let _ctrlDown = CtrlDownStates.NOT_YET_DETECTED,\n        _altGrDown = false;\n\n    /**\n     * Used to record the timeStamp property of the last keydown event.\n     *\n     * @private\n     * @type {number}\n     */\n    let _lastTimeStamp;\n\n    /**\n     * Used to record the keyIdentifier property of the last keydown event.\n     *\n     * @private\n     * @type {string}\n     */\n    let _lastKeyIdentifier;\n\n    /**\n     * Constant used for checking the interval between Control keydown event and Alt keydown event.\n     * If the right Alt key is down we get Control keydown followed by Alt keydown within 30 ms. if\n     * the user is pressing Control key and then Alt key, the interval will be larger than 30 ms.\n     *\n     * @private\n     * @type {number}\n     */\n    let MAX_INTERVAL_FOR_CTRL_ALT_KEYS = 30;\n\n    /**\n     * Forward declaration for JSLint.\n     *\n     * @private\n     * @type {Function}\n     */\n    let _onCtrlUp;\n\n    /**\n     * Resets all the flags and removes _onCtrlUp event listener.\n     *\n     * @private\n     */\n    function _quitAltGrMode() {\n        _enabled = true;\n        _ctrlDown = CtrlDownStates.NOT_YET_DETECTED;\n        _altGrDown = false;\n        _lastTimeStamp = null;\n        _lastKeyIdentifier = null;\n        $(window).off(\"keyup\", _onCtrlUp);\n    }\n\n    /**\n     * Detects the release of AltGr key by checking all keyup events\n     * until we receive one with ctrl key code. Once detected, reset\n     * all the flags and also remove this event listener.\n     *\n     * @private\n     * @param {!KeyboardEvent} e keyboard event object\n     */\n    _onCtrlUp = function (e) {\n        let key = e.keyCode || e.which;\n        if (_altGrDown && key === KeyEvent.DOM_VK_CONTROL) {\n            _quitAltGrMode();\n        }\n    };\n\n    /**\n     * Detects whether AltGr key is pressed. When it is pressed, the first keydown event has\n     * ctrlKey === true with keyIdentifier === \"Control\". The next keydown event with\n     * altKey === true, ctrlKey === true and keyIdentifier === \"Alt\" is sent within 30 ms. Then\n     * the next keydown event with altKey === true, ctrlKey === true and keyIdentifier === \"Control\"\n     * is sent. If the user keep holding AltGr key down, then the second and third\n     * keydown events are repeatedly sent out alternately. If the user is also holding down Ctrl\n     * key, then either keyIdentifier === \"Control\" or keyIdentifier === \"Alt\" is repeatedly sent\n     * but not alternately.\n     *\n     * Once we detect the AltGr key down, then disable KeyBindingManager and set up a keyup\n     * event listener to detect the release of the altGr key so that we can re-enable KeyBindingManager.\n     * When we detect the addition of Ctrl key besides AltGr key, we also quit AltGr mode and re-enable\n     * KeyBindingManager.\n     *\n     * @private\n     * @param {!KeyboardEvent} e keyboard event object\n     */\n    function _detectAltGrKeyDown(e) {\n        if (brackets.platform !== \"win\") {\n            return;\n        }\n\n        if (!_altGrDown) {\n            if (_ctrlDown !== CtrlDownStates.DETECTED_AND_IGNORED && e.ctrlKey && e.key === \"Control\") {\n                _ctrlDown = CtrlDownStates.DETECTED;\n            } else if (e.repeat && e.ctrlKey && e.key === \"Control\") {\n                // We get here if the user is holding down left/right Control key. Set it to false\n                // so that we don't misidentify the combination of Ctrl and Alt keys as AltGr key.\n                _ctrlDown = CtrlDownStates.DETECTED_AND_IGNORED;\n            } else if (_ctrlDown === CtrlDownStates.DETECTED && e.altKey && e.ctrlKey && e.key === \"Alt\" &&\n                        (e.timeStamp - _lastTimeStamp) < MAX_INTERVAL_FOR_CTRL_ALT_KEYS) {\n                _altGrDown = true;\n                _lastKeyIdentifier = \"Alt\";\n                _enabled = false;\n                $(window).on(\"keyup\", _onCtrlUp);\n            } else {\n                // Reset _ctrlDown so that we can start over in detecting the two key events\n                // required for AltGr key.\n                _ctrlDown = CtrlDownStates.NOT_YET_DETECTED;\n            }\n            _lastTimeStamp = e.timeStamp;\n        } else if (e.key === \"Control\" || e.key === \"Alt\") {\n            // If the user is NOT holding down AltGr key or is also pressing Ctrl key,\n            // then _lastKeyIdentifier will be the same as keyIdentifier in the current\n            // key event. So we need to quit AltGr mode to re-enable KBM.\n            if (e.altKey && e.ctrlKey && e.key === _lastKeyIdentifier) {\n                _quitAltGrMode();\n            } else {\n                _lastKeyIdentifier = e.key;\n            }\n        }\n    }\n\n    /**\n     * @private\n     */\n    function _reset() {\n        _keyMap = {};\n        _defaultKeyMap = {};\n        _customKeyMap = {};\n        _customKeyMapCache = {};\n        _commandMap = {};\n        _globalKeydownHooks = [];\n        _userKeyMapFilePath = path.normalize(brackets.app.getApplicationSupportDirectory() + \"/\" + KEYMAP_FILENAME);\n    }\n\n    /**\n     * Initialize an empty keymap as the current keymap. It overwrites the current keymap if there is one.\n     * builds the keyDescriptor string from the given parts\n     *\n     * @private\n     * @param {boolean} hasCtrl Is Ctrl key enabled\n     * @param {boolean} hasAlt Is Alt key enabled\n     * @param {boolean} hasShift Is Shift key enabled\n     * @param {string} key The key that's pressed\n     * @return {string} The normalized key descriptor\n     */\n    function _buildKeyDescriptor(hasMacCtrl, hasCtrl, hasAlt, hasShift, key) {\n        if (!key) {\n            console.log(\"KeyBindingManager _buildKeyDescriptor() - No key provided!\");\n            return \"\";\n        }\n\n        let keyDescriptor = [];\n\n        if (hasMacCtrl) {\n            keyDescriptor.push(\"Ctrl\");\n        }\n        if (hasAlt) {\n            keyDescriptor.push(\"Alt\");\n        }\n        if (hasShift) {\n            keyDescriptor.push(\"Shift\");\n        }\n\n        if (hasCtrl) {\n            // Windows display Ctrl first, Mac displays Command symbol last\n            if (brackets.platform === \"mac\") {\n                keyDescriptor.push(\"Cmd\");\n            } else {\n                keyDescriptor.unshift(\"Ctrl\");\n            }\n        }\n\n        keyDescriptor.push(key);\n\n        return keyDescriptor.join(\"-\");\n    }\n\n\n    /**\n     * normalizes the incoming key descriptor so the modifier keys are always specified in the correct order\n     *\n     * @private\n     * @param {string} origDescriptor The string for a key descriptor, can be in any order, the result will be Ctrl-Alt-Shift-<Key>\n     * @return {string} The normalized key descriptor or null if the descriptor invalid\n     */\n    function normalizeKeyDescriptorString(origDescriptor) {\n        let hasMacCtrl = false,\n            hasCtrl = false,\n            hasAlt = false,\n            hasShift = false,\n            key = \"\",\n            error = false;\n\n        function _compareModifierString(left, right) {\n            if (!left || !right) {\n                return false;\n            }\n            left = left.trim().toLowerCase();\n            right = right.trim().toLowerCase();\n\n            return (left.length > 0 && left === right);\n        }\n\n        origDescriptor.split(\"-\").forEach(function parseDescriptor(ele, i, arr) {\n            if (_compareModifierString(\"ctrl\", ele)) {\n                if (brackets.platform === \"mac\") {\n                    hasMacCtrl = true;\n                } else {\n                    hasCtrl = true;\n                }\n            } else if (_compareModifierString(\"cmd\", ele)) {\n                if (brackets.platform === \"mac\") {\n                    hasCtrl = true;\n                } else {\n                    error = true;\n                }\n            } else if (_compareModifierString(\"alt\", ele)) {\n                hasAlt = true;\n            } else if (_compareModifierString(\"opt\", ele)) {\n                if (brackets.platform === \"mac\") {\n                    hasAlt = true;\n                } else {\n                    error = true;\n                }\n            } else if (_compareModifierString(\"shift\", ele)) {\n                hasShift = true;\n            } else if (key.length > 0) {\n                console.log(\"KeyBindingManager normalizeKeyDescriptorString() - Multiple keys defined. Using key: \" + key + \" from: \" + origDescriptor);\n                error = true;\n            } else {\n                key = ele;\n            }\n        });\n\n        if (error) {\n            return null;\n        }\n\n        // Check to see if the binding is for \"-\".\n        if (key === \"\" && origDescriptor.search(/^.+--$/) !== -1) {\n            key = \"-\";\n        }\n\n        // Check if it is a shift key only press\n        if (key === \"\" && origDescriptor.toLowerCase() === 'shift-shift') {\n            key = \"Shift\";\n        }\n\n        // '+' char is valid if it's the only key. Keyboard shortcut strings should use\n        // unicode characters (unescaped). Keyboard shortcut display strings may use\n        // unicode escape sequences (e.g. \\u20AC euro sign)\n        if ((key.indexOf(\"+\")) >= 0 && (key.length > 1)) {\n            return null;\n        }\n\n        // Ensure that the first letter of the key name is in upper case and the rest are\n        // in lower case. i.e. 'a' => 'A' and 'up' => 'Up'\n        if (/^[a-z]/i.test(key)) {\n            key = _.capitalize(key.toLowerCase());\n        }\n\n        // Also make sure that the second word of PageUp/PageDown has the first letter in upper case.\n        if (/^Page/.test(key)) {\n            key = key.replace(/(up|down)$/, function (match, p1) {\n                return _.capitalize(p1);\n            });\n        }\n\n        // No restriction on single character key yet, but other key names are restricted to either\n        // Function keys or those listed in _keyNames array.\n        if (key.length > 1 && !/F\\d+/.test(key) &&\n                _keyNames.indexOf(key) === -1) {\n            return null;\n        }\n\n        return _buildKeyDescriptor(hasMacCtrl, hasCtrl, hasAlt, hasShift, key);\n    }\n\n    function _mapKeycodeToKeyLegacy(keycode) {\n        // https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode\n        // keycode is deprecated. We only use this in one edge case in mac listed in the caller.\n        // If keycode represents one of the digit keys (0-9), then return the corresponding digit\n        // by subtracting KeyEvent.DOM_VK_0 from keycode. ie. [48-57] --> [0-9]\n        if ((keycode >= KeyEvent.DOM_VK_0 && keycode <= KeyEvent.DOM_VK_9) ||\n            (keycode >= KeyEvent.DOM_VK_A && keycode <= KeyEvent.DOM_VK_Z)){\n            return String.fromCharCode(keycode);\n            // Do the same with the numpad numbers\n            // by subtracting KeyEvent.DOM_VK_NUMPAD0 from keycode. ie. [96-105] --> [0-9]\n        } else if (keycode >= KeyEvent.DOM_VK_NUMPAD0 && keycode <= KeyEvent.DOM_VK_NUMPAD9) {\n            return String.fromCharCode(keycode - KeyEvent.DOM_VK_NUMPAD0 + KeyEvent.DOM_VK_0);\n        }\n\n\n        switch (keycode) {\n        case KeyEvent.DOM_VK_SEMICOLON:\n            return \";\";\n        case KeyEvent.DOM_VK_EQUALS:\n            return \"=\";\n        case KeyEvent.DOM_VK_COMMA:\n            return \",\";\n        case KeyEvent.DOM_VK_SUBTRACT:\n        case KeyEvent.DOM_VK_DASH:\n            return \"-\";\n        case KeyEvent.DOM_VK_ADD:\n            return \"+\";\n        case KeyEvent.DOM_VK_DECIMAL:\n        case KeyEvent.DOM_VK_PERIOD:\n            return \".\";\n        case KeyEvent.DOM_VK_DIVIDE:\n        case KeyEvent.DOM_VK_SLASH:\n            return \"/\";\n        case KeyEvent.DOM_VK_BACK_QUOTE:\n            return \"`\";\n        case KeyEvent.DOM_VK_OPEN_BRACKET:\n            return \"[\";\n        case KeyEvent.DOM_VK_BACK_SLASH:\n            return \"\\\\\";\n        case KeyEvent.DOM_VK_CLOSE_BRACKET:\n            return \"]\";\n        case KeyEvent.DOM_VK_QUOTE:\n            return \"'\";\n        default:\n            return null;\n        }\n    }\n\n    /**\n     * Looks for keycodes that have os-inconsistent keys and fixes them.\n     *\n     * @private\n     * @return {string} If the key is OS-inconsistent, the correct key; otherwise, the original key.\n     **/\n    function _mapKeycodeToKey(event) {\n        // key code mapping https://developer.mozilla.org/en-US/docs/Web/API/UI_Events/Keyboard_event_code_values\n        if((event.ctrlKey || event.metaKey) && event.altKey && brackets.platform === \"mac\"){\n            // in mac, Cmd-alt-<shift?>-key are valid. But alt-key will trigger international keyboard typing and\n            // hence instead of Cmd-Alt-O, mac will get event Cmd-alt-Î¦ which is not what we want. So we will\n            // fallback to the deprecated keyCode event in the case\n            const key = _mapKeycodeToKeyLegacy(event.keyCode);\n            if(key){\n                return key;\n            }\n        }\n        const key = event.key;\n        let codes = {\n            \"ArrowUp\": \"Up\",\n            \"ArrowDown\": \"Down\",\n            \"ArrowLeft\": \"Left\",\n            \"ArrowRight\": \"Right\",\n            \" \": \"Space\"\n        };\n        if(codes[key]){\n            return codes[key];\n        }\n        return key;\n    }\n\n    /**\n     * Takes a keyboard event and translates it into a key in a key map\n     *\n     * @private\n     */\n    function _translateKeyboardEvent(event) {\n        let hasMacCtrl = (brackets.platform === \"mac\") ? (event.ctrlKey) : false,\n            hasCtrl = (brackets.platform !== \"mac\") ? (event.ctrlKey) : (event.metaKey),\n            hasAlt = (event.altKey),\n            hasShift = (event.shiftKey),\n            key = _mapKeycodeToKey(event);\n        return normalizeKeyDescriptorString(_buildKeyDescriptor(hasMacCtrl, hasCtrl, hasAlt, hasShift, key));\n    }\n\n    /**\n     * Convert normalized key representation to display appropriate for platform.\n     *\n     * @param {!string} descriptor Normalized key descriptor.\n     * @return {!string} Display/Operating system appropriate string\n     */\n    function formatKeyDescriptor(descriptor) {\n        let displayStr;\n\n        if (brackets.platform === \"mac\") {\n            displayStr = descriptor.replace(/-(?!$)/g, \"\");     // remove dashes\n            displayStr = displayStr.replace(\"Ctrl\", \"\\u2303\");  // Ctrl > control symbol\n            displayStr = displayStr.replace(\"Cmd\", \"\\u2318\");   // Cmd > command symbol\n            displayStr = displayStr.replace(\"Shift\", \"\\u21E7\"); // Shift > shift symbol\n            displayStr = displayStr.replace(\"Alt\", \"\\u2325\");   // Alt > option symbol\n        } else {\n            displayStr = descriptor.replace(\"Ctrl\", Strings.KEYBOARD_CTRL);\n            displayStr = displayStr.replace(\"Shift\", Strings.KEYBOARD_SHIFT);\n            displayStr = displayStr.replace(/-(?!$)/g, \"+\");\n        }\n\n        displayStr = displayStr.replace(\"Space\", Strings.KEYBOARD_SPACE);\n\n        displayStr = displayStr.replace(\"PageUp\", Strings.KEYBOARD_PAGE_UP);\n        displayStr = displayStr.replace(\"PageDown\", Strings.KEYBOARD_PAGE_DOWN);\n        displayStr = displayStr.replace(\"Home\", Strings.KEYBOARD_HOME);\n        displayStr = displayStr.replace(\"End\", Strings.KEYBOARD_END);\n\n        displayStr = displayStr.replace(\"Ins\", Strings.KEYBOARD_INSERT);\n        displayStr = displayStr.replace(\"Del\", Strings.KEYBOARD_DELETE);\n\n        return displayStr;\n    }\n\n    /**\n     * @private\n     * @param {string} A normalized key-description string.\n     * @return {boolean} true if the key is already assigned, false otherwise.\n     */\n    function _isKeyAssigned(key) {\n        return (_keyMap[key] !== undefined);\n    }\n\n    /**\n     * Remove a key binding from _keymap\n     *\n     * @param {!string} key - a key-description string that may or may not be normalized.\n     * @param {?string} [platform] - OS from which to remove the binding (all platforms if unspecified)\n     */\n    function removeBinding(key, platform) {\n        if (!key || ((platform !== null) && (platform !== undefined) && (platform !== brackets.platform))) {\n            return;\n        }\n\n        let normalizedKey = normalizeKeyDescriptorString(key);\n\n        if (!normalizedKey) {\n            console.log(\"Failed to normalize \" + key);\n        } else if (_isKeyAssigned(normalizedKey)) {\n            let binding = _keyMap[normalizedKey],\n                command = CommandManager.get(binding.commandID),\n                bindings = _commandMap[binding.commandID];\n\n            // delete key binding record\n            delete _keyMap[normalizedKey];\n\n            if (bindings) {\n                // delete mapping from command to key binding\n                _commandMap[binding.commandID] = bindings.filter(function (b) {\n                    return (b.key !== normalizedKey);\n                });\n\n                if (command) {\n                    command.trigger(EVENT_KEY_BINDING_REMOVED, {key: normalizedKey, displayKey: binding.displayKey});\n                    exports.trigger(EVENT_KEY_BINDING_REMOVED, {\n                        commandID: command.getID(),\n                        key: normalizedKey,\n                        displayKey: binding.displayKey\n                    });\n                }\n            }\n        }\n    }\n\n    /**\n     * Updates _allCommands array and _defaultKeyMap with the new key binding\n     * if it is not yet in the _allCommands array. _allCommands array is initialized\n     * only in extensionsLoaded event. So any new commands or key bindings added after\n     * that will be updated here.\n     *\n     * @private\n     * @param {{commandID: string, key: string, displayKey:string, explicitPlatform: string}} newBinding\n     */\n    function _updateCommandAndKeyMaps(newBinding) {\n        if (_allCommands.length === 0) {\n            return;\n        }\n\n        if (newBinding && newBinding.commandID && _allCommands.indexOf(newBinding.commandID) === -1) {\n            _defaultKeyMap[newBinding.commandID] = _.cloneDeep(newBinding);\n\n            // Process user key map again to catch any reassignment to all new key bindings added from extensions.\n            _loadUserKeyMap();\n        }\n    }\n\n    /**\n     * @private\n     *\n     * @param {string} commandID\n     * @param {string|{{key: string, displayKey: string}}} keyBinding - a single shortcut.\n     * @param {string?} platform\n     *     - \"all\" indicates all platforms, not overridable\n     *     - undefined indicates all platforms, overridden by platform-specific binding\n     * @param {boolean?} userBindings true if adding a user key binding or undefined otherwise.\n     * @param {boolean?} isMenuShortcut\n     * @return {?{key: string, displayKey:String}} Returns a record for valid key bindings.\n     *     Returns null when key binding platform does not match, binding does not normalize,\n     *     or is already assigned.\n     */\n    function _addBinding(commandID, keyBinding, {platform, userBindings, isMenuShortcut}) {\n        knownBindableCommands.add(commandID);\n        let key,\n            result = null,\n            normalized,\n            normalizedDisplay,\n            explicitPlatform = keyBinding.platform || platform,\n            explicitBrowserOnly = keyBinding.browserOnly,\n            explicitNativeOnly = keyBinding.nativeOnly,\n            targetPlatform,\n            command,\n            bindingsToDelete = [],\n            existing;\n\n        if(Phoenix.isNativeApp && explicitBrowserOnly) {\n            return null;\n        }\n        if(!Phoenix.isNativeApp && explicitNativeOnly) {\n            return null;\n        }\n        // For platform: \"all\", use explicit current platform\n        if (explicitPlatform && explicitPlatform !== \"all\") {\n            targetPlatform = explicitPlatform;\n        } else {\n            targetPlatform = brackets.platform;\n        }\n\n\n        // Skip if the key binding is not for this platform.\n        if (explicitPlatform === \"mac\" && brackets.platform !== \"mac\") {\n            return null;\n        }\n\n        // if the request does not specify an explicit platform, and we're\n        // currently on a mac, then replace Ctrl with Cmd.\n        key = (keyBinding.key) || keyBinding;\n        if (brackets.platform === \"mac\" && (explicitPlatform === undefined || explicitPlatform === \"all\")) {\n            key = key.replace(\"Ctrl\", \"Cmd\");\n            if (keyBinding.displayKey !== undefined) {\n                keyBinding.displayKey = keyBinding.displayKey.replace(\"Ctrl\", \"Cmd\");\n            }\n        }\n\n        normalized = normalizeKeyDescriptorString(key);\n\n        // skip if the key binding is invalid\n        if (!normalized) {\n            console.error(`Unable to parse key binding '${key}' for command '${commandID}'. Permitted modifiers: Ctrl, Cmd, Alt, Opt, Shift; separated by '-' (not '+').`);\n            return null;\n        }\n        function isSingleCharAZ(str) {\n            return /^[A-Z]$/i.test(str);\n        }\n        const keySplit = normalized.split(\"-\");\n        if(!isMenuShortcut && ((keySplit.length ===2 && keySplit[0] === 'Alt' && isSingleCharAZ(keySplit[1])) ||\n            (keySplit.length ===3 && keySplit[0] === 'Alt' && keySplit[1] === 'Shift' && isSingleCharAZ(keySplit[2])))){\n            console.error(`Key binding '${normalized}' for command '${commandID}' may cause issues. The key combinations starting with 'Alt-<letter>' and 'Alt-Shift-<letter>' are reserved. On macOS, they are used for AltGr internationalization, and on Windows/Linux, they are used for menu navigation shortcuts. If this is a menu shortcut, use 'isMenuShortcut' option.`);\n        }\n        // ctrl-alt-<key> events are allowed in all platforms. In windows ctrl-alt-<key> events are treated as altGr\n        // and used for international keyboards. But we have special handling for detecting alt gr key press that\n        // accounts for this and disables keybinding manager inwindows on detecting altGr key press.\n        // See _detectAltGrKeyDown function in this file.\n\n        // check for duplicate key bindings\n        existing = _keyMap[normalized];\n\n        // for cross-platform compatibility\n        if (exports.useWindowsCompatibleBindings) {\n            // windows-only key bindings are used as the default binding\n            // only if a default binding wasn't already defined\n            if (explicitPlatform === \"win\") {\n                // search for a generic or platform-specific binding if it\n                // already exists\n                if (existing && (!existing.explicitPlatform ||\n                                 existing.explicitPlatform === brackets.platform ||\n                                 existing.explicitPlatform === \"all\")) {\n                    // do not clobber existing binding with windows-only binding\n                    return null;\n                }\n\n                // target this windows binding for the current platform\n                targetPlatform = brackets.platform;\n            }\n        }\n\n        // skip if this binding doesn't match the current platform\n        if (targetPlatform !== brackets.platform) {\n            return null;\n        }\n\n        // skip if the key is already assigned\n        if (existing) {\n            if (!existing.explicitPlatform && explicitPlatform) {\n                // remove the the generic binding to replace with this new platform-specific binding\n                removeBinding(normalized);\n                existing = false;\n            }\n        }\n\n        // delete existing bindings when\n        // (1) replacing a windows-compatible binding with a generic or\n        //     platform-specific binding\n        // (2) replacing a generic binding with a platform-specific binding\n        let existingBindings = _commandMap[commandID] || [],\n            isWindowsCompatible,\n            isReplaceGeneric,\n            ignoreGeneric;\n\n        existingBindings.forEach(function (binding) {\n            // remove windows-only bindings in _commandMap\n            isWindowsCompatible = exports.useWindowsCompatibleBindings &&\n                binding.explicitPlatform === \"win\";\n\n            // remove existing generic binding\n            isReplaceGeneric = !binding.explicitPlatform &&\n                explicitPlatform;\n\n            if (isWindowsCompatible || isReplaceGeneric) {\n                bindingsToDelete.push(binding);\n            } else {\n                // existing binding is platform-specific and the requested binding is generic\n                ignoreGeneric = binding.explicitPlatform && !explicitPlatform;\n            }\n        });\n\n        if (ignoreGeneric) {\n            // explicit command binding overrides this one\n            return null;\n        }\n\n        if (existing) {\n            // do not re-assign a key binding\n            if(commandID !== _keyMap[normalized].commandID) {\n                console.error(\"Cannot assign \" + normalized + \" to \" + commandID + \". It is already assigned to \" + _keyMap[normalized].commandID);\n            }// else the same shortcut is already there, do nothing\n            return null;\n        }\n\n        // remove generic or windows-compatible bindings\n        bindingsToDelete.forEach(function (binding) {\n            removeBinding(binding.key);\n        });\n\n        // optional display-friendly string (e.g. CMD-+ instead of CMD-=)\n        normalizedDisplay = (keyBinding.displayKey) ? normalizeKeyDescriptorString(keyBinding.displayKey) : normalized;\n\n        // 1-to-many commandID mapping to key binding\n        if (!_commandMap[commandID]) {\n            _commandMap[commandID] = [];\n        }\n\n        result = {\n            key: normalized,\n            displayKey: normalizedDisplay,\n            explicitPlatform: explicitPlatform\n        };\n\n        _commandMap[commandID].push(result);\n\n        // 1-to-1 key binding to commandID\n        _keyMap[normalized] = {\n            commandID: commandID,\n            key: normalized,\n            displayKey: normalizedDisplay,\n            explicitPlatform: explicitPlatform\n        };\n\n        if (!userBindings) {\n            _updateCommandAndKeyMaps(_keyMap[normalized]);\n        }\n\n        // notify listeners\n        command = CommandManager.get(commandID);\n\n        if (command) {\n            command.trigger(EVENT_KEY_BINDING_ADDED, result, commandID);\n            exports.trigger(EVENT_KEY_BINDING_ADDED, result, commandID);\n        }\n\n        return result;\n    }\n\n    /**\n     * Returns a copy of the current key map. If the optional 'defaults' parameter is true,\n     * then a copy of the default key map is returned.\n     * In the default keymap each key is associated with an object containing `commandID`, `key`, and `displayKey`.\n     *\n     * @param {boolean=} defaults true if the caller wants a copy of the default key map. Otherwise, the current active key map is returned.\n     * @return {Object}\n     */\n    function getKeymap(defaults) {\n        return $.extend({}, defaults ? _defaultKeyMap : _keyMap);\n    }\n\n    function _makeMapFromArray(map, arr){\n        for(let item of arr) {\n            map[item] = true;\n        }\n        return map;\n    }\n\n    /**\n     * If there is a registered and enabled key event, we always mark the event as processed\n     * except the ones in UN_SWALLOWED_EVENTS.\n     *\n     * @private\n     * @type {Array.<string>}\n     */\n    const UN_SWALLOWED_EVENTS = _makeMapFromArray({}, [\n        Commands.EDIT_SELECT_ALL,\n        Commands.EDIT_UNDO,\n        Commands.EDIT_REDO,\n        Commands.EDIT_CUT,\n        Commands.EDIT_COPY,\n        Commands.EDIT_PASTE\n    ]);\n\n    // single keys except function keys and key combinations are never swallowed. Ãka we want default behavior\n    // for the below keys if the command handler for the registered key didnt do anything.\n    let UN_SWALLOWED_KEYS = _makeMapFromArray({},\n        _keyNames.concat(_reservedShortcuts)\n            .concat(_macReservedShortcuts));\n    function _isUnSwallowedKeys(key) {\n        return UN_SWALLOWED_KEYS[key] || key.length === 1; // keys like a-z, 0-9 etc\n    }\n\n    /**\n     * Process the keybinding for the current key.\n     *\n     * @private\n     * @param {string} key A key-description string.\n     * @return {boolean} true if the key was processed, false otherwise\n     */\n    function _handleKey(key) {\n        if (_enabled && _keyMap[key]) {\n            Metrics.countEvent(Metrics.EVENT_TYPE.KEYBOARD, \"shortcut\", key);\n            Metrics.countEvent(Metrics.EVENT_TYPE.KEYBOARD, \"command\", _keyMap[key].commandID);\n            logger.leaveTrail(\"Keyboard shortcut: \" + key + \" command: \" + _keyMap[key].commandID);\n            // If there is a registered and enabled key event except the swallowed key events,\n            // we always mark the event as processed and return true.\n            // We don't want multiple behavior tied to the same key event. For Instance, in browser, if `ctrl-k`\n            // is not handled by quick edit, it will open browser url bar if we return false here(which is bad ux).\n            let command = CommandManager.get(_keyMap[key].commandID);\n            let eventDetails = undefined;\n            if(command._options.eventSource){\n                eventDetails = {\n                    eventSource: CommandManager.SOURCE_KEYBOARD_SHORTCUT,\n                    sourceType: key\n                };\n            }\n            let promise = CommandManager.execute(_keyMap[key].commandID, eventDetails);\n            if(UN_SWALLOWED_EVENTS[_keyMap[key].commandID] || _isUnSwallowedKeys(key)){\n                // The execute() function returns a promise because some commands are async.\n                // Generally, commands decide whether they can run or not synchronously,\n                // and reject immediately, so we can test for that synchronously.\n                return (promise.state() !== \"rejected\");\n            }\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Sort objects by platform property. Objects with a platform property come\n     * before objects without a platform property.\n     *\n     * @private\n     */\n    function _sortByPlatform(a, b) {\n        let a1 = (a.platform) ? 1 : 0,\n            b1 = (b.platform) ? 1 : 0;\n        return b1 - a1;\n    }\n\n    /**\n     * Add one or more key bindings to a particular Command.\n     * Returns record(s) for valid key binding(s).\n     *\n     * @param {!string | Command} command - A command ID or command object\n     * @param {{key: string, displayKey:string, platform: string, browserOnly: boolean, nativeOnly:boolean}} keyBindings\n     *     A single key binding or an array of keybindings.\n     *     In an array of keybinding `platform` property is also available. Example:\n     *     \"Shift-Cmd-F\". Mac and Win key equivalents are automatically\n     *     mapped to each other. Use displayKey property to display a different\n     *     string (e.g. \"CMD+\" instead of \"CMD=\"). if browserOnly is true, then the shortcut will only apply in browser\n     *     if nativeOnly is set, the shortcut will only apply in native apps\n     * @param {?string} platform The target OS of the keyBindings either\n     *     \"mac\", \"win\" or \"linux\". If undefined, all platforms not explicitly\n     *     defined will use the key binding.\n     *     NOTE: If platform is not specified, Ctrl will be replaced by Cmd for \"mac\" platform\n     * @param {object?} options\n     * @param {boolean?} options.isMenuShortcut this allows alt-key shortcuts to be registered.\n     * @return {{key: string, displayKey:string}}\n     */\n    function addBinding(command, keyBindings, platform, options={}) {\n        let commandID = \"\",\n            results,\n            isMenuShortcut = options.isMenuShortcut;\n\n        if (!command) {\n            console.error(\"addBinding(): missing required parameter: command\");\n            return;\n        }\n\n        if (!keyBindings) { return; }\n\n        if (typeof (command) === \"string\") {\n            commandID = command;\n        } else {\n            commandID = command.getID();\n        }\n\n        if (Array.isArray(keyBindings)) {\n            let keyBinding;\n            results = [];\n\n            // process platform-specific bindings first\n            keyBindings.sort(_sortByPlatform);\n\n            keyBindings.forEach(function (keyBindingRequest) {\n                // attempt to add keybinding\n                keyBinding = _addBinding(commandID, keyBindingRequest, {\n                    platform: keyBindingRequest.platform,\n                    isMenuShortcut: isMenuShortcut\n                });\n\n                if (keyBinding) {\n                    results.push(keyBinding);\n                }\n            });\n        } else {\n            results = _addBinding(commandID, keyBindings, {\n                platform: platform,\n                isMenuShortcut: isMenuShortcut\n            });\n        }\n\n        return results;\n    }\n    /**\n     * Retrieve key bindings currently associated with a command\n     *\n     * @param {!string | Command} command - A command ID or command object\n     * @return {Array.<Object>} The object has two properties `key` and `displayKey`\n     */\n    function getKeyBindings(command) {\n        let bindings    = [],\n            commandID   = \"\";\n\n        if (!command) {\n            console.error(\"getKeyBindings(): missing required parameter: command\");\n            return [];\n        }\n\n        if (typeof (command) === \"string\") {\n            commandID = command;\n        } else {\n            commandID = command.getID();\n        }\n\n        bindings = _commandMap[commandID];\n        return bindings || [];\n    }\n\n    /**\n     * Retrieves the platform-specific string representation of the key bindings for a specified command.\n     * This function is useful for displaying the keyboard shortcut associated with a given command ID to the user.\n     * If a key binding is found for the command, it returns the formatted key descriptor. Otherwise, it returns null.\n     *\n     * @param {string} commandID - The unique identifier of the command for which the key binding is to be retrieved.\n     * @returns {string|null} The formatted key binding as a string if available; otherwise, null.\n     */\n    function getKeyBindingsDisplay(commandID) {\n        let shortCut = getKeyBindings(commandID);\n        if (shortCut && shortCut[0] && shortCut[0].displayKey) {\n            return formatKeyDescriptor(shortCut[0].displayKey);\n        }\n        return null;\n    }\n\n\n    const _handledCommands = {};\n    /**\n     * Adds default key bindings when commands are registered to CommandManager\n     *\n     * @private\n     * @param {$.Event} event jQuery event\n     * @param {Command} command Newly registered command\n     */\n    function _handleCommandRegistered(event, command) {\n        let commandId   = command.getID(),\n            defaults    = KeyboardPrefs[commandId];\n\n        if (defaults) {\n            _handledCommands[commandId] = true;\n            addBinding(commandId, defaults);\n        }\n    }\n\n    function _initDefaultShortcuts() {\n        for(let commandId of _allCommands){\n            let defaults    = KeyboardPrefs[commandId];\n\n            if (defaults && !_handledCommands[commandId]) {\n                addBinding(commandId, defaults);\n            }\n        }\n    }\n\n    /**\n     * Adds a global keydown hook that gets first crack at keydown events\n     * before standard keybindings do. This is intended for use by modal or\n     * semi-modal UI elements like dialogs or the code hint list that should\n     * execute before normal command bindings are run.\n     *\n     * The hook is passed two parameters, the first param is the original keyboard event.\n     * The second param is the deduced shortcut string like `Ctrl-F` if present for\n     * that event or null if not keyboard shortcut string. If the\n     * hook handles the event (or wants to block other global hooks from\n     * handling the event), it should return true. Note that this will *only*\n     * stop other global hooks and KeyBindingManager from handling the\n     * event; to prevent further event propagation, you will need to call\n     * stopPropagation(), stopImmediatePropagation(), and/or preventDefault()\n     * as usual.\n     *\n     * Multiple keydown hooks can be registered, and are executed in order,\n     * most-recently-added first. A keydown hook will only be added once if the same\n     * hook is already added before.\n     *\n     * (We have to have a special API for this because (1) handlers are normally\n     * called in least-recently-added order, and we want most-recently-added;\n     * (2) native DOM events don't have a way for us to find out if\n     * stopImmediatePropagation()/stopPropagation() has been called on the\n     * event, so we have to have some other way for one of the hooks to\n     * indicate that it wants to block the other hooks from running.)\n     *\n     * @param {function(Event): boolean} hook The global hook to add.\n     */\n    function addGlobalKeydownHook(hook) {\n        let index = _globalKeydownHooks.indexOf(hook);\n        if (index !== -1) {\n            return;\n        }\n        _globalKeydownHooks.push(hook);\n    }\n\n    /**\n     * Removes a global keydown hook added by `addGlobalKeydownHook`.\n     * Does not need to be the most recently added hook.\n     *\n     * @param {function(Event): boolean} hook The global hook to remove.\n     */\n    function removeGlobalKeydownHook(hook) {\n        let index = _globalKeydownHooks.indexOf(hook);\n        if (index !== -1) {\n            _globalKeydownHooks.splice(index, 1);\n        }\n    }\n\n    let lastCtrlKeyPressTime = 0; // Store the time of the last key press\n    let pressCount = 0; // Counter for consecutive Control key presses\n    const doublePressInterval = 250; // Maximum time interval between presses, in milliseconds, to consider it a double press\n    const PRESS_ACTIVATE_COUNT = 3;\n    const ctrlKeyCodes = {\n        ControlLeft: true,\n        ControlRight: true,\n        MetaLeft: true,\n        MetaRight: true,\n        Control: true,\n        Meta: true\n    };\n    let isCtrlDepressed = false; // flag set to true if the user keeps the ctrl key pressed without releasing\n    function _detectTripleCtrlKeyPress(event) {\n        const isCtrlKeyPressStart = !isCtrlDepressed;\n        if (ctrlKeyCodes[event.code] && ctrlKeyCodes[event.key]) {\n            isCtrlDepressed = true;\n        }\n        if(PreferencesManager && !PreferencesManager.get(PREF_TRIPLE_CTRL_KEY_PRESS_ENABLED)){\n            return false;\n        }\n        const currentTime = new Date().getTime(); // Get the current time\n        if (ctrlKeyCodes[event.code] && ctrlKeyCodes[event.key] && !event.shiftKey && !event.altKey\n            && isCtrlKeyPressStart) {\n            pressCount++;\n            isCtrlDepressed = true;\n            if(pressCount === PRESS_ACTIVATE_COUNT && (currentTime - lastCtrlKeyPressTime) <= doublePressInterval) {\n                KeyboardOverlayMode.startOverlayMode();\n                event.stopPropagation();\n                event.preventDefault();\n                lastCtrlKeyPressTime = currentTime;\n                Metrics.countEvent(Metrics.EVENT_TYPE.KEYBOARD, 'ctrlx'+PRESS_ACTIVATE_COUNT, \"showOverlay\");\n                return true;\n            }\n            if((currentTime - lastCtrlKeyPressTime) > doublePressInterval){\n                pressCount = 1;\n            }\n            lastCtrlKeyPressTime = currentTime;\n        } else {\n            pressCount = 0;\n        }\n        return false;\n    }\n\n    const dontHideMouseOnKeys = {\n        \"Escape\": true,\n        \"ArrowLeft\": true,\n        \"ArrowRight\": true,\n        \"ArrowUp\": true,\n        \"ArrowDown\": true,\n        \"Home\": true,\n        \"End\": true,\n        \"PageUp\": true,\n        \"PageDown\": true,\n        \"Shift\": true,\n        \"Control\": true,\n        \"Alt\": true,\n        \"Meta\": true,\n        \"F1\": true,\n        \"F2\": true,\n        \"F3\": true,\n        \"F4\": true,\n        \"F5\": true,\n        \"F6\": true,\n        \"F7\": true,\n        \"F8\": true,\n        \"F9\": true,\n        \"F10\": true,\n        \"F11\": true,\n        \"F12\": true,\n        \"Insert\": true,\n        \"ContextMenu\": true,\n        \"NumLock\": true,\n        \"ScrollLock\": true,\n        \"CapsLock\": true\n    };\n    let mouseCursorHidden = false;\n    function _hideMouseCursonOnTyping(event) {\n        if(dontHideMouseOnKeys[event.key] || mouseCursorHidden){\n            return;\n        }\n        mouseCursorHidden = true;\n        if(!Phoenix.isSpecRunnerWindow){\n            document.body.classList.add('hide-cursor');\n        }\n    }\n\n    /**\n     * Handles a given keydown event, checking global hooks first before\n     * deciding to handle it ourselves.\n     *\n     * @private\n     * @param {Event} event The keydown event to handle.\n     */\n    function _handleKeyEvent(event) {\n        _hideMouseCursonOnTyping(event);\n        if(KeyboardOverlayMode.isInOverlayMode()){\n            return KeyboardOverlayMode.processOverlayKeyboardEvent(event);\n        }\n        if(_detectTripleCtrlKeyPress(event)){\n            return true;\n        }\n        const shortcut = _translateKeyboardEvent(event);\n        let i, handled = false;\n        for (i = _globalKeydownHooks.length - 1; i >= 0; i--) {\n            if (_globalKeydownHooks[i](event, shortcut)) {\n                handled = true;\n                break;\n            }\n        }\n        _detectAltGrKeyDown(event);\n        if(keyboardShortcutCaptureInProgress) {\n            return updateShortcutSelection(event, shortcut);\n        }\n        if (!handled && _handleKey(shortcut)) {\n            event.stopPropagation();\n            event.preventDefault();\n        }\n    }\n\n    AppInit.htmlReady(function () {\n        // Install keydown event listener.\n        window.document.body.addEventListener(\n            \"keydown\",\n            _handleKeyEvent,\n            true\n        );\n        window.document.body.addEventListener(\n            \"keyup\",\n            (event)=>{\n                if (ctrlKeyCodes[event.code] && ctrlKeyCodes[event.key]) {\n                    isCtrlDepressed = false;\n                }\n            },\n            true\n        );\n        document.body.addEventListener('mousemove', ()=>{\n            if(!mouseCursorHidden){\n                return;\n            }\n            mouseCursorHidden = false;\n            document.body.classList.remove('hide-cursor');\n        });\n\n        exports.useWindowsCompatibleBindings = (brackets.platform !== \"mac\") &&\n            (brackets.platform !== \"win\");\n    });\n\n    /**\n     * Displays an error dialog and also opens the user key map file for editing only if\n     * the error is not the loading file error.\n     *\n     * @private\n     * @param {?string} err Error type returned from JSON parser or open file operation\n     * @param {string=} message Error message to be displayed in the dialog\n     */\n    function _showErrorsAndOpenKeyMap(err, message) {\n        // Asynchronously loading Dialogs module to avoid the circular dependency\n        require([\"widgets/Dialogs\"], function (Dialogs) {\n            let errorMessage = Strings.ERROR_KEYMAP_CORRUPT;\n\n            if (err === FileSystemError.UNSUPPORTED_ENCODING) {\n                errorMessage = Strings.ERROR_LOADING_KEYMAP;\n            } else if (message) {\n                errorMessage = message;\n            }\n\n            Dialogs.showModalDialog(\n                DefaultDialogs.DIALOG_ID_ERROR,\n                Strings.ERROR_KEYMAP_TITLE,\n                errorMessage\n            )\n                .done(function () {\n                    if (err !== FileSystemError.UNSUPPORTED_ENCODING) {\n                        CommandManager.execute(Commands.FILE_OPEN_KEYMAP);\n                    }\n                });\n        });\n    }\n\n    /**\n     * Checks whether the given command ID is a special command that the user can't bind\n     * to another shortcut.\n     *\n     * @private\n     * @param {!string} commandID A string referring to a specific command\n     * @return {boolean} true if normalizedKey is a special command, false otherwise.\n     */\n    function _isSpecialCommand(commandID) {\n        if (brackets.platform === \"mac\" && commandID === \"file.quit\") {\n            return true;\n        }\n\n        return (_specialCommands.indexOf(commandID) > -1);\n    }\n\n    /**\n     * Checks whether the given key combination is a shortcut of a special command\n     * or a Mac system command that the user can't reassign to another command.\n     *\n     * @private\n     * @param {!string} normalizedKey A key combination string used for a keyboard shortcut\n     * @return {boolean} true if normalizedKey is a restricted shortcut, false otherwise.\n     */\n    function _isReservedShortcuts(normalizedKey) {\n        if (!normalizedKey) {\n            return false;\n        }\n\n        if (_reservedShortcuts.indexOf(normalizedKey) > -1 ||\n                _reservedShortcuts.indexOf(normalizedKey.replace(\"Cmd\", \"Ctrl\")) > -1) {\n            return true;\n        }\n\n        if (brackets.platform === \"mac\" && _macReservedShortcuts.indexOf(normalizedKey) > -1) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Creates a bullet list item for any item in the given list.\n     *\n     * @private\n     * @param {Array.<string>} list An array of strings to be converted into a\n     * message string with a bullet list.\n     * @return {string} the html text version of the list\n     */\n    function _getBulletList(list) {\n        let message = \"<ul class='dialog-list'>\";\n        list.forEach(function (info) {\n            message += \"<li>\" + info + \"</li>\";\n        });\n        message += \"</ul>\";\n        return message;\n    }\n\n    /**\n     * Gets the corresponding unicode symbol of an arrow key for display in the menu.\n     *\n     * @private\n     * @param {string} key The non-modifier key used in the shortcut. It does not need to be normalized.\n     * @return {string} An empty string if key is not one of those we want to show with the unicode symbol. Otherwise, the corresponding unicode symbol is returned.\n     */\n    function _getDisplayKey(key) {\n        let displayKey = \"\",\n            match = key ? key.match(/(Up|Down|Left|Right|\\-)$/i) : null;\n        if (match && !/Page(Up|Down)/.test(key)) {\n            displayKey = key.substr(0, match.index) + _displayKeyMap[match[0].toLowerCase()];\n        }\n        return displayKey;\n    }\n\n    /**\n     * Applies each user key binding to all the affected commands and updates _keyMap.\n     * Shows errors in a dialog and then opens the user key map file if any of the following\n     * is detected while applying the user key bindings.\n     *     - A key binding is attempting to modify a special command.\n     *     - A key binding is attempting to assign a shortcut of a special command to another one.\n     *     - Multiple key bindings are specified for the same command ID.\n     *     - The same key combination is listed for multiple key bindings.\n     *     - A key binding has any invalid key syntax.\n     *     - A key binding is referring to a non-existent command ID.\n     *\n     * @private\n     */\n    function _applyUserKeyBindings() {\n        let remappedCommands   = [],\n            remappedKeys       = [],\n            restrictedCommands = [],\n            restrictedKeys     = [],\n            invalidKeys        = [],\n            invalidCommands    = [],\n            multipleKeys       = [],\n            duplicateBindings  = [],\n            errorMessage       = \"\";\n\n        _.forEach(_customKeyMap, function (commandID, key) {\n            let normalizedKey    = normalizeKeyDescriptorString(key),\n                existingBindings = _commandMap[commandID] || [];\n\n            // Skip this since we don't allow user to update key binding of a special\n            // command like cut, copy, paste, undo, redo and select all.\n            if (_isSpecialCommand(commandID)) {\n                restrictedCommands.push(commandID);\n                return;\n            }\n\n            // Skip this since we don't allow user to update a shortcut used in\n            // a special command or any Mac system command.\n            if (_isReservedShortcuts(normalizedKey)) {\n                restrictedKeys.push(key);\n                return;\n            }\n\n            // Skip this if the key is invalid.\n            if (!normalizedKey) {\n                invalidKeys.push(key);\n                return;\n            }\n\n            if (_isKeyAssigned(normalizedKey)) {\n                if (remappedKeys.indexOf(normalizedKey) !== -1) {\n                    // JSON parser already removed all the duplicates that have the exact\n                    // same case or order in their keys. So we're only detecting duplicate\n                    // bindings that have different orders or different cases used in the key.\n                    duplicateBindings.push(key);\n                    return;\n                }\n                // The same key binding already exists, so skip this.\n                if (_keyMap[normalizedKey].commandID === commandID) {\n                    // Still need to add it to the remappedCommands so that\n                    // we can detect any duplicate later on.\n                    remappedCommands.push(commandID);\n                    return;\n                }\n                removeBinding(normalizedKey);\n            }\n\n            if (remappedKeys.indexOf(normalizedKey) === -1) {\n                remappedKeys.push(normalizedKey);\n            }\n\n            // Remove another key binding if the new key binding is for a command\n            // that has a different key binding. e.g. \"Ctrl-W\": \"edit.selectLine\"\n            // requires us to remove \"Ctrl-W\" from \"file.close\" command, but we\n            // also need to remove \"Ctrl-L\" from \"edit.selectLine\".\n            if (existingBindings.length) {\n                existingBindings.forEach(function (binding) {\n                    removeBinding(binding.key);\n                });\n            }\n\n            if (commandID) {\n                if (_allCommands.indexOf(commandID) !== -1) {\n                    if (remappedCommands.indexOf(commandID) === -1) {\n                        let keybinding = { key: normalizedKey };\n\n                        keybinding.displayKey = _getDisplayKey(normalizedKey);\n                        _addBinding(commandID, keybinding.displayKey ? keybinding : normalizedKey, {\n                            platform: brackets.platform,\n                            userBindings: true\n                        });\n                        remappedCommands.push(commandID);\n                    } else {\n                        multipleKeys.push(commandID);\n                    }\n                } else {\n                    invalidCommands.push(commandID);\n                }\n            }\n        });\n\n        if (restrictedCommands.length) {\n            errorMessage = StringUtils.format(Strings.ERROR_RESTRICTED_COMMANDS, _getBulletList(restrictedCommands));\n        }\n\n        if (restrictedKeys.length) {\n            errorMessage += StringUtils.format(Strings.ERROR_RESTRICTED_SHORTCUTS, _getBulletList(restrictedKeys));\n        }\n\n        if (multipleKeys.length) {\n            errorMessage += StringUtils.format(Strings.ERROR_MULTIPLE_SHORTCUTS, _getBulletList(multipleKeys));\n        }\n\n        if (duplicateBindings.length) {\n            errorMessage += StringUtils.format(Strings.ERROR_DUPLICATE_SHORTCUTS, _getBulletList(duplicateBindings));\n        }\n\n        if (invalidKeys.length) {\n            errorMessage += StringUtils.format(Strings.ERROR_INVALID_SHORTCUTS, _getBulletList(invalidKeys));\n        }\n\n        if (invalidCommands.length) {\n            errorMessage += StringUtils.format(Strings.ERROR_NONEXISTENT_COMMANDS, _getBulletList(invalidCommands));\n        }\n\n        if (_showErrors && errorMessage) {\n            _showErrorsAndOpenKeyMap(\"\", errorMessage);\n        }\n    }\n\n    /**\n     * Restores the default key bindings for all the commands that are modified by each key binding\n     * specified in _customKeyMapCache (old version) but no longer specified in _customKeyMap (new version).\n     *\n     * @private\n     */\n    function _undoPriorUserKeyBindings() {\n        _.forEach(_customKeyMapCache, function (commandID, key) {\n            let normalizedKey  = normalizeKeyDescriptorString(key),\n                defaults       = _.find(_.toArray(_defaultKeyMap), { \"commandID\": commandID }),\n                defaultCommand = _defaultKeyMap[normalizedKey];\n\n            // We didn't modified this before, so skip it.\n            if (_isSpecialCommand(commandID) ||\n                    _isReservedShortcuts(normalizedKey)) {\n                return;\n            }\n\n            if (_isKeyAssigned(normalizedKey) &&\n                    _customKeyMap[key] !== commandID && _customKeyMap[normalizedKey] !== commandID) {\n                // Unassign the key from any command. e.g. \"Cmd-W\": \"file.open\" in _customKeyMapCache\n                // will require us to remove Cmd-W shortcut from file.open command.\n                removeBinding(normalizedKey);\n            }\n\n            // Reassign the default key binding. e.g. \"Cmd-W\": \"file.open\" in _customKeyMapCache\n            // will require us to reassign Cmd-O shortcut to file.open command.\n            if (defaults) {\n                addBinding(commandID, defaults, brackets.platform);\n            }\n\n            // Reassign the default key binding of the previously modified command.\n            // e.g. \"Cmd-W\": \"file.open\" in _customKeyMapCache will require us to reassign Cmd-W\n            // shortcut to file.close command.\n            if (defaultCommand && defaultCommand.key) {\n                addBinding(defaultCommand.commandID, defaultCommand.key, brackets.platform);\n            }\n        });\n    }\n\n    /**\n     * Gets the full file path to the user key map file. In testing environment\n     * a different file path is returned so that running integration tests won't\n     * pop up the error dialog showing the errors from the actual user key map file.\n     *\n     * @private\n     * @return {string} full file path to the user key map file.\n     */\n    function _getUserKeyMapFilePath() {\n        if (window.isBracketsTestWindow) {\n            return path.normalize(brackets.app.getApplicationSupportDirectory() + \"/_test_/\" + KEYMAP_FILENAME);\n        }\n        return _userKeyMapFilePath;\n    }\n\n    async function _addToUserKeymapFile(shortcut, commandID) {\n        if(shortcut instanceof Array && commandID) {\n            console.error(\"Shortcut arrays can be specified only if the command id is null\", shortcut, commandID);\n            return;\n        }\n        let file   = FileSystem.getFileForPath(_getUserKeyMapFilePath());\n        let userKeyMap = {overrides:{}};\n        let keyMapExists = await Phoenix.VFS.existsAsync(file.fullPath);\n        if (keyMapExists) {\n            const text = await deferredToPromise(FileUtils.readAsText(file, true));\n            try {\n                if (text) {\n                    userKeyMap = JSON.parse(text);\n                    const overrides = userKeyMap.overrides || {};\n                    // check if the same command is already assigned a shortcut, then remove before we add\n                    // a new shortcut. This is because when one command has multiple shortcuts, we usually\n                    // show a duplicate shortcut dialog. this is unlikely to happen when using the ui. only happens\n                    // when a use manually edits the json. in which case we hope he knows what he is doing.\n                    for(let shortcutKey of Object.keys(overrides)) {\n                        if(commandID && overrides[shortcutKey] === commandID){\n                            delete overrides[shortcutKey];\n                        }\n                    }\n                }\n            } catch (err) {\n                // Cannot parse the text read from the key map file.\n                console.error(\"Error reading \", _getUserKeyMapFilePath(), err);\n                return;\n            }\n        }\n        if(shortcut instanceof Array) {\n            for(let shortcutKey of shortcut) {\n                if(!_isReservedShortcuts(shortcutKey)) {\n                    userKeyMap.overrides[shortcutKey] = commandID;\n                }\n            }\n        } else {\n            if(!_isReservedShortcuts(shortcut)) {\n                userKeyMap.overrides[shortcut] = commandID;\n            } // else we should show an error message here, but not doing it for now.\n        }\n        const textContent = JSON.stringify(userKeyMap, null, 4);\n        await deferredToPromise(FileUtils.writeText(file, textContent, true));\n        _loadUserKeyMap();\n    }\n\n    /**\n     * Reads in the user key map file and parses its content into JSON.\n     * Returns the user key bindings if JSON has \"overrides\".\n     * Otherwise, returns an empty object or an error if the file\n     * cannot be parsed or loaded.\n     *\n     * @private\n     * @return {$.Promise} a jQuery promise that will be resolved with the JSON\n     * object if the user key map file has \"overrides\" property or an empty JSON.\n     * If the key map file cannot be read or cannot be parsed by the JSON parser,\n     * then the promise is rejected with an error.\n     */\n    function _readUserKeyMap() {\n        let file   = FileSystem.getFileForPath(_getUserKeyMapFilePath()),\n            result = new $.Deferred();\n\n        file.exists(function (err, doesExist) {\n            if (doesExist) {\n                FileUtils.readAsText(file, true)\n                    .done(function (text) {\n                        let keyMap = {};\n                        try {\n                            if (text) {\n                                let json = JSON.parse(text);\n                                // If no overrides, return an empty key map.\n                                result.resolve((json && json.overrides) || keyMap);\n                            } else {\n                                // The file is empty, so return an empty key map.\n                                result.resolve(keyMap);\n                            }\n                        } catch (err) {\n                            // Cannot parse the text read from the key map file.\n                            result.reject(err);\n                        }\n                    })\n                    .fail(function (err) {\n                        // Key map file cannot be loaded.\n                        result.reject(err);\n                    });\n            } else {\n                // Just resolve if no user key map file\n                result.resolve({});\n            }\n        });\n        return result.promise();\n    }\n\n    /**\n     * This can be used by extensions to register new kepmap packs that can be listed in the keyboard shortcuts panel\n     * under use preset dropdown. For EG. distribute a `netbeans editor` shortcuts pack via extension.\n     *\n     * @param {string} packID - A unique ID for the pack. Use `extensionID.name` format to avoid collisions.\n     * @param {string} packName - A name for the pack.\n     * @param {Object} keyMap - a keymap of the format `{'Ctrl-Alt-L': 'file.liveFilePreview'}` depending on the platform.\n     * The extension should decide the correct keymap based on the platform before calling this function.\n     */\n    function registerCustomKeymapPack(packID, packName, keyMap) {\n        if(_registeredCustomKeyMaps[packID]){\n            console.error(`registerCustomKeymapPack: ${packID} with name ${packName} is already registered. Ignoring`);\n            return;\n        }\n        console.log(\"registering custom keymap pack\", packID, packName);\n        _registeredCustomKeyMaps[packID] = {\n            packageName: packName,\n            keyMap: _getNormalisedKeyMap(keyMap)\n        };\n        if(_customKeymapIDInUse === packID) {\n            _loadUserKeyMap();\n        }\n        exports.trigger(EVENT_NEW_PRESET, packID);\n    }\n\n    /**\n     * Responsible to get all the custom keymap packs\n     *\n     * @returns {Array.<Object>} an array of all the custom keymap packs,\n     * each pack is an object with keys: `packID`, `packageName` & `keyMap`\n     */\n    function getAllCustomKeymapPacks() {\n        const packDetails = [];\n        for(let packID of Object.keys(_registeredCustomKeyMaps)){\n            packDetails.push({\n                packID,\n                packageName: _registeredCustomKeyMaps[packID].packageName,\n                keyMap: structuredClone(_registeredCustomKeyMaps[packID].keyMap)\n            });\n        }\n        return packDetails;\n    }\n\n    /**\n     * To get the current custom keymap pack\n     *\n     * @returns {Object} the current custom keymap pack\n     */\n    function getCurrentCustomKeymapPack() {\n        return _registeredCustomKeyMaps[_customKeymapIDInUse];\n    }\n\n    /**\n     * Determines the origin of a custom keyboard shortcut is from user keymap.json or a custom keymap preset.\n     * If it is neither (Eg. phoenix default shortcuts, will return null.)\n     *\n     * @private\n     * @param {string} shortcut - The keyboard shortcut to check.\n     * @returns {string|null} - The origin of the custom shortcut, or null if it is not a custom shortcut.\n     */\n    function _getCustomShortcutOrigin(shortcut) {\n        shortcut = normalizeKeyDescriptorString(shortcut);\n        if(_originalUserKeyMap.hasOwnProperty(shortcut)){\n            return Strings.KEYBOARD_SHORTCUT_SRC_USER;\n        } else if(_customKeyMap.hasOwnProperty(shortcut) && _customKeymapIDInUse &&\n            _registeredCustomKeyMaps[_customKeymapIDInUse]){\n            return StringUtils.format(Strings.KEYBOARD_SHORTCUT_SRC_PRESET,\n                _registeredCustomKeyMaps[_customKeymapIDInUse].packageName);\n        }\n        return null;\n    }\n\n    /**\n     * internal use, this is for setting the current custom keyboard pack.\n     *\n     * @param packID\n     * @private\n     */\n    function _setCurrentCustomKeymapPack(packID) {\n        if(!PreferencesManager){\n            throw new Error(\"setCurrentCustomKeymapPack should be called only after appinit event.\");\n        }\n        PreferencesManager.stateManager.set(STATE_CUSTOM_KEY_MAP_ID, packID);\n    }\n\n    function _mixCustomKeyMaps(userKeyMap) {\n        if(!_customKeymapIDInUse || !_registeredCustomKeyMaps[_customKeymapIDInUse]){\n            return userKeyMap;\n        }\n        Metrics.countEvent(Metrics.EVENT_TYPE.KEYBOARD, 'preset', _customKeymapIDInUse);\n        // the custom keymap is something like {\"Ctrl-Shift-&\": \"navigate.gotoFirstProblem\"} .\n        // user defined shortcuts take precedence over custom shortcuts.\n        const customKeyMap = _registeredCustomKeyMaps[_customKeymapIDInUse].keyMap;\n        const userDefinedKeys = Object.keys(userKeyMap);\n        const userDefinedCommandIDs = Object.values(userKeyMap);\n        for(const customKey of Object.keys(customKeyMap)){\n            const customCommand = customKeyMap[customKey];\n            if(!userDefinedCommandIDs.includes(customCommand) && !userDefinedKeys.includes(customKey)){\n                // Assigning multiple shortcuts to the same command will throw a dialog, so we omit a custom command\n                // that is already assigned by user defined command. Also if a shortcut is already in user keymap, we\n                // wont apply the custom keymap\n                userKeyMap[customKey] = customCommand;\n            }\n        }\n    }\n\n    function _getNormalisedKeyMap(keyMap) {\n        const normalisedKeyMap = {};\n        const normalisedKeyMapCounts = {};\n        // if the supplied keymap has duplicates, we have to retain them as is for error dialogs later. Eg:\n        // { \"ctrl-2\": \"file.newFile\", \"Ctrl-2\": \"navigate.previousMatch\", // observe case of Ctrl here\n        //   \"Ctrl-Alt-4\": \"view.toggleSidebar\", \"Alt-Ctrl-4\": \"view.toggleSidebar\"}\n        for(let key of Object.keys(keyMap)) {\n            const normalisedKey = normalizeKeyDescriptorString(key);\n            normalisedKeyMapCounts[normalisedKey] = (normalisedKeyMapCounts[normalisedKey] || 0) + 1;\n        }\n        for(let key of Object.keys(keyMap)) {\n            try {\n                const normalisedKey = normalizeKeyDescriptorString(key);\n                if(normalisedKeyMapCounts[normalisedKey] === 1) {\n                    normalisedKeyMap[normalisedKey] = keyMap[key];\n                } else {\n                    // if we are here, it means the supplied keymap has non-normalised duplicates.\n                    // in case of duplicates, we will keep the keys as is in the map for the error dialogs to kick in.\n                    normalisedKeyMap[key] = keyMap[key];\n                }\n            } catch (e) {\n                console.error(\"Error normalising user keymap key: \", key, e);\n                // we will still inject the key with error as so that the error dialogs will come up as expected.\n                normalisedKeyMap[key] = keyMap[key];\n            }\n        }\n        return normalisedKeyMap;\n    }\n\n    /**\n     * Reads in the user key bindings and updates the key map with each user key\n     * binding by removing the existing one assigned to each key and adding\n     * new one for the specified command id. Shows errors and opens the user\n     * key map file if it cannot be parsed.\n     *\n     * This function is wrapped with debounce so that its execution is always delayed\n     * by 200 ms. The delay is required because when this function is called some\n     * extensions may still be adding some commands and their key bindings asynchronously.\n     *\n     * @private\n     */\n    function _loadUserKeyMapImmediate() {\n        return new Promise((resolve, reject)=>{\n            _readUserKeyMap()\n                .then(function (keyMap) {\n                    keyMap = _getNormalisedKeyMap(keyMap);\n                    _originalUserKeyMap = structuredClone(keyMap);\n                    _mixCustomKeyMaps(keyMap);\n                    // Some extensions may add a new command without any key binding. So\n                    // we always have to get all commands again to ensure that we also have\n                    // those from any extensions installed during the current session.\n                    _allCommands = CommandManager.getAll();\n\n                    _customKeyMapCache = _.cloneDeep(_customKeyMap);\n                    _customKeyMap = keyMap;\n                    _undoPriorUserKeyBindings();\n                    _applyUserKeyBindings();\n                    resolve();\n                }, function (err) {\n                    _showErrorsAndOpenKeyMap(err);\n                    console.error(err);\n                    // we always resolve here as the event is handled\n                    resolve();\n                });\n        });\n    };\n\n    /**\n     * resets all user defined shortcuts\n     *\n     * @return {Promise|Promise<void>|*}\n     */\n    function resetUserShortcutsAsync() {\n        return new Promise((resolve, reject)=>{\n            let userKeyMapPath = _getUserKeyMapFilePath(),\n                file = FileSystem.getFileForPath(userKeyMapPath);\n            let defaultContent = \"{\\n    \\\"documentation\\\": \\\"https://github.com/phcode-dev/phoenix/wiki/User-%60keymap.json%60\\\",\" +\n                \"\\n    \\\"overrides\\\": {\" +\n                \"\\n        \\n    }\\n}\\n\";\n\n            return FileUtils.writeText(file, defaultContent, true).done(()=>{\n                _loadUserKeyMapImmediate()\n                    .then(resolve)\n                    .catch(reject);\n            }).fail(reject);\n        });\n    }\n\n    /**\n     * Opens the existing key map file or creates a new one with default content\n     * if it does not exist.\n     *\n     * @private\n     */\n    function _openUserKeyMap() {\n        let userKeyMapPath = _getUserKeyMapFilePath(),\n            file = FileSystem.getFileForPath(userKeyMapPath);\n        file.exists(function (err, doesExist) {\n            if (doesExist) {\n                CommandManager.execute(Commands.FILE_OPEN, { fullPath: userKeyMapPath });\n            } else {\n                resetUserShortcutsAsync().finally(function () {\n                    CommandManager.execute(Commands.FILE_OPEN, { fullPath: userKeyMapPath });\n                });\n            }\n        });\n    }\n\n    // Due to circular dependencies, not safe to call on() directly\n    EventDispatcher.on_duringInit(CommandManager, \"commandRegistered\", _handleCommandRegistered);\n    CommandManager.register(Strings.CMD_OPEN_KEYMAP, Commands.FILE_OPEN_KEYMAP, _openUserKeyMap);\n\n    // Asynchronously loading DocumentManager to avoid the circular dependency\n    require([\"document/DocumentManager\"], function (DocumentManager) {\n        DocumentManager.on(\"documentSaved\", function checkKeyMapUpdates(e, doc) {\n            if (doc && doc.file.fullPath === _userKeyMapFilePath) {\n                _loadUserKeyMap();\n            }\n        });\n    });\n\n    /**\n     * Initializes _allCommands array and _defaultKeyMap so that we can use them for\n     * detecting non-existent commands and restoring the original key binding.\n     *\n     * @private\n     */\n    function _initCommandAndKeyMaps() {\n        _allCommands = CommandManager.getAll();\n        // Keep a copy of the default key bindings before loading user key bindings.\n        _initDefaultShortcuts();\n        _defaultKeyMap = _.cloneDeep(_keyMap);\n    }\n\n    /**\n     * Sets the full file path to the user key map file. Only used by unit tests\n     * to load a test file instead of the actual user key map file.\n     *\n     * @private\n     * @param {string} fullPath file path to the user key map file.\n     */\n    function _setUserKeyMapFilePath(fullPath) {\n        _userKeyMapFilePath = fullPath;\n    }\n\n    AppInit.extensionsLoaded(function () {\n        let params  = new UrlParams();\n        params.parse();\n        if (params.get(\"reloadWithoutUserExts\") === \"true\") {\n            _showErrors = false;\n        }\n\n        _initCommandAndKeyMaps(); // this will save the default keymap. custom keymap loads should only come after this.\n        PreferencesManager = Phoenix.globalAPI && Phoenix.globalAPI.PreferencesManager;\n        PreferencesManager.stateManager.definePreference(STATE_CUSTOM_KEY_MAP_ID, \"string\", null)\n            .on(\"change\", ()=>{\n                _customKeymapIDInUse = PreferencesManager.stateManager.get(STATE_CUSTOM_KEY_MAP_ID);\n                _loadUserKeyMap();\n                exports.constructor(EVENT_PRESET_CHANGED, _customKeymapIDInUse);\n            });\n        PreferencesManager.definePreference(PREF_TRIPLE_CTRL_KEY_PRESS_ENABLED, \"boolean\", true, {\n            description: Strings.DESCRIPTION_TRIPLE_CTRL_PALETTE\n        });\n        _customKeymapIDInUse = PreferencesManager.stateManager.get(STATE_CUSTOM_KEY_MAP_ID);\n        _loadUserKeyMap();\n    });\n\n    /**\n     * Whether the keyboard is in overlay mode or not\n     *\n     * @returns {boolean} True if in overlay mode else false\n     */\n    function isInOverlayMode() {\n        return KeyboardOverlayMode.isInOverlayMode();\n    }\n\n    function _isAnAssignableKey(key) {\n        if(!key){\n            return false;\n        }\n        const split = key.split(\"-\");\n        if(split.length === 1 && key.length > 1 && key[0]==='F'){\n            // F1-12\n            return true;\n        } else if(split.length === 2 && split[0] === \"Shift\" && split[1].length > 1){\n            // Shift - F1-12, shift-PgUp etc... which are allowed\n            return true;\n        } else if(split.length === 2 && split[0] === \"Shift\" && split[1].length === 1){\n            // Shift-A, Shift-! etc which are upper case chars -not shortcuts. we don't allow that.\n            return false;\n        } else if(key.includes(\"-\")){\n            // allow all compound shortcuts\n            return true;\n        }\n        return false;\n    }\n\n    function updateShortcutSelection(event, key) {\n        if(key && _isAnAssignableKey(key) && normalizeKeyDescriptorString(key)) {\n            let normalizedKey = normalizeKeyDescriptorString(key);\n            if (_isReservedShortcuts(normalizedKey)) {\n                console.warn(\"Cannot assign reserved shortcut: \", normalizedKey);\n                event.stopPropagation();\n                event.preventDefault();\n                return true;\n            }\n            capturedShortcut = normalizedKey;\n            let existingBinding = _keyMap[normalizedKey];\n            if (!normalizedKey) {\n                console.error(\"Failed to normalize \" + key);\n            } else if(existingBinding && existingBinding.commandID === keyboardShortcutCaptureInProgress.getID()){\n                // user press the same shortcut that is already assigned to the command\n                keyboardShortcutDialog.close();\n                keyboardShortcutDialog = null;\n                keyboardShortcutCaptureInProgress = null;\n            } else if (existingBinding) {\n                const command = CommandManager.get(existingBinding.commandID);\n                $(\".change-shortcut-dialog .message\").html(\n                    StringUtils.format(Strings.KEYBOARD_SHORTCUT_CHANGE_DIALOG_DUPLICATE,\n                        key, command.getName(), keyboardShortcutCaptureInProgress.getName()));\n                $(\".change-shortcut-dialog .Assign\").removeClass(\"forced-hidden\").focus();\n                $(\".change-shortcut-dialog .Remove\").addClass(\"forced-hidden\");\n            } else {\n                keyboardShortcutDialog.close();\n                keyboardShortcutDialog = null;\n                _addToUserKeymapFile(key, keyboardShortcutCaptureInProgress.getID());\n                keyboardShortcutCaptureInProgress = null;\n            }\n            event.stopPropagation();\n            event.preventDefault();\n        }\n        return true;\n    }\n\n    let keyboardShortcutCaptureInProgress = null,\n        keyboardShortcutDialog = null,\n        capturedShortcut = null;\n\n    /**\n     * to display the shortcut selection dialog\n     *\n     * @param command\n     */\n    function showShortcutSelectionDialog(command) {\n        Metrics.countEvent(Metrics.EVENT_TYPE.KEYBOARD, 'shortcut', \"DialogShown\");\n        if(_isSpecialCommand(command.getID())){\n            return;\n        }\n        const panelCommand = CommandManager.get(Commands.HELP_TOGGLE_SHORTCUTS_PANEL);\n        capturedShortcut = null;\n        const keyBindings = getKeyBindings(command);\n        let currentShortcutText = Strings.KEYBOARD_SHORTCUT_NONE;\n        if(keyBindings.length){\n            currentShortcutText = keyBindings[0].displayKey || keyBindings[0].key;\n            for(let i=1; i<keyBindings.length; i++){\n                currentShortcutText = currentShortcutText + `, ${keyBindings[i].displayKey || keyBindings[i].key}`;\n            }\n        }\n        keyboardShortcutCaptureInProgress = command;\n        keyboardShortcutDialog = Dialogs.showModalDialogUsingTemplate(Mustache.render(KeyboardDialogTemplate, {\n            Strings: Strings,\n            message: StringUtils.format(Strings.KEYBOARD_SHORTCUT_CHANGE_DIALOG_TEXT, command.getName(), currentShortcutText)\n        }));\n        if(currentShortcutText === Strings.KEYBOARD_SHORTCUT_NONE){\n            $(\".change-shortcut-dialog .Remove\").addClass(\"forced-hidden\");\n        }\n        if(panelCommand && panelCommand.getChecked()){\n            $(\".change-shortcut-dialog .Show\").addClass(\"forced-hidden\");\n        }\n        keyboardShortcutDialog.done((closeReason)=>{\n            if(closeReason === 'remove' && currentShortcutText){\n                _addToUserKeymapFile(keyBindings.map(k=>k.key), null);\n                Metrics.countEvent(Metrics.EVENT_TYPE.KEYBOARD, 'shortcut', \"removed\");\n            } else if(closeReason === Dialogs.DIALOG_BTN_OK && capturedShortcut){\n                _addToUserKeymapFile(capturedShortcut, command.getID());\n                Metrics.countEvent(Metrics.EVENT_TYPE.KEYBOARD, 'shortcut', \"changed\");\n            } else if(closeReason === 'show'){\n                if(!panelCommand.getChecked()){\n                    panelCommand.execute();\n                }\n            }\n            capturedShortcut = null;\n            keyboardShortcutCaptureInProgress = null;\n            keyboardShortcutDialog = null;\n        });\n    }\n\n    /**\n     * Returns true the given command id can be overriden by user.\n     *\n     * @param commandId\n     * @return {boolean}\n     */\n    function canAssignBinding(commandId) {\n        return !_isSpecialCommand(commandId);\n    }\n\n    /**\n     * gets a list of commands that are known to have had a key binding in this session. Note that this will contain\n     * commands that may not currently have a key binding. IT is mainly used in keyboard shortcuts panel to list items\n     * that can be assigned a key binding.\n     *\n     * @type {Set<string>}\n     * @private\n     */\n    function _getKnownBindableCommands() {\n        return new Set(knownBindableCommands);\n    }\n\n    EventDispatcher.makeEventDispatcher(exports);\n\n    // unit test only\n    exports._reset = _reset;\n    exports._setUserKeyMapFilePath = _setUserKeyMapFilePath;\n    exports._getUserKeyMapFilePath = _getUserKeyMapFilePath;\n    exports._getDisplayKey = _getDisplayKey;\n    exports._loadUserKeyMap = _loadUserKeyMap;\n    exports._loadUserKeyMapImmediate = _loadUserKeyMapImmediate;\n    exports._initCommandAndKeyMaps = _initCommandAndKeyMaps;\n    exports._onCtrlUp = _onCtrlUp;\n\n    // private api\n    exports._getKnownBindableCommands = _getKnownBindableCommands;\n    exports._getCustomShortcutOrigin = _getCustomShortcutOrigin;\n    exports._setCurrentCustomKeymapPack = _setCurrentCustomKeymapPack;\n\n    // Define public API\n    exports.getKeymap = getKeymap;\n    exports.canAssignBinding = canAssignBinding;\n    exports.addBinding = addBinding;\n    exports.removeBinding = removeBinding;\n    exports.formatKeyDescriptor = formatKeyDescriptor;\n    exports.getKeyBindings = getKeyBindings;\n    exports.getKeyBindingsDisplay = getKeyBindingsDisplay;\n    exports.addGlobalKeydownHook = addGlobalKeydownHook;\n    exports.removeGlobalKeydownHook = removeGlobalKeydownHook;\n    exports.isInOverlayMode = isInOverlayMode;\n    exports.resetUserShortcutsAsync = resetUserShortcutsAsync;\n    exports.showShortcutSelectionDialog = showShortcutSelectionDialog;\n    exports.registerCustomKeymapPack = registerCustomKeymapPack;\n    exports.getAllCustomKeymapPacks = getAllCustomKeymapPacks;\n    exports.getCurrentCustomKeymapPack = getCurrentCustomKeymapPack;\n\n    // public constants\n    exports.KEY = KEY;\n    // public events\n    exports.EVENT_KEY_BINDING_ADDED = EVENT_KEY_BINDING_ADDED;\n    exports.EVENT_KEY_BINDING_REMOVED = EVENT_KEY_BINDING_REMOVED;\n    exports.EVENT_NEW_PRESET = EVENT_NEW_PRESET;\n    exports.EVENT_PRESET_CHANGED = EVENT_PRESET_CHANGED;\n\n    /**\n     * Use windows-specific bindings if no other are found (e.g. Linux).\n     * Core Brackets modules that use key bindings should always define at\n     * least a generic keybinding that is applied for all platforms. This\n     * setting effectively creates a compatibility mode for third party\n     * extensions that define explicit key bindings for Windows and Mac, but\n     * not Linux.\n     */\n    exports.useWindowsCompatibleBindings = false;\n\n    // For unit testing only\n    exports._handleKey = _handleKey;\n    exports._handleKeyEvent = _handleKeyEvent;\n});\n"],"file":"KeyBindingManager.js"}