{"version":3,"sources":["worker/WorkerComm.js"],"names":["ENV_BROWSER","ENV_WORKER","EVT_TYPE_EXEC","EVT_TYPE_RESPONSE","EVT_TYPE_TRIGGER","EXEC_LOAD_SCRIPT","EVENT_WORKER_COMM_INIT_COMPLETE","globalObject","env","createWorkerComm","postTarget","eventDispatcher","postUniqueId","callBacks","execHandlers","setExecHandler","fnName","execHandlerFn","console","error","execPeer","paramObject","Promise","resolve","reject","postMessage","JSON","stringify","type","exec","params","triggerPeer","eventName","loadScriptQueue","workerCommLoadCompleteInWorker","loadPendingScripts","queuedLoads","loadScriptInWorker","scriptURL","isModule","on","async","push","_loadScriptHandler","log","import","importScripts","_processResponse","data","err","response","_processTrigger","trigger","_processExec","message","stack","toString","onmessage","e","parse","window","self","WorkerComm","EventDispatcher","makeEventDispatcher","define","require","exports","module"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n// @INCLUDE_IN_API_DOCS\n\n/**\n * WorkerComm provides util methods to communicate between web workers and Phoenix.\n * This module can be loaded from within web-workers and a phoenix extension that loads the web-worker.\n *\n * ### Creating a WebWorker from your extension and attaching `WorkerComm` to it.\n * See an example extension code below that creates its own web worker and uses `WorkerComm` for communication.\n * @example\n * ```js\n * // from within an extension\n * const WorkerComm = brackets.getModule(\"worker/WorkerComm\"),\n *       EventDispatcher = brackets.getModule(\"utils/EventDispatcher\"),\n *       ExtensionUtils = brackets.getModule(\"utils/ExtensionUtils\");\n *\n * // figure out the path of the web worker relative to your extension\n * let workerPath = ExtensionUtils.getModulePath(module, \"my_worker_path_within_extension.js\")\n *\n * // we need to pass in the `workerCommUrl` so that the web-worker can\n * // load`WorkerComm` within the worker context as described below.\n * let workerCommUrl = `${Phoenix.baseURL}worker/WorkerComm.js`;\n * let eventDispatcherURL = `${Phoenix.baseURL}utils/EventDispatcher.js`;\n *\n * // load the worker\n * const _myWorker = new Worker(\n * `${workerPath}?workerCommUrl=${workerCommUrl}&eventDispatcherURL=${eventDispatcherURL}`);\n *\n * // Not create a `WorkerComm` object and attach to your extension module exports.\n * EventDispatcher.makeEventDispatcher(exports);\n * // all WorkerComm objects needs to be an EventDispatcher.\n * WorkerComm.createWorkerComm(_myWorker, exports);\n *\n * // Now `exports` can be used to communicate with the web-worker\n * // using `WorkerComm` APIs listed below.\n * ```\n *\n * ### Loading `WorkerComm` from within your webWorker\n * The Web Worker we created above also needs to load `WorkerComm` to be able to communicate with the `WorkerComm`\n * instance in Phoenix. For this, we need to load `WorkerComm` from the URL parameters.\n * (WorkerComm.js lib url needs to passed in while creating the web worker from Phoenix).\n * @example\n * ```js\n * const urlParams = new URLSearchParams(location.search);\n * importScripts(urlParams.get('workerCommUrl'));\n * importScripts(urlParams.get('eventDispatcherURL'));\n * // After this, a global `WorkerComm` object will be available within the\n * // web-worker that can be used to communicate with Phoenix.\n * ```\n * ## APIs\n * @module worker/WorkerComm\n */\n\n(function () {\n\n    const ENV_BROWSER = 'browser',\n        ENV_WORKER = 'worker',\n        EVT_TYPE_EXEC = 'exec',\n        EVT_TYPE_RESPONSE = 'response',\n        EVT_TYPE_TRIGGER = 'trigger';\n\n    const EXEC_LOAD_SCRIPT = 'loadScript',\n        EVENT_WORKER_COMM_INIT_COMPLETE = \"WorkerCommInitDone\";\n\n    let globalObject = {};\n    let env;\n    if(typeof window !== 'undefined'){\n        globalObject = window; // browser\n        env = ENV_BROWSER;\n    } else if(typeof self !== 'undefined'){\n        globalObject = self; // web worker\n        env = ENV_WORKER;\n    } else {\n        console.error(\"unknown environment used to setup WorkerComm\");\n    }\n\n    if(globalObject.WorkerComm){\n        // already created\n        return;\n    }\n\n    if(!globalObject.EventDispatcher){\n        console.error(\n            `${env}: Event dispatcher not loaded. Please importScripts utils/EventDispatcher.js before WorkerComm`);\n        return;\n    }\n\n    /**\n     * Adds support for WorkerComm APIs to the provided web-Worker instance. Only available in the main thread.\n     * This API should be called immediately after creating the worker in main thread.\n     * Create a web-worker with `WorkerComm` in an extension.\n     * // load the worker [See API docs for full sample]\n     * const _myWorker = new Worker(\n     * `${workerPath}?workerCommUrl=${workerCommUrl}&eventDispatcherURL=${eventDispatcherURL}`);\n     *\n     * // Now create a `WorkerComm` object and attach to your extension module exports.\n     * EventDispatcher.makeEventDispatcher(exports);\n     * // all WorkerComm objects needs to be an EventDispatcher.\n     * WorkerComm.createWorkerComm(_myWorker, exports);\n     * @param {string} postTarget - The web-worker reference.\n     * @param {object} eventDispatcher created with `util/EventDispatcher`.\n     * @type {function}\n     */\n    function createWorkerComm(postTarget, eventDispatcher) {\n        let postUniqueId = 0;\n        let callBacks = {};\n        let execHandlers = {};\n\n        /**\n         * Sets a named function execution handler in the main thread or worker thread.\n         * To set a named function `sayHello` in worker and phoenix\n         *\n         * function sayHello(arg)=>{\n         *     console.log(\"hello from worker \", arg); // prints \"hello from worker phoenix\"\n         *     return \"Hello Phoenix\";\n         * }\n         *\n         * // For usage in web-worker say my_worker.js, use the global `WorkerComm` object.\n         * WorkerComm.setExecHandler(\"sayHello\", sayHello);\n         * // For usage in phoenix extension side, use `eventDispatcher` object used with `createWorkerComm`.\n         * YourWorker.setExecHandler(\"sayHello\", sayHello);\n         * @param {string} fnName - The name of the function to register as exec handler.\n         * @param {function} execHandlerFn\n         * @returns {Promise} That will be resolved or rejected based on function execution at the other end.\n         * @type {function}\n         */\n        eventDispatcher.setExecHandler = function (fnName, execHandlerFn) {\n            if(execHandlers[fnName]){\n                console.error(`${env}: Exec handler of same name already registered, will be overwritten: ${fnName}`);\n            }\n            execHandlers[fnName] = execHandlerFn;\n        };\n\n        /**\n         * Executes the named function at the other end if present. If this is called from the main thread, it will\n         * execute the function at the worker thread and vice-versa. The function to execute\n         * is set with API `setExecHandler`.\n         * To Execute a named function `sayHello` in the worker from phoenix\n         * // in my_worker.js\n         * WorkerComm.setExecHandler(\"sayHello\", (arg)=>{\n         *     console.log(\"hello from worker \", arg); // prints \"hello from worker phoenix\"\n         *     return \"Hello Phoenix\";\n         *   });\n         * // In Phoenix/extension\n         * let workerMessage = await YourWorker.execPeer(\"sayHello\", \"phoenix\");\n         * console.log(workerMessage); // prints \"Hello Phoenix\"\n         * @param {string} fnName - The name of the function to execute at the other end.\n         * @param {object} paramObject to be passed on to the function at the other end.\n         * @returns {Promise} That will be resolved or rejected based on function execution at the other end.\n         * @type {function}\n         */\n        eventDispatcher.execPeer = function (fnName, paramObject) {\n            postUniqueId++;\n            return new Promise((resolve, reject)=>{\n                postTarget.postMessage(JSON.stringify({\n                    type: EVT_TYPE_EXEC,\n                    exec: fnName,\n                    params: paramObject,\n                    postUniqueId: postUniqueId\n                }));\n                callBacks[postUniqueId] = {resolve, reject};\n            });\n        };\n\n        /**\n         * Triggers events at the other end on the eventDispatcher. If this is called from the main thread, it will\n         * trigger `WorkerComm` global at the worker thread. If this is called from the worker thread, it will\n         * trigger `eventDispatcher` used in `createWorkerComm` API call when creating the worker.\n         * To Trigger a named event `searchDone` from worker to phoenix\n         * // in my_worker.js\n         * WorkerComm.triggerPeer(\"searchDone\", {matches: 2});\n         *\n         * // In Phoenix/extension, you can listen to these events\n         * YourWorker.on(\"searchDone\", (result)=>{\n         *     console.log(result.matches);\n         * });\n         * @param {string} eventName to trigger at the other end\n         * @param {object} paramObject to be passed on to the event listener at the other end.\n         * @type {function}\n         */\n        eventDispatcher.triggerPeer = function (eventName, paramObject) {\n            postTarget.postMessage(JSON.stringify({\n                type: EVT_TYPE_TRIGGER,\n                eventName: eventName,\n                params: paramObject\n            }));\n        };\n\n        if(env === ENV_BROWSER){\n            // In browser main thread, loadScriptInWorker api will be present in WorkerComm. But we have to ensure that\n            // within the web-worker thread, WorkerComm is inited to properly handle the script load message. So,\n            // we queue all script load requests till we get EVENT_WORKER_COMM_INIT_COMPLETE and then load all pending\n            // queued scripts.\n            let loadScriptQueue = [],\n                workerCommLoadCompleteInWorker = false;\n            function loadPendingScripts() {\n                workerCommLoadCompleteInWorker = true;\n                for(let queuedLoads of loadScriptQueue){\n                    eventDispatcher.loadScriptInWorker(queuedLoads.scriptURL, queuedLoads.isModule);\n                }\n                loadScriptQueue = [];\n            }\n            eventDispatcher.on(EVENT_WORKER_COMM_INIT_COMPLETE, loadPendingScripts);\n            /**\n             * Loads a script into the worker context. Only available within the main thread. This can be used\n             * by the main Phoenix thread to dynamically load scripts in the worker-thread.\n             * To load a script `add_worker_Script.js` into the your worker:\n             * WorkerComm.createWorkerComm(_myWorker, exports);\n             * .....\n             * let ExtensionUtils = brackets.getModule(\"utils/ExtensionUtils\");\n             * let addWorkerScriptPath = ExtensionUtils.getModulePath(module, \"add_worker_Script.js\")\n             * await exports.loadScriptInWorker(addWorkerScriptPath);\n             * // if the worker is an es-module, then set optional isModule to true\n             * // Eg.loadScriptInWorker(addWorkerScriptPath, true);\n             * @param {string} scriptURL the Full url to load.\n             * @param {boolean} isModule if the url is a module url\n             * @type {function}\n             */\n            eventDispatcher.loadScriptInWorker = async function (scriptURL, isModule) {\n                if(!workerCommLoadCompleteInWorker){\n                    loadScriptQueue.push({scriptURL, isModule});\n                    return;\n                }\n                await eventDispatcher.execPeer(EXEC_LOAD_SCRIPT, {scriptURL, isModule});\n            };\n        } else {\n            function _loadScriptHandler({scriptURL, isModule}) {\n                console.log(`${env}: loading script from url: ${scriptURL}, isModule: ${isModule}`);\n                if(!isModule){\n                    importScripts(scriptURL);\n                } else {\n                    return import(scriptURL);\n                }\n            }\n            eventDispatcher.setExecHandler(EXEC_LOAD_SCRIPT, _loadScriptHandler);\n        }\n\n\n        function _processResponse(data) {\n            if(data.type === EVT_TYPE_RESPONSE){\n                // this is a response event\n                let postUniqueId = data.postUniqueId;\n                if(callBacks[postUniqueId]){\n                    let {resolve, reject} = callBacks[postUniqueId];\n                    if(data.err){\n                        reject(data.err);\n                    } else {\n                        resolve(data.response);\n                    }\n                    delete callBacks[postUniqueId];\n                }\n                return true;\n            }\n            return false;\n        }\n\n        function _processTrigger(data) {\n            if(data.type === EVT_TYPE_TRIGGER){\n                // this is a trigger event\n                eventDispatcher.trigger(data.eventName, data.params);\n                return true;\n            }\n            return false;\n        }\n\n        async function _processExec(data) {\n            let response = {\n                type: EVT_TYPE_RESPONSE,\n                err: null,\n                response: null,\n                postUniqueId: data.postUniqueId\n            };\n            let execHandlerFn = execHandlers[data.exec];\n            try {\n                if(!execHandlerFn){\n                    console.error(`${env}: Unknown exec function received: ${JSON.stringify(data)}`);\n                    response.err = `\"Unknown exec function received\" ${data.exec}`;\n                } else {\n                    response.response = execHandlerFn(data.params);\n                    if(response.response instanceof Promise){\n                        response.response = await response.response;\n                    }\n                }\n            } catch (err) {\n                response.err = err.message || err.stack ?\n                    {message: err.message, stack: err.stack}\n                    : err.toString();\n            }\n            postTarget.postMessage(JSON.stringify(response));\n        }\n\n        postTarget.onmessage = async function(e) {\n            let data = JSON.parse(e.data);\n            if(_processResponse(data)){\n                return;\n            }\n            if(_processTrigger(data)){\n                return;\n            }\n            await _processExec(data);\n        };\n    }\n\n    if(env === ENV_BROWSER){\n        // from browser thread, multiple worker thread can be created and attached to workerComm.\n        globalObject.WorkerComm = {createWorkerComm};\n    } else {\n        // from worker thread, communication is only possible with parent main thread.\n        // we create a global `WorkerComm` in worker for event handling within the worker\n        globalObject.WorkerComm = {};\n        globalObject.EventDispatcher.makeEventDispatcher(globalObject.WorkerComm);\n        createWorkerComm(globalObject, globalObject.WorkerComm);\n        globalObject.WorkerComm.triggerPeer(EVENT_WORKER_COMM_INIT_COMPLETE);\n    }\n\n    if(globalObject.define && env === ENV_BROWSER){\n        // for requirejs support\n        define(function (require, exports, module) {\n            exports.createWorkerComm = globalObject.WorkerComm.createWorkerComm;\n            /**\n             * Raised on main thread when WorkerComm is loaded in the web-worker and is ready.\n             * @event EVENT_WORKER_COMM_INIT_COMPLETE\n             */\n            exports.EVENT_WORKER_COMM_INIT_COMPLETE = EVENT_WORKER_COMM_INIT_COMPLETE;\n        });\n    }\n}());\n"],"file":"WorkerComm.js"}