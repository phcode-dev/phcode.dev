{"version":3,"sources":["extensions/default/CodeFolding/extension-min.js"],"names":["define","require","exports","module","CodeMirror","brackets","getModule","Strings","AppInit","CommandManager","DocumentManager","Editor","EditorManager","ProjectManager","ViewStateManager","KeyBindingManager","ExtensionUtils","Menus","prefs","COLLAPSE_ALL","COLLAPSE","EXPAND","EXPAND_ALL","GUTTER_NAME","CODE_FOLDING_GUTTER_PRIORITY","codeFoldingMenuDivider","collapseKey","expandKey","loadStyleSheet","foldGutter","foldCode","indentFold","handlebarsFold","selectionFold","_isInitialized","restoreLineFolds","editor","rangeEqualsSelection","range","selection","from","line","start","ch","to","end","isInViewStateSelection","viewState","selections","some","saveFolds","getSetting","cm","_codeMirror","getViewState","document","file","path","fullPath","folds","_lineFolds","getFolds","nonSelectionFolds","selectionFolds","Object","keys","forEach","getValidFolds","setFolds","Number","saveLineFolds","length","undefined","onGutterClick","gutter","event","opts","state","options","pos","Pos","isFolded","altKey","commands","unfoldAll","unfoldCode","fold","auto","foldToLevel","collapseCurrent","getFocusedEditor","cursor","i","getCursorPos","setCursorPos","expandCurrent","collapseAll","foldAll","expandAll","clearGutter","BLANK_GUTTER_CLASS","blank","window","createElement","className","vp","getViewport","operation","eachLine","setGutterMarker","lineNo","setupGutterEventListeners","$","getRootElement","addClass","setOption","getGutterElement","on","mouseenter","updateInViewport","mouseleave","removeClass","removeGutters","unregisterGutter","defineOption","enableFoldingInEditor","refresh","onActiveEditorChanged","current","previous","saveBeforeClose","getActiveEditor","deinit","removeBinding","getMenu","AppMenuBar","VIEW_MENU","removeMenuDivider","id","removeMenuItem","off","forEveryEditor","init","registerGlobalHelper","mode","registerHelper","doc","_masterEditor","addMenuDivider","addMenuItem","addBinding","key","platform","registerGutter","watchPrefsForChanges","prefsObject","e","data","ids","indexOf","isEnabled","htmlReady","register","COLLAPSE_CURRENT","EXPAND_CURRENT","PreferencesManager","getExtensionPrefs","FOLDS_PREF_KEY","ENABLE_CODE_FOLDING","MIN_FOLD_SIZE","SAVE_FOLD_STATES","ALWAYS_USE_INDENT_FOLD","HIDE_FOLD_BUTTONS","MAX_FOLD_LEVEL","MAKE_SELECTIONS_FOLDABLE","simplify","res","Array","isArray","inflate","ranges","obj","STATE_PROJECT_CONTEXT","allFolds","setViewState","get","clearAllFolds","definePreference","name","description","DESCRIPTION_CODE_FOLDING_ENABLED","DESCRIPTION_CODE_FOLDING_MIN_FOLD_SIZE","DESCRIPTION_CODE_FOLDING_SAVE_FOLD_STATES","DESCRIPTION_CODE_FOLDING_ALWAY_USE_INDENT_FOLD","DESCRIPTION_CODE_FOLDING_HIDE_UNTIL_MOUSEOVER","DESCRIPTION_CODE_FOLDING_MAX_FOLD_LEVEL","DESCRIPTION_CODE_FOLDING_MAKE_SELECTIONS_FOLDABLE","stateManager","SelectionFold","somethingSelected","getCursor","doFold","force","finder","rangeFinder","widget","textRange","getRange","allowFolded","marks","findMarksAt","lastMark","foldMarks","__isFold","cleared","clear","filter","d","find","makeWidget","scanUp","firstLine","markText","replacedWith","clearOnEnter","preventDefault","signal","defineExtension","this","rf","result","cachedRange","lineNumber","lastLine","unfold","foldLevel","n","funcs","prototype","slice","call","arguments","found","helpers","getHelpers","getMode","modeHelper","push","State","parseOptions","indicatorOpen","indicatorFolded","marker","spec","elt","isFold","m","updateFoldInfo","minFoldSize","fade","$gutter","_isCurrentlyFolded","setTimeout","sr","mark","func","is","isNaN","getFoldOnLine","syncDocToFoldsCache","lineAdded","moveRange","numLines","updateFoldsCache","linesDiff","oldRange","newRange","foldedLines","map","newFolds","Math","abs","onChange","changeObj","origin","lineChanges","text","removed","max","clearTimeout","changeUpdate","onViewportChange","onCursorActivity","onFold","onUnFold","val","old","Init","_","StringUtils","scanTextUntil","startCh","startLine","condition","getLine","seen","characterIndex","currentLine","concat","string","lineSeparator","endHelperName","test","endsWith","readUntil","character","tagStack","braceStack","openTag","openPos","currentCharacter","openTagIndex","substring","substr","tag","last","pop","cols","countColumn","lastNonEmptyLineNumber","lc","trim","lineText","tabSize","getOption","lineIndent","collapsible","lineCount","token","getTokenAt","type","indent"],"mappings":"AA4BAA,OAAO,SAAUC,QAASC,QAASC,QAG/B,IAAIC,WAA0BC,SAASC,UAAU,wCAC7CC,QAA0BF,SAASC,UAAU,WAC7CE,QAA0BH,SAASC,UAAU,iBAC7CG,eAA0BJ,SAASC,UAAU,0BAC7CI,gBAA0BL,SAASC,UAAU,4BAC7CK,OAA0BN,SAASC,UAAU,iBAAiBK,OAC9DC,cAA0BP,SAASC,UAAU,wBAC7CO,eAA0BR,SAASC,UAAU,0BAC7CQ,iBAA0BT,SAASC,UAAU,yBAC7CS,kBAA0BV,SAASC,UAAU,6BAC7CU,eAA0BX,SAASC,UAAU,wBAC7CW,MAA0BZ,SAASC,UAAU,iBAC7CY,MAA0BjB,QAAQ,SAClCkB,aAA0B,2BAC1BC,SAA0B,uBAC1BC,OAA0B,qBAC1BC,WAA0B,yBAC1BC,YAA0B,wBAC1BC,6BAAiCb,OAAOa,6BACxCC,uBAA0B,sBAC1BC,YAA0B,eAC1BC,UAA0B,eAE9BX,eAAeY,eAAezB,OAAQ,aAGtCE,SAASC,UAAU,CAAC,gDACpBD,SAASC,UAAU,CAAC,kDACpBD,SAASC,UAAU,CAAC,mDAKpB,IAAIuB,WAA0B5B,QAAQ,0BAClC6B,SAA0B7B,QAAQ,wBAClC8B,WAA0B9B,QAAQ,0BAClC+B,eAA0B/B,QAAQ,8BAClCgC,cAA0BhC,QAAQ,4BAIlCiC,gBAAiB,EAcrB,SAASC,iBAAiBC,QAOtB,SAASC,qBAAqBC,MAAOC,WACjC,OAAOD,MAAME,KAAKC,OAASF,UAAUG,MAAMD,MAAQH,MAAME,KAAKG,KAAOJ,UAAUG,MAAMC,IACjFL,MAAMM,GAAGH,OAASF,UAAUM,IAAIJ,MAAQH,MAAMM,GAAGD,KAAOJ,UAAUM,IAAIF,GAS9E,SAASG,uBAAuBR,MAAOS,WACnC,SAAKA,YAAcA,UAAUC,aAItBD,UAAUC,WAAWC,KAAK,SAAUV,WACvC,OAAOF,qBAAqBC,MAAOC,aAI3C,IAAIW,UAAYhC,MAAMiC,WAAW,kBAEjC,GAAKf,QAAWc,UAAhB,CAOA,IAAIE,GAAKhB,OAAOiB,YACZN,UAAYjC,iBAAiBwC,aAAalB,OAAOmB,SAASC,MAC1DC,KAAOrB,OAAOmB,SAASC,KAAKE,SAC5BC,MAAQP,GAAGQ,YAAc1C,MAAM2C,SAASJ,OAAS,GAGjDK,kBAAoB,GAAIC,eAAiB,GAAIzB,MACjD0B,OAAOC,KAAKN,OAAOO,QAAQ,SAAUzB,MAE7BK,uBADJR,MAAQqB,MAAMlB,MACoBM,WAC9BgB,eAAetB,MAAQH,MAEvBwB,kBAAkBrB,MAAQH,QAGlCwB,kBAAoBV,GAAGe,cAAcL,mBAErCE,OAAOC,KAAKF,gBAAgBG,QAAQ,SAAUzB,MAC1CqB,kBAAkBrB,MAAQsB,eAAetB,QAE7CW,GAAGQ,WAAaE,kBAChB5C,MAAMkD,SAASX,KAAML,GAAGQ,YACxBI,OAAOC,KAAKb,GAAGQ,YAAYM,QAAQ,SAAUzB,MACzCW,GAAGtB,SAASuC,OAAO5B,MAAO,CAACH,MAAOc,GAAGQ,WAAWnB,eA7B5CL,SACAA,OAAOiB,YAAYO,WAAaxB,OAAOiB,YAAYO,YAAc,IAoC7E,SAASU,cAAclC,QACnB,IAAIc,UAAYhC,MAAMiC,WAAW,kBACjC,GAAKf,QAAWc,UAAhB,CAGA,IAAIS,MAAQvB,OAAOiB,YAAYO,YAAc,GACzCH,KAAOrB,OAAOmB,SAASC,KAAKE,SAC5BM,OAAOC,KAAKN,OAAOY,OACnBrD,MAAMkD,SAASX,KAAME,OAErBzC,MAAMkD,SAASX,UAAMe,IAa7B,SAASC,cAAcrB,GAAIX,KAAMiC,OAAQC,OACrC,IAAIC,KAAOxB,GAAGyB,MAAMhD,WAAWiD,QAASC,IAAM3E,WAAW4E,IAAIvC,MAC7D,GAAIiC,SAAWE,KAAKF,OAApB,CACA,IAAIpC,MACAsB,WAAaR,GAAGQ,WAChBR,GAAG6B,SAASxC,MACRkC,MAAMO,QACN5C,MAAQsB,WAAWnB,MACnBrC,WAAW+E,SAASC,UAAUhC,GAAId,MAAME,KAAKC,KAAMH,MAAMM,GAAGH,OAE5DW,GAAGiC,WAAW5C,KAAM,CAACH,MAAOsB,WAAWnB,QAGvCkC,MAAMO,QACN5C,MAAQlC,WAAWkF,KAAKC,KAAKnC,GAAI2B,OAE7B3E,WAAW+E,SAASK,YAAYpC,GAAId,MAAME,KAAKC,KAAMH,MAAMM,GAAGH,MAGlEW,GAAGtB,SAASW,OAUxB,SAASgD,kBACL,IAAIrD,OAASxB,cAAc8E,mBAC3B,GAAKtD,OAAL,CAGA,IAAIgB,GAAKhB,OAAOiB,YACZsC,OAAgCC,EAEpC,IAAKA,EAFQxD,OAAOyD,eAEJpD,KAAMmD,GAAK,EAAGA,IAC1B,GAAIxC,GAAGtB,SAAS8D,GAEZ,YADAxD,OAAO0D,aAAaF,IAShC,SAASG,gBACL,IAAI3D,OAASxB,cAAc8E,mBAC3B,GAAItD,OAAQ,CACR,IAAIuD,OAASvD,OAAOyD,eAAgBzC,GAAKhB,OAAOiB,YAC7CgC,WAAWM,OAAOlD,OAiB7B,SAASuD,cACL,IAAI5D,OAASxB,cAAc8E,mBAC3B,GAAItD,OAAQ,CACR,IAAIgB,GAAKhB,OAAOiB,YAChBjD,WAAW+E,SAASc,QAAQ7C,KAOpC,SAAS8C,YACL,IAAI9D,OAASxB,cAAc8E,mBAC3B,GAAItD,OAAQ,CACR,IAAIgB,GAAKhB,OAAOiB,YAChBjD,WAAW+E,SAASC,UAAUhC,KAItC,SAAS+C,YAAY/D,QACjB,IAAIgB,GAAKhB,OAAOiB,YACZ+C,mBAAqB,8BACzBhE,OAAO+D,YAAY5E,aACnB,IAAI8E,MAAQC,OAAO/C,SAASgD,cAAc,OAC1CF,MAAMG,UAAYJ,mBAClB,IAAIK,GAAKrD,GAAGsD,cACZtD,GAAGuD,UAAU,WACTvD,GAAGwD,SAASH,GAAGjE,KAAMiE,GAAG7D,GAAI,SAAUH,MAClCL,OAAOyE,gBAAgBpE,KAAKqE,SAAUvF,YAAa8E,WAS/D,SAASU,0BAA0B3E,QAC/B,IAAIgB,GAAKhB,OAAOiB,YAChB2D,EAAE5E,OAAO6E,kBAAkBC,SAAS,mBACpC9D,GAAG+D,UAAU,aAAc,CAAC1C,cAAeA,gBAE3CuC,EAAE5D,GAAGgE,oBAAoBC,GAAG,CACxBC,WAAY,WACJpG,MAAMiC,WAAW,sBACjBtB,WAAW0F,iBAAiBnE,IAE5B4D,EAAE5E,OAAO6E,kBAAkBC,SAAS,gBAG5CM,WAAY,WACJtG,MAAMiC,WAAW,sBACjBgD,YAAY/D,QAEZ4E,EAAE5E,OAAO6E,kBAAkBQ,YAAY,kBAUvD,SAASC,cAActF,QACnBzB,OAAOgH,iBAAiBpG,aACxByF,EAAE5E,OAAO6E,kBAAkBQ,YAAY,mBACvCrH,WAAWwH,aAAa,cAAc,EAAO,MAOjD,SAASC,sBAAsBzF,QAC3BD,iBAAiBC,QACjB2E,0BAA0B3E,QAC1BA,OAAOiB,YAAYyE,UAUvB,SAASC,sBAAsBpD,MAAOqD,QAASC,UACvCD,UAAYA,QAAQ3E,YAAYO,YAChCiE,sBAAsBG,SAEtBC,UACA3D,cAAc2D,UAOtB,SAASC,kBAEL5D,cAAc1D,cAAcuH,mBAMhC,SAASC,SACLlG,gBAAiB,EAEjBnB,kBAAkBsH,cAAc3G,aAChCX,kBAAkBsH,cAAc1G,WAGhCV,MAAMqH,QAAQrH,MAAMsH,WAAWC,WAAWC,kBAAkBhH,uBAAuBiH,IACnFzH,MAAMqH,QAAQrH,MAAMsH,WAAWC,WAAWG,eAAevH,UACzDH,MAAMqH,QAAQrH,MAAMsH,WAAWC,WAAWG,eAAetH,QACzDJ,MAAMqH,QAAQrH,MAAMsH,WAAWC,WAAWG,eAAexH,cACzDF,MAAMqH,QAAQrH,MAAMsH,WAAWC,WAAWG,eAAerH,YAEzDV,cAAcgI,IAAI,gBAClBlI,gBAAgBkI,IAAI,gBACpB/H,eAAe+H,IAAI,gBAGnBjI,OAAOkI,eAAe,SAAUzG,QAC5BhC,WAAW+E,SAASC,UAAUhD,OAAOiB,eAEzCqE,gBAMJ,SAASoB,OACL5G,gBAAiB,EAEjBJ,SAASgH,OACTjH,WAAWiH,OAKX1I,WAAW2I,qBAAqB,OAAQ,gBAAiB,SAAUC,KAAM5F,IACrE,OAAOlC,MAAMiC,WAAW,2BACzBlB,eACH7B,WAAW2I,qBAAqB,OAAQ,SAAU,SAAUC,KAAM5F,IAC9D,OAAOlC,MAAMiC,WAAW,wBACzBpB,YAEH3B,WAAW6I,eAAe,OAAQ,aAAcjH,gBAChD5B,WAAW6I,eAAe,OAAQ,iBAAkBjH,gBACpD5B,WAAW6I,eAAe,OAAQ,YAAajH,gBAE/CpB,cAAcyG,GAAG,iCAAkCU,uBACnDrH,gBAAgB2G,GAAG,gCAAiC,SAAU1C,MAAOuE,KACjE/G,iBAAiB+G,IAAIC,iBAGzBtI,eAAewG,GAAG,4DAA6Da,iBAG/EzG,uBAAyBR,MAAMqH,QAAQrH,MAAMsH,WAAWC,WAAWY,iBACnEnI,MAAMqH,QAAQrH,MAAMsH,WAAWC,WAAWa,YAAYlI,cACtDF,MAAMqH,QAAQrH,MAAMsH,WAAWC,WAAWa,YAAY/H,YACtDL,MAAMqH,QAAQrH,MAAMsH,WAAWC,WAAWa,YAAYjI,UACtDH,MAAMqH,QAAQrH,MAAMsH,WAAWC,WAAWa,YAAYhI,QAGtDN,kBAAkBuI,WAAWlI,SAAU,CAAC,CAACmI,IAAK7H,aAAc,CAAC6H,IAAK7H,YAAa8H,SAAU,SACzFzI,kBAAkBuI,WAAWjI,OAAQ,CAAC,CAACkI,IAAI5H,WAAY,CAAC4H,IAAI5H,UAAW6H,SAAU,SAIjF7I,OAAO8I,eAAelI,YAAaC,8BACnCb,OAAOkI,eAAe,SAAUzG,QAC5ByF,sBAAsBzF,UAO9B,SAASsH,uBACLxI,MAAMyI,YAAYtC,GAAG,SAAU,SAAUuC,EAAGC,MACxC,GAAIA,KAAKC,IAAIC,QAAQ,YAAc,EAAG,CAGlC,IAAIC,UAAY9I,MAAMiC,WAAW,WAC7B6G,YAAc9H,eACd4G,QACQkB,WAAa9H,gBACrBkG,YAMhB5H,QAAQyJ,UAAU,WACdxJ,eAAeyJ,SAAS3J,QAAQY,aAAcA,aAAc6E,aAC5DvF,eAAeyJ,SAAS3J,QAAQe,WAAYA,WAAY4E,WACxDzF,eAAeyJ,SAAS3J,QAAQ4J,iBAAkB/I,SAAUqE,iBAC5DhF,eAAeyJ,SAAS3J,QAAQ6J,eAAgB/I,OAAQ0E,eAEpD7E,MAAMiC,WAAW,YACjB2F,OAEJY,2BAWR1J,OAAO,QAAS,SAAUC,QAASC,QAASC,QAGxC,IAAIU,eAA8BR,SAASC,UAAU,0BACjD+J,mBAA8BhK,SAASC,UAAU,kCACjDC,QAA8BF,SAASC,UAAU,WACjDY,MAA8BmJ,mBAAmBC,kBAAkB,gBACnEC,eAA8B,qBAE9BC,oBAA8B,sBAC9BC,cAA8B,oBAC9BC,iBAA8B,mBAC9BC,uBAA8B,yBAC9BC,kBAA8B,sBAC9BC,eAA8B,iBAC9BC,yBAA+B,4BA0BnC,SAASC,SAASpH,OACd,GAAKA,MAAL,CAGA,IAAIqH,IAAM,GAAI1I,MAKd,OAJA0B,OAAOC,KAAKN,OAAOO,QAAQ,SAAUzB,MACjCH,MAAQqB,MAAMlB,MACduI,IAAIvI,MAAQwI,MAAMC,QAAQ5I,OAASA,MAAQ,CAAC,CAACA,MAAME,KAAKC,KAAMH,MAAME,KAAKG,IAAK,CAACL,MAAMM,GAAGH,KAAMH,MAAMM,GAAGD,OAEpGqI,KASX,SAASG,QAAQxH,OACb,GAAKA,MAAL,CAIA,IAAIyH,OAAS,GAAIC,IAMjB,OALArH,OAAOC,KAAKN,OAAOO,QAAQ,SAAUzB,MACjC4I,IAAM1H,MAAMlB,MACZ2I,OAAO3I,MAAQ,CAACD,KAAM,CAACC,KAAM4I,IAAI,GAAG,GAAI1I,GAAI0I,IAAI,GAAG,IAAKzI,GAAI,CAACH,KAAM4I,IAAI,GAAG,GAAI1I,GAAI0I,IAAI,GAAG,OAGtFD,QAQX,SAASvH,SAASJ,MACd,IAAIE,MACJ,OAAOwH,QADKd,mBAAmB/G,aAAaiH,eAAgBF,mBAAmBiB,uBAC1D7H,OAQzB,SAASW,SAASX,KAAME,OACpB,MAAM4H,SAAWlB,mBAAmB/G,aAAaiH,eAAgBF,mBAAmBiB,uBACpFC,SAAS9H,MAAQsH,SAASpH,OAC1B0G,mBAAmBmB,aAAajB,eAAgBgB,SAAUlB,mBAAmBiB,uBAQjF,SAASnI,WAAWoG,KAChB,OAAOrI,MAAMuK,IAAIlC,KAMrB,SAASmC,gBACLrB,mBAAmBmB,aAAajB,eAAgB,IAzFpDrJ,MAAMyK,iBAAiB,UAAW,WAAW,EACtB,CAACC,KAAMpB,oBAAqBqB,YAAatL,QAAQuL,mCACxE5K,MAAMyK,iBAAiB,cAAe,SAAU,EACzB,CAACC,KAAMnB,cAAeoB,YAAatL,QAAQwL,yCAClE7K,MAAMyK,iBAAiB,iBAAkB,WAAW,EAC7B,CAACC,KAAMlB,iBAAkBmB,YAAatL,QAAQyL,4CACrE9K,MAAMyK,iBAAiB,sBAAuB,WAAW,EAClC,CAACC,KAAMjB,uBAAwBkB,YAAatL,QAAQ0L,iDAC3E/K,MAAMyK,iBAAiB,qBAAsB,WAAW,EACjC,CAACC,KAAMhB,kBAAmBiB,YAAatL,QAAQ2L,gDACtEhL,MAAMyK,iBAAiB,eAAgB,SAAU,EAC1B,CAACC,KAAMf,eAAgBgB,YAAatL,QAAQ4L,0CACnEjL,MAAMyK,iBAAiB,yBAA0B,WAAW,EACrC,CAACC,KAAMd,yBAA0Be,YAAatL,QAAQ6L,oDAE7E/B,mBAAmBgC,aAAaV,iBAAiBpB,eAAgB,SAAU,IA6E3EpK,OAAOD,QAAQ2D,SAAWA,SAC1B1D,OAAOD,QAAQkE,SAAWA,SAC1BjE,OAAOD,QAAQiD,WAAaA,WAC5BhD,OAAOD,QAAQwL,cAAgBA,cAC/BvL,OAAOD,QAAQyJ,YAAczI,QASjClB,OAAO,2BAA4B,SAAUC,QAASC,QAASC,QAU3D,SAASmM,cAAclJ,GAAIV,OACvB,GAAKU,GAAGmJ,oBAAR,CAIA,IAAI/J,KAAOY,GAAGoJ,UAAU,QACpB5J,GAAMQ,GAAGoJ,UAAU,MACvB,OAAIhK,KAAKC,OAASC,MAAMD,KACb,CAACD,KAAMA,KAAMI,GAAIA,SAD5B,GAKJzC,OAAOD,QAAUoM,gBAQrBtM,OAAO,uBAAwB,SAAUC,QAASC,QAASC,QAEvD,IAAIC,WAAsBC,SAASC,UAAU,wCACzCY,MAAsBjB,QAAQ,SAOlC,SAASwM,OAAOrJ,GAAI2B,IAAKD,QAAS4H,OAC9B5H,QAAUA,SAAW,GACrB4H,MAAQA,OAAS,OACE,iBAAR3H,MACPA,IAAM3E,WAAW4E,IAAID,IAAK,IAG9B,IAAI4H,OAAS7H,QAAQ8H,aAAexM,WAAWkF,KAAKC,KAChDjD,MACAuK,OACAC,UAEJ,SAASC,SAASC,aACd,IAAI1K,MAAQwC,QAAQxC,OAASqK,OAAOvJ,GAAI2B,KACxC,IAAKzC,OAASA,MAAMM,GAAGH,KAAOH,MAAME,KAAKC,KAAOvB,MAAMiC,WAAW,eAC7D,OAAO,KAEX,IAAI8J,MAAQ7J,GAAG8J,YAAY5K,MAAME,MAC7BoD,EACAuH,SACAC,UACJ,IAAKxH,EAAI,EAAGA,EAAIqH,MAAM1I,SAAUqB,EAC5B,GAAIqH,MAAMrH,GAAGyH,UAAsB,SAAVX,MAAkB,CACvC,IAAKM,YACD,OAAO,KAEX1K,MAAMgL,SAAU,EAChBL,MAAMrH,GAAG2H,QAIjB,OAAIN,OAASA,MAAM1I,SACf6I,UAAYH,MAAMO,OAAO,SAAUC,GAC/B,OAAOA,EAAEJ,aAEID,UAAU7I,SACvB4I,SAAWC,UAAUA,UAAU7I,OAAS,GAAGmJ,SAC3BpL,MAAME,KAAKC,MAAQ0K,SAASvK,GAAGH,MAAQ0K,SAASvK,GAAGH,KAAOH,MAAMM,GAAGH,KACxE,KAIZH,MAGX,SAASqL,aACL,IAAId,OAASvG,OAAO/C,SAASgD,cAAc,QAE3C,OADAsG,OAAOrG,UAAY,wBACZqG,OAIX,GADAvK,MAAQyK,UAAS,GACbjI,QAAQ8I,OACR,MAAQtL,OAASyC,IAAItC,KAAOW,GAAGyK,aAC3B9I,IAAM3E,WAAW4E,IAAID,IAAItC,KAAO,EAAG,GACnCH,MAAQyK,UAAS,GAGzB,MAAKzK,OAASA,MAAMgL,SAAqB,WAAVZ,OAAsBpK,MAAMM,GAAGH,KAAOH,MAAME,KAAKC,KAAOvB,MAAMiC,WAAW,gBAqCxG,OAhCA0J,OAASc,aACTb,UAAY1J,GAAG0K,SAASxL,MAAME,KAAMF,MAAMM,GAAI,CAC1CmL,aAAclB,OACdmB,cAAc,EACdX,UAAU,IAGdjN,WAAWiH,GAAGwF,OAAQ,YAAa,SAAUjD,GACzCkD,UAAUS,QACV3D,EAAEqE,mBAGNnB,UAAUzF,GAAG,QAAS,SAAU7E,KAAMI,WAC3BQ,GAAGQ,WAAWpB,KAAKC,MAC1BrC,WAAW8N,OAAO9K,GAAI,SAAUA,GAAIZ,KAAMI,MAGhC,SAAV8J,cACOpK,MAAMgL,QAITvI,IAAItC,KAAOH,MAAME,KAAKC,KACtBW,GAAGQ,WAAWtB,MAAME,KAAKC,MAAQH,MAEjCc,GAAGQ,WAAWmB,IAAItC,MAAQH,cAGvBc,GAAGQ,WAAWmB,IAAItC,MAG7BrC,WAAW8N,OAAO9K,GAAIsJ,MAAOtJ,GAAId,MAAME,KAAMF,MAAMM,IAC5CN,MApCCA,QAASA,MAAMgL,SAAU,GA0CrC,SAASxE,OACL1I,WAAW+N,gBAAgB,WAAY,SAAUpJ,IAAKD,QAAS4H,OAC3D,OAAOD,OAAO2B,KAAMrJ,IAAKD,QAAS4H,SAGtCtM,WAAW+N,gBAAgB,aAAc,SAAUpJ,IAAKD,SACpD,OAAO2H,OAAO2B,KAAMrJ,IAAKD,QAAS,YAGtC1E,WAAW+N,gBAAgB,WAAY,SAAU1L,MAC7C,OAAO2L,KAAKxK,YAAcwK,KAAKxK,WAAWnB,QAS9CrC,WAAW+N,gBAAgB,gBAAiB,SAAUxK,OAClD,IAAIM,KAAMoK,GAAKjO,WAAWkF,KAAKC,KAAMnC,GAAKgL,KAAME,OAAS,GAAIhM,MAAOiM,YAcpE,OAbI5K,QAAUM,KAAOD,OAAOC,KAAKN,QAAQY,QACrCN,KAAKC,QAAQ,SAAUsK,aACnBA,YAAcA,aACIpL,GAAGyK,aAAeW,YAAcpL,GAAGqL,aACjDnM,MAAQ+L,GAAGjL,GAAIhD,WAAW4E,IAAIwJ,WAAY,IAC1CD,YAAc5K,MAAM6K,YAChBlM,OAASiM,aAAejM,MAAME,KAAKC,OAAS8L,YAAY/L,KAAKC,MACzDH,MAAMM,GAAGH,OAAS8L,YAAY3L,GAAGH,OACrC6L,OAAOE,YAAc7K,MAAM6K,gBAKpCF,SAQXlO,WAAW+E,SAASG,KAAO,SAAUlC,GAAI0B,SACrC1B,GAAGtB,SAASsB,GAAGoJ,YAAa1H,QAAS,SAQzC1E,WAAW+E,SAASuJ,OAAS,SAAUtL,GAAI0B,SACvC1B,GAAGtB,SAASsB,GAAGoJ,YAAa1H,QAAS,WAOzC1E,WAAW+E,SAASc,QAAU,SAAU7C,IACpCA,GAAGuD,UAAU,WACT,IAAIf,EAAGgE,EACP,IAAKhE,EAAIxC,GAAGyK,YAAajE,EAAIxG,GAAGqL,WAAY7I,GAAKgE,EAAGhE,IAChDxC,GAAGtB,SAAS1B,WAAW4E,IAAIY,EAAG,GAAI,KAAM,WAWpDxF,WAAW+E,SAASC,UAAY,SAAUhC,GAAIZ,KAAMI,IAChDJ,KAAOA,MAAQY,GAAGyK,YAClBjL,GAAKA,IAAMQ,GAAGqL,WACdrL,GAAGuD,UAAU,WACT,IAAIf,EAAGgE,EACP,IAAKhE,EAAIpD,KAAMoH,EAAIhH,GAAIgD,GAAKgE,EAAGhE,IACvBxC,GAAG6B,SAASW,IAAMxC,GAAGiC,WAAWO,EAAG,CAACtD,MAAOc,GAAGQ,WAAWgC,QAYzExF,WAAW+E,SAASK,YAAc,SAAUpC,GAAIV,MAAOG,KACnD,IAAIwL,GAAKjO,WAAWkF,KAAKC,KACzB,SAASoJ,UAAUC,EAAGpM,KAAMI,IACxB,GAAIgM,EAAI,EAEJ,IADA,IAAIhJ,EAAIpD,KAAMF,MACPsD,EAAIhD,KACPN,MAAQ+L,GAAGjL,GAAIhD,WAAW4E,IAAIY,EAAG,MAG7B+I,UAAUC,EAAI,EAAGtM,MAAME,KAAKC,KAAO,EAAGH,MAAMM,GAAGH,KAAO,GACtDW,GAAGtB,SAAS1B,WAAW4E,IAAIY,EAAG,GAAI,KAAM,QACxCA,EAAItD,MAAMM,GAAGH,KAAO,GAEpBmD,IAKhBxC,GAAGuD,UAAU,WACTjE,WAAkB8B,IAAV9B,MAAsBU,GAAGyK,YAAcnL,MAC/CG,IAAMA,KAAOO,GAAGqL,WAChBE,UAAUzN,MAAMiC,WAAW,gBAAiBT,MAAOG,QAS3DzC,WAAW6I,eAAe,OAAQ,UAAW,WACzC,IAAI4F,MAAQ5D,MAAM6D,UAAUC,MAAMC,KAAKC,UAAW,GAClD,OAAO,SAAU7L,GAAIV,OACjB,IAAIkD,EACJ,IAAKA,EAAI,EAAGA,EAAIiJ,MAAMtK,SAAUqB,EAAG,CAC/B,IAAIsJ,MAAQL,MAAMjJ,IAAMiJ,MAAMjJ,GAAGxC,GAAIV,OACrC,GAAIwM,MACA,OAAOA,UAYvB9O,WAAW6I,eAAe,OAAQ,OAAQ,SAAU7F,GAAIV,OACpD,IAAIyM,QAAU/L,GAAGgM,WAAW1M,MAAO,QAASkD,EAAGtD,MAE3C0G,KAAO5F,GAAGiM,UAAUzD,KACpB0D,WAAalP,WAAWkF,KAAK0D,MAIjC,IAHIsG,YAAcH,QAAQpF,QAAQuF,YAAc,GAC5CH,QAAQI,KAAKD,YAEZ1J,EAAI,EAAGA,EAAIuJ,QAAQ5K,OAAQqB,IAE5B,IADAtD,MAAQ6M,QAAQvJ,GAAGxC,GAAIV,SACVJ,MAAMM,GAAGH,KAAOH,MAAME,KAAKC,MAAQvB,MAAMiC,WAAW,eAAkB,OAAOb,QAKtGpC,QAAQ4I,KAAOA,OAQnB9I,OAAO,yBAA0B,SAAUC,QAASC,QAASC,QAEzD,IAAIC,WAAkBC,SAASC,UAAU,wCACrCY,MAAkBjB,QAAQ,SAE9B,SAASuP,MAAM1K,SACXsJ,KAAKtJ,QAAUA,QACfsJ,KAAK5L,KAAO4L,KAAKxL,GAAK,EAG1B,SAAS6M,aAAa7K,MAKlB,OAJa,IAATA,OAAiBA,KAAO,IACvBA,KAAKF,SAAUE,KAAKF,OAAS,yBAC7BE,KAAK8K,gBAAiB9K,KAAK8K,cAAgB,8BAC3C9K,KAAK+K,kBAAmB/K,KAAK+K,gBAAkB,gCAC7C/K,KAQX,SAASgL,OAAOC,MACZ,IAAIC,IAAMxJ,OAAO/C,SAASgD,cAAc,OAExC,OADAuJ,IAAItJ,UAAYqJ,KACTC,IAQX,SAASC,OAAOC,GACZ,OAAOA,EAAE3C,SASb,SAAS4C,eAAe7M,GAAIZ,KAAMI,IAC9B,IAAIsN,YAAchP,MAAMiC,WAAW,gBAAkB,EACjDyB,KAAOxB,GAAGyB,MAAMhD,WAAWiD,QAC3BqL,KAAOjP,MAAMiC,WAAW,sBACxBiN,QAAUpJ,EAAE5D,GAAGgE,oBACfxB,EAAIpD,KAER,SAAS+K,MAAMyC,GACX,OAAOA,EAAEzC,QASb,SAAS8C,mBAAmB5N,MAExB,IADA,IAAIwB,KAAOD,OAAOC,KAAKb,GAAGQ,YAAagC,EAAI,EAAGtD,MACvCsD,EAAI3B,KAAKM,QAAQ,CAEpB,IADAjC,MAAQc,GAAGQ,WAAWK,KAAK2B,KACjBpD,KAAKC,KAAOA,MAAQH,MAAMM,GAAGH,MAAQA,KAC3C,OAAOH,MAEXsD,KAiBR,IAPIA,IAAMhD,IACN0D,OAAOgK,WAAW,WACd,IAAI7J,GAAKrD,GAAGsD,cACZuJ,eAAe7M,GAAIqD,GAAGjE,KAAMiE,GAAG7D,KAChC,KAGAgD,EAAIhD,IAAI,CACX,IAAI2N,GAAKF,mBAAmBzK,GACxBtD,MACAkO,KAAOZ,OAAO,+BACd7K,IAAM3E,WAAW4E,IAAIY,EAAG,GACxB6K,KAAO7L,KAAKgI,aAAexM,WAAWkF,KAAKC,KAE3CgL,GACA3K,EAAI2K,GAAG3N,GAAGH,KAAO,GAEjBH,MAAQc,GAAGQ,WAAWgC,IAAO6K,MAAQA,KAAKrN,GAAI2B,OAEzCoL,MAASA,MAAQC,QAAQM,GAAG,aACzBtN,GAAG6B,SAASW,GAERtD,MACAkO,KAAOZ,OAAOhL,KAAK+K,iBAEnBvM,GAAG8J,YAAYnI,KAAKyI,OAAOuC,QACtB7L,QAAQqJ,OAGbjL,OAASA,MAAMM,GAAGH,KAAOH,MAAME,KAAKC,MAAQyN,cAC5CM,KAAOZ,OAAOhL,KAAK8K,iBAI/BtM,GAAGyD,gBAAgBjB,EAAGhB,KAAKF,OAAQ8L,MACnC5K,MAWZ,SAAS2B,iBAAiBnE,GAAIZ,KAAMI,IAChC,IAAI6D,GAAKrD,GAAGsD,cAAe7B,MAAQzB,GAAGyB,MAAMhD,WAC5CW,KAAOmO,MAAMnO,MAAQiE,GAAGjE,KAAOA,KAC/BI,GAAK+N,MAAM/N,IAAM6D,GAAG7D,GAAKA,GAEpBiC,QACLzB,GAAGuD,UAAU,WACTsJ,eAAe7M,GAAIZ,KAAMI,MAE7BiC,MAAMrC,KAAOA,KACbqC,MAAMjC,GAAKA,IASf,SAASgO,cAAcxN,GAAIX,MACvB,IAAIsC,IAAM3E,WAAW4E,IAAIvC,KAAM,GAC3BkB,MAAQP,GAAG8J,YAAYnI,MAAQ,GAEnC,OADApB,MAAQA,MAAM6J,OAAOuC,SACRxL,OAASZ,MAAM,QAAKa,EAWrC,SAASqM,oBAAoBzN,GAAIZ,KAAMsO,WACnC,IAAIZ,YAAchP,MAAMiC,WAAW,gBAAkB,EACjDyC,EAAGN,KAAMhD,MACb,KAAIwO,WAAa,GAIjB,IAAKlL,EAAIpD,KAAMoD,GAAKpD,KAAOsO,UAAWlL,GAAQ,GAC1CN,KAAOsL,cAAcxN,GAAIwC,OAErBtD,MAAQgD,KAAKoI,SACApL,MAAMM,GAAGH,KAAOH,MAAME,KAAKC,MAAQyN,aAC5C9M,GAAGQ,WAAWgC,GAAKtD,MACnBsD,EAAItD,MAAMM,GAAGH,aAENW,GAAGQ,WAAWgC,IAWrC,SAASmL,UAAUzO,MAAO0O,UACtB,MAAO,CAACxO,KAAMpC,WAAW4E,IAAI1C,MAAME,KAAKC,KAAOuO,SAAU1O,MAAME,KAAKG,IAChEC,GAAIxC,WAAW4E,IAAI1C,MAAMM,GAAGH,KAAOuO,SAAU1O,MAAMM,GAAGD,KAoB9D,SAASsO,iBAAiB7N,GAAIZ,KAAM0O,WAChC,IAAIC,SAAUC,SACVlB,YAAchP,MAAMiC,WAAW,gBAAkB,EACjDkO,YAAcrN,OAAOC,KAAKb,GAAGQ,YAAY0N,IAAI,SAAU7D,GACvD,OAAQA,IAER7I,KACAyJ,IADOjL,GAAGyB,MAAMhD,WAAWiD,SAAW,IAC5B8H,aAAexM,WAAWkF,KAAKC,KAE7C,GAAkB,IAAd2L,UACIG,YAAYtH,QAAQvH,OAAS,KAC7B4O,SAAW/C,GAAGjL,GAAIhD,WAAW4E,IAAIxC,KAAM,MACvB4O,SAASxO,GAAGH,KAAO2O,SAAS5O,KAAKC,MAAQyN,YACrD9M,GAAGQ,WAAWpB,MAAQ4O,gBAEfhO,GAAGQ,WAAWpB,YAG1B,GAAI6O,YAAY9M,OAAQ,CAC3B,IAAIgN,SAAW,GACfF,YAAYnN,QAAQ,SAAUzB,MAC1B0O,SAAW/N,GAAGQ,WAAWnB,MAEzB2O,SAAWL,UAAUI,SAAUD,WAE3BA,UAAY,EACRzO,KAAOD,KACP+O,SAAS9O,MAAQ0O,SACV1O,MAAQD,KAAOgP,KAAKC,IAAIP,aAC/BK,SAAS9O,KAAOyO,WAAaE,UAG7B3O,KAAOD,KACP+O,SAAS9O,MAAQ0O,SACV1O,MAAQD,OACf+O,SAAS9O,KAAOyO,WAAaE,YAIzChO,GAAGQ,WAAa2N,UAWxB,SAASG,SAAStO,GAAIuO,WAClB,GAAyB,aAArBA,UAAUC,OAAuB,CACjC,IAAIjO,MAAQP,GAAGe,cAAcf,GAAGQ,YAChCR,GAAGQ,WAAaD,MAChBK,OAAOC,KAAKN,OAAOO,QAAQ,SAAUzB,MACjCW,GAAGtB,UAAUW,YAEd,CACH,IAAIoC,MAAQzB,GAAGyB,MAAMhD,WACjBgQ,YAAcF,UAAUG,KAAKvN,OAASoN,UAAUI,QAAQxN,OAGnC,SAArBoN,UAAUC,QAAqBC,YAAc,GAC7CZ,iBAAiB7N,GAAIuO,UAAUnP,KAAKC,KAAMoP,aAC1ChB,oBAAoBzN,GAAIuO,UAAUnP,KAAKC,KAAMoP,cAE7CZ,iBAAiB7N,GAAIuO,UAAUnP,KAAKC,KAAMoP,aAE1B,IAAhBA,aACA5B,eAAe7M,GAAIoO,KAAKQ,IAAI,EAAGL,UAAUnP,KAAKC,KAAOoP,aAAcL,KAAKQ,IAAI,EAAGL,UAAUnP,KAAKC,KAAOoP,aAAe,GAExHhN,MAAMrC,KAAOmP,UAAUnP,KAAKC,KAC5BoC,MAAMjC,GAAK,EACX0D,OAAO2L,aAAapN,MAAMqN,cAC1BrN,MAAMqN,aAAe5L,OAAOgK,WAAW,WACnC/I,iBAAiBnE,KAClB,MAQX,SAAS+O,iBAAiB/O,IACtB,IAAIyB,MAAQzB,GAAGyB,MAAMhD,WACrByE,OAAO2L,aAAapN,MAAMqN,cAC1BrN,MAAMqN,aAAe5L,OAAOgK,WAAW,WACnC,IAAI7J,GAAKrD,GAAGsD,cACR7B,MAAMrC,OAASqC,MAAMjC,IAAM6D,GAAGjE,KAAOqC,MAAMjC,GAAK,IAAMiC,MAAMrC,KAAOiE,GAAG7D,GAAK,GAC3E2E,iBAAiBnE,IAEjBA,GAAGuD,UAAU,WACLF,GAAGjE,KAAOqC,MAAMrC,OAChByN,eAAe7M,GAAIqD,GAAGjE,KAAMqC,MAAMrC,MAClCqC,MAAMrC,KAAOiE,GAAGjE,MAEhBiE,GAAG7D,GAAKiC,MAAMjC,IACdqN,eAAe7M,GAAIyB,MAAMjC,GAAI6D,GAAG7D,IAChCiC,MAAMjC,GAAK6D,GAAG7D,KAEdqN,eAAe7M,GAAIqD,GAAGjE,KAAMiE,GAAG7D,IAC/BiC,MAAMjC,GAAK6D,GAAG7D,GACdiC,MAAMrC,KAAOiE,GAAGjE,SAI7B,KAQP,SAAS4P,iBAAiBhP,IACtB,IAAIyB,MAAQzB,GAAGyB,MAAMhD,WACjB4E,GAAKrD,GAAGsD,cACZJ,OAAO2L,aAAapN,MAAMqN,cAC1BrN,MAAMqN,aAAe5L,OAAOgK,WAAW,WAEnC/I,iBAAiBnE,GAAIqD,GAAGjE,KAAMiE,GAAG7D,KAClC,KASP,SAASyP,OAAOjP,GAAIZ,KAAMI,IACtB,IAAIiC,MAAQzB,GAAGyB,MAAMhD,WACrBoO,eAAe7M,GAAIZ,KAAKC,KAAMD,KAAKC,KAAO,GAS9C,SAAS6P,SAASlP,GAAIZ,KAAMI,IACxB,IAAIiC,MAAQzB,GAAGyB,MAAMhD,WACjB4E,GAAKrD,GAAGsD,qBACLtD,GAAGQ,WAAWpB,KAAKC,MAC1BwN,eAAe7M,GAAIZ,KAAKC,KAAMG,GAAGH,MAAQgE,GAAG7D,IAOhD,SAASkG,OACL1I,WAAWwH,aAAa,cAAc,EAAO,SAAUxE,GAAImP,IAAKC,KACxDA,KAAOA,MAAQpS,WAAWqS,OAC1BrP,GAAG+C,YAAY/C,GAAGyB,MAAMhD,WAAWiD,QAAQJ,QAC3CtB,GAAGyB,MAAMhD,WAAa,KACtBuB,GAAGwF,IAAI,cAAe4J,IAAI/N,eAC1BrB,GAAGwF,IAAI,SAAU8I,UACjBtO,GAAGwF,IAAI,iBAAkBuJ,kBACzB/O,GAAGwF,IAAI,iBAAkBwJ,kBAEzBhP,GAAGwF,IAAI,OAAQyJ,QACfjP,GAAGwF,IAAI,SAAU0J,UACjBlP,GAAGwF,IAAI,UAAWrB,mBAElBgL,MACAnP,GAAGyB,MAAMhD,WAAa,IAAI2N,MAAMC,aAAa8C,MAC7ChL,iBAAiBnE,IACjBA,GAAGiE,GAAG,cAAekL,IAAI9N,eACzBrB,GAAGiE,GAAG,SAAUqK,UAChBtO,GAAGiE,GAAG,iBAAkB8K,kBACxB/O,GAAGiE,GAAG,iBAAkB+K,kBACxBhP,GAAGiE,GAAG,OAAQgL,QACdjP,GAAGiE,GAAG,SAAUiL,UAChBlP,GAAGiE,GAAG,UAAWE,qBAK7BrH,QAAQ4I,KAAOA,KACf5I,QAAQqH,iBAAmBA,mBA+B/BvH,OAAO,6BAA8B,SAAUC,QAASC,QAASC,QAE7D,IAAIC,WAAcC,SAASC,UAAU,wCACjCoS,EAAcrS,SAASC,UAAU,qBACjCqS,YAActS,SAASC,UAAU,qBAUrC,SAASsS,cAAcxP,GAAIyP,QAASC,UAAWC,WAM3C,IALA,IAAItQ,KAAOW,GAAG4P,QAAQF,WAClBG,KAAO,GACPC,eAAiBL,QACjBM,YAAcL,UACdxQ,MACG6Q,aAAe/P,GAAGqL,YACrB,GAAoB,IAAhBhM,KAAK8B,OACL2O,eAAiB,EACjBzQ,KAAOW,GAAG4P,UAAUG,iBACjB,CAEH,GAAIJ,UADJE,KAAOA,KAAKG,OAAO3Q,KAAKyQ,iBAAmB,KAOvC,OALA5Q,MAAQ,CACJE,KAAM,CAACG,GAAIkQ,QAASpQ,KAAMqQ,WAC1BlQ,GAAI,CAACD,GAAIuQ,eAAgBzQ,KAAM0Q,aAC/BE,OAAQJ,MAGT,GAAIC,gBAAkBzQ,KAAK8B,OAAQ,CAEtC,GAAIwO,UADJE,KAAOA,KAAKG,OAAOhQ,GAAGkQ,kBAOlB,OALAhR,MAAQ,CACJE,KAAM,CAACG,GAAIkQ,QAASpQ,KAAMqQ,WAC1BlQ,GAAI,CAACD,GAAIuQ,eAAgBzQ,KAAM0Q,aAC/BE,OAAQJ,MAIhBC,eAAiB,EACjBzQ,KAAOW,GAAG4P,UAAUG,mBAElBD,gBAYlB,SAASK,cAAcN,MACnB,MAAO,MAAQO,KAAKP,OAASN,YAAYc,SAASR,KAAM,KAQ5D,SAASS,UAAUC,WACf,OAAO,SAAUV,MACb,OAAOA,KAAKA,KAAK1O,OAAS,KAAOoP,WAIzC,SAAS5G,SAAS3J,GAAIV,OAClB,IAAIyQ,YAAczQ,MAAMD,KACpBqP,KAAO1O,GAAG4P,QAAQG,cAAgB,GAClCvN,EAAI,EACJgO,SAAW,GACXC,WAAa,GACb3E,MACA4E,QACAC,QACAC,iBACAC,aAAenC,KAAK/H,QAAQ,MAC5BzH,MAEJ,KAAI2R,aAAe,GAAgC,MAA3BnC,KAAKmC,aAAe,MAI5C/E,MAAQ0D,cAAcxP,GAAI6Q,aAAe,EAAGd,YAAaI,gBAyBzD,IApBAQ,QAAU,CACNvR,KAAM,CAACC,KAAM0Q,YAAaxQ,GAAIsR,cAC9BrR,GAAIsM,MAAMtM,IAGK,OADnBkR,QAAU5E,MAAMmE,OAAOa,UAAU,EAAGhF,MAAMmE,OAAO9O,OAAS,IAC9C,IAA6B,MAAfuP,QAAQ,IAA6B,MAAfA,QAAQ,KACpD5E,MAAQ0D,cAAcxP,GAAI2Q,QAAQnR,GAAGD,GAAIoR,QAAQnR,GAAGH,KAAM,SAAUwQ,MAChE,OAAOA,KAAK1O,OAAS,GAAyB,OAApB0O,KAAKkB,QAAQ,QAGvCJ,QAAQnR,GAAK,CAACH,KAAMyM,MAAMtM,GAAGH,KAAME,GAAIuM,MAAMtM,GAAGD,GAAK,IAEzDiR,SAASrE,KAAKuE,QAAQK,OAAO,KAE7BN,WAAWtE,KAAK,MAGpB3J,EAAIsJ,MAAMtM,GAAGD,GACbwQ,YAAcjE,MAAMtM,GAAGH,KAEhB0Q,aAAe/P,GAAGqL,YAAY,CAGjC,OADAuF,kBADAlC,KAAO1O,GAAG4P,QAAQG,eACUrB,KAAKlM,IAAO,IAExC,IAAK,IACD,GAAoB,MAAhBkM,KAAKlM,EAAI,KACTsJ,MAAQ0D,cAAcxP,GAAIwC,EAAI,EAAGuN,YAAaI,gBACnC,CACP,IAAIa,IAAMlF,MAAMmE,OAAOa,UAAU,EAAGhF,MAAMmE,OAAO9O,OAAS,GAC1D,GAAe,MAAX6P,IAAI,IAAyB,MAAXA,IAAI,IAAyB,MAAXA,IAAI,GACxCR,SAASrE,KAAK6E,IAAID,OAAO,SACtB,GAAe,MAAXC,IAAI,IACH1B,EAAE2B,KAAKT,YAAcQ,IAAID,OAAO,IAAMzB,EAAE2B,KAAKT,YAAc,IAAMQ,IAAID,OAAO,GAUpFN,WAAWtE,KAAK,WARhB,GADAqE,SAASU,MACe,IAApBV,SAASrP,QAAsC,IAAtBsP,WAAWtP,OAKpC,OAJAjC,MAAQ,CACJE,KAAMuR,QAAQnR,GACdA,GAAI,CAACD,GAAIiD,EAAGnD,KAAM0Q,cAStC,MACJ,IAAK,IACD,GAAoB,MAAhBrB,KAAKlM,EAAI,KACTiO,WAAWS,MACe,IAAtBT,WAAWtP,QAAoC,IAApBqP,SAASrP,QAKpC,OAJAjC,MAAQ,CACJE,KAAMuR,QAAQnR,GACdA,GAAI,CAACD,GAAIiD,EAAGnD,KAAM0Q,cAK9B,MACJ,IAAK,IACL,IAAK,KACDjE,MAAQ0D,cAAcxP,GAAIwC,EAAI,EAAGuN,YAAaO,UAAU5B,KAAKlM,QAEzDA,EAAIsJ,MAAMtM,GAAGD,GACbwQ,YAAcjE,MAAMtM,GAAGH,QAO7BmD,GACOkM,KAAKvN,WACR4O,YACFvN,EAAI,IAKhBzF,OAAOD,QAAU6M,WASrB/M,OAAO,yBAA0B,SAAUC,QAASC,QAASC,QAEzD,IAAIC,WAAcC,SAASC,UAAU,wCACjCiU,KAAcnU,WAAWoU,YACzBzP,IAAc3E,WAAW4E,IAE7B,SAASyP,uBAAuBrR,IAE5B,IADA,IAAIsR,GAAKtR,GAAGqL,WAAYhM,KAAOW,GAAG4P,QAAQ0B,IACnCA,GAAK,GAA4B,IAAvBjS,KAAKkS,OAAOpQ,QACzBmQ,KACAjS,KAAOW,GAAG4P,QAAQ0B,IAEtB,OAAOA,GAGX,SAAS3S,WAAWqB,GAAIV,OACpB,IAAIkS,SAAWxR,GAAG4P,QAAQtQ,MAAMD,MAAOoS,QAAUzR,GAAG0R,UAAU,WAE1DC,WAAaR,KAAKK,SAAU,KAAMC,SAAUG,aAAc,EAAOC,UAAY7R,GAAG6R,YAChFC,MAAQ9R,GAAG+R,WAAWpQ,IAAIrC,MAAMD,KAAMsS,WAAa,IAEvD,KAA+B,IAA3BH,SAASD,OAAOpQ,QAAiB2Q,OAAwB,YAAfA,MAAME,MAApD,CAGA,IAAIxP,EAAGyP,OAAQlC,YACf,IAAKvN,EAAIlD,MAAMD,KAAO,EAAGmD,EAAIqP,UAAWrP,IAMpC,GALAuN,YAAc/P,GAAG4P,QAAQpN,GACzByP,OAASd,KAAKpB,YAAa,KAAM0B,SAEjCK,MAAQ9R,GAAG+R,WAAWpQ,IAAIa,EAAGyP,OAAS,IAEJ,IAA9BlC,YAAYwB,OAAOpQ,QAAiB2Q,OAAwB,YAAfA,MAAME,KAAqB,CACxE,GAAKJ,aAKD,GAAIK,QAAUN,WACV,MAAO,CAACvS,KAAMuC,IAAIrC,MAAMD,KAAMmS,SAASrQ,QACnC3B,GAAImC,IAAIa,EAAI,EAAGxC,GAAG4P,QAAQpN,EAAI,GAAGrB,cANrC8Q,OAASN,aACTC,aAAc,GAStB,GAAIK,SAAWN,YAAcM,OAASN,WAClC,OAKZ,OAAIC,aACApP,EAAI6O,uBAAuBrR,IACpB,CAACZ,KAAMuC,IAAIrC,MAAMD,KAAMmS,SAASrQ,QAAS3B,GAAImC,IAAIa,EAAGxC,GAAG4P,QAAQpN,GAAGrB,eAF7E,GAMJpE,OAAOD,QAAU6B","sourcesContent":["/*\n* Copyright (c) 2013 Patrick Oladimeji. All rights reserved.\n*\n* Permission is hereby granted, free of charge, to any person obtaining a\n* copy of this software and associated documentation files (the \"Software\"),\n* to deal in the Software without restriction, including without limitation\n* the rights to use, copy, modify, merge, publish, distribute, sublicense,\n* and/or sell copies of the Software, and to permit persons to whom the\n* Software is furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in\n* all copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n* DEALINGS IN THE SOFTWARE.\n*\n*/\n/**\n * Code folding extension for brackets\n * @author Patrick Oladimeji\n * @date 10/24/13 9:35:26 AM\n */\n\ndefine(function (require, exports, module) {\n\n\n    var CodeMirror              = brackets.getModule(\"thirdparty/CodeMirror/lib/codemirror\"),\n        Strings                 = brackets.getModule(\"strings\"),\n        AppInit                 = brackets.getModule(\"utils/AppInit\"),\n        CommandManager          = brackets.getModule(\"command/CommandManager\"),\n        DocumentManager         = brackets.getModule(\"document/DocumentManager\"),\n        Editor                  = brackets.getModule(\"editor/Editor\").Editor,\n        EditorManager           = brackets.getModule(\"editor/EditorManager\"),\n        ProjectManager          = brackets.getModule(\"project/ProjectManager\"),\n        ViewStateManager        = brackets.getModule(\"view/ViewStateManager\"),\n        KeyBindingManager       = brackets.getModule(\"command/KeyBindingManager\"),\n        ExtensionUtils          = brackets.getModule(\"utils/ExtensionUtils\"),\n        Menus                   = brackets.getModule(\"command/Menus\"),\n        prefs                   = require(\"Prefs\"),\n        COLLAPSE_ALL            = \"codefolding.collapse.all\",\n        COLLAPSE                = \"codefolding.collapse\",\n        EXPAND                  = \"codefolding.expand\",\n        EXPAND_ALL              = \"codefolding.expand.all\",\n        GUTTER_NAME             = \"CodeMirror-foldgutter\",\n        CODE_FOLDING_GUTTER_PRIORITY   = Editor.CODE_FOLDING_GUTTER_PRIORITY,\n        codeFoldingMenuDivider  = \"codefolding.divider\",\n        collapseKey             = \"Ctrl-Shift-{\",\n        expandKey               = \"Ctrl-Shift-}\";\n\n    ExtensionUtils.loadStyleSheet(module, \"main.less\");\n\n    // Load CodeMirror addons\n    brackets.getModule([\"thirdparty/CodeMirror/addon/fold/brace-fold\"]);\n    brackets.getModule([\"thirdparty/CodeMirror/addon/fold/comment-fold\"]);\n    brackets.getModule([\"thirdparty/CodeMirror/addon/fold/markdown-fold\"]);\n\n    // Still using slightly modified versions of the foldcode.js and foldgutter.js since we\n    // need to modify the gutter click handler to take care of some collapse and expand features\n    // e.g. collapsing all children when 'alt' key is pressed\n    var foldGutter              = require(\"foldhelpers/foldgutter\"),\n        foldCode                = require(\"foldhelpers/foldcode\"),\n        indentFold              = require(\"foldhelpers/indentFold\"),\n        handlebarsFold          = require(\"foldhelpers/handlebarsFold\"),\n        selectionFold           = require(\"foldhelpers/foldSelected\");\n\n\n    /** Set to true when init() has run; set back to false after deinit() has run */\n    var _isInitialized = false;\n\n    /** Used to keep track of files for which line folds have been restored.*/\n\n    /**\n      * Restores the linefolds in the editor using values fetched from the preference store\n      * Checks the document to ensure that changes have not been made (e.g., in a different editor)\n      * to invalidate the saved line folds.\n      * Selection Folds are found by comparing the line folds in the preference store with the\n      * selection ranges in the viewState of the current document. Any selection range in the view state\n      * that is folded in the prefs will be folded. Unlike other fold range finder, the only validation\n      * on selection folds is to check that they satisfy the minimum fold range.\n      * @param {Editor} editor  the editor whose saved line folds should be restored\n      */\n    function restoreLineFolds(editor) {\n        /**\n         * Checks if the range from and to Pos is the same as the selection start and end Pos\n         * @param   {Object}  range     {from, to} where from and to are CodeMirror.Pos objects\n         * @param   {Object}  selection {start, end} where start and end are CodeMirror.Pos objects\n         * @returns {Boolean} true if the range and selection span the same region and false otherwise\n         */\n        function rangeEqualsSelection(range, selection) {\n            return range.from.line === selection.start.line && range.from.ch === selection.start.ch &&\n                range.to.line === selection.end.line && range.to.ch === selection.end.ch;\n        }\n\n        /**\n         * Checks if the range is equal to one of the selections in the viewState\n         * @param   {Object}  range     {from, to} where from and to are CodeMirror.Pos objects.\n         * @param   {Object}  viewState The current editor's ViewState object\n         * @returns {Boolean} true if the range is found in the list of selections or false if not.\n         */\n        function isInViewStateSelection(range, viewState) {\n            if (!viewState || !viewState.selections) {\n                return false;\n            }\n\n            return viewState.selections.some(function (selection) {\n                return rangeEqualsSelection(range, selection);\n            });\n        }\n\n        var saveFolds = prefs.getSetting(\"saveFoldStates\");\n\n        if (!editor || !saveFolds) {\n            if (editor) {\n                editor._codeMirror._lineFolds = editor._codeMirror._lineFolds || {};\n            }\n            return;\n        }\n\n        var cm = editor._codeMirror;\n        var viewState = ViewStateManager.getViewState(editor.document.file);\n        var path = editor.document.file.fullPath;\n        var folds = cm._lineFolds || prefs.getFolds(path) || {};\n\n        //separate out selection folds from non-selection folds\n        var nonSelectionFolds = {}, selectionFolds = {}, range;\n        Object.keys(folds).forEach(function (line) {\n            range = folds[line];\n            if (isInViewStateSelection(range, viewState)) {\n                selectionFolds[line] = range;\n            } else {\n                nonSelectionFolds[line] = range;\n            }\n        });\n        nonSelectionFolds = cm.getValidFolds(nonSelectionFolds);\n        //add the selection folds\n        Object.keys(selectionFolds).forEach(function (line) {\n            nonSelectionFolds[line] = selectionFolds[line];\n        });\n        cm._lineFolds = nonSelectionFolds;\n        prefs.setFolds(path, cm._lineFolds);\n        Object.keys(cm._lineFolds).forEach(function (line) {\n            cm.foldCode(Number(line), {range: cm._lineFolds[line]});\n        });\n    }\n\n    /**\n      * Saves the line folds in the editor using the preference storage\n      * @param {Editor} editor the editor whose line folds should be saved\n      */\n    function saveLineFolds(editor) {\n        var saveFolds = prefs.getSetting(\"saveFoldStates\");\n        if (!editor || !saveFolds) {\n            return;\n        }\n        var folds = editor._codeMirror._lineFolds || {};\n        var path = editor.document.file.fullPath;\n        if (Object.keys(folds).length) {\n            prefs.setFolds(path, folds);\n        } else {\n            prefs.setFolds(path, undefined);\n        }\n    }\n\n    /**\n      * Event handler for gutter click. Manages folding and unfolding code regions. If the Alt key\n      * is pressed while clicking the fold gutter, child code fragments are also folded/unfolded\n      * up to a level defined in the `maxFoldLevel' preference.\n      * @param {!CodeMirror} cm the CodeMirror object\n      * @param {number} line the line number for the clicked gutter\n      * @param {string} gutter the name of the gutter element clicked\n      * @param {!KeyboardEvent} event the underlying dom event triggered for the gutter click\n      */\n    function onGutterClick(cm, line, gutter, event) {\n        var opts = cm.state.foldGutter.options, pos = CodeMirror.Pos(line);\n        if (gutter !== opts.gutter) { return; }\n        var range;\n        var _lineFolds = cm._lineFolds;\n        if (cm.isFolded(line)) {\n            if (event.altKey) { // unfold code including children\n                range = _lineFolds[line];\n                CodeMirror.commands.unfoldAll(cm, range.from.line, range.to.line);\n            } else {\n                cm.unfoldCode(line, {range: _lineFolds[line]});\n            }\n        } else {\n            if (event.altKey) {\n                range = CodeMirror.fold.auto(cm, pos);\n                if (range) {\n                    CodeMirror.commands.foldToLevel(cm, range.from.line, range.to.line);\n                }\n            } else {\n                cm.foldCode(line);\n            }\n        }\n    }\n\n    /**\n      * Collapses the code region nearest the current cursor position.\n      * Nearest is found by searching from the current line and moving up the document until an\n      * opening code-folding region is found.\n      */\n    function collapseCurrent() {\n        var editor = EditorManager.getFocusedEditor();\n        if (!editor) {\n            return;\n        }\n        var cm = editor._codeMirror;\n        var cursor = editor.getCursorPos(), i;\n        // Move cursor up until a collapsible line is found\n        for (i = cursor.line; i >= 0; i--) {\n            if (cm.foldCode(i)) {\n                editor.setCursorPos(i);\n                return;\n            }\n        }\n    }\n\n    /**\n      * Expands the code region at the current cursor position.\n      */\n    function expandCurrent() {\n        var editor = EditorManager.getFocusedEditor();\n        if (editor) {\n            var cursor = editor.getCursorPos(), cm = editor._codeMirror;\n            cm.unfoldCode(cursor.line);\n        }\n    }\n\n    /**\n      * Collapses all foldable regions in the current document. Folding is done up to a level 'n'\n      * which is defined in the `maxFoldLevel` preference. Levels refer to fold heirarchies e.g., for the following\n      * code fragment, the function is level 1, the if statement is level 2 and the forEach is level 3\n      *\n      *     function sample() {\n      *         if (debug) {\n      *             logMessages.forEach(function (m) {\n      *                 console.debug(m);\n      *             });\n      *         }\n      *     }\n      */\n    function collapseAll() {\n        var editor = EditorManager.getFocusedEditor();\n        if (editor) {\n            var cm = editor._codeMirror;\n            CodeMirror.commands.foldAll(cm);\n        }\n    }\n\n    /**\n      * Expands all folded regions in the current document\n      */\n    function expandAll() {\n        var editor = EditorManager.getFocusedEditor();\n        if (editor) {\n            var cm = editor._codeMirror;\n            CodeMirror.commands.unfoldAll(cm);\n        }\n    }\n\n    function clearGutter(editor) {\n        var cm = editor._codeMirror;\n        var BLANK_GUTTER_CLASS = \"CodeMirror-foldgutter-blank\";\n        editor.clearGutter(GUTTER_NAME);\n        var blank = window.document.createElement(\"div\");\n        blank.className = BLANK_GUTTER_CLASS;\n        var vp = cm.getViewport();\n        cm.operation(function () {\n            cm.eachLine(vp.from, vp.to, function (line) {\n                editor.setGutterMarker(line.lineNo(), GUTTER_NAME, blank);\n            });\n        });\n    }\n\n    /**\n      * Renders and sets up event listeners the code-folding gutter.\n      * @param {Editor} editor the editor on which to initialise the fold gutter\n      */\n    function setupGutterEventListeners(editor) {\n        var cm = editor._codeMirror;\n        $(editor.getRootElement()).addClass(\"folding-enabled\");\n        cm.setOption(\"foldGutter\", {onGutterClick: onGutterClick});\n\n        $(cm.getGutterElement()).on({\n            mouseenter: function () {\n                if (prefs.getSetting(\"hideUntilMouseover\")) {\n                    foldGutter.updateInViewport(cm);\n                } else {\n                    $(editor.getRootElement()).addClass(\"over-gutter\");\n                }\n            },\n            mouseleave: function () {\n                if (prefs.getSetting(\"hideUntilMouseover\")) {\n                    clearGutter(editor);\n                } else {\n                    $(editor.getRootElement()).removeClass(\"over-gutter\");\n                }\n            }\n        });\n    }\n\n    /**\n      * Remove the fold gutter for a given CodeMirror instance.\n      * @param {Editor} editor the editor instance whose gutter should be removed\n      */\n    function removeGutters(editor) {\n        Editor.unregisterGutter(GUTTER_NAME);\n        $(editor.getRootElement()).removeClass(\"folding-enabled\");\n        CodeMirror.defineOption(\"foldGutter\", false, null);\n    }\n\n    /**\n      * Add gutter and restore saved expand/collapse state.\n      * @param {Editor} editor the editor instance where gutter should be added.\n      */\n    function enableFoldingInEditor(editor) {\n        restoreLineFolds(editor);\n        setupGutterEventListeners(editor);\n        editor._codeMirror.refresh();\n    }\n\n    /**\n      * When a brand new editor is seen, initialise fold-gutter and restore line folds in it.\n      * Save line folds in departing editor in case it's getting closed.\n      * @param {object} event the event object\n      * @param {Editor} current the current editor\n      * @param {Editor} previous the previous editor\n      */\n    function onActiveEditorChanged(event, current, previous) {\n        if (current && !current._codeMirror._lineFolds) {\n            enableFoldingInEditor(current);\n        }\n        if (previous) {\n            saveLineFolds(previous);\n        }\n    }\n\n    /**\n      * Saves the line folds in the current full editor before it is closed.\n      */\n    function saveBeforeClose() {\n        // We've already saved all other open editors when they go active->inactive\n        saveLineFolds(EditorManager.getActiveEditor());\n    }\n\n    /**\n     * Remove code-folding functionality\n     */\n    function deinit() {\n        _isInitialized = false;\n\n        KeyBindingManager.removeBinding(collapseKey);\n        KeyBindingManager.removeBinding(expandKey);\n\n        //remove menus\n        Menus.getMenu(Menus.AppMenuBar.VIEW_MENU).removeMenuDivider(codeFoldingMenuDivider.id);\n        Menus.getMenu(Menus.AppMenuBar.VIEW_MENU).removeMenuItem(COLLAPSE);\n        Menus.getMenu(Menus.AppMenuBar.VIEW_MENU).removeMenuItem(EXPAND);\n        Menus.getMenu(Menus.AppMenuBar.VIEW_MENU).removeMenuItem(COLLAPSE_ALL);\n        Menus.getMenu(Menus.AppMenuBar.VIEW_MENU).removeMenuItem(EXPAND_ALL);\n\n        EditorManager.off(\".CodeFolding\");\n        DocumentManager.off(\".CodeFolding\");\n        ProjectManager.off(\".CodeFolding\");\n\n        // Remove gutter & revert collapsed sections in all currently open editors\n        Editor.forEveryEditor(function (editor) {\n            CodeMirror.commands.unfoldAll(editor._codeMirror);\n        });\n        removeGutters();\n    }\n\n    /**\n     * Enable code-folding functionality\n     */\n    function init() {\n        _isInitialized = true;\n\n        foldCode.init();\n        foldGutter.init();\n\n        // Many CodeMirror modes specify which fold helper should be used for that language. For a few that\n        // don't, we register helpers explicitly here. We also register a global helper for generic indent-based\n        // folding, which cuts across all languages if enabled via preference.\n        CodeMirror.registerGlobalHelper(\"fold\", \"selectionFold\", function (mode, cm) {\n            return prefs.getSetting(\"makeSelectionsFoldable\");\n        }, selectionFold);\n        CodeMirror.registerGlobalHelper(\"fold\", \"indent\", function (mode, cm) {\n            return prefs.getSetting(\"alwaysUseIndentFold\");\n        }, indentFold);\n\n        CodeMirror.registerHelper(\"fold\", \"handlebars\", handlebarsFold);\n        CodeMirror.registerHelper(\"fold\", \"htmlhandlebars\", handlebarsFold);\n        CodeMirror.registerHelper(\"fold\", \"htmlmixed\", handlebarsFold);\n\n        EditorManager.on(\"activeEditorChange.CodeFolding\", onActiveEditorChanged);\n        DocumentManager.on(\"documentRefreshed.CodeFolding\", function (event, doc) {\n            restoreLineFolds(doc._masterEditor);\n        });\n\n        ProjectManager.on(\"beforeProjectClose.CodeFolding beforeAppClose.CodeFolding\", saveBeforeClose);\n\n        //create menus\n        codeFoldingMenuDivider = Menus.getMenu(Menus.AppMenuBar.VIEW_MENU).addMenuDivider();\n        Menus.getMenu(Menus.AppMenuBar.VIEW_MENU).addMenuItem(COLLAPSE_ALL);\n        Menus.getMenu(Menus.AppMenuBar.VIEW_MENU).addMenuItem(EXPAND_ALL);\n        Menus.getMenu(Menus.AppMenuBar.VIEW_MENU).addMenuItem(COLLAPSE);\n        Menus.getMenu(Menus.AppMenuBar.VIEW_MENU).addMenuItem(EXPAND);\n\n        //register keybindings\n        KeyBindingManager.addBinding(COLLAPSE, [{key: collapseKey}, {key: collapseKey, platform: \"mac\"}]);\n        KeyBindingManager.addBinding(EXPAND, [{key:expandKey}, {key:expandKey, platform: \"mac\"}]);\n\n\n        // Add gutters & restore saved expand/collapse state in all currently open editors\n        Editor.registerGutter(GUTTER_NAME, CODE_FOLDING_GUTTER_PRIORITY);\n        Editor.forEveryEditor(function (editor) {\n            enableFoldingInEditor(editor);\n        });\n    }\n\n    /**\n      * Register change listener for the preferences file.\n      */\n    function watchPrefsForChanges() {\n        prefs.prefsObject.on(\"change\", function (e, data) {\n            if (data.ids.indexOf(\"enabled\") > -1) {\n                // Check if enabled state mismatches whether code-folding is actually initialized (can't assume\n                // since preference change events can occur when the value hasn't really changed)\n                var isEnabled = prefs.getSetting(\"enabled\");\n                if (isEnabled && !_isInitialized) {\n                    init();\n                } else if (!isEnabled && _isInitialized) {\n                    deinit();\n                }\n            }\n        });\n    }\n\n    AppInit.htmlReady(function () {\n        CommandManager.register(Strings.COLLAPSE_ALL, COLLAPSE_ALL, collapseAll);\n        CommandManager.register(Strings.EXPAND_ALL, EXPAND_ALL, expandAll);\n        CommandManager.register(Strings.COLLAPSE_CURRENT, COLLAPSE, collapseCurrent);\n        CommandManager.register(Strings.EXPAND_CURRENT, EXPAND, expandCurrent);\n\n        if (prefs.getSetting(\"enabled\")) {\n            init();\n        }\n        watchPrefsForChanges();\n    });\n});\n\n/**\n * Wrapper around brackets pref system to ensure preferences are stored in in one single object instead of using multiple keys.\n * This is to make it easy for the user who edits their preferences file to easily manage the potentially numerous lines of preferences generated by the persisting code-folding state.\n * @author Patrick Oladimeji\n * @date 3/22/14 20:39:53 PM\n */\n\ndefine(\"Prefs\", function (require, exports, module) {\n\n\n    var ProjectManager              = brackets.getModule(\"project/ProjectManager\"),\n        PreferencesManager          = brackets.getModule(\"preferences/PreferencesManager\"),\n        Strings                     = brackets.getModule(\"strings\"),\n        prefs                       = PreferencesManager.getExtensionPrefs(\"code-folding\"),\n        FOLDS_PREF_KEY              = \"code-folding-folds\",\n        // preference key strings are here for now since they are not used in any UI\n        ENABLE_CODE_FOLDING         = \"Enable code folding\",\n        MIN_FOLD_SIZE               = \"Minimum fold size\",\n        SAVE_FOLD_STATES            = \"Save fold states\",\n        ALWAYS_USE_INDENT_FOLD      = \"Always use indent fold\",\n        HIDE_FOLD_BUTTONS           = \"Hide fold triangles\",\n        MAX_FOLD_LEVEL              = \"Max fold level\",\n        MAKE_SELECTIONS_FOLDABLE     = \"Makes selections foldable\";\n\n    //default preference values\n    prefs.definePreference(\"enabled\", \"boolean\", true,\n                           {name: ENABLE_CODE_FOLDING, description: Strings.DESCRIPTION_CODE_FOLDING_ENABLED});\n    prefs.definePreference(\"minFoldSize\", \"number\", 2,\n                           {name: MIN_FOLD_SIZE, description: Strings.DESCRIPTION_CODE_FOLDING_MIN_FOLD_SIZE});\n    prefs.definePreference(\"saveFoldStates\", \"boolean\", true,\n                           {name: SAVE_FOLD_STATES, description: Strings.DESCRIPTION_CODE_FOLDING_SAVE_FOLD_STATES});\n    prefs.definePreference(\"alwaysUseIndentFold\", \"boolean\", false,\n                           {name: ALWAYS_USE_INDENT_FOLD, description: Strings.DESCRIPTION_CODE_FOLDING_ALWAY_USE_INDENT_FOLD});\n    prefs.definePreference(\"hideUntilMouseover\", \"boolean\", false,\n                           {name: HIDE_FOLD_BUTTONS, description: Strings.DESCRIPTION_CODE_FOLDING_HIDE_UNTIL_MOUSEOVER});\n    prefs.definePreference(\"maxFoldLevel\", \"number\", 2,\n                           {name: MAX_FOLD_LEVEL, description: Strings.DESCRIPTION_CODE_FOLDING_MAX_FOLD_LEVEL});\n    prefs.definePreference(\"makeSelectionsFoldable\", \"boolean\", true,\n                           {name: MAKE_SELECTIONS_FOLDABLE, description: Strings.DESCRIPTION_CODE_FOLDING_MAKE_SELECTIONS_FOLDABLE});\n\n    PreferencesManager.stateManager.definePreference(FOLDS_PREF_KEY, \"object\", {});\n\n    /**\n      * Simplifies the fold ranges into an array of pairs of numbers.\n      * @param {!Object} folds the raw fold ranges indexed by line numbers\n      * @return {Object} an object whose keys are line numbers and the values are array\n      * of two 2-element arrays. First array contains [from.line, from.ch] and the second contains [to.line, to.ch]\n      */\n    function simplify(folds) {\n        if (!folds) {\n            return;\n        }\n        var res = {}, range;\n        Object.keys(folds).forEach(function (line) {\n            range = folds[line];\n            res[line] = Array.isArray(range) ? range : [[range.from.line, range.from.ch], [range.to.line, range.to.ch]];\n        });\n        return res;\n    }\n\n    /**\n      * Inflates the fold ranges stored as simplified numeric arrays. The inflation converts the data into\n      * objects whose keys are line numbers and whose values are objects in the format {from: {line, ch}, to: {line, ch}}.\n      * @param {Object}  folds the simplified fold ranges\n      * @return {Object} the converted fold ranges\n      */\n    function inflate(folds) {\n        if (!folds) {\n            return;\n        }\n         //transform the folds into objects with from and to properties\n        var ranges = {}, obj;\n        Object.keys(folds).forEach(function (line) {\n            obj = folds[line];\n            ranges[line] = {from: {line: obj[0][0], ch: obj[0][1]}, to: {line: obj[1][0], ch: obj[1][1]}};\n        });\n\n        return ranges;\n    }\n\n    /**\n      * Gets the line folds saved for the specified path.\n      * @param {string} path the document path\n      * @return {Object} the line folds for the document at the specified path\n      */\n    function getFolds(path) {\n        var folds = PreferencesManager.getViewState(FOLDS_PREF_KEY, PreferencesManager.STATE_PROJECT_CONTEXT);\n        return inflate(folds[path]);\n    }\n\n    /**\n      * Saves the line folds for the specified path\n      * @param {!string} path the path to the document\n      * @param {Object} folds the fold ranges to save for the current document\n      */\n    function setFolds(path, folds) {\n        const allFolds = PreferencesManager.getViewState(FOLDS_PREF_KEY, PreferencesManager.STATE_PROJECT_CONTEXT);\n        allFolds[path] = simplify(folds);\n        PreferencesManager.setViewState(FOLDS_PREF_KEY, allFolds, PreferencesManager.STATE_PROJECT_CONTEXT);\n    }\n\n    /**\n      * Get the code folding setting with the specified key from the store\n      * @param {!string} key The key for the setting to retrieve\n      * @return {string} the setting with the specified key\n      */\n    function getSetting(key) {\n        return prefs.get(key);\n    }\n\n    /**\n      * Clears all the saved line folds for all documents.\n      */\n    function clearAllFolds() {\n        PreferencesManager.setViewState(FOLDS_PREF_KEY, {});\n    }\n\n    module.exports.getFolds = getFolds;\n    module.exports.setFolds = setFolds;\n    module.exports.getSetting = getSetting;\n    module.exports.clearAllFolds = clearAllFolds;\n    module.exports.prefsObject = prefs;\n});\n\n/**\n * Selection range helper for code folding.\n * @author Patrick Oladimeji\n * @date 31/07/2015 00:11:53\n */\n\ndefine(\"foldhelpers/foldSelected\", function (require, exports, module) {\n\n\n    /**\n     * This helper returns the start and end range representing the current selection in the editor.\n     * @param   {Object} cm    The Codemirror instance\n     * @param   {Object} start A Codemirror.Pos object {line, ch} representing the current line we are\n     *                          checking for fold ranges\n     * @returns {Object} The fold range, {from, to} representing the current selection.\n     */\n    function SelectionFold(cm, start) {\n        if (!cm.somethingSelected()) {\n            return;\n        }\n\n        var from = cm.getCursor(\"from\"),\n            to  = cm.getCursor(\"to\");\n        if (from.line === start.line) {\n            return {from: from, to: to};\n        }\n    }\n\n    module.exports = SelectionFold;\n});\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n// Based on http://codemirror.net/addon/fold/foldcode.js\n// Modified by Patrick Oladimeji for Brackets\n\ndefine(\"foldhelpers/foldcode\", function (require, exports, module) {\n\n    var CodeMirror          = brackets.getModule(\"thirdparty/CodeMirror/lib/codemirror\"),\n        prefs               = require(\"Prefs\");\n\n    /**\n      * Performs the folding and unfolding of code regions.\n      * @param {CodeMirror} cm the CodeMirror instance\n      * @param {number| Object} pos\n      */\n    function doFold(cm, pos, options, force) {\n        options = options || {};\n        force = force || \"fold\";\n        if (typeof pos === \"number\") {\n            pos = CodeMirror.Pos(pos, 0);\n        }\n\n        var finder = options.rangeFinder || CodeMirror.fold.auto,\n            range,\n            widget,\n            textRange;\n\n        function getRange(allowFolded) {\n            var range = options.range || finder(cm, pos);\n            if (!range || range.to.line - range.from.line < prefs.getSetting(\"minFoldSize\")) {\n                return null;\n            }\n            var marks = cm.findMarksAt(range.from),\n                i,\n                lastMark,\n                foldMarks;\n            for (i = 0; i < marks.length; ++i) {\n                if (marks[i].__isFold && force !== \"fold\") {\n                    if (!allowFolded) {\n                        return null;\n                    }\n                    range.cleared = true;\n                    marks[i].clear();\n                }\n            }\n            //check for overlapping folds\n            if (marks && marks.length) {\n                foldMarks = marks.filter(function (d) {\n                    return d.__isFold;\n                });\n                if (foldMarks && foldMarks.length) {\n                    lastMark = foldMarks[foldMarks.length - 1].find();\n                    if (lastMark && range.from.line <= lastMark.to.line && lastMark.to.line < range.to.line) {\n                        return null;\n                    }\n                }\n            }\n            return range;\n        }\n\n        function makeWidget() {\n            var widget = window.document.createElement(\"span\");\n            widget.className = \"CodeMirror-foldmarker\";\n            return widget;\n        }\n\n        range = getRange(true);\n        if (options.scanUp) {\n            while (!range && pos.line > cm.firstLine()) {\n                pos = CodeMirror.Pos(pos.line - 1, 0);\n                range = getRange(false);\n            }\n        }\n        if (!range || range.cleared || force === \"unfold\" || range.to.line - range.from.line < prefs.getSetting(\"minFoldSize\")) {\n            if (range) { range.cleared = false; }\n            return;\n        }\n\n        widget = makeWidget();\n        textRange = cm.markText(range.from, range.to, {\n            replacedWith: widget,\n            clearOnEnter: true,\n            __isFold: true\n        });\n\n        CodeMirror.on(widget, \"mousedown\", function (e) {\n            textRange.clear();\n            e.preventDefault();\n        });\n\n        textRange.on(\"clear\", function (from, to) {\n            delete cm._lineFolds[from.line];\n            CodeMirror.signal(cm, \"unfold\", cm, from, to);\n        });\n\n        if (force === \"fold\") {\n            delete range.cleared;\n            // In some cases such as in xml style files, the start of  line folds can span multiple lines.\n            // For instance the attributes of an element can span multiple lines. In these cases when folding\n            // we want to render a gutter marker for both the beginning and end of the opening xml tag.\n            if (pos.line < range.from.line) {\n                cm._lineFolds[range.from.line] = range;\n            } else {\n                cm._lineFolds[pos.line] = range;\n            }\n        } else {\n            delete cm._lineFolds[pos.line];\n        }\n\n        CodeMirror.signal(cm, force, cm, range.from, range.to);\n        return range;\n    }\n\n    /**\n        Initialises extensions and helpers on the CodeMirror object\n    */\n    function init() {\n        CodeMirror.defineExtension(\"foldCode\", function (pos, options, force) {\n            return doFold(this, pos, options, force);\n        });\n\n        CodeMirror.defineExtension(\"unfoldCode\", function (pos, options) {\n            return doFold(this, pos, options, \"unfold\");\n        });\n\n        CodeMirror.defineExtension(\"isFolded\", function (line) {\n            return this._lineFolds && this._lineFolds[line];\n        });\n\n        /**\n          * Checks the validity of the ranges passed in the parameter and returns the foldranges\n          * that are still valid in the current document\n          * @param {object} folds the dictionary of lines in the current document that should be folded\n          * @returns {object} valid folds found in those passed in parameter\n          */\n        CodeMirror.defineExtension(\"getValidFolds\", function (folds) {\n            var keys, rf = CodeMirror.fold.auto, cm = this, result = {}, range, cachedRange;\n            if (folds && (keys = Object.keys(folds)).length) {\n                keys.forEach(function (lineNumber) {\n                    lineNumber = +lineNumber;\n                    if (lineNumber >= cm.firstLine() && lineNumber <= cm.lastLine()) {\n                        range = rf(cm, CodeMirror.Pos(lineNumber, 0));\n                        cachedRange = folds[lineNumber];\n                        if (range && cachedRange && range.from.line === cachedRange.from.line &&\n                                range.to.line === cachedRange.to.line) {\n                            result[lineNumber] = folds[lineNumber];\n                        }\n                    }\n                });\n            }\n            return result;\n        });\n\n        /**\n          * Utility function to fold the region at the current cursor position in  a document\n          * @param {CodeMirror} cm the CodeMirror instance\n          * @param {?options} options extra options to pass to the fold function\n          */\n        CodeMirror.commands.fold = function (cm, options) {\n            cm.foldCode(cm.getCursor(), options, \"fold\");\n        };\n\n        /**\n          * Utility function to unfold the region at the current cursor position in  a document\n          * @param {CodeMirror} cm the CodeMirror instance\n          * @param {?options} options extra options to pass to the fold function\n          */\n        CodeMirror.commands.unfold = function (cm, options) {\n            cm.foldCode(cm.getCursor(), options, \"unfold\");\n        };\n\n        /**\n          * Utility function to fold all foldable regions in a document\n          * @param {CodeMirror} cm the CodeMirror instance\n          */\n        CodeMirror.commands.foldAll = function (cm) {\n            cm.operation(function () {\n                var i, e;\n                for (i = cm.firstLine(), e = cm.lastLine(); i <= e; i++) {\n                    cm.foldCode(CodeMirror.Pos(i, 0), null, \"fold\");\n                }\n            });\n        };\n\n        /**\n          * Utility function to unfold all folded regions in a document\n          * @param {CodeMirror} cm the CodeMirror instance\n          * @param {?number} from the line number for the beginning of the region to unfold\n          * @param {?number} to the line number for the end of the region to unfold\n          */\n        CodeMirror.commands.unfoldAll = function (cm, from, to) {\n            from = from || cm.firstLine();\n            to = to || cm.lastLine();\n            cm.operation(function () {\n                var i, e;\n                for (i = from, e = to; i <= e; i++) {\n                    if (cm.isFolded(i)) { cm.unfoldCode(i, {range: cm._lineFolds[i]}); }\n                }\n            });\n        };\n\n        /**\n          * Folds the specified range. The descendants of any fold regions within the range are also folded up to\n          * a level set globally in the `maxFoldLevel' preferences\n          * @param {CodeMirror} cm the CodeMirror instance\n          * @param {?number} start the line number for the beginning of the region to fold\n          * @param {?number} end the line number for the end of the region to fold\n          */\n        CodeMirror.commands.foldToLevel = function (cm, start, end) {\n            var rf = CodeMirror.fold.auto;\n            function foldLevel(n, from, to) {\n                if (n > 0) {\n                    var i = from, range;\n                    while (i < to) {\n                        range = rf(cm, CodeMirror.Pos(i, 0));\n                        if (range) {\n                            //call fold level for the range just folded\n                            foldLevel(n - 1, range.from.line + 1, range.to.line - 1);\n                            cm.foldCode(CodeMirror.Pos(i, 0), null, \"fold\");\n                            i = range.to.line + 1;\n                        } else {\n                            i++;\n                        }\n                    }\n                }\n            }\n            cm.operation(function () {\n                start = start === undefined ? cm.firstLine() : start;\n                end = end || cm.lastLine();\n                foldLevel(prefs.getSetting(\"maxFoldLevel\"), start, end);\n            });\n        };\n\n        /**\n          * Helper to combine an array of fold range finders into one. This goes through the\n          * list of fold helpers in the parameter arguments and returns the first non-null\n          * range found from calling the fold helpers in order.\n          */\n        CodeMirror.registerHelper(\"fold\", \"combine\", function () {\n            var funcs = Array.prototype.slice.call(arguments, 0);\n            return function (cm, start) {\n                var i;\n                for (i = 0; i < funcs.length; ++i) {\n                    var found = funcs[i] && funcs[i](cm, start);\n                    if (found) {\n                        return found;\n                    }\n                }\n            };\n        });\n\n        /**\n          * Creates a helper which returns the appropriate fold function based on the mode of the current position in\n          * a document.\n          * @param {CodeMirror} cm the CodeMirror instance\n          * @param {number} start the current position in the document\n          */\n        CodeMirror.registerHelper(\"fold\", \"auto\", function (cm, start) {\n            var helpers = cm.getHelpers(start, \"fold\"), i, range;\n            //ensure mode helper is loaded if there is one\n            var mode = cm.getMode().name;\n            var modeHelper = CodeMirror.fold[mode];\n            if (modeHelper && helpers.indexOf(modeHelper) < 0) {\n                helpers.push(modeHelper);\n            }\n            for (i = 0; i < helpers.length; i++) {\n                range = helpers[i](cm, start);\n                if (range && range.to.line - range.from.line >= prefs.getSetting(\"minFoldSize\")) { return range; }\n            }\n        });\n    }\n\n    exports.init = init;\n});\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n// Based on http://codemirror.net/addon/fold/foldgutter.js\n// Modified by Patrick Oladimeji for Brackets\n\ndefine(\"foldhelpers/foldgutter\", function (require, exports, module) {\n\n    var CodeMirror      = brackets.getModule(\"thirdparty/CodeMirror/lib/codemirror\"),\n        prefs           = require(\"Prefs\");\n\n    function State(options) {\n        this.options = options;\n        this.from = this.to = 0;\n    }\n\n    function parseOptions(opts) {\n        if (opts === true) { opts = {}; }\n        if (!opts.gutter) { opts.gutter = \"CodeMirror-foldgutter\"; }\n        if (!opts.indicatorOpen) { opts.indicatorOpen = \"CodeMirror-foldgutter-open\"; }\n        if (!opts.indicatorFolded) { opts.indicatorFolded = \"CodeMirror-foldgutter-folded\"; }\n        return opts;\n    }\n\n    /**\n      * Utility for creating fold markers in fold gutter\n      * @param {string} spec the className for the marker\n      * @return {HTMLElement} a htmlelement representing the fold marker\n      */\n    function marker(spec) {\n        var elt = window.document.createElement(\"div\");\n        elt.className = spec;\n        return elt;\n    }\n\n    /**\n     * Checks whether or not a marker is a code-folding marker\n     * @param   {Object}   m a CodeMirror TextMarker object\n     * @returns {boolean} true if the marker is a codefolding range marker or false otherwise\n     */\n    function isFold(m) {\n        return m.__isFold;\n    }\n\n    /**\n      * Updates the gutter markers for the specified range\n      * @param {!CodeMirror} cm the CodeMirror instance for the active editor\n      * @param {!number} from the starting line for the update\n      * @param {!number} to the ending line for the update\n      */\n    function updateFoldInfo(cm, from, to) {\n        var minFoldSize = prefs.getSetting(\"minFoldSize\") || 2;\n        var opts = cm.state.foldGutter.options;\n        var fade = prefs.getSetting(\"hideUntilMouseover\");\n        var $gutter = $(cm.getGutterElement());\n        var i = from;\n\n        function clear(m) {\n            return m.clear();\n        }\n\n        /**\n          * @private\n          * helper function to check if the given line is in a folded region in the editor.\n          * @param {number} line the\n          * @return {Object} the range that hides the specified line or undefine if the line is not hidden\n          */\n        function _isCurrentlyFolded(line) {\n            var keys = Object.keys(cm._lineFolds), i = 0, range;\n            while (i < keys.length) {\n                range = cm._lineFolds[keys[i]];\n                if (range.from.line < line && range.to.line >= line) {\n                    return range;\n                }\n                i++;\n            }\n        }\n\n        /**\n            This case is needed when unfolding a region that does not cause the viewport to change.\n            For instance in a file with about 15 lines, if some code regions are folded and unfolded, the\n            viewport change event isn't fired by CodeMirror. The setTimeout is a workaround to trigger the\n            gutter update after the viewport has been drawn.\n        */\n        if (i === to) {\n            window.setTimeout(function () {\n                var vp = cm.getViewport();\n                updateFoldInfo(cm, vp.from, vp.to);\n            }, 200);\n        }\n\n        while (i < to) {\n            var sr = _isCurrentlyFolded(i), // surrounding range for the current line if one exists\n                range;\n            var mark = marker(\"CodeMirror-foldgutter-blank\");\n            var pos = CodeMirror.Pos(i, 0),\n                func = opts.rangeFinder || CodeMirror.fold.auto;\n            // don't look inside collapsed ranges\n            if (sr) {\n                i = sr.to.line + 1;\n            } else {\n                range = cm._lineFolds[i] || (func && func(cm, pos));\n\n                if (!fade || (fade && $gutter.is(\":hover\"))) {\n                    if (cm.isFolded(i)) {\n                        // expand fold if invalid\n                        if (range) {\n                            mark = marker(opts.indicatorFolded);\n                        } else {\n                            cm.findMarksAt(pos).filter(isFold)\n                                .forEach(clear);\n                        }\n                    } else {\n                        if (range && range.to.line - range.from.line >= minFoldSize) {\n                            mark = marker(opts.indicatorOpen);\n                        }\n                    }\n                }\n                cm.setGutterMarker(i, opts.gutter, mark);\n                i++;\n            }\n        }\n    }\n\n    /**\n      * Updates the fold information in the viewport for the specified range\n      * @param {CodeMirror} cm the instance of the CodeMirror object\n      * @param {?number} from the starting line number for the update\n      * @param {?number} to the end line number for the update\n      */\n    function updateInViewport(cm, from, to) {\n        var vp = cm.getViewport(), state = cm.state.foldGutter;\n        from = isNaN(from) ? vp.from : from;\n        to = isNaN(to) ? vp.to : to;\n\n        if (!state) { return; }\n        cm.operation(function () {\n            updateFoldInfo(cm, from, to);\n        });\n        state.from = from;\n        state.to = to;\n    }\n\n    /**\n     * Helper function to return the fold text marker on a line in an editor\n     * @param   {CodeMirror} cm   The CodeMirror instance for the active editor\n     * @param   {Number}     line The line number representing the position of the fold marker\n     * @returns {TextMarker} A CodeMirror TextMarker object\n     */\n    function getFoldOnLine(cm, line) {\n        var pos = CodeMirror.Pos(line, 0);\n        var folds = cm.findMarksAt(pos) || [];\n        folds = folds.filter(isFold);\n        return folds.length ? folds[0] : undefined;\n    }\n\n    /**\n     * Synchronises the code folding states in the CM doc to cm._lineFolds cache.\n     * When an undo operation is done, if folded code fragments are restored, then\n     * we need to update cm._lineFolds with the fragments\n     * @param {Object}   cm       cm the CodeMirror instance for the active  editor\n     * @param {Object}   from     starting position in the doc to sync the fold states from\n     * @param {[[Type]]} lineAdded a number to show how many lines where added to the document\n     */\n    function syncDocToFoldsCache(cm, from, lineAdded) {\n        var minFoldSize = prefs.getSetting(\"minFoldSize\") || 2;\n        var i, fold, range;\n        if (lineAdded <= 0) {\n            return;\n        }\n\n        for (i = from; i <= from + lineAdded; i = i + 1) {\n            fold = getFoldOnLine(cm, i);\n            if (fold) {\n                range = fold.find();\n                if (range && range.to.line - range.from.line >= minFoldSize) {\n                    cm._lineFolds[i] = range;\n                    i = range.to.line;\n                } else {\n                    delete cm._lineFolds[i];\n                }\n            }\n        }\n    }\n\n    /**\n     * Helper function to move a fold range object by the specified number of lines\n     * @param {Object} range    An object specifying the fold range to move. It contains {from, to} which are CodeMirror.Pos objects.\n     * @param {Number} numLines A positive or negative number representing the numbe of lines to move the range by\n     */\n    function moveRange(range, numLines) {\n        return {from: CodeMirror.Pos(range.from.line + numLines, range.from.ch),\n            to: CodeMirror.Pos(range.to.line + numLines, range.to.ch)};\n    }\n\n    /**\n      * Updates the line folds cache usually when the document changes.\n      * The following cases are accounted for:\n      * 1.  When the change does not add a new line to the document we check if the line being modified\n      *     is folded. If that is the case, changes to this line might affect the range stored in the cache\n      *     so we update the range using the range finder function.\n      * 2.  If lines have been added, we need to update the records for all lines in the folds cache\n      *     which are greater than the line position at which we are adding the new line(s). When existing\n      *     folds are above the addition we keep the original position in the cache.\n      * 3.  If lines are being removed, we need to update the records for all lines in the folds cache which are\n      *     greater than the line position at which we are removing the new lines, while making sure to\n      *     not include any folded lines in the cache that are part of the removed chunk.\n      * @param {!CodeMirror} cm        the CodeMirror instance for the active editor\n      * @param {!number}     from      the line number designating the start position of the change\n      * @param {!number}     linesDiff a number to show how many lines where removed or added to the document.\n      *                                This value is negative for deletions and positive for additions.\n      */\n    function updateFoldsCache(cm, from, linesDiff) {\n        var oldRange, newRange;\n        var minFoldSize = prefs.getSetting(\"minFoldSize\") || 2;\n        var foldedLines = Object.keys(cm._lineFolds).map(function (d) {\n            return +d;\n        });\n        var opts = cm.state.foldGutter.options || {};\n        var rf = opts.rangeFinder || CodeMirror.fold.auto;\n\n        if (linesDiff === 0) {\n            if (foldedLines.indexOf(from) >= 0) {\n                newRange = rf(cm, CodeMirror.Pos(from, 0));\n                if (newRange && newRange.to.line - newRange.from.line >= minFoldSize) {\n                    cm._lineFolds[from] = newRange;\n                } else {\n                    delete cm._lineFolds[from];\n                }\n            }\n        } else if (foldedLines.length) {\n            var newFolds = {};\n            foldedLines.forEach(function (line) {\n                oldRange = cm._lineFolds[line];\n                //update range with lines-diff\n                newRange = moveRange(oldRange, linesDiff);\n                // for removed lines we want to check lines that lie outside the deleted range\n                if (linesDiff < 0) {\n                    if (line < from) {\n                        newFolds[line] = oldRange;\n                    } else if (line >= from + Math.abs(linesDiff)) {\n                        newFolds[line + linesDiff] = newRange;\n                    }\n                } else {\n                    if (line < from) {\n                        newFolds[line] = oldRange;\n                    } else if (line >= from) {\n                        newFolds[line + linesDiff] = newRange;\n                    }\n                }\n            });\n            cm._lineFolds = newFolds;\n        }\n    }\n\n    /**\n      * Triggered when the content of the document changes. When the entire content of the document\n      * is changed - e.g., changes made from a different editor, the same lineFolds are kept only if\n      * they are still valid in the context of the new document content.\n      * @param {!CodeMirror} cm the CodeMirror instance for the active editor\n      * @param {!Object} changeObj detailed information about the change that occurred in the document\n      */\n    function onChange(cm, changeObj) {\n        if (changeObj.origin === \"setValue\") { //text content has changed outside of brackets\n            var folds = cm.getValidFolds(cm._lineFolds);\n            cm._lineFolds = folds;\n            Object.keys(folds).forEach(function (line) {\n                cm.foldCode(+line);\n            });\n        } else {\n            var state = cm.state.foldGutter;\n            var lineChanges = changeObj.text.length - changeObj.removed.length;\n            // for undo actions that add new line(s) to the document first update the folds cache as normal\n            // and then update the folds cache with any line folds that exist in the new lines\n            if (changeObj.origin === \"undo\" && lineChanges > 0) {\n                updateFoldsCache(cm, changeObj.from.line, lineChanges);\n                syncDocToFoldsCache(cm, changeObj.from.line, lineChanges);\n            } else {\n                updateFoldsCache(cm, changeObj.from.line, lineChanges);\n            }\n            if (lineChanges !== 0) {\n                updateFoldInfo(cm, Math.max(0, changeObj.from.line + lineChanges), Math.max(0, changeObj.from.line + lineChanges) + 1);\n            }\n            state.from = changeObj.from.line;\n            state.to = 0;\n            window.clearTimeout(state.changeUpdate);\n            state.changeUpdate = window.setTimeout(function () {\n                updateInViewport(cm);\n            }, 600);\n        }\n    }\n\n    /**\n      * Triggered on viewport changes e.g., user scrolls or resizes the viewport.\n      * @param {!CodeMirror} cm the CodeMirror instance for the active editor\n      */\n    function onViewportChange(cm) {\n        var state = cm.state.foldGutter;\n        window.clearTimeout(state.changeUpdate);\n        state.changeUpdate = window.setTimeout(function () {\n            var vp = cm.getViewport();\n            if (state.from === state.to || vp.from - state.to > 20 || state.from - vp.to > 20) {\n                updateInViewport(cm);\n            } else {\n                cm.operation(function () {\n                    if (vp.from < state.from) {\n                        updateFoldInfo(cm, vp.from, state.from);\n                        state.from = vp.from;\n                    }\n                    if (vp.to > state.to) {\n                        updateFoldInfo(cm, state.to, vp.to);\n                        state.to = vp.to;\n                    } else {\n                        updateFoldInfo(cm, vp.from, vp.to);\n                        state.to = vp.to;\n                        state.from = vp.from;\n                    }\n                });\n            }\n        }, 400);\n    }\n\n    /**\n     * Triggered when the cursor moves in the editor and used to detect text selection changes\n     * in the editor.\n     * @param {!CodeMirror} cm the CodeMirror instance for the active editor\n     */\n    function onCursorActivity(cm) {\n        var state = cm.state.foldGutter;\n        var vp = cm.getViewport();\n        window.clearTimeout(state.changeUpdate);\n        state.changeUpdate = window.setTimeout(function () {\n            //need to render the entire visible viewport to remove fold marks rendered from previous selections if any\n            updateInViewport(cm, vp.from, vp.to);\n        }, 400);\n    }\n\n    /**\n      * Triggered when a code segment is folded.\n      * @param {!CodeMirror} cm the CodeMirror instance for the active editor\n      * @param {!Object} from  the ch and line position that designates the start of the region\n      * @param {!Object} to the ch and line position that designates the end of the region\n      */\n    function onFold(cm, from, to) {\n        var state = cm.state.foldGutter;\n        updateFoldInfo(cm, from.line, from.line + 1);\n    }\n\n    /**\n      * Triggered when a folded code segment is unfolded.\n      * @param {!CodeMirror} cm the CodeMirror instance for the active editor\n      * @param {!{line:number, ch:number}} from  the ch and line position that designates the start of the region\n      * @param {!{line:number, ch:number}} to the ch and line position that designates the end of the region\n      */\n    function onUnFold(cm, from, to) {\n        var state = cm.state.foldGutter;\n        var vp = cm.getViewport();\n        delete cm._lineFolds[from.line];\n        updateFoldInfo(cm, from.line, to.line || vp.to);\n    }\n\n    /**\n      * Initialises the fold gutter and registers event handlers for changes to document, viewport\n      * and user interactions.\n      */\n    function init() {\n        CodeMirror.defineOption(\"foldGutter\", false, function (cm, val, old) {\n            if (old && old !== CodeMirror.Init) {\n                cm.clearGutter(cm.state.foldGutter.options.gutter);\n                cm.state.foldGutter = null;\n                cm.off(\"gutterClick\", old.onGutterClick);\n                cm.off(\"change\", onChange);\n                cm.off(\"viewportChange\", onViewportChange);\n                cm.off(\"cursorActivity\", onCursorActivity);\n\n                cm.off(\"fold\", onFold);\n                cm.off(\"unfold\", onUnFold);\n                cm.off(\"swapDoc\", updateInViewport);\n            }\n            if (val) {\n                cm.state.foldGutter = new State(parseOptions(val));\n                updateInViewport(cm);\n                cm.on(\"gutterClick\", val.onGutterClick);\n                cm.on(\"change\", onChange);\n                cm.on(\"viewportChange\", onViewportChange);\n                cm.on(\"cursorActivity\", onCursorActivity);\n                cm.on(\"fold\", onFold);\n                cm.on(\"unfold\", onUnFold);\n                cm.on(\"swapDoc\", updateInViewport);\n            }\n        });\n    }\n\n    exports.init = init;\n    exports.updateInViewport = updateInViewport;\n\n});\n\n/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2016 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/**\n * Fold range finder for handlebars/mustache template type files.\n * @author Patrick Oladimeji\n * @date 14/08/2016 22:04:21\n */\n\ndefine(\"foldhelpers/handlebarsFold\", function (require, exports, module) {\n\n    var CodeMirror  = brackets.getModule(\"thirdparty/CodeMirror/lib/codemirror\"),\n        _           = brackets.getModule(\"thirdparty/lodash\"),\n        StringUtils = brackets.getModule(\"utils/StringUtils\");\n\n    /**\n     * Utility function for scanning the text in a document until a certain condition is met\n     * @param {object}  cm  The code mirror object representing the document\n     * @param {string}  startCh  The start character position for the scan operation\n     * @param {number}  startLine The start line position for the scan operation\n     * @param {function (string): boolean} condition A predicate function that takes in the text seen so far and returns true if the scanning process should be halted\n     * @returns {{from:CodeMirror.Pos, to: CodeMirror.Pos, string: string}} An object representing the range of text scanned.\n     */\n    function scanTextUntil(cm, startCh, startLine, condition) {\n        var line = cm.getLine(startLine),\n            seen = \"\",\n            characterIndex = startCh,\n            currentLine = startLine,\n            range;\n        while (currentLine <= cm.lastLine()) {\n            if (line.length === 0) {\n                characterIndex = 0;\n                line = cm.getLine(++currentLine);\n            } else {\n                seen = seen.concat(line[characterIndex] || \"\");\n                if (condition(seen)) {\n                    range = {\n                        from: {ch: startCh, line: startLine},\n                        to: {ch: characterIndex, line: currentLine},\n                        string: seen\n                    };\n                    return range;\n                } else if (characterIndex >= line.length) {\n                    seen = seen.concat(cm.lineSeparator());\n                    if (condition(seen)) {\n                        range = {\n                            from: {ch: startCh, line: startLine},\n                            to: {ch: characterIndex, line: currentLine},\n                            string: seen\n                        };\n                        return range;\n                    }\n                    characterIndex = 0;\n                    line = cm.getLine(++currentLine);\n                } else {\n                    ++characterIndex;\n                }\n            }\n        }\n    }\n\n    /**\n     * Utility function used to detect the end of a helper name when scanning a series of text.\n     * The end of a helper name is signalled by a space character or the `}`\n     * @param   {string}  seen The string seen so far\n     * @returns {boolean} True when the end of a helper name has been detected.\n     */\n    function endHelperName(seen) {\n        return (/\\s$/).test(seen) || StringUtils.endsWith(seen, \"}\");\n    }\n\n    /**\n     * Returns a predicate function that returns true when a specific character is found\n     * @param   {string}   character the character to use in the match function\n     * @returns {function} A function that checks if the last character of the parameter string matches the parameter character\n     */\n    function readUntil(character) {\n        return function (seen) {\n            return seen[seen.length - 1] === character;\n        };\n    }\n\n    function getRange(cm, start) {\n        var currentLine = start.line,\n            text = cm.getLine(currentLine) || \"\",\n            i = 0,\n            tagStack = [],\n            braceStack = [],\n            found,\n            openTag,\n            openPos,\n            currentCharacter,\n            openTagIndex = text.indexOf(\"{{\"),\n            range;\n\n        if (openTagIndex < 0 || text[openTagIndex + 2] === \"/\") {\n            return;\n        }\n\n        found = scanTextUntil(cm, openTagIndex + 2, currentLine, endHelperName);\n        if (!found) {\n            return;\n        }\n\n        openPos = {\n            from: {line: currentLine, ch: openTagIndex},\n            to: found.to\n        };\n        openTag = found.string.substring(0, found.string.length - 1);\n        if (openTag[0] === \"#\" || openTag[0] === \"~\" || openTag[0] === \"^\") {\n            found = scanTextUntil(cm, openPos.to.ch, openPos.to.line, function (seen) {\n                return seen.length > 1 && seen.substr(-2) === \"}}\";\n            });\n            if (found) {\n                openPos.to = {line: found.to.line, ch: found.to.ch + 1};\n            }\n            tagStack.push(openTag.substr(1));\n        } else {\n            braceStack.push(\"{{\");\n        }\n\n        i = found.to.ch;\n        currentLine = found.to.line;\n\n        while (currentLine <= cm.lastLine()) {\n            text = cm.getLine(currentLine);\n            currentCharacter = (text && text[i]) || \"\";\n            switch (currentCharacter) {\n            case \"{\":\n                if (text[i + 1] === \"{\") {\n                    found = scanTextUntil(cm, i + 2, currentLine, endHelperName);\n                    if (found) {\n                        var tag = found.string.substring(0, found.string.length - 1);\n                        if (tag[0] === \"#\" || tag[0] === \"~\" || tag[0] === \"^\") {\n                            tagStack.push(tag.substr(1));\n                        } else if (tag[0] === \"/\" &&\n                                   (_.last(tagStack) === tag.substr(1) || _.last(tagStack) === \"*\" + tag.substr(1))) {\n                            tagStack.pop();\n                            if (tagStack.length === 0 && braceStack.length === 0) {\n                                range = {\n                                    from: openPos.to,\n                                    to: {ch: i, line: currentLine}\n                                };\n                                return range;\n                            }\n                        } else {\n                            braceStack.push(\"{{\");\n                        }\n                    }\n                }\n                break;\n            case \"}\":\n                if (text[i + 1] === \"}\") {\n                    braceStack.pop();\n                    if (braceStack.length === 0 && tagStack.length === 0) {\n                        range = {\n                            from: openPos.to,\n                            to: {ch: i, line: currentLine}\n                        };\n                        return range;\n                    }\n                }\n                break;\n            case \"\\\"\":\n            case \"'\":\n                found = scanTextUntil(cm, i + 1, currentLine, readUntil(text[i]));\n                if (found) {\n                    i = found.to.ch;\n                    currentLine = found.to.line;\n                }\n                break;\n            default:\n                break;\n            }\n\n            ++i;\n            if (i >= text.length) {\n                ++currentLine;\n                i = 0;\n            }\n        }\n    }\n\n    module.exports = getRange;\n});\n\n/**\n * Fold range finder based on line indentations. Ignores blank lines and commented lines\n * @author Patrick Oladimeji\n * @date 12/27/13 21:54:41 PM\n */\n\ndefine(\"foldhelpers/indentFold\", function (require, exports, module) {\n\n    var CodeMirror  = brackets.getModule(\"thirdparty/CodeMirror/lib/codemirror\"),\n        cols        = CodeMirror.countColumn,\n        pos         = CodeMirror.Pos;\n\n    function lastNonEmptyLineNumber(cm) {\n        var lc = cm.lastLine(), line = cm.getLine(lc);\n        while (lc > 0 && line.trim().length === 0) {\n            lc--;\n            line = cm.getLine(lc);\n        }\n        return lc;\n    }\n\n    function indentFold(cm, start) {\n        var lineText = cm.getLine(start.line), tabSize = cm.getOption(\"tabSize\");\n\n        var lineIndent = cols(lineText, null, tabSize), collapsible = false, lineCount = cm.lineCount();\n        var token = cm.getTokenAt(pos(start.line, lineIndent + 1));\n        //no folding for blank lines or commented lines\n        if (lineText.trim().length === 0 || (token && token.type === \"comment\")) {\n            return;\n        }\n        var i, indent, currentLine;\n        for (i = start.line + 1; i < lineCount; i++) {\n            currentLine = cm.getLine(i);\n            indent = cols(currentLine, null, tabSize);\n\n            token = cm.getTokenAt(pos(i, indent + 1));\n            //only fold for non blank lines or non commented lines\n            if (currentLine.trim().length !== 0 && (token && token.type !== \"comment\")) {\n                if (!collapsible) {\n                    if (indent > lineIndent) {\n                        collapsible = true;\n                    }\n                } else {\n                    if (indent <= lineIndent) {\n                        return {from: pos(start.line, lineText.length),\n                            to: pos(i - 1, cm.getLine(i - 1).length)};\n                    }\n                }\n\n                if (indent === lineIndent || indent < lineIndent) {\n                    return;\n                }\n            }\n        }\n        //use last nonempty line as the end of the folding region if there is no explicit end to this indent\n        if (collapsible) {\n            i = lastNonEmptyLineNumber(cm);\n            return {from: pos(start.line, lineText.length), to: pos(i, cm.getLine(i).length)};\n        }\n    }\n\n    module.exports = indentFold;\n});\n"],"file":"extension-min.js"}