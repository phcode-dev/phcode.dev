{"version":3,"sources":["extensions/default/JavaScriptRefactoring/extension-min.js"],"names":["define","require","exports","module","AppInit","brackets","getModule","PreferencesManager","Strings","RenameIdentifier","ExtractToVariable","ExtractToFunction","WrapSelection","CommandManager","Menus","Metrics","_","EditorManager","jsRefactoringEnabled","KeyboardPrefs","JSON","parse","EXTRACTTO_VARIABLE","EXTRACTTO_FUNCTION","REFACTOR_RENAME","REFACTORWRAPINTRYCATCH","REFACTORWRAPINCONDITION","REFACTORCONVERTTOARROWFN","REFACTORCREATEGETSET","_isRefactoringEnabled","get","_handleRefactor","functionName","eventName","eventType","handleRename","handleExtractToVariable","handleExtractToFunction","wrapInTryCatch","wrapInCondition","convertToArrowFunction","createGettersAndSetters","editor","getActiveEditor","getModeForSelection","countEvent","EVENT_TYPE","CODE_HINTS","definePreference","description","DESCRIPTION_CODE_REFACTORING","on","appReady","subMenu","getContextMenu","ContextMenuIds","EDITOR_MENU","addSubMenu","CMD_REFACTOR","menuLocation","AppMenuBar","EDIT_MENU","getMenu","addMenuDivider","register","CMD_REFACTORING_RENAME","partial","addMenuItem","renameIdentifier","CMD_EXTRACTTO_VARIABLE","extractToVariable","CMD_EXTRACTTO_FUNCTION","extractToFunction","CMD_REFACTORING_TRY_CATCH","CMD_REFACTORING_CONDITION","CMD_REFACTORING_ARROW_FUNCTION","CMD_REFACTORING_GETTERS_SETTERS","ASTWalker","StringUtils","Session","RefactoringUtils","InlineMenu","template","session","analyzeCode","text","scopes","srcScope","destScope","start","end","identifiers","inThisScope","thisPointerUsed","returnStatementUsed","variableDeclarations","changedValues","dependentValues","ast","getAST","doc","document","restScopeStr","full","node","value","name","type","left","id","init","variableDeclarationNode","findSurroundASTNode","kind","argument","object","originNode","getText","substr","simple","Identifier","Expression","passProps","slice","reduce","props","scope","union","keys","retProps","passParams","intersection","difference","retParams","extract","isExpression","retObj","fnBody","fnName","getUniqueIdentifierName","fnDeclaration","fnCall","appendVarDeclaration","identifier","hasOwnProperty","isClass","format","functionCall","class","join","unshift","thisPointer","shift","normal","returnStatement","single","retParamsStr","length","multiple","map","param","assignment","functionDeclaration","posFromIndex","insertPos","clone","fnScopes","filter","isFnScope","i","surroundStatement","indexFromPos","ch","batchOperation","replaceRange","adjustPosForChange","split","setSelections","indexOf","line","numLines","_codeMirror","indentLine","result","$","Deferred","getSelections","displayErrorMessageAtCursor","ERROR_EXTRACTTO_FUNCTION_MULTICURSORS","resolve","initializeSession","selection","getSelection","normalizeText","getSelectedText","expns","inlineMenu","getScopeData","done","checkStatement","getExpression","getAllScopes","EXTRACTTO_FUNCTION_SELECT_SCOPE","open","onSelect","scopeId","close","onClose","ERROR_EXTRACTTO_FUNCTION_NOT_VALID","fail","ERROR_TERN_FAILED","promise","parentStatement","insertPosition","varType","varName","varDeclaration","parentStatementStartPos","insertStartPos","selections","replaceExpnIndex","posToIndent","edits","isEqual","expression","push","edit","doMultipleEdits","primary","findAllExpressions","parentBlockStatement","expn","obj","getExpressions","s","e","findSurroundExpression","checkExpnEquality","find","parentExpn","firstExpnsScopes","insertPostion","parentScope","body","insertNode","ERROR_EXTRACTTO_VARIABLE_NOT_VALID","ERROR_EXTRACTTO_VARIABLE_MULTICURSORS","hasSelection","forEach","index","sort","a","b","firstExpnLength","callExtractToVariable","EXTRACTTO_VARIABLE_SELECT_EXPRESSION","onHover","expnId","off","isLineVisible","openRemovedMenu","setSelection","startPos","endPos","expnscope","ScopeManager","MessageIds","Editor","getRefs","fileInfo","offset","postMessage","TERN_REFS","addPendingRequest","requestFindRefs","path","file","fullPath","ternPromise","TERN_FILE_INFO_TYPE_FULL","offsetLines","filterText","getJavascriptText","HIGHLIGHT_REFS_MARKER","_handleHighLightRefs","refsResp","references","refs","operation","ref","endsWith","markText","getMarkOptionMatchingRefs","_hasASingleCursor","allowedHighlightTypes","lastHighlightToken","_cursorActivity","_evt","clearAllMarks","token","getToken","includes","getOffset","response","err","console","error","_activeEditorChanged","current","previous","Acorn","AcornLoose","templates","FUNCTION_BODY_PREFIX_LENGTH","fileText","parentExpStr","str","isStandAloneExpression","ecmaVersion","notStatement","FunctionDeclaration","ClassDeclaration","startStatement","endStatement","prefix","num","found","findNodeAt","nodeType","TERN_SCOPEDATA_MSG","resolveWith","reject","removeTrailingSemiColons","trimmedText","trimLeft","trimRight","isBlock","isCatch","surroundExpn","methodDefinitionNode","types","foundNode","findNodeAround","fullText","curScope","cnt","fnType","key","classNode","temp","prev","newScope","assignmentExpNode","varDeclaratorNode","Math","min","RefactoringSession","this","selectedText","cm","startIndex","endIndex","createAstOfCurrentDoc","prototype","lineEndPosition","lineText","getLine","replaceTextFromTemplate","args","rangeToReplace","subTemplate","templateText","compiled","formattedText","startLine","endLine","getParamsOfFunction","Function","params","item","getParentNode","isLastNodeInScope","parentNode","currentNodeStart","Property","TokenUtils","Keys","ProjectManager","keywords","MARK_TYPE_RENAME","ERROR_RENAME_MULTICURSOR","getTokenAt","string","ERROR_RENAME_GENERAL","isInSameFile","projectRoot","getProjectRoot","projectDir","fileName","_multiFileRename","_isCursorWithinMark","cursorPos","marker","pos","from","to","_outlineText","currentEditor","getMarkOptionRenameOutline","EVENT_BEFORE_SELECTION_CHANGE","EVENT_CURSOR_ACTIVITY","EVENT_KEY_DOWN","newSelections","ranges","mainCursor","getCursorPos","primaryMark","getAllMarks","setCursorPos","_editor","keyboardEvent","KEY","RETURN","ENTER","preventDefault","stopPropagation","handleFindRefs","inlineWidget","getFocusedInlineWidget","isInTextRange","_startLine","_endLine","ERROR_RENAME_QUICKEDIT","currentPosition","refsArray","primaryRef","element","requestFindReferences","errorMsg","_MARK_TYPE_RENAME","WRAP_IN_CONDITION","ARROW_FUNCTION","GETTERS_SETTERS","TRY_CATCH","initializeRefactoringSession","_wrapSelectedStatements","wrapperName","statementNode","selectionDetails","cursorLine","startCursorCh","endCursorCh","ERROR_TRY_CATCH","ERROR_WRAP_IN_CONDITION","funcExprNode","noOfStatements","dontChangeParam","numberOfParams","treatAsManyParam","splice","loc","fullFunctionScope","functionsDeclOnly","locPos","isReturnStatement","bodyStatements","statement","trim","ERROR_ARROW_FUNCTION","commaString","isLastNode","templateParams","propertyEndPos","properties","propertyNodeArray","properyNodeIndex","findIndex","propertyNode","nextPropertNode","nextPropertyStartPos","getSetPos","getName","setName","tokenName","ERROR_GETTERS_SETTERS"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\ndefine(function (require, exports, module) {\n\n\n\n    var AppInit              = brackets.getModule(\"utils/AppInit\"),\n        PreferencesManager   = brackets.getModule(\"preferences/PreferencesManager\"),\n        Strings              = brackets.getModule(\"strings\"),\n        RenameIdentifier     = require(\"RenameIdentifier\"),\n        ExtractToVariable    = require(\"ExtractToVariable\"),\n        ExtractToFunction    = require(\"ExtractToFunction\"),\n        WrapSelection        = require(\"WrapSelection\"),\n        CommandManager       = brackets.getModule(\"command/CommandManager\"),\n        Menus                = brackets.getModule(\"command/Menus\"),\n        Metrics              = brackets.getModule(\"utils/Metrics\"),\n        _                    = brackets.getModule(\"thirdparty/lodash\"),\n        EditorManager        = brackets.getModule(\"editor/EditorManager\");\n\n    require(\"HighLightReferences\");\n\n    var jsRefactoringEnabled     = true;\n\n    var KeyboardPrefs = JSON.parse(require(\"text!keyboard.json\"));\n\n    // Command ids\n    var EXTRACTTO_VARIABLE       = \"refactoring.extractToVariable\",\n        EXTRACTTO_FUNCTION       = \"refactoring.extractToFunction\",\n        REFACTOR_RENAME          = \"refactoring.renamereference\",\n        REFACTORWRAPINTRYCATCH   = \"refactoring.wrapintrycatch\",\n        REFACTORWRAPINCONDITION  = \"refactoring.wrapincondition\",\n        REFACTORCONVERTTOARROWFN = \"refactoring.converttoarrowfunction\",\n        REFACTORCREATEGETSET     = \"refactoring.creategettersandsetters\";\n\n    // This preference controls whether to create a session and process all JS files or not.\n    PreferencesManager.definePreference(\"refactoring.JSRefactoring\", \"boolean\", true, {\n        description: Strings.DESCRIPTION_CODE_REFACTORING\n    });\n\n\n    /**\n     * Check whether any of refactoring hints preferences for JS Refactoring is disabled\n     * @return {boolean} enabled/disabled\n     */\n    function _isRefactoringEnabled() {\n        return (PreferencesManager.get(\"refactoring.JSRefactoring\") !== false);\n    }\n\n    PreferencesManager.on(\"change\", \"refactoring.JSRefactoring\", function () {\n        jsRefactoringEnabled = _isRefactoringEnabled();\n    });\n\n    function _handleRefactor(functionName) {\n        var eventName, eventType = \"\";\n\n        switch (functionName) {\n        case REFACTOR_RENAME:\n            eventName = REFACTOR_RENAME;\n            eventType = \"rename\";\n            RenameIdentifier.handleRename();\n            break;\n        case EXTRACTTO_VARIABLE:\n            eventName = EXTRACTTO_VARIABLE;\n            eventType = \"extractToVariable\";\n            ExtractToVariable.handleExtractToVariable();\n            break;\n        case EXTRACTTO_FUNCTION:\n            eventName = EXTRACTTO_FUNCTION;\n            eventType = \"extractToFunction\";\n            ExtractToFunction.handleExtractToFunction();\n            break;\n        case REFACTORWRAPINTRYCATCH:\n            eventName = REFACTORWRAPINTRYCATCH;\n            eventType = \"wrapInTryCatch\";\n            WrapSelection.wrapInTryCatch();\n            break;\n        case REFACTORWRAPINCONDITION:\n            eventName = REFACTORWRAPINCONDITION;\n            eventType = \"wrapInCondition\";\n            WrapSelection.wrapInCondition();\n            break;\n        case REFACTORCONVERTTOARROWFN:\n            eventName = REFACTORCONVERTTOARROWFN;\n            eventType = \"convertToFunction\";\n            WrapSelection.convertToArrowFunction();\n            break;\n        case REFACTORCREATEGETSET:\n            eventName = REFACTORCREATEGETSET;\n            eventType = \"createGetterSetter\";\n            WrapSelection.createGettersAndSetters();\n            break;\n        }\n        if (eventName) {\n            var editor = EditorManager.getActiveEditor();\n\n            // Logging should be done only when the context is javascript\n            if (!editor || editor.getModeForSelection() !== \"javascript\") {\n                return;\n            }\n            // Send analytics data for js refactoring\n            Metrics.countEvent(\n                Metrics.EVENT_TYPE.CODE_HINTS,\n                \"jsRefactor\",\n                eventType\n            );\n        }\n    }\n\n    AppInit.appReady(function () {\n\n        if (jsRefactoringEnabled) {\n            var subMenu = Menus.getContextMenu(Menus.ContextMenuIds.EDITOR_MENU).addSubMenu(Strings.CMD_REFACTOR, \"refactor-submenu\");\n\n            var menuLocation = Menus.AppMenuBar.EDIT_MENU;\n\n            Menus.getMenu(menuLocation).addMenuDivider();\n\n            // Rename Identifier\n            CommandManager.register(Strings.CMD_REFACTORING_RENAME, REFACTOR_RENAME, _.partial(_handleRefactor, REFACTOR_RENAME));\n            subMenu.addMenuItem(REFACTOR_RENAME);\n            Menus.getMenu(menuLocation).addMenuItem(REFACTOR_RENAME, KeyboardPrefs.renameIdentifier);\n\n            // Extract to Variable\n            CommandManager.register(Strings.CMD_EXTRACTTO_VARIABLE, EXTRACTTO_VARIABLE, _.partial(_handleRefactor, EXTRACTTO_VARIABLE));\n            subMenu.addMenuItem(EXTRACTTO_VARIABLE);\n            Menus.getMenu(menuLocation).addMenuItem(EXTRACTTO_VARIABLE, KeyboardPrefs.extractToVariable);\n\n            // Extract to Function\n            CommandManager.register(Strings.CMD_EXTRACTTO_FUNCTION, EXTRACTTO_FUNCTION, _.partial(_handleRefactor, EXTRACTTO_FUNCTION));\n            subMenu.addMenuItem(EXTRACTTO_FUNCTION);\n            Menus.getMenu(menuLocation).addMenuItem(EXTRACTTO_FUNCTION, KeyboardPrefs.extractToFunction);\n\n            // Wrap Selection\n            CommandManager.register(Strings.CMD_REFACTORING_TRY_CATCH, REFACTORWRAPINTRYCATCH, _.partial(_handleRefactor, REFACTORWRAPINTRYCATCH));\n            subMenu.addMenuItem(REFACTORWRAPINTRYCATCH);\n            Menus.getMenu(menuLocation).addMenuItem(REFACTORWRAPINTRYCATCH);\n\n            CommandManager.register(Strings.CMD_REFACTORING_CONDITION, REFACTORWRAPINCONDITION, _.partial(_handleRefactor, REFACTORWRAPINCONDITION));\n            subMenu.addMenuItem(REFACTORWRAPINCONDITION);\n            Menus.getMenu(menuLocation).addMenuItem(REFACTORWRAPINCONDITION);\n\n            CommandManager.register(Strings.CMD_REFACTORING_ARROW_FUNCTION, REFACTORCONVERTTOARROWFN, _.partial(_handleRefactor, REFACTORCONVERTTOARROWFN));\n            subMenu.addMenuItem(REFACTORCONVERTTOARROWFN);\n            Menus.getMenu(menuLocation).addMenuItem(REFACTORCONVERTTOARROWFN);\n\n            CommandManager.register(Strings.CMD_REFACTORING_GETTERS_SETTERS, REFACTORCREATEGETSET, _.partial(_handleRefactor, REFACTORCREATEGETSET));\n            subMenu.addMenuItem(REFACTORCREATEGETSET);\n            Menus.getMenu(menuLocation).addMenuItem(REFACTORCREATEGETSET);\n        }\n    });\n});\n\n/*\n*  Copyright (c) 2021 - present core.ai . All rights reserved.\n *  Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n*\n* Permission is hereby granted, free of charge, to any person obtaining a\n* copy of this software and associated documentation files (the \"Software\"),\n* to deal in the Software without restriction, including without limitation\n* the rights to use, copy, modify, merge, publish, distribute, sublicense,\n* and/or sell copies of the Software, and to permit persons to whom the\n* Software is furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in\n* all copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n* DEALINGS IN THE SOFTWARE.\n*\n*/\n\ndefine(\"ExtractToFunction\", function(require, exports, module) {\n\n\n    var ASTWalker           = brackets.getModule(\"thirdparty/acorn/dist/walk\"),\n        EditorManager       = brackets.getModule(\"editor/EditorManager\"),\n        _                   = brackets.getModule(\"thirdparty/lodash\"),\n        StringUtils         = brackets.getModule(\"utils/StringUtils\"),\n        Session             = brackets.getModule(\"JSUtils/Session\"),\n        RefactoringUtils    = require(\"RefactoringUtils\"),\n        Strings             = brackets.getModule(\"strings\"),\n        InlineMenu          = brackets.getModule(\"widgets/InlineMenu\").InlineMenu;\n\n    var template = JSON.parse(require(\"text!Templates.json\"));\n\n    var session = null;\n\n    /**\n     * Analyzes the code and finds values required for extract to function\n     * @param {!string} text - text to be extracted\n     * @param {!Array.<Scope>} - scopes\n     * @param {!Scope} srcScope - source scope of the extraction\n     * @param {!Scope} destScope - destination scope of the extraction\n     * @param {!number} start - the start offset\n     * @param {!number} end - the end offset\n     * @return {!{\n     *          passParams: Array.<string>,\n     *          retParams: Array.<string>,\n     *          thisPointerUsed: boolean,\n     *          varaibleDeclarations: {} // variable-name: kind\n     * }}\n     */\n    function analyzeCode(text, scopes, srcScope, destScope, start, end) {\n        var identifiers          = {},\n            inThisScope          = {},\n            thisPointerUsed      = false,\n            returnStatementUsed  = false,\n            variableDeclarations = {},\n            changedValues        = {},\n            dependentValues      = {},\n            ast                  = RefactoringUtils.getAST(text),\n            doc                  = session.editor.document,\n            restScopeStr;\n\n        ASTWalker.full(ast, function(node) {\n            var value, name;\n            switch (node.type) {\n            case \"AssignmentExpression\":\n                value = node.left;\n                break;\n            case \"VariableDeclarator\":\n                inThisScope[node.id.name] = true;\n                value = node.init && node.id;\n                var variableDeclarationNode = RefactoringUtils.findSurroundASTNode(ast, node, [\"VariableDeclaration\"]);\n                variableDeclarations[node.id.name] = variableDeclarationNode.kind;\n                break;\n            case \"ThisExpression\":\n                thisPointerUsed = true;\n                break;\n            case \"UpdateExpression\":\n                value = node.argument;\n                break;\n            case \"Identifier\":\n                identifiers[node.name] = true;\n                break;\n            case \"ReturnStatement\":\n                returnStatementUsed = true;\n                break;\n            }\n            if (value){\n                if (value.type === \"MemberExpression\") {\n                    name = value.object.name;\n                } else {\n                    name = value.name;\n                }\n                changedValues[name] = true;\n            }\n        });\n\n        if (srcScope.originNode) {\n            restScopeStr = doc.getText().substr(end, srcScope.originNode.end - end);\n        } else {\n            restScopeStr = doc.getText().substr(end);\n        }\n\n        ASTWalker.simple(RefactoringUtils.getAST(restScopeStr), {\n            Identifier: function(node) {\n                var name = node.name;\n                dependentValues[name] = true;\n            },\n            Expression: function(node) {\n                if (node.type === \"MemberExpression\") {\n                    var name = node.object.name;\n                    dependentValues[name] = true;\n                }\n            }\n        });\n\n        var passProps = scopes.slice(srcScope.id, destScope.id).reduce(function(props, scope) {\n            return _.union(props, _.keys(scope.props));\n        }, []);\n\n        var retProps = scopes.slice(srcScope.id, destScope.id + 1).reduce(function(props, scope) {\n            return _.union(props, _.keys(scope.props));\n        }, []);\n\n        return {\n            passParams: _.intersection(_.difference(_.keys(identifiers), _.keys(inThisScope)), passProps),\n            retParams: _.intersection( _.keys(changedValues), _.keys(dependentValues), retProps),\n            thisPointerUsed: thisPointerUsed,\n            returnStatementUsed: returnStatementUsed,\n            variableDeclarations: variableDeclarations\n        };\n    }\n\n    /**\n     * Does the actual extraction. i.e Replacing the text, Creating a function\n     * and multi select function names\n     */\n    function extract(ast, text, scopes, srcScope, destScope, start, end, isExpression) {\n        var retObj               = analyzeCode(text, scopes, srcScope, destScope, start, end),\n            passParams           = retObj.passParams,\n            retParams            = retObj.retParams,\n            thisPointerUsed      = retObj.thisPointerUsed,\n            returnStatementUsed  = retObj.returnStatementUsed,\n            variableDeclarations = retObj.variableDeclarations,\n            doc                  = session.editor.document,\n            fnBody               = text,\n            fnName               = RefactoringUtils.getUniqueIdentifierName(scopes, \"extracted\"),\n            fnDeclaration,\n            fnCall;\n\n        function appendVarDeclaration(identifier) {\n            if (variableDeclarations.hasOwnProperty(identifier)) {\n                return variableDeclarations[identifier] + \" \" + identifier;\n            }\n\n            return identifier;\n\n        }\n\n        if (destScope.isClass) {\n            fnCall = StringUtils.format(template.functionCall.class, fnName, passParams.join(\", \"));\n        } else if (thisPointerUsed) {\n            passParams.unshift(\"this\");\n            fnCall = StringUtils.format(template.functionCall.thisPointer, fnName, passParams.join(\", \"));\n            passParams.shift();\n        } else {\n            fnCall = StringUtils.format(template.functionCall.normal, fnName, passParams.join(\", \"));\n        }\n\n        // Append return to the fnCall, if the extracted text contains return statement\n        // Ideally in this case retParams should be empty.\n        if (returnStatementUsed) {\n            fnCall = \"return \" + fnCall;\n        }\n\n        if (isExpression) {\n            fnBody = StringUtils.format(template.returnStatement.single, fnBody);\n        } else {\n\n            var retParamsStr = \"\";\n            if (retParams.length > 1) {\n                retParamsStr = StringUtils.format(template.returnStatement.multiple, retParams.join(\", \"));\n                fnCall = \"var ret = \" + fnCall + \";\\n\";\n                fnCall += retParams.map(function (param) {\n                    return StringUtils.format(template.assignment, appendVarDeclaration(param),  \"ret.\" + param);\n                }).join(\"\\n\");\n            } else if (retParams.length === 1) {\n                retParamsStr = StringUtils.format(template.returnStatement.single, retParams.join(\", \"));\n                fnCall = StringUtils.format(template.assignment, appendVarDeclaration(retParams[0]), fnCall);\n            } else {\n                fnCall += \";\";\n            }\n\n            fnBody = fnBody + \"\\n\" + retParamsStr;\n        }\n\n        if (destScope.isClass) {\n            fnDeclaration = StringUtils.format(template.functionDeclaration.class, fnName, passParams.join(\", \"), fnBody);\n        } else {\n            fnDeclaration = StringUtils.format(template.functionDeclaration.normal, fnName, passParams.join(\", \"), fnBody);\n        }\n\n        start = session.editor.posFromIndex(start);\n        end   = session.editor.posFromIndex(end);\n\n        // Get the insertion pos for function declaration\n        var insertPos = _.clone(start);\n        var fnScopes = scopes.filter(RefactoringUtils.isFnScope);\n\n        for (var i = 0; i < fnScopes.length; ++i) {\n            if (fnScopes[i].id === destScope.id) {\n                if (fnScopes[i - 1]) {\n                    insertPos = session.editor.posFromIndex(fnScopes[i - 1].originNode.start);\n                     // If the origin node of the destination scope is a function expression or a arrow function expression,\n                     // get the surrounding statement to get the position\n                    if (fnScopes[i - 1].originNode.type === \"FunctionExpression\" || fnScopes[i - 1].originNode.type === \"ArrowFunctionExpression\") {\n                        var surroundStatement = RefactoringUtils.findSurroundASTNode(ast, { start: session.editor.indexFromPos(insertPos)}, [\"Statement\"]);\n                        insertPos = session.editor.posFromIndex(surroundStatement.start);\n                    }\n                }\n                break;\n            }\n        }\n\n        insertPos.ch = 0;\n\n        // Replace and multi-select and indent\n        doc.batchOperation(function() {\n            // Replace\n            doc.replaceRange(fnCall, start, end);\n            doc.replaceRange(fnDeclaration, insertPos);\n\n            // Set selections\n            start = doc.adjustPosForChange(start, fnDeclaration.split(\"\\n\"), insertPos, insertPos);\n            end   = doc.adjustPosForChange(end, fnDeclaration.split(\"\\n\"), insertPos, insertPos);\n\n            session.editor.setSelections([\n                {\n                    start: session.editor.posFromIndex(session.editor.indexFromPos(start) + fnCall.indexOf(fnName)),\n                    end: session.editor.posFromIndex(session.editor.indexFromPos(start) + fnCall.indexOf(fnName) + fnName.length)\n                },\n                {\n                    start: session.editor.posFromIndex(session.editor.indexFromPos(insertPos) + fnDeclaration.indexOf(fnName)),\n                    end: session.editor.posFromIndex(session.editor.indexFromPos(insertPos) + fnDeclaration.indexOf(fnName) + fnName.length)\n                }\n            ]);\n\n            // indent\n            for (var i = start.line; i < start.line + RefactoringUtils.numLines(fnCall); ++i) {\n                session.editor._codeMirror.indentLine(i, \"smart\");\n            }\n            for (var i = insertPos.line; i < insertPos.line + RefactoringUtils.numLines(fnDeclaration); ++i) {\n                session.editor._codeMirror.indentLine(i, \"smart\");\n            }\n        });\n    }\n\n    /**\n     * Main function that handles extract to function\n     */\n    function handleExtractToFunction() {\n        var editor = EditorManager.getActiveEditor();\n        var result = new $.Deferred(); // used only for testing purpose\n\n        if (editor.getSelections().length > 1) {\n            editor.displayErrorMessageAtCursor(Strings.ERROR_EXTRACTTO_FUNCTION_MULTICURSORS);\n            result.resolve(Strings.ERROR_EXTRACTTO_FUNCTION_MULTICURSORS);\n            return;\n        }\n        initializeSession(editor);\n\n        var selection = editor.getSelection(),\n            doc       = editor.document,\n            retObj    = RefactoringUtils.normalizeText(editor.getSelectedText(), editor.indexFromPos(selection.start), editor.indexFromPos(selection.end)),\n            text      = retObj.text,\n            start     = retObj.start,\n            end       = retObj.end,\n            ast,\n            scopes,\n            expns,\n            inlineMenu;\n\n        RefactoringUtils.getScopeData(session, editor.posFromIndex(start)).done(function(scope) {\n            ast = RefactoringUtils.getAST(doc.getText());\n\n            var isExpression = false;\n            if (!RefactoringUtils.checkStatement(ast, start, end, doc.getText())) {\n                isExpression = RefactoringUtils.getExpression(ast, start, end, doc.getText());\n                if (!isExpression) {\n                    editor.displayErrorMessageAtCursor(Strings.ERROR_EXTRACTTO_FUNCTION_NOT_VALID);\n                    result.resolve(Strings.ERROR_EXTRACTTO_FUNCTION_NOT_VALID);\n                    return;\n                }\n            }\n            scopes = RefactoringUtils.getAllScopes(ast, scope, doc.getText());\n\n            // if only one scope, extract without menu\n            if (scopes.length === 1) {\n                extract(ast, text, scopes, scopes[0], scopes[0], start, end, isExpression);\n                result.resolve();\n                return;\n            }\n\n            inlineMenu = new InlineMenu(editor, Strings.EXTRACTTO_FUNCTION_SELECT_SCOPE);\n\n            inlineMenu.open(scopes.filter(RefactoringUtils.isFnScope));\n\n            result.resolve(inlineMenu);\n\n            inlineMenu.onSelect(function (scopeId) {\n                extract(ast, text, scopes, scopes[0], scopes[scopeId], start, end, isExpression);\n                inlineMenu.close();\n            });\n\n            inlineMenu.onClose(function(){\n                inlineMenu.close();\n            });\n        }).fail(function() {\n            editor.displayErrorMessageAtCursor(Strings.ERROR_TERN_FAILED);\n            result.resolve(Strings.ERROR_TERN_FAILED);\n        });\n\n        return result.promise();\n    }\n\n    /**\n     * Creates a new session from editor and stores it in session global variable\n     */\n    function initializeSession(editor) {\n        session = new Session(editor);\n    }\n\n    exports.handleExtractToFunction = handleExtractToFunction;\n});\n\n/*\n*  Copyright (c) 2021 - present core.ai . All rights reserved.\n *  Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n*\n* Permission is hereby granted, free of charge, to any person obtaining a\n* copy of this software and associated documentation files (the \"Software\"),\n* to deal in the Software without restriction, including without limitation\n* the rights to use, copy, modify, merge, publish, distribute, sublicense,\n* and/or sell copies of the Software, and to permit persons to whom the\n* Software is furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in\n* all copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n* DEALINGS IN THE SOFTWARE.\n*\n*/\n\ndefine(\"ExtractToVariable\", function(require, exports, module) {\n\n\n    var ASTWalker           = brackets.getModule(\"thirdparty/acorn/dist/walk\"),\n        EditorManager       = brackets.getModule(\"editor/EditorManager\"),\n        Session             = brackets.getModule(\"JSUtils/Session\"),\n        RefactoringUtils    = require(\"RefactoringUtils\"),\n        Strings             = brackets.getModule(\"strings\"),\n        InlineMenu          = brackets.getModule(\"widgets/InlineMenu\").InlineMenu;\n\n    var session = null;\n\n    /**\n     * Does the actual extraction. i.e Replacing the text, Creating a variable\n     * and multi select variable names\n     */\n    function extract(scopes, parentStatement, expns, text, insertPosition) {\n        var varType          = \"var\",\n            varName          = RefactoringUtils.getUniqueIdentifierName(scopes, \"extracted\"),\n            varDeclaration   = varType + \" \" + varName + \" = \" + text + \";\\n\",\n            parentStatementStartPos = session.editor.posFromIndex(parentStatement.start),\n            insertStartPos   = insertPosition || parentStatementStartPos,\n            selections       = [],\n            doc              = session.editor.document,\n            replaceExpnIndex = 0,\n            posToIndent,\n            edits            = [];\n\n        // If parent statement is expression statement, then just append var declaration\n        // Ex: \"add(1, 2)\" will become \"var extracted = add(1, 2)\"\n        if (parentStatement.type === \"ExpressionStatement\" &&\n                RefactoringUtils.isEqual(parentStatement.expression, expns[0]) &&\n                insertStartPos.line === parentStatementStartPos.line &&\n                insertStartPos.ch === parentStatementStartPos.ch) {\n            varDeclaration = varType + \" \" + varName + \" = \";\n            replaceExpnIndex = 1;\n        }\n\n        posToIndent = doc.adjustPosForChange(insertStartPos, varDeclaration.split(\"\\n\"), insertStartPos, insertStartPos);\n\n        // adjust pos for change\n        for (var i = replaceExpnIndex; i < expns.length; ++i) {\n            expns[i].start  = session.editor.posFromIndex(expns[i].start);\n            expns[i].end    = session.editor.posFromIndex(expns[i].end);\n            expns[i].start  = doc.adjustPosForChange(expns[i].start, varDeclaration.split(\"\\n\"), insertStartPos, insertStartPos);\n            expns[i].end    = doc.adjustPosForChange(expns[i].end, varDeclaration.split(\"\\n\"), insertStartPos, insertStartPos);\n\n            edits.push({\n                edit: {\n                    text: varName,\n                    start: expns[i].start,\n                    end: expns[i].end\n                },\n                selection: {\n                    start: expns[i].start,\n                    end: {line: expns[i].start.line, ch: expns[i].start.ch + varName.length}\n                }\n            });\n        }\n\n        // Replace and multi-select\n        doc.batchOperation(function() {\n            doc.replaceRange(varDeclaration, insertStartPos);\n\n            selections = doc.doMultipleEdits(edits);\n            selections.push({\n                start: {line: insertStartPos.line, ch: insertStartPos.ch + varType.length + 1},\n                end: {line: insertStartPos.line, ch: insertStartPos.ch + varType.length + varName.length + 1},\n                primary: true\n            });\n            session.editor.setSelections(selections);\n            session.editor._codeMirror.indentLine(posToIndent.line, \"smart\");\n        });\n    }\n\n    /**\n     * Find all expressions in the parentBlockStatement that are same as expn\n     * @param {!ASTNode} parentBlockStatement\n     * @param {!ASTNode} expn\n     * @param {!string} text - text of the expression\n     * @return {!Array.<ASTNode>}\n     */\n    function findAllExpressions(parentBlockStatement, expn, text) {\n        var doc   = session.editor.document,\n            obj   = {},\n            expns = [];\n\n        // find all references of the expression\n        obj[expn.type] = function(node) {\n            if (text === doc.getText().substr(node.start, node.end - node.start)) {\n                expns.push(node);\n            }\n        };\n        ASTWalker.simple(parentBlockStatement, obj);\n\n        return expns;\n    }\n\n    /**\n     * Gets the surrounding expressions of start and end offset\n     * @param {!ASTNode} ast - the ast of the complete file\n     * @param {!number} start - the start offset\n     * @param {!number} end - the end offset\n     * @return {!Array.<ASTNode>}\n     */\n    function getExpressions(ast, start, end) {\n        var expns = [],\n            s     = start,\n            e     = end,\n            expn;\n\n        while (true) {\n            expn = RefactoringUtils.findSurroundExpression(ast, {start: s, end: e});\n            if (!expn) {\n                break;\n            }\n            expns.push(expn);\n            s = expn.start - 1;\n        }\n\n        s = start;\n        e = end;\n\n        function checkExpnEquality(e) {\n            return e.start === expn.start && e.end === expn.end;\n        }\n\n        while (true) {\n            expn = RefactoringUtils.findSurroundExpression(ast, {start: s, end: e});\n            if (!expn) {\n                break;\n            }\n            e = expn.end + 1;\n\n            // if expn already added, continue\n            if (expns.find(checkExpnEquality)) {\n                continue;\n            }\n\n            expns.push(expn);\n        }\n\n        return expns;\n    }\n\n    /**\n     * Creates params needed for extraction and calls extract\n     * extract() does the actual extraction\n     */\n    function extractToVariable(ast, start, end, text, scopes) {\n        var doc                   = session.editor.document,\n            editor = EditorManager.getActiveEditor(),\n            parentExpn            = RefactoringUtils.getExpression(ast, start, end, doc.getText()),\n            expns                 = [],\n            parentBlockStatement,\n            parentStatement;\n\n        if (!parentExpn) {\n            session.editor.displayErrorMessageAtCursor(Strings.ERROR_EXTRACTTO_VARIABLE_NOT_VALID);\n            return;\n        }\n\n        // Find all expressions only if selected expn is not a subexpression\n        // In case of subexpressions, ast cannot be used to find all expressions\n        if (doc.getText().substr(parentExpn.start, parentExpn.end - parentExpn.start) === text) {\n            parentBlockStatement = RefactoringUtils.findSurroundASTNode(ast, parentExpn, [\"BlockStatement\", \"Program\"]);\n            expns                = findAllExpressions(parentBlockStatement, parentExpn, text);\n\n            RefactoringUtils.getScopeData(session, editor.posFromIndex(expns[0].start)).done(function(scope) {\n                var firstExpnsScopes = RefactoringUtils.getAllScopes(ast, scope, doc.getText()),\n                    insertPostion;\n                parentStatement = RefactoringUtils.findSurroundASTNode(ast, expns[0], [\"Statement\"]);\n                if (scopes.length < firstExpnsScopes.length) {\n                    var parentScope;\n                    if (expns[0].body && expns[0].body.type === \"BlockStatement\") {\n                        parentScope = firstExpnsScopes[firstExpnsScopes.length - scopes.length];\n                    } else {\n                        parentScope = firstExpnsScopes[firstExpnsScopes.length - scopes.length - 1];\n                    }\n\n                    var insertNode = RefactoringUtils.findSurroundASTNode(ast, parentScope.originNode, [\"Statement\"]);\n                    if (insertNode) {\n                        insertPostion = session.editor.posFromIndex(insertNode.start);\n                    }\n                }\n                extract(scopes, parentStatement, expns, text, insertPostion);\n            });\n        } else {\n            parentStatement = RefactoringUtils.findSurroundASTNode(ast, parentExpn, [\"Statement\"]);\n            extract(scopes, parentStatement, [{ start: start, end: end }], text);\n        }\n    }\n\n\n    /**\n     * Main function that handles extract to variable\n     */\n    function handleExtractToVariable() {\n        var editor = EditorManager.getActiveEditor();\n\n        if (editor.getSelections().length > 1) {\n            editor.displayErrorMessageAtCursor(Strings.ERROR_EXTRACTTO_VARIABLE_MULTICURSORS);\n            return;\n        }\n\n        initializeSession(editor);\n\n        var selection = editor.getSelection(),\n            doc       = editor.document,\n            retObj    = RefactoringUtils.normalizeText(editor.getSelectedText(), editor.indexFromPos(selection.start),\n                        editor.indexFromPos(selection.end), true),\n            text      = retObj.text,\n            start     = retObj.start,\n            end       = retObj.end,\n            ast,\n            scopes,\n            expns,\n            inlineMenu;\n\n        function callExtractToVariable(startPos, endPos, value) {\n            RefactoringUtils.getScopeData(session, editor.posFromIndex(startPos))\n                .done(function(expnscope) {\n                    scopes = RefactoringUtils.getAllScopes(ast, expnscope, doc.getText());\n                    extractToVariable(ast, startPos, endPos, value, scopes);\n                }).fail(function() {\n                    editor.displayErrorMessageAtCursor(Strings.ERROR_TERN_FAILED);\n                });\n        }\n\n        RefactoringUtils.getScopeData(session, editor.posFromIndex(start)).done(function(scope) {\n            ast = RefactoringUtils.getAST(doc.getText());\n            scopes = RefactoringUtils.getAllScopes(ast, scope, doc.getText());\n\n            if (editor.hasSelection()) {\n                extractToVariable(ast, start, end, text, scopes);\n            } else {\n                expns = getExpressions(ast, start, end);\n\n                expns.forEach(function(expn, index) {\n                    expn.value = doc.getText().substr(expn.start, expn.end - expn.start);\n                });\n\n                // Sort expressions by their length\n                expns.sort(function(a, b) {\n                    return a.value.length - b.value.length;\n                });\n\n                if (!expns || !expns.length) {\n                    session.editor.displayErrorMessageAtCursor(Strings.ERROR_EXTRACTTO_VARIABLE_NOT_VALID);\n                    return;\n                }\n\n                // Filter expns based on length of first surrounding expression\n                var firstExpnLength = RefactoringUtils.numLines(expns[0].value);\n                expns = expns.filter(function(expn) {\n                    return RefactoringUtils.numLines(expn.value) === firstExpnLength;\n                });\n\n                // Add name for the expression based on its value\n                expns.forEach(function(expn, index) {\n                    // If expn name is multi-line, display only first line\n                    if (RefactoringUtils.numLines(expn.value) > 1) {\n                        expn.name = expn.value.substr(0, expn.value.indexOf(\"\\n\")) + \"...\";\n                    } else {\n                        expn.name = expn.value;\n                    }\n                });\n\n                // If only one surround expression, extract\n                if (expns.length === 1) {\n                    callExtractToVariable(expns[0].start, expns[0].end, expns[0].value);\n                    return;\n                }\n\n                expns.forEach(function(expn, index) {\n                    expn.id = index;\n                });\n\n                // UI for extract to variable\n                inlineMenu = new InlineMenu(session.editor, Strings.EXTRACTTO_VARIABLE_SELECT_EXPRESSION);\n\n                inlineMenu.onHover(function (expnId) {\n                    // Remove the scroll Handlers If already Attached.\n                    editor.off(\"scroll.inlinemenu\");\n                    // Add a scroll handler If Selection Range is not View.\n                    // This is Added for a Bug, where Menu used not to open for the first Time\n                    if(!editor.isLineVisible(editor.posFromIndex(expns[expnId].end).line)) {\n                        editor.on(\"scroll.inlinemenu\", function() {\n                            // Remove the Handlers so that If scroll event is triggerd again by any other operation\n                            // Menu should not be reopened.\n                            // Menu Should be reopened only if Scroll event is triggered by onHover.\n                            editor.off(\"scroll.inlinemenu\");\n                            inlineMenu.openRemovedMenu();\n                        });\n                    }\n                    editor.setSelection(editor.posFromIndex(expns[expnId].start), editor.posFromIndex(expns[expnId].end));\n                });\n\n                inlineMenu.open(expns);\n\n                inlineMenu.onSelect(function (expnId) {\n                    callExtractToVariable(expns[expnId].start, expns[expnId].end, expns[expnId].value);\n                    inlineMenu.close();\n                });\n\n                inlineMenu.onClose(function () {\n                    inlineMenu.close();\n                });\n            }\n        }).fail(function() {\n            editor.displayErrorMessageAtCursor(Strings.ERROR_TERN_FAILED);\n        });\n    }\n\n    /**\n     * Creates a new session from editor and stores it in session global variable\n     */\n    function initializeSession(editor) {\n        session = new Session(editor);\n    }\n\n    exports.handleExtractToVariable = handleExtractToVariable;\n});\n\n/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\ndefine(\"HighLightReferences\", function (require, exports, module) {\n\n\n    let EditorManager        = brackets.getModule(\"editor/EditorManager\"),\n        ScopeManager         = brackets.getModule(\"JSUtils/ScopeManager\"),\n        Session              = brackets.getModule(\"JSUtils/Session\"),\n        MessageIds           = JSON.parse(brackets.getModule(\"text!JSUtils/MessageIds.json\")),\n        Editor               = brackets.getModule(\"editor/Editor\").Editor;\n\n    let session             = null;\n\n    //Create new session\n    function initializeSession(editor) {\n        session = new Session(editor);\n    }\n\n    //Post message to tern node domain that will request tern server to find refs\n    function getRefs(fileInfo, offset) {\n        ScopeManager.postMessage({\n            type: MessageIds.TERN_REFS,\n            fileInfo: fileInfo,\n            offset: offset\n        });\n\n        return ScopeManager.addPendingRequest(fileInfo.name, offset, MessageIds.TERN_REFS);\n    }\n\n    //Create info required to find reference\n    function requestFindRefs(session, document, offset) {\n        if (!document || !session) {\n            return;\n        }\n        let path    = document.file.fullPath,\n            fileInfo = {\n                type: MessageIds.TERN_FILE_INFO_TYPE_FULL,\n                name: path,\n                offsetLines: 0,\n                text: ScopeManager.filterText(session.getJavascriptText())\n            };\n        let ternPromise = getRefs(fileInfo, offset);\n\n        return {promise: ternPromise};\n    }\n\n    // This is the highlight references under cursor feature. We should ideally move this to\n    // features/findReferencesManager\n\n    const HIGHLIGHT_REFS_MARKER = \"JS_REFS\";\n\n    function _handleHighLightRefs(editor, refsResp) {\n        if (!refsResp || !refsResp.references || !refsResp.references.refs) {\n            return;\n        }\n        editor.operation(function () {\n            for(let ref of refsResp.references.refs){\n                if(editor.document.file.fullPath.endsWith(ref.file)){\n                    editor.markText(HIGHLIGHT_REFS_MARKER, ref.start, ref.end, Editor.getMarkOptionMatchingRefs());\n                }\n            }\n        });\n    }\n\n    function _hasASingleCursor(editor) {\n        let selections = editor.getSelections();\n        if(selections.length > 1){\n            // multi cursor, no highlight\n            return false;\n        }\n        let start = selections[0].start,\n            end = selections[0].end;\n        if(start.line !== end.line || start.ch !== end.ch){\n            // has a range selection\n            return false;\n        }\n        return true;\n    }\n\n    let allowedHighlightTypes = [\"def\", \"variable\", \"variable-2\", \"variable-3\", \"property\"];\n    let lastHighlightToken = {};\n    function _cursorActivity(_evt, editor) {\n        // Only provide a JavaScript editor when cursor is in JavaScript content\n        if (editor.getModeForSelection() !== \"javascript\") {\n            return;\n        }\n\n        if(!_hasASingleCursor(editor)){\n            editor.clearAllMarks(HIGHLIGHT_REFS_MARKER);\n            return;\n        }\n\n        let token = editor.getToken();\n        if(lastHighlightToken === token) {\n            return;\n        }\n\n        editor.clearAllMarks(HIGHLIGHT_REFS_MARKER);\n        lastHighlightToken = token;\n        if(!allowedHighlightTypes.includes(token.type)){\n            return;\n        }\n\n        let offset = session.getOffset();\n\n        // only do this request if token under cursor is a variable type\n        requestFindRefs(session, session.editor.document, offset).promise\n            .done(response =>{\n                _handleHighLightRefs(editor, response);\n            })\n            .fail(function (err) {\n                console.error(\"find references failed with: \", err);\n            });\n    }\n\n    function _activeEditorChanged(_evt,  current, previous) {\n        if(previous){\n            previous.off(\"cursorActivity.highlightRefs\");\n        }\n        if(current){\n            current.off(\"cursorActivity.highlightRefs\");\n            current.on(\"cursorActivity.highlightRefs\", _cursorActivity);\n            initializeSession(current);\n            _cursorActivity(_evt, current);\n        }\n    }\n\n    EditorManager.on(\"activeEditorChange\", _activeEditorChanged);\n\n    exports.HIGHLIGHT_REFS_MARKER = HIGHLIGHT_REFS_MARKER;\n});\n\n/*\n*  Copyright (c) 2021 - present core.ai . All rights reserved.\n *  Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n*\n* Permission is hereby granted, free of charge, to any person obtaining a\n* copy of this software and associated documentation files (the \"Software\"),\n* to deal in the Software without restriction, including without limitation\n* the rights to use, copy, modify, merge, publish, distribute, sublicense,\n* and/or sell copies of the Software, and to permit persons to whom the\n* Software is furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in\n* all copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n* DEALINGS IN THE SOFTWARE.\n*\n*/\n\n/*\n * Utilities functions related to refactoring\n */\ndefine(\"RefactoringUtils\", function (require, exports, module) {\n\n\n    var Acorn         = brackets.getModule(\"thirdparty/acorn/dist/acorn\"),\n        ASTWalker     = brackets.getModule(\"thirdparty/acorn/dist/walk\"),\n        MessageIds    = JSON.parse(brackets.getModule(\"text!JSUtils/MessageIds.json\")),\n        _             = brackets.getModule(\"thirdparty/lodash\"),\n        AcornLoose    = brackets.getModule(\"thirdparty/acorn/dist/acorn_loose\"),\n        ScopeManager  = brackets.getModule(\"JSUtils/ScopeManager\");\n\n\n    var templates = JSON.parse(require(\"text!Templates.json\"));\n\n\n\n    // Length of the function body used as function name for nameless functions\n    var FUNCTION_BODY_PREFIX_LENGTH = 30;\n\n    /**\n     * Checks whether two ast nodes are equal\n     * @param {!ASTNode} a\n     * @param {!ASTNode} b\n     * @return {boolean}\n     */\n    function isEqual(a, b) {\n        return a.start === b.start && a.end === b.end;\n    }\n\n    /**\n     * Gets a expression surrounding start and end (if any)\n     * @param {!ASTNode} ast - the ast of the complete file\n     * @param {!number} start - the start offset\n     * @param {!number} end - the end offset\n     * @param {!string} fileText - the entire file text\n     * @return {ASTNode|boolean}\n     */\n    function getExpression(ast, start, end, fileText) {\n        var expn = findSurroundExpression(ast, {start: start, end: end});\n        if (!expn) {\n            return false;\n        }\n\n        // Class Expression also includes the trailing semicolon\n        // Add special case for it\n        if (expn.type === \"ClassExpression\" && expn.start === start && expn.end - end <= 1) {\n            expn.end = end;\n            return expn;\n        }        else if (expn.start === start && expn.end === end) {\n            return expn;\n        }\n\n        // Subexpressions are possible only for BinaryExpression, LogicalExpression and SequenceExpression\n        if (!([\"BinaryExpression\", \"LogicalExpression\", \"SequenceExpression\"].includes(expn.type))) {\n            return false;\n        }\n\n        // Check subexpression\n        var parentExpn = expn;\n        var parentExpStr = fileText.substr(parentExpn.start, parentExpn.end - parentExpn.start);\n\n        // Check whether the parentExpn forms a valid expression after replacing the sub expression\n        var str = parentExpStr.substr(0, start - parentExpn.start) + \"placeHolder\" + parentExpStr.substr(end - parentExpn.start);\n        var node = isStandAloneExpression(str);\n        if (node && node.type === parentExpn.type) {\n            return parentExpn;\n        }\n\n        return false;\n    }\n\n    function getAST(text) {\n        var ast;\n        try {\n            ast = Acorn.parse(text, {ecmaVersion: 9});\n        } catch(e) {\n            ast = AcornLoose.parse(text, {ecmaVersion: 9});\n        }\n        return ast;\n    }\n\n    /*\n     * Checks whether the text between start and end offsets form a valid set of statements\n     * @param {!ASTNode} ast - the ast of the complete file\n     * @param {!number} start - the start offset\n     * @param {!number} end - the end offset\n     * @param {!string} fileText - the entire file text\n     * @return {boolean}\n     */\n    function checkStatement(ast, start, end, fileText) {\n        // Do not allow function or class nodes\n        var notStatement = false;\n        ASTWalker.simple(getAST(fileText.substr(start, end - start)), {\n            FunctionDeclaration: function (node) {\n                notStatement = true;\n            },\n            ClassDeclaration: function (node) {\n                notStatement = true;\n            }\n        });\n\n        if (notStatement) {\n            return false;\n        }\n\n        var startStatement = findSurroundASTNode(ast, {start: start}, [\"Statement\"]);\n        var endStatement   = findSurroundASTNode(ast, {start: end}, [\"Statement\"]);\n\n        return startStatement && endStatement && startStatement.start === start &&\n            startStatement.end <= end && endStatement.start >= start &&\n            endStatement.end === end;\n    }\n\n    /**\n     * Gets a unique identifier name in the scope that starts with prefix\n     * @param {!Scope} scopes - an array of all scopes returned from tern (each element contains 'props' with identifiers\n     *  in that scope)\n     * @param {!string} prefix - prefix of the identifier\n     * @param {number} num - number to start checking for\n     * @return {!string} identifier name\n     */\n    function getUniqueIdentifierName(scopes, prefix, num) {\n        if (!scopes) {\n            return prefix;\n        }\n\n        var props = scopes.reduce(function(props, scope) {\n            return _.union(props, _.keys(scope.props));\n        }, []);\n\n        if (!props) {\n            return prefix;\n        }\n\n        num = num || \"1\";\n        var name;\n        while (num < 100) { // limit search length\n            name = prefix + num;\n            if (props.indexOf(name) === -1) {\n                break;\n            }\n            ++num;\n        }\n        return name;\n    }\n\n    /**\n     * Returns the no of lines in the text\n     * @param {!string} text\n     * @return {number}\n     */\n    function numLines(text) {\n        return text.split(\"\\n\").length;\n    }\n\n    /**\n     * Checks whether the text forms a stand alone expression without considering the context of text\n     * @param {!string} text\n     * @return {boolean}\n     */\n    function isStandAloneExpression(text) {\n        var found = ASTWalker.findNodeAt(getAST(text), 0, text.length, function (nodeType, node) {\n            if (nodeType === \"Expression\") {\n                return true;\n            }\n            return false;\n        });\n        return found && found.node;\n    }\n\n    /**\n     * Requests scope data from tern\n     * @param {!Session} session\n     * @param {!{line: number, ch: number}} offset\n     * @return {!$.Promise} a jQuery promise that will be resolved with the scope data\n     */\n    function getScopeData(session, offset) {\n        var path = session.path,\n            fileInfo = {\n                type: MessageIds.TERN_FILE_INFO_TYPE_FULL,\n                name: path,\n                offsetLines: 0,\n                text: ScopeManager.filterText(session.getJavascriptText())\n            };\n\n        ScopeManager.postMessage({\n            type: MessageIds.TERN_SCOPEDATA_MSG,\n            fileInfo: fileInfo,\n            offset: offset\n        });\n\n        var ternPromise = ScopeManager.addPendingRequest(fileInfo.name, offset, MessageIds.TERN_SCOPEDATA_MSG);\n\n        var result = new $.Deferred();\n\n        ternPromise.done(function (response) {\n            result.resolveWith(null, [response.scope]);\n        }).fail(function () {\n            result.reject();\n        });\n\n        return result;\n    }\n\n    /**\n    * Normalize text by removing leading and trailing whitespace characters\n    * and moves the start and end offset to reflect the new offset\n    * @param {!string} text - selected text\n    * @param {!number} start - the start offset of the text\n    * @param {!number} end - the end offset of the text\n    * @param {!boolean} removeTrailingSemiColons - removes trailing semicolons also if true\n    * @return {!{text: string, start: number, end: number}}\n    */\n    function normalizeText(text, start, end, removeTrailingSemiColons) {\n        var trimmedText;\n\n        // Remove leading spaces\n        trimmedText = _.trimLeft(text);\n\n        if (trimmedText.length < text.length) {\n            start += (text.length - trimmedText.length);\n        }\n\n        text = trimmedText;\n\n        // Remove trailing spaces\n        trimmedText = _.trimRight(text);\n\n        if (trimmedText.length < text.length) {\n            end -= (text.length - trimmedText.length);\n        }\n\n        text = trimmedText;\n\n        // Remove trailing semicolons\n        if (removeTrailingSemiColons) {\n            trimmedText = _.trimRight(text, ';');\n\n            if (trimmedText.length < text.length) {\n                end -= (text.length - trimmedText.length);\n            }\n        }\n\n        return {\n            text: trimmedText,\n            start: start,\n            end: end\n        };\n    }\n\n    /**\n     * Checks whether the scope is a function scope\n     */\n    function isFnScope(scope) {\n        return !scope.isBlock && !scope.isCatch;\n    }\n\n    function findSurroundExpression(ast, expn) {\n        var start = expn.start;\n        var end = expn.end;\n        var surroundExpn;\n\n        while (true) {\n            surroundExpn = findSurroundASTNode(ast, {start: start, end: end}, [\"Expression\"]);\n\n            if (!surroundExpn) {\n                return null;\n            }\n\n            // Do not allow sequence expressions\n            if (surroundExpn.type === \"SequenceExpression\") {\n                start = surroundExpn.start - 1;\n            }            else if (surroundExpn.type === \"FunctionExpression\") { // Do not allow method definition expressions\n                var methodDefinitionNode = findSurroundASTNode(ast, surroundExpn, [\"MethodDefinition\"]);\n                if (methodDefinitionNode && isEqual(methodDefinitionNode.value, surroundExpn)) {\n                    start = surroundExpn.start - 1;\n                } else {\n                    return surroundExpn;\n                }\n            } else {\n                return surroundExpn;\n            }\n        }\n\n        return surroundExpn;\n    }\n\n    /**\n     * Finds the surrounding ast node of the given expression of any of the given types\n     * @param {!ASTNode} ast\n     * @param {!{start: number, end: number}} expn - contains start and end offsets of expn\n     * @param {!Array.<string>} types\n     * @return {?ASTNode}\n     */\n    function findSurroundASTNode(ast, expn, types) {\n        var foundNode = ASTWalker.findNodeAround(ast, expn.start, function (nodeType, node) {\n            if (expn.end) {\n                return types.includes(nodeType) && node.end >= expn.end;\n            }\n            return types.includes(nodeType);\n\n        });\n        return foundNode && _.clone(foundNode.node);\n    }\n\n    /**\n     * Converts the scopes returned from tern to an array of scopes and adds id and name to the scope\n     * Also checks for class scopes\n     * @param {!ASTNode} ast - ast of the complete file\n     * @param {!Scope} scope - scope returned from tern\n     * @param {!string} fullText - the complete text of a file\n     * @return {!Array.<Scope>}\n     */\n    function getAllScopes(ast, scope, fullText) {\n        var curScope = scope;\n        var cnt = 0;\n        var scopes = [];\n\n        while (curScope) {\n            curScope.id = cnt++;\n            scopes.push(curScope);\n\n            if (curScope.fnType) {\n                // Check for class scopes surrounding the function\n                if (curScope.fnType === \"FunctionExpression\") {\n                    var methodDefinitionNode = findSurroundASTNode(ast, curScope.originNode, [\"MethodDefinition\"]);\n                    // class scope found\n                    if (methodDefinitionNode && isEqual(methodDefinitionNode.value, curScope.originNode)) {\n                        // Change curScope name and originNode to that of methodDefinitionNode\n                        curScope.name = methodDefinitionNode.key.name;\n                        curScope.originNode = methodDefinitionNode;\n\n                        var classNode = findSurroundASTNode(ast, methodDefinitionNode, [\"ClassDeclaration\", \"ClassExpression\"]);\n\n                        if (classNode) {\n                            // Class Declaration found add it to scopes\n                            var temp = curScope.prev;\n                            var newScope = {};\n                            newScope.isClass = true;\n\n                            // if the class is class expression, check if it has a name\n                            if (classNode.type === \"ClassExpression\") {\n                                var assignmentExpNode = findSurroundASTNode(ast, classNode, [\"AssignmentExpression\"]);\n                                if (assignmentExpNode && assignmentExpNode.left && assignmentExpNode.left.name) {\n                                    newScope.name = \"class \" + assignmentExpNode.left.name;\n                                } else {\n                                    var varDeclaratorNode = findSurroundASTNode(ast, classNode, [\"VariableDeclarator\"]);\n                                    if (varDeclaratorNode && varDeclaratorNode.id && varDeclaratorNode.id.name) {\n                                        newScope.name = \"class \" + varDeclaratorNode.id.name;\n                                    } else {\n                                        newScope.name = \"class null\";\n                                    }\n                                }\n                            } else {\n                                newScope.name = \"class \" + (classNode.id && classNode.id.name);\n                            }\n                            newScope.originNode = classNode;\n                            curScope.prev = newScope;\n                            newScope.prev = temp;\n                        }\n                    } else {\n                        // For function expressions, assign name to prefix of the function body\n                        curScope.name = \"function starting with \" +\n                            fullText.substr(\n                                curScope.originNode.body.start,\n                                Math.min(\n                                    FUNCTION_BODY_PREFIX_LENGTH,\n                                    curScope.originNode.body.end - curScope.originNode.body.start\n                                )\n                            );\n                    }\n                } else {\n                    // Acorn parse marks name with '' under erroneous declarations, check it\n                    if (curScope.fnType === \"\") {\n                        curScope.name = \"function starting with \" +\n                            fullText.substr(\n                                curScope.originNode.body.start,\n                                Math.min(\n                                    FUNCTION_BODY_PREFIX_LENGTH,\n                                    curScope.originNode.body.end - curScope.originNode.body.start\n                                )\n                            );\n                    } else {\n                        curScope.name = curScope.fnType;\n                    }\n                }\n            } else if (!curScope.originNode) {\n                curScope.name = \"global\";\n            }\n\n            curScope = curScope.prev;\n        }\n        return scopes;\n    }\n\n    /**\n     * Note - To use these state defined in Refactoring Session,\n     * Please reinitialize this RefactoringSession after performing any of the below operations\n     * (i.e. replaceRange, setSelection or indentLine)\n     *\n     * RefactoringSession objects encapsulate state associated with a refactoring session\n     * and This will help finding information around documents, selection,\n     * position, ast, and queries around AST nodes\n     *\n     * @constructor\n     * @param {Editor} editor - the editor context for the session\n     */\n    function RefactoringSession(editor) {\n        this.editor = editor;\n        this.document = editor.document;\n        this.selection = editor.getSelection();\n        this.text = this.document.getText();\n        this.selectedText = editor.getSelectedText();\n        this.cm = editor._codeMirror;\n        this.startIndex = editor.indexFromPos(this.selection.start);\n        this.endIndex = editor.indexFromPos(this.selection.end);\n        this.startPos = this.selection.start;\n        this.endPos = this.selection.end;\n        this.ast = this.createAstOfCurrentDoc();\n    }\n\n    /**\n     * Get the end position of given line\n     *\n     * @param {number} line - line number\n     * @return {{line: number, ch: number}} - line end position\n     */\n    RefactoringSession.prototype.lineEndPosition = function (line) {\n        var lineText = this.document.getLine(line);\n\n        return {\n            line: line,\n            ch: lineText.length\n        };\n    };\n\n    /**\n     * Get the ast of current opened document in focused editor\n     *\n     * @return {Object} - Ast of current opened doc\n     */\n    RefactoringSession.prototype.createAstOfCurrentDoc = function () {\n        var ast,\n            text = this.document.getText();\n        try {\n            ast = Acorn.parse(text);\n        } catch(e) {\n            ast = AcornLoose.parse(text);\n        }\n        return ast;\n    };\n\n    /**\n     * This will add template at given position/selection\n     *\n     * @param {string} template - name of the template defined in templates.json\n     * @param {Array} args- Check all arguments that exist in defined templated pass all that args as array\n     * @param {{line: number, ch: number}} rangeToReplace - Range which we want to replace\n     * @param {string} subTemplate - If template written under some category\n     */\n    RefactoringSession.prototype.replaceTextFromTemplate = function (template, args, rangeToReplace, subTemplate) {\n        var templateText = templates[template];\n\n        if (subTemplate) {\n            templateText = templateText[subTemplate];\n        }\n\n        var compiled = _.template(templateText),\n            formattedText = compiled(args);\n\n        if (!rangeToReplace) {\n            rangeToReplace = this.editor.getSelection();\n        }\n\n        this.document.replaceRange(formattedText, rangeToReplace.start, rangeToReplace.end);\n\n        var startLine = rangeToReplace.start.line,\n            endLine = startLine + formattedText.split(\"\\n\").length;\n\n        for (var i = startLine + 1; i < endLine; i++) {\n            this.cm.indentLine(i);\n        }\n    };\n\n    /**\n     * Get Params of selected function\n     *\n     * @param {number} start- start offset\n     * @param {number} end - end offset\n     * @param {string} selectedText - Create ast for only selected node\n     * @return {Array} param - Array of all parameters in function\n     */\n    RefactoringSession.prototype.getParamsOfFunction = function getParamsOfFunction(start, end, selectedText) {\n        var param = [];\n        ASTWalker.simple(AcornLoose.parse(selectedText), {\n            Function: function (node) {\n                if (node.type === \"FunctionDeclaration\") {\n                    node.params.forEach(function (item) {\n                        param.push(item.name);\n                    });\n                }\n            }\n        });\n\n        return param;\n    };\n\n    /**\n     * Get the Parent node\n     *\n     * @param {Object} ast - ast of full document\n     * @param {number} start - start Offset\n     * @return {Object} node - Returns the parent node of node which is at offset start\n     */\n    RefactoringSession.prototype.getParentNode = function (ast, start) {\n        var foundNode = ASTWalker.findNodeAround(ast, start, function(nodeType, node) {\n            return (nodeType === \"ObjectExpression\");\n        });\n        return foundNode && foundNode.node;\n    };\n\n    /**\n     * Checks weather the node at start is last in that scope or not\n     *\n     * @param {Object} ast - ast of full document\n     * @param {number} start - start Offset\n     * @return {boolean} - is last node in that scope\n     */\n    RefactoringSession.prototype.isLastNodeInScope = function (ast, start) {\n        var parentNode = this.getParentNode(ast, start),\n            currentNodeStart;\n\n        ASTWalker.simple(parentNode, {\n            Property: function (node) {\n                currentNodeStart = node.start;\n            }\n        });\n\n        return start >= currentNodeStart;\n    };\n\n\n    // Define public api\n    exports.isEqual = isEqual;\n    exports.getUniqueIdentifierName = getUniqueIdentifierName;\n    exports.isStandAloneExpression = isStandAloneExpression;\n    exports.numLines = numLines;\n    exports.getScopeData = getScopeData;\n    exports.normalizeText = normalizeText;\n    exports.getExpression = getExpression;\n    exports.isFnScope = isFnScope;\n    exports.getAllScopes = getAllScopes;\n    exports.checkStatement = checkStatement;\n    exports.findSurroundASTNode = findSurroundASTNode;\n    exports.getAST = getAST;\n    exports.findSurroundExpression = findSurroundExpression;\n    exports.RefactoringSession = RefactoringSession;\n});\n\n/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\ndefine(\"RenameIdentifier\", function (require, exports, module) {\n\n\n    const EditorManager        = brackets.getModule(\"editor/EditorManager\"),\n        ScopeManager         = brackets.getModule(\"JSUtils/ScopeManager\"),\n        Session              = brackets.getModule(\"JSUtils/Session\"),\n        MessageIds           = JSON.parse(brackets.getModule(\"text!JSUtils/MessageIds.json\")),\n        TokenUtils           = brackets.getModule(\"utils/TokenUtils\"),\n        Strings              = brackets.getModule(\"strings\"),\n        Keys                 = brackets.getModule(\"command/Keys\"),\n        Editor               = brackets.getModule(\"editor/Editor\").Editor,\n        ProjectManager       = brackets.getModule(\"project/ProjectManager\");\n\n    let session             = null,  // object that encapsulates the current session state\n        keywords = [\"define\", \"alert\", \"exports\", \"require\", \"module\", \"arguments\"];\n\n    const MARK_TYPE_RENAME = \"renameVar\";\n\n    //Create new session\n    function initializeSession(editor) {\n        session = new Session(editor);\n    }\n\n    //Post message to tern node domain that will request tern server to find refs\n    function getRefs(fileInfo, offset) {\n        ScopeManager.postMessage({\n            type: MessageIds.TERN_REFS,\n            fileInfo: fileInfo,\n            offset: offset\n        });\n\n        return ScopeManager.addPendingRequest(fileInfo.name, offset, MessageIds.TERN_REFS);\n    }\n\n    //Create info required to find reference\n    function requestFindRefs(session, document, offset) {\n        if (!document || !session) {\n            return;\n        }\n        let path    = document.file.fullPath,\n            fileInfo = {\n                type: MessageIds.TERN_FILE_INFO_TYPE_FULL,\n                name: path,\n                offsetLines: 0,\n                text: ScopeManager.filterText(session.getJavascriptText())\n            };\n        let ternPromise = getRefs(fileInfo, offset);\n\n        return {promise: ternPromise};\n    }\n\n    //Do rename of identifier which is at cursor\n    function handleRename() {\n        let editor = EditorManager.getActiveEditor(),\n            offset, token;\n\n        if (!editor) {\n            return;\n        }\n\n        if (editor.getSelections().length > 1) {\n            editor.displayErrorMessageAtCursor(Strings.ERROR_RENAME_MULTICURSOR);\n            return;\n        }\n        initializeSession(editor);\n\n\n        if (!editor || editor.getModeForSelection() !== \"javascript\") {\n            return;\n        }\n\n        token = TokenUtils.getTokenAt(editor._codeMirror, editor._codeMirror.posFromIndex(session.getOffset()));\n\n        if (keywords.indexOf(token.string) >= 0) {\n            editor.displayErrorMessageAtCursor(Strings.ERROR_RENAME_GENERAL);\n            return;\n        }\n\n        let result = new $.Deferred();\n\n        function isInSameFile(obj, refsResp) {\n            let projectRoot = ProjectManager.getProjectRoot(),\n                projectDir,\n                fileName = \"\";\n            if (projectRoot) {\n                projectDir = projectRoot.fullPath;\n            }\n\n            // get the relative path of File as Tern can also return\n            // references with file name as a relative path wrt projectRoot\n            // so refernce file name will be compared with both relative and absolute path to check if it is same file\n            if (projectDir && refsResp && refsResp.file && refsResp.file.indexOf(projectDir) === 0) {\n                fileName = refsResp.file.slice(projectDir.length);\n            }\n            // In case of unsaved files, After renameing once Tern is returning filename without forward slash\n            return (obj && (obj.file === refsResp.file || obj.file === fileName\n                            || obj.file === refsResp.file.slice(1, refsResp.file.length)));\n        }\n\n        function _multiFileRename(refs) {\n            // TODO: Multi file rename here\n            // note that before we enable this, we should load tern with the full code base to identify all\n            // references properly. This sadly needs refactoring the current tern integration heavily\n        }\n\n        function _isCursorWithinMark(cursorPos, marker) {\n            if(!marker){\n                return false;\n            }\n            // Get the position of the marker\n            var pos = marker.find();\n            if (!pos) {return false;} // The marker doesn't cover any range\n\n            // Check if the cursor is within the mark's range\n            var from = pos.from, to = pos.to;\n            // Check if cursor line is between the start and end lines\n            if (cursorPos.line < from.line || cursorPos.line > to.line) {\n                return false;\n            }\n            // If cursor is on the same line as the start or end, check the character position\n            if (cursorPos.line === from.line && cursorPos.ch < from.ch) {\n                return false;\n            }\n            if (cursorPos.line === to.line && cursorPos.ch > to.ch) {\n                return false;\n            }\n\n            return true; // The cursor is within the mark\n        }\n\n\n        function _outlineText(currentEditor) {\n            let selections = currentEditor.getSelections();\n            if(selections.length > 1 ){\n                let primary = currentEditor.getSelection();\n                currentEditor.markText(MARK_TYPE_RENAME, primary.start, primary.end, Editor.getMarkOptionRenameOutline());\n                currentEditor.off(Editor.EVENT_BEFORE_SELECTION_CHANGE + \".renameVar\");\n                currentEditor.off(Editor.EVENT_CURSOR_ACTIVITY + \".renameVar\");\n                currentEditor.off(Editor.EVENT_KEY_DOWN + \".renameVar\");\n                currentEditor.on(Editor.EVENT_BEFORE_SELECTION_CHANGE + \".renameVar\", function (_evt, newSelections) {\n                    if(newSelections.ranges && newSelections.ranges.length === 1) {\n                        currentEditor.clearAllMarks(MARK_TYPE_RENAME);\n                        currentEditor.off(Editor.EVENT_BEFORE_SELECTION_CHANGE + \".renameVar\");\n                    }\n                });\n                currentEditor.on(Editor.EVENT_CURSOR_ACTIVITY + \".renameVar\", function (_evt, newSelections) {\n                    const mainCursor = currentEditor.getCursorPos();\n                    let primaryMark = currentEditor.getAllMarks(MARK_TYPE_RENAME);\n                    primaryMark = primaryMark && primaryMark[0];\n                    if(primaryMark && !_isCursorWithinMark(mainCursor, primaryMark)) {\n                        currentEditor.clearAllMarks(MARK_TYPE_RENAME);\n                        currentEditor.off(Editor.EVENT_BEFORE_SELECTION_CHANGE + \".renameVar\");\n                        currentEditor.setCursorPos(mainCursor.line, mainCursor.ch);\n                    }\n                });\n                currentEditor.on(Editor.EVENT_KEY_DOWN + \".renameVar\", function (_evt, _editor, keyboardEvent) {\n                    const mainCursor = currentEditor.getCursorPos();\n                    let primaryMark = currentEditor.getAllMarks(MARK_TYPE_RENAME);\n                    primaryMark = primaryMark && primaryMark[0];\n                    if(primaryMark && (keyboardEvent.key === Keys.KEY.RETURN || keyboardEvent.key === Keys.KEY.ENTER)){\n                        currentEditor.clearAllMarks(MARK_TYPE_RENAME);\n                        currentEditor.off(Editor.EVENT_KEY_DOWN + \".renameVar\");\n                        currentEditor.setCursorPos(mainCursor.line, mainCursor.ch);\n                        keyboardEvent.preventDefault();\n                        keyboardEvent.stopPropagation();\n                    }\n                });\n            }\n        }\n\n        /**\n         * Check if references are in this file only\n         * If yes then select all references\n         */\n        function handleFindRefs (refsResp) {\n            if (!refsResp || !refsResp.references || !refsResp.references.refs) {\n                return;\n            }\n\n            let inlineWidget = EditorManager.getFocusedInlineWidget(),\n                editor = EditorManager.getActiveEditor(),\n                refs = refsResp.references.refs;\n\n            //In case of inline widget if some references are outside widget's text range then don't allow for rename\n            if (inlineWidget) {\n                let isInTextRange  = !refs.find(function(item) {\n                    return (item.start.line < inlineWidget._startLine || item.end.line > inlineWidget._endLine);\n                });\n\n                if (!isInTextRange) {\n                    editor.displayErrorMessageAtCursor(Strings.ERROR_RENAME_QUICKEDIT);\n                    return;\n                }\n            }\n\n            let currentPosition = editor.posFromIndex(refsResp.offset),\n                refsArray;\n            refsArray = refs.filter(function (element) {\n                return isInSameFile(element, refsResp);\n            });\n            if (refsArray.length !== refs.length) {\n                // There are references across multiple files, we are not ready to handle this yet\n                _multiFileRename(refs);\n                return;\n            }\n\n            // Finding the Primary Reference in Array\n            let primaryRef = refsArray.find(function (element) {\n                return ((element.start.line === currentPosition.line || element.end.line === currentPosition.line)\n                        && currentPosition.ch <= element.end.ch && currentPosition.ch >= element.start.ch);\n            });\n            // Setting the primary flag of Primary Refence to true\n            primaryRef.primary = true;\n\n            editor.setSelections(refsArray);\n            _outlineText(editor);\n        }\n\n        /**\n         * Make a find ref request.\n         * @param {Session} session - the session\n         * @param {number} offset - the offset of where to jump from\n         */\n        function requestFindReferences(session, offset) {\n            let response = requestFindRefs(session, session.editor.document, offset);\n\n            if (response && response.hasOwnProperty(\"promise\")) {\n                response.promise.done(handleFindRefs).fail(function (errorMsg) {\n                    EditorManager.getActiveEditor().displayErrorMessageAtCursor(errorMsg);\n                    result.reject();\n                });\n            }\n        }\n\n        offset = session.getOffset();\n        requestFindReferences(session, offset);\n\n        return result.promise();\n    }\n\n    // for tests\n    exports._MARK_TYPE_RENAME = MARK_TYPE_RENAME;\n\n    // public api\n    exports.handleRename = handleRename;\n});\n\n/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\ndefine(\"WrapSelection\", function (require, exports, module) {\n\n\n    var _ = brackets.getModule(\"thirdparty/lodash\");\n\n    var EditorManager        = brackets.getModule(\"editor/EditorManager\"),\n        TokenUtils           = brackets.getModule(\"utils/TokenUtils\"),\n        Strings              = brackets.getModule(\"strings\"),\n        RefactoringUtils     = require(\"RefactoringUtils\"),\n        RefactoringSession   = RefactoringUtils.RefactoringSession;\n\n    //Template keys mentioned in Templates.json\n    var WRAP_IN_CONDITION       = \"wrapCondition\",\n        ARROW_FUNCTION          = \"arrowFunction\",\n        GETTERS_SETTERS         = \"gettersSetters\",\n        TRY_CATCH               = \"tryCatch\";\n\n    //Active session which will contain information about editor, selection etc\n    var current = null;\n\n    /**\n     * Initialize session\n     */\n    function initializeRefactoringSession(editor) {\n        current = new RefactoringSession(editor);\n    }\n\n    /**\n     * Wrap selected statements\n     *\n     * @param {string} wrapperName - template name where we want wrap selected statements\n     * @param {string} err- error message if we can't wrap selected code\n     */\n    function _wrapSelectedStatements (wrapperName, err) {\n        var editor = EditorManager.getActiveEditor();\n        if (!editor) {\n            return;\n        }\n        initializeRefactoringSession(editor);\n\n        var startIndex = current.startIndex,\n            endIndex = current.endIndex,\n            selectedText = current.selectedText,\n            pos;\n\n        if (selectedText.length === 0) {\n            var statementNode = RefactoringUtils.findSurroundASTNode(current.ast, {start: startIndex}, [\"Statement\"]);\n            if (!statementNode) {\n                current.editor.displayErrorMessageAtCursor(err);\n                return;\n            }\n            selectedText = current.text.substr(statementNode.start, statementNode.end - statementNode.start);\n            startIndex = statementNode.start;\n            endIndex = statementNode.end;\n        } else {\n            var selectionDetails = RefactoringUtils.normalizeText(selectedText, startIndex, endIndex);\n            selectedText = selectionDetails.text;\n            startIndex = selectionDetails.start;\n            endIndex = selectionDetails.end;\n        }\n\n        if (!RefactoringUtils.checkStatement(current.ast, startIndex, endIndex, selectedText)) {\n            current.editor.displayErrorMessageAtCursor(err);\n            return;\n        }\n\n        pos = {\n            \"start\": current.cm.posFromIndex(startIndex),\n            \"end\": current.cm.posFromIndex(endIndex)\n        };\n\n        current.document.batchOperation(function() {\n            current.replaceTextFromTemplate(wrapperName, {body: selectedText}, pos);\n        });\n\n        if (wrapperName === TRY_CATCH) {\n            var cursorLine = current.editor.getSelection().end.line - 1,\n                startCursorCh = current.document.getLine(cursorLine).indexOf(\"\\/\\/\"),\n                endCursorCh = current.document.getLine(cursorLine).length;\n\n            current.editor.setSelection({\"line\": cursorLine, \"ch\": startCursorCh}, {\"line\": cursorLine, \"ch\": endCursorCh});\n        } else if (wrapperName === WRAP_IN_CONDITION) {\n            current.editor.setSelection({\"line\": pos.start.line, \"ch\": pos.start.ch + 4}, {\"line\": pos.start.line, \"ch\": pos.start.ch + 13});\n        }\n    }\n\n\n     //Wrap selected statements in try catch block\n    function wrapInTryCatch() {\n        _wrapSelectedStatements(TRY_CATCH, Strings.ERROR_TRY_CATCH);\n    }\n\n    //Wrap selected statements in try condition\n    function wrapInCondition() {\n        _wrapSelectedStatements(WRAP_IN_CONDITION, Strings.ERROR_WRAP_IN_CONDITION);\n    }\n\n    //Convert function to arrow function\n    function convertToArrowFunction() {\n        var editor = EditorManager.getActiveEditor();\n        if (!editor) {\n            return;\n        }\n        initializeRefactoringSession(editor);\n\n        var funcExprNode = RefactoringUtils.findSurroundASTNode(current.ast, {start: current.startIndex}, [\"Function\"]);\n\n        if (!funcExprNode || funcExprNode.type !== \"FunctionExpression\" || funcExprNode.id) {\n            current.editor.displayErrorMessageAtCursor(Strings.ERROR_ARROW_FUNCTION);\n            return;\n        }\n\n        if (funcExprNode === \"FunctionDeclaration\") {\n            current.editor.displayErrorMessageAtCursor(Strings.ERROR_ARROW_FUNCTION);\n            return;\n        }\n\n        if (!funcExprNode.body) {\n            return;\n        }\n\n        var noOfStatements = funcExprNode.body.body.length,\n            selectedText = current.text.substr(funcExprNode.start, funcExprNode.end - funcExprNode.start),\n            param = [],\n            dontChangeParam = false,\n            numberOfParams = funcExprNode.params.length,\n            treatAsManyParam = false;\n\n        funcExprNode.params.forEach(function (item) {\n            if (item.type === \"Identifier\") {\n                param.push(item.name);\n            } else if (item.type === \"AssignmentPattern\") {\n                dontChangeParam = true;\n            }\n        });\n\n        //In case defaults params keep params as it is\n        if (dontChangeParam) {\n            if (numberOfParams >= 1) {\n                param.splice(0, param.length);\n                param.push(current.text.substr(funcExprNode.params[0].start, funcExprNode.params[numberOfParams-1].end - funcExprNode.params[0].start));\n                // In case default param, treat them as many paramater because to use\n                // one parameter template, That param should be an identifier\n                if (numberOfParams === 1) {\n                    treatAsManyParam = true;\n                }\n            }\n            dontChangeParam = false;\n        }\n\n        var loc = {\n                \"fullFunctionScope\": {\n                    start: funcExprNode.start,\n                    end: funcExprNode.end\n                },\n                \"functionsDeclOnly\": {\n                    start: funcExprNode.start,\n                    end: funcExprNode.body.start\n                }\n            },\n            locPos = {\n                \"fullFunctionScope\": {\n                    \"start\": current.cm.posFromIndex(loc.fullFunctionScope.start),\n                    \"end\": current.cm.posFromIndex(loc.fullFunctionScope.end)\n                },\n                \"functionsDeclOnly\": {\n                    \"start\": current.cm.posFromIndex(loc.functionsDeclOnly.start),\n                    \"end\": current.cm.posFromIndex(loc.functionsDeclOnly.end)\n                }\n            },\n            isReturnStatement = (noOfStatements >= 1 && funcExprNode.body.body[0].type === \"ReturnStatement\"),\n            bodyStatements = funcExprNode.body.body[0],\n            params;\n\n            // If there is nothing in function body, then get the text b/w curly braces\n            // In this case, We will update params only as per Arrow function expression\n        if (!bodyStatements) {\n            bodyStatements = funcExprNode.body;\n        }\n        params = {\n            \"params\": param.join(\", \"),\n            \"statement\": _.trimRight(current.text.substr(bodyStatements.start, bodyStatements.end - bodyStatements.start), \";\")\n        };\n\n        if (isReturnStatement) {\n            params.statement = params.statement.substr(7).trim();\n        }\n\n        if (noOfStatements === 1) {\n            current.document.batchOperation(function() {\n                (numberOfParams === 1 && !treatAsManyParam) ?  current.replaceTextFromTemplate(ARROW_FUNCTION, params, locPos.fullFunctionScope, \"oneParamOneStament\") :\n                current.replaceTextFromTemplate(ARROW_FUNCTION, params, locPos.fullFunctionScope, \"manyParamOneStament\");\n\n            });\n        } else {\n            current.document.batchOperation(function() {\n                (numberOfParams === 1 && !treatAsManyParam) ?  current.replaceTextFromTemplate(ARROW_FUNCTION, {params: param},\n                locPos.functionsDeclOnly, \"oneParamManyStament\") :\n                current.replaceTextFromTemplate(ARROW_FUNCTION, {params: param.join(\", \")}, locPos.functionsDeclOnly, \"manyParamManyStament\");\n            });\n        }\n\n        current.editor.setCursorPos(locPos.functionsDeclOnly.end.line, locPos.functionsDeclOnly.end.ch, false);\n    }\n\n    // Create gtteres and setters for a property\n    function createGettersAndSetters() {\n        var editor = EditorManager.getActiveEditor();\n        if (!editor) {\n            return;\n        }\n        initializeRefactoringSession(editor);\n\n        var startIndex = current.startIndex,\n            endIndex = current.endIndex,\n            selectedText = current.selectedText;\n\n        if (selectedText.length >= 1) {\n            var selectionDetails = RefactoringUtils.normalizeText(selectedText, startIndex, endIndex);\n            selectedText = selectionDetails.text;\n            startIndex = selectionDetails.start;\n            endIndex = selectionDetails.end;\n        }\n\n        var token = TokenUtils.getTokenAt(current.cm, current.cm.posFromIndex(endIndex)),\n            commaString = \",\",\n            isLastNode,\n            templateParams,\n            parentNode,\n            propertyEndPos;\n\n        //Create getters and setters only if selected reference is a property\n        if (token.type !== \"property\") {\n            current.editor.displayErrorMessageAtCursor(Strings.ERROR_GETTERS_SETTERS);\n            return;\n        }\n\n        parentNode = current.getParentNode(current.ast, endIndex);\n        // Check if selected propery is child of a object expression\n        if (!parentNode || !parentNode.properties) {\n            current.editor.displayErrorMessageAtCursor(Strings.ERROR_GETTERS_SETTERS);\n            return;\n        }\n\n\n        var propertyNodeArray = parentNode.properties;\n        // Find the last Propery Node before endIndex\n        var properyNodeIndex = propertyNodeArray.findIndex(function (element) {\n            return (endIndex >= element.start && endIndex < element.end);\n        });\n\n        var propertyNode = propertyNodeArray[properyNodeIndex];\n\n        //Get Current Selected Property End Index;\n        propertyEndPos = editor.posFromIndex(propertyNode.end);\n\n\n        //We have to add ',' so we need to find position of current property selected\n        isLastNode = current.isLastNodeInScope(current.ast, endIndex);\n        var nextPropertNode, nextPropertyStartPos;\n        if(!isLastNode && properyNodeIndex + 1 <= propertyNodeArray.length - 1) {\n            nextPropertNode = propertyNodeArray[properyNodeIndex + 1];\n            nextPropertyStartPos = editor.posFromIndex(nextPropertNode.start);\n\n            if(propertyEndPos.line !== nextPropertyStartPos.line) {\n                propertyEndPos = current.lineEndPosition(current.startPos.line);\n            } else {\n                propertyEndPos = nextPropertyStartPos;\n                commaString = \", \";\n            }\n        }\n\n        var getSetPos;\n        if (isLastNode) {\n            getSetPos = current.document.adjustPosForChange(propertyEndPos, commaString.split(\"\\n\"),\n                                                            propertyEndPos, propertyEndPos);\n        } else {\n            getSetPos = propertyEndPos;\n        }\n        templateParams = {\n            \"getName\": token.string,\n            \"setName\": token.string,\n            \"tokenName\": token.string\n        };\n\n        // Replace, setSelection, IndentLine\n        // We need to call batchOperation as indentLine don't have option to add origin as like replaceRange\n        current.document.batchOperation(function() {\n            if (isLastNode) {\n                //Add ',' in the end of current line\n                current.document.replaceRange(commaString, propertyEndPos, propertyEndPos);\n            }\n\n            current.editor.setSelection(getSetPos); //Selection on line end\n\n            // Add getters and setters for given token using template at current cursor position\n            current.replaceTextFromTemplate(GETTERS_SETTERS, templateParams);\n\n            if (!isLastNode) {\n                // Add ',' at the end setter\n                current.document.replaceRange(commaString, current.editor.getSelection().start, current.editor.getSelection().start);\n            }\n        });\n    }\n\n    exports.wrapInCondition         = wrapInCondition;\n    exports.wrapInTryCatch          = wrapInTryCatch;\n    exports.convertToArrowFunction  = convertToArrowFunction;\n    exports.createGettersAndSetters = createGettersAndSetters;\n});\n"],"file":"extension-min.js"}