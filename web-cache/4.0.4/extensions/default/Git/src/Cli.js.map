{"version":3,"sources":["extensions/default/Git/src/Cli.js"],"names":["define","require","exports","module","NodeConnector","brackets","getModule","ErrorHandler","Preferences","Events","Utils","gitTimeout","get","nextCliId","deferredMap","getExtensionPref","on","MAX_COUNTER_VALUE","gitNodeConnector","createNodeConnector","getNextCliId","normalizePathForOs","path","platform","replace","sanitizeOutput","str","toString","logDebug","opts","debugInfo","method","type","out","logger","loggingOptions","logGit","processInfo","duration","Date","getTime","startTime","push","cliId","msg","join","consoleDebug","cliHandler","cmd","args","retry","cliPromise","Promise","resolve","reject","progressTracker","savedDefer","watchProgress","indexOf","cwd","fs","getTauriPlatformPath","getProjectRoot","resolved","timeoutLength","timeout","domainOpts","timeoutPromise","err","Error","timeoutExpected","logError","execPeer","catch","toError","off","GIT_PROGRESS_EVENT","trigger","directory","command","invalidCwdErr","stack","message","then","response","isResolved","finally","lastProgressTime","timeoutCall","setTimeout","currentTime","diff","which","spawnCommand","_event","evtData","deferred","data"],"mappings":"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","sourcesContent":["/*globals logger, fs*/\ndefine(function (require, exports, module) {\n\n    const NodeConnector = brackets.getModule('NodeConnector');\n\n    const ErrorHandler  = require(\"src/ErrorHandler\"),\n        Preferences   = require(\"src/Preferences\"),\n        Events        = require(\"src/Events\"),\n        Utils         = require(\"src/Utils\");\n\n    let gitTimeout        = Preferences.get(\"gitTimeout\") * 1000,\n        nextCliId         = 0,\n        deferredMap       = {};\n\n    Preferences.getExtensionPref().on(\"change\", \"gitTimeout\", ()=>{\n        gitTimeout = Preferences.get(\"gitTimeout\") * 1000;\n    });\n\n    // Constants\n    var MAX_COUNTER_VALUE = 4294967295; // 2^32 - 1\n\n    let gitNodeConnector = NodeConnector.createNodeConnector(\"phcode-git-core\", exports);\n    gitNodeConnector.on(Events.GIT_PROGRESS_EVENT, (_event, evtData) => {\n        const deferred = deferredMap[evtData.cliId];\n        if(!deferred){\n            ErrorHandler.logError(\"Progress sent for a non-existing process(\" + evtData.cliId + \"): \" + evtData);\n            return;\n        }\n        if (!deferred.isResolved && deferred.progressTracker) {\n            deferred.progressTracker.trigger(Events.GIT_PROGRESS_EVENT, evtData.data);\n        }\n    });\n\n    function getNextCliId() {\n        if (nextCliId >= MAX_COUNTER_VALUE) {\n            nextCliId = 0;\n        }\n        return ++nextCliId;\n    }\n\n    function normalizePathForOs(path) {\n        if (brackets.platform === \"win\") {\n            path = path.replace(/\\//g, \"\\\\\");\n        }\n        return path;\n    }\n\n    // this functions prevents sensitive info from going further (like http passwords)\n    function sanitizeOutput(str) {\n        if (typeof str !== \"string\") {\n            if (str != null) { // checks for both null & undefined\n                str = str.toString();\n            } else {\n                str = \"\";\n            }\n        }\n        return str;\n    }\n\n    function logDebug(opts, debugInfo, method, type, out) {\n        if (!logger.loggingOptions.logGit) {\n            return;\n        }\n        var processInfo = [];\n\n        var duration = (new Date()).getTime() - debugInfo.startTime;\n        processInfo.push(duration + \"ms\");\n\n        if (opts.cliId) {\n            processInfo.push(\"ID=\" + opts.cliId);\n        }\n\n        var msg = \"cmd-\" + method + \"-\" + type + \" (\" + processInfo.join(\";\") + \")\";\n        if (out) { msg += \": \\\"\" + out + \"\\\"\"; }\n        Utils.consoleDebug(msg);\n    }\n\n    function cliHandler(method, cmd, args, opts, retry) {\n        const cliPromise = new Promise((resolve, reject)=>{\n            const cliId     = getNextCliId();\n            args = args || [];\n            opts = opts || {};\n            const progressTracker = opts.progressTracker;\n\n            const savedDefer = {resolve, reject, progressTracker};\n            deferredMap[cliId] = savedDefer;\n\n            const watchProgress = !!progressTracker || (args.indexOf(\"--progress\") !== -1);\n            const startTime = (new Date()).getTime();\n\n            // it is possible to set a custom working directory in options\n            // otherwise the current project root is used to execute commands\n            if (!opts.cwd) {\n                opts.cwd = fs.getTauriPlatformPath(Preferences.get(\"currentGitRoot\") || Utils.getProjectRoot());\n            }\n\n            // convert paths like c:/foo/bar to c:\\foo\\bar on windows\n            opts.cwd = normalizePathForOs(opts.cwd);\n\n            // log all cli communication into console when debug mode is on\n            Utils.consoleDebug(\"cmd-\" + method + (watchProgress ? \"-watch\" : \"\") + \": \" +\n                opts.cwd + \" -> \" +\n                cmd + \" \" + args.join(\" \"));\n\n            let resolved      = false,\n                timeoutLength = opts.timeout ? (opts.timeout * 1000) : gitTimeout;\n\n            const domainOpts = {\n                cliId: cliId,\n                watchProgress: watchProgress\n            };\n\n            const debugInfo = {\n                startTime: startTime\n            };\n\n            if (watchProgress && progressTracker) {\n                progressTracker.trigger(Events.GIT_PROGRESS_EVENT,\n                    \"Running command: git \" + args.join(\" \"));\n            }\n\n            gitNodeConnector.execPeer(method, {directory: opts.cwd, command: cmd, args: args, opts: domainOpts})\n                .catch(function (err) {\n                    if (!resolved) {\n                        err = sanitizeOutput(err);\n                        logDebug(domainOpts, debugInfo, method, \"fail\", err);\n                        delete deferredMap[cliId];\n\n                        err = ErrorHandler.toError(err);\n\n                        // spawn ENOENT error\n                        var invalidCwdErr = \"spawn ENOENT\";\n                        if (err.stack && err.stack.indexOf(invalidCwdErr)) {\n                            err.message = err.message.replace(invalidCwdErr, invalidCwdErr + \" (\" + opts.cwd + \")\");\n                            err.stack = err.stack.replace(invalidCwdErr, invalidCwdErr + \" (\" + opts.cwd + \")\");\n                        }\n\n                        // socket was closed so we should try this once again (if not already retrying)\n                        if (err.stack && err.stack.indexOf(\"WebSocket.self._ws.onclose\") !== -1 && !retry) {\n                            cliHandler(method, cmd, args, opts, true)\n                                .then(function (response) {\n                                    savedDefer.isResolved = true;\n                                    resolve(response);\n                                })\n                                .catch(function (err) {\n                                    reject(err);\n                                });\n                            return;\n                        }\n\n                        reject(err);\n                    }\n                })\n                .then(function (out) {\n                    if (!resolved) {\n                        out = sanitizeOutput(out);\n                        logDebug(domainOpts, debugInfo, method, \"out\", out);\n                        delete deferredMap[cliId];\n                        resolve(out);\n                    }\n                })\n                .finally(function () {\n                    progressTracker && progressTracker.off(`${Events.GIT_PROGRESS_EVENT}.${cliId}`);\n                    resolved = true;\n                });\n\n            function timeoutPromise() {\n                logDebug(domainOpts, debugInfo, method, \"timeout\");\n                var err = new Error(\"cmd-\" + method + \"-timeout: \" + cmd + \" \" + args.join(\" \"));\n                if (!opts.timeoutExpected) {\n                    ErrorHandler.logError(err);\n                }\n\n                // process still lives and we need to kill it\n                gitNodeConnector.execPeer(\"kill\", domainOpts.cliId)\n                    .catch(function (err) {\n                        ErrorHandler.logError(err);\n                    });\n\n                delete deferredMap[cliId];\n                reject(ErrorHandler.toError(err));\n                resolved = true;\n                progressTracker && progressTracker.off(`${Events.GIT_PROGRESS_EVENT}.${cliId}`);\n            }\n\n            var lastProgressTime = 0;\n            function timeoutCall() {\n                setTimeout(function () {\n                    if (!resolved) {\n                        if (domainOpts.watchProgress) {\n                            // we are watching the promise progress\n                            // so we should check if the last message was sent in more than timeout time\n                            const currentTime = (new Date()).getTime();\n                            const diff = currentTime - lastProgressTime;\n                            if (diff > timeoutLength) {\n                                Utils.consoleDebug(\"cmd(\" + cliId + \") - last progress message was sent \" + diff + \"ms ago - timeout\");\n                                timeoutPromise();\n                            } else {\n                                Utils.consoleDebug(\"cmd(\" + cliId + \") - last progress message was sent \" + diff + \"ms ago - delay\");\n                                timeoutCall();\n                            }\n                        } else {\n                            // we don't have any custom handler, so just kill the promise here\n                            // note that command WILL keep running in the background\n                            // so even when timeout occurs, operation might finish after it\n                            timeoutPromise();\n                        }\n                    }\n                }, timeoutLength);\n            }\n\n            // when opts.timeout === false then never timeout the process\n            if (opts.timeout !== false) {\n                // if we are watching for progress events, mark the time when last progress was made\n                if (domainOpts.watchProgress && progressTracker) {\n                    progressTracker.off(`${Events.GIT_PROGRESS_EVENT}.${cliId}`);\n                    progressTracker.on(`${Events.GIT_PROGRESS_EVENT}.${cliId}`, function () {\n                        lastProgressTime = (new Date()).getTime();\n                    });\n                }\n                // call the method which will timeout the promise after a certain period of time\n                timeoutCall();\n            }\n        });\n        return cliPromise;\n    }\n\n    function which(cmd) {\n        return cliHandler(\"which\", cmd);\n    }\n\n    function spawnCommand(cmd, args, opts) {\n        return cliHandler(\"spawn\", cmd, args, opts);\n    }\n\n    // Public API\n    exports.cliHandler      = cliHandler;\n    exports.which           = which;\n    exports.spawnCommand    = spawnCommand;\n});\n"],"file":"Cli.js"}