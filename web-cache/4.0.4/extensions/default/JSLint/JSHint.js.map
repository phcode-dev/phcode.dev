{"version":3,"sources":["extensions/default/JSLint/JSHint.js"],"names":["define","require","exports","module","CodeInspection","brackets","getModule","FileSystemError","AppInit","PreferencesManager","DocumentManager","Strings","StringUtils","ProjectManager","FileSystem","IndexingWorker","Metrics","ESLint","Phoenix","isTestWindow","on","window","_JsHintExtensionReadyToIntegTest","loadScriptInWorker","uri","prefs","getExtensionPrefs","projectSpecificOptions","jsHintConfigFileErrorMessage","PREFS_JSHINT_DISABLED","DEFAULT_OPTIONS","esversion","browser","node","jquery","rhino","jasmine","devel","_getLinterConfigFileErrorMsg","pos","line","ch","message","type","Type","ERROR","async","lintOneFile","text","_fullPath","Promise","resolve","reject","errors","replace","options","startTime","Date","now","execPeer","then","jsHintErrors","logPerformanceTime","lintResult","length","map","lintError","character","reason","code","catch","err","console","error","Error","definePreference","description","DESCRIPTION_JSHINT_DISABLE","requestRun","JSHINT_NAME","CONFIG_FILE_NAME","removeComments","str","_readConfig","dir","configFileName","configFilePath","path","join","displayPath","getProjectRelativeOrDisplayPath","getDocumentForPath","done","configDoc","isWithinProject","config","content","getText","JSON","parse","log","e","format","JSHINT_CONFIG_JSON_ERROR","extends","extendFile","getFileForPath","parentPath","name","baseConfigResult","mergedConfig","$","extend","globals","extendDisplayPath","makeProjectRelativeIfPossible","fullPath","fail","NOT_FOUND","JSHINT_CONFIG_ERROR","_reloadOptions","scanningProjectPath","getProjectRoot","countEvent","EVENT_TYPE","LINT","isJSHintConfigActive","_projectFileChanged","_evt","changedPath","addedSet","removedSet","configPath","has","appReady","EVENT_PROJECT_CHANGED_OR_RENAMED_PATH","EVENT_PROJECT_OPEN","register","scanFileAsync","canInspect","get","endsWith","isESLintActive"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n// Parts of this file is adapted from https://github.com/cfjedimaster/brackets-jshint\n\n/*global path*/\n\n/**\n * Provides JSLint results via the core linting extension point\n */\ndefine(function (require, exports, module) {\n\n    // Load dependent modules\n    const CodeInspection     = brackets.getModule(\"language/CodeInspection\"),\n        FileSystemError    = brackets.getModule(\"filesystem/FileSystemError\"),\n        AppInit            = brackets.getModule(\"utils/AppInit\"),\n        PreferencesManager = brackets.getModule(\"preferences/PreferencesManager\"),\n        DocumentManager    = brackets.getModule(\"document/DocumentManager\"),\n        Strings            = brackets.getModule(\"strings\"),\n        StringUtils        = brackets.getModule(\"utils/StringUtils\"),\n        ProjectManager     = brackets.getModule(\"project/ProjectManager\"),\n        FileSystem         = brackets.getModule(\"filesystem/FileSystem\"),\n        IndexingWorker     = brackets.getModule(\"worker/IndexingWorker\"),\n        Metrics            = brackets.getModule(\"utils/Metrics\"),\n        ESLint       = require(\"./ESLint\");\n\n    if(Phoenix.isTestWindow) {\n        IndexingWorker.on(\"JsHint_extension_Loaded\", ()=>{\n            window._JsHintExtensionReadyToIntegTest = true;\n        });\n    }\n    IndexingWorker.loadScriptInWorker(`${module.uri}/../worker/jslint-helper.js`);\n\n    let prefs = PreferencesManager.getExtensionPrefs(\"jshint\"),\n        projectSpecificOptions = null,\n        jsHintConfigFileErrorMessage = null;\n\n    const PREFS_JSHINT_DISABLED = \"disabled\";\n\n    // We don't provide default options in the preferences as preferences will try to mixin default options with\n    // user defined options leading to unexpected results. Either we take user defined options or default, no mixin.\n    let DEFAULT_OPTIONS = {\n        \"esversion\": 11,\n        \"browser\": true,\n        \"node\": true,\n        \"jquery\": true,\n        \"rhino\": false, // false here means read-only global property\n        \"jasmine\": true,\n        \"devel\": false\n    };\n\n    prefs.definePreference(PREFS_JSHINT_DISABLED, \"boolean\", false, {\n        description: Strings.DESCRIPTION_JSHINT_DISABLE\n    }).on(\"change\", function () {\n        CodeInspection.requestRun(Strings.JSHINT_NAME);\n    });\n\n    function _getLinterConfigFileErrorMsg() {\n        return [{\n            // JSLint returns 1-based line/col numbers\n            pos: { line: -1, ch: 0 },\n            message: jsHintConfigFileErrorMessage,\n            type: CodeInspection.Type.ERROR\n        }];\n    }\n\n    /**\n     * Run JSLint on the current document. Reports results to the main UI. Displays\n     * a gold star when no errors are found.\n     */\n    async function lintOneFile(text, _fullPath) {\n        return new Promise((resolve, reject)=>{\n            if(jsHintConfigFileErrorMessage){\n                resolve({ errors: _getLinterConfigFileErrorMsg() });\n                return;\n            }\n            // If a line contains only whitespace (here spaces or tabs), remove the whitespace\n            text = text.replace(/^[ \\t]+$/gm, \"\");\n\n            let options = projectSpecificOptions || DEFAULT_OPTIONS;\n\n            const startTime = Date.now();\n            IndexingWorker.execPeer(\"jsHint\", {\n                text,\n                options\n            }).then(jsHintErrors =>{\n                Metrics.logPerformanceTime(\"JSHint\", Date.now() - startTime);\n                if (!jsHintErrors.lintResult && jsHintErrors.errors.length) {\n                    let errors = jsHintErrors.errors;\n\n                    errors = errors.map(function (lintError) {\n                        return {\n                            // JSLint returns 1-based line/col numbers\n                            pos: { line: lintError.line - 1, ch: lintError.character },\n                            message: `${lintError.reason} jshint (${lintError.code})`,\n                            type: CodeInspection.Type.ERROR\n                        };\n                    });\n\n                    resolve({ errors: errors });\n                }\n                resolve();\n            }).catch(err=>{\n                console.error(\"JSHint failed:\", err);\n                reject(new Error(\"JSHint failed as JSHint plugin is not yet loaded. Please try again.\"));\n            });\n        });\n    }\n\n    /**\n     * @private\n     * @type {string}\n     */\n    const CONFIG_FILE_NAME = \".jshintrc\";\n\n    /**\n     * Removes JavaScript comments from a string by replacing\n     * everything between block comments and everything after\n     * single-line comments in a non-greedy way.\n     *\n     * English version of the regex:\n     *   match '/*'\n     *   then match zero or more instances of any character (incl. \\n)\n     *   except for instances of '* /' (without a space, obv.)\n     *   then match '* /' (again, without a space)\n     *\n     * @param {string} str a string with potential JavaScript comments.\n     * @returns {string} a string without JavaScript comments.\n     */\n    function removeComments(str) {\n        str = str || \"\";\n\n        str = str.replace(/\\/\\*(?:(?!\\*\\/)[\\s\\S])*\\*\\//g, \"\");\n        str = str.replace(/\\/\\/[^\\n\\r]*/g, \"\"); // Everything after '//'\n\n        return str;\n    }\n\n    /**\n     * Reads configuration file in the specified directory. Returns a promise for configuration object.\n     *\n     * @param {string} dir absolute path to a directory.\n     * @param {string} configFileName name of the configuration file (optional)\n     *\n     * @returns {Promise} a promise to return configuration object.\n     */\n    function _readConfig(dir, configFileName) {\n        return new Promise((resolve, reject)=>{\n            configFileName = configFileName || CONFIG_FILE_NAME;\n            const configFilePath = path.join(dir, configFileName);\n            let displayPath = ProjectManager.getProjectRelativeOrDisplayPath(configFilePath);\n            DocumentManager.getDocumentForPath(configFilePath).done(function (configDoc) {\n                if (!ProjectManager.isWithinProject(configFilePath)) {\n                    // this is a rare race condition where the user switches project between the get document call.\n                    // Eg. in integ tests.\n                    reject(`JSHint Project changed while scanning ${configFilePath}`);\n                    return;\n                }\n                let config;\n                const content = configDoc.getText();\n                try {\n                    config = JSON.parse(removeComments(content));\n                    console.log(\"JSHint: loaded config file for project \" + configFilePath);\n                } catch (e) {\n                    console.log(\"JSHint: error parsing \" + configFilePath, content, e);\n                    // just log and return as this is an expected failure for us while the user edits code\n                    reject(StringUtils.format(Strings.JSHINT_CONFIG_JSON_ERROR, displayPath));\n                    return;\n                }\n                // Load any base config defined by \"extends\".\n                // The same functionality as in\n                // jslints -> cli.js -> loadConfig -> if (config['extends'])...\n                // https://jshint.com/docs/cli/ > Special Options\n                if (config.extends) {\n                    let extendFile = FileSystem.getFileForPath(path.join(dir, config.extends));\n                    _readConfig(extendFile.parentPath, extendFile.name).then(baseConfigResult=>{\n                        delete config.extends;\n                        let mergedConfig = $.extend({}, baseConfigResult, config);\n                        if (config.globals) {\n                            delete config.globals;\n                        }\n                        resolve(mergedConfig);\n                    }).catch(()=>{\n                        let extendDisplayPath = ProjectManager.makeProjectRelativeIfPossible(extendFile.fullPath);\n                        extendDisplayPath = ProjectManager.getProjectRelativeOrDisplayPath(extendDisplayPath);\n                        reject(StringUtils.format(Strings.JSHINT_CONFIG_JSON_ERROR, extendDisplayPath));\n                    });\n                } else {\n                    resolve(config);\n                }\n            }).fail((err)=>{\n                if(err === FileSystemError.NOT_FOUND){\n                    resolve(null); // no config file is a valid case. we just resolve with null\n                    return;\n                }\n                console.error(\"Error reading JSHint Config File\", configFilePath, err);\n                reject(StringUtils.format(Strings.JSHINT_CONFIG_ERROR, displayPath));\n            });\n        });\n    }\n\n    function _reloadOptions() {\n        projectSpecificOptions = null;\n        jsHintConfigFileErrorMessage = null;\n        const scanningProjectPath = ProjectManager.getProjectRoot().fullPath;\n        _readConfig(scanningProjectPath, CONFIG_FILE_NAME).then((config)=>{\n            if(scanningProjectPath !== ProjectManager.getProjectRoot().fullPath){\n                // this is a rare race condition where the user switches project between the get document call.\n                // Eg. in integ tests. do nothing as another scan for the new project will be in progress.\n                return;\n            }\n            if(config) {\n                Metrics.countEvent(Metrics.EVENT_TYPE.LINT, \"jsHint\", \"config\");\n            }\n            projectSpecificOptions = config;\n            jsHintConfigFileErrorMessage = null;\n            CodeInspection.requestRun(Strings.JSHINT_NAME);\n        }).catch((err)=>{\n            if(scanningProjectPath !== ProjectManager.getProjectRoot().fullPath){\n                return;\n            }\n            Metrics.countEvent(Metrics.EVENT_TYPE.LINT, \"jsHintConfig\", \"error\");\n            jsHintConfigFileErrorMessage = err;\n            CodeInspection.requestRun(Strings.JSHINT_NAME);\n        });\n    }\n\n    function isJSHintConfigActive() {\n        return !!(jsHintConfigFileErrorMessage || projectSpecificOptions);\n    }\n\n    function _projectFileChanged(_evt, changedPath, addedSet, removedSet) {\n        let configPath = path.join(ProjectManager.getProjectRoot().fullPath, CONFIG_FILE_NAME);\n        if(changedPath === configPath || addedSet.has(configPath)){\n            _reloadOptions();\n        } else if(removedSet.has(configPath)){\n            projectSpecificOptions = null;\n            jsHintConfigFileErrorMessage = null;\n        }\n    }\n\n    AppInit.appReady(function () {\n        ProjectManager.on(ProjectManager.EVENT_PROJECT_CHANGED_OR_RENAMED_PATH, _projectFileChanged);\n        ProjectManager.on(ProjectManager.EVENT_PROJECT_OPEN, _reloadOptions);\n        _reloadOptions();\n    });\n\n    // Register for JS files\n    CodeInspection.register(\"javascript\", {\n        name: Strings.JSHINT_NAME,\n        scanFileAsync: lintOneFile,\n        canInspect: function (fullPath) {\n            return !prefs.get(PREFS_JSHINT_DISABLED) && fullPath && !fullPath.endsWith(\".min.js\")\n                && (isJSHintConfigActive() || !ESLint.isESLintActive());\n            // if there is no linter, then we use jsHint as the default linter as it works in browser and native apps.\n            // remove ESLint.isESLintActive() once we add typescript language service that supports browser.\n        }\n    });\n\n    exports.isJSHintConfigActive = isJSHintConfigActive;\n});\n"],"file":"JSHint.js"}