{"version":3,"sources":["filesystem/FileSystem.js"],"names":["define","require","exports","module","Directory","File","FileIndex","FileSystemError","RemoteFile","WatchedRoot","EventDispatcher","PathUtils","_","_fileProtocolPlugins","MAX_DEDUPE_NUMBER","registerProtocolAdapter","protocol","adapter","adapters","push","sort","a","b","priority","_getProtocolAdapter","filePath","protocolAdapters","selectedAdapter","forEach","canRead","FileSystem","this","_index","_watchedRoots","_watchRequests","_externalChanges","makeEventDispatcher","prototype","_impl","_activeChangeCount","_getActiveChangeCount","_triggerExternalChangesNow","info","_handleExternalChange","path","stat","length","_enqueueExternalChange","_dequeueWatchRequest","request","fn","call","callbackArgs","arguments","cb","apply","shift","bind","_enqueueWatchRequest","_findWatchedRootForPath","fullPath","watchedRoot","Object","keys","some","watchedPath","indexOf","_watchOrUnwatchEntry","entry","callback","shouldWatch","impl","commandName","filterGitIgnore","requestCb","_watchEntry","_unwatchEntry","err","visitAll","child","_clearCachedData","init","console","assert","changeCallback","offlineCallback","_unwatchAll","initWatchers","close","unwatchAll","clear","alwaysIndex","doNotRemoveFromIndex","_beginChange","_endChange","error","isAbsolutePath","_DUPLICATED_SLASH_RE","_instance","_getNewPath","suggestedPath","isDir","i","pathLib","normalize","dir","dirname","extName","extname","baseName","basename","join","_wrap","func","_normalizePath","isDirectory","Error","isUNCPath","normalizeUNCPaths","search","replace","segments","split","splice","Phoenix","VFS","ensureTrailingSlash","addEntryForPathIfRequired","fileEntry","getEntry","addEntry","_getEntryForPath","EntryConstructor","getFileForPath","virtualServingPath","getPathForVirtualServingURL","parseUrl","protocolAdapter","fileImpl","copy","src","dst","self","async","target","isFile","parentDir","window","realPath","getDirectoryForPath","_handleDirectoryChange","added","removed","_isWatched","_fireChangeEvent","getFreePath","newPath","exists","existsAsync","TOO_MANY_ENTRIES","NOT_FOUND","resolve","normalizedPath","item","_stat","resolveAsync","Promise","reject","showOpenDialog","allowMultipleSelection","chooseDirectories","title","initialPath","fileTypes","showSaveDialog","proposedNewFilename","_fireRenameEvent","oldPath","trigger","_handleRename","oldFullPath","newFullPath","entryRenamed","directory","oldContents","_contents","getContents","contents","addedEntries","filter","removedEntries","name","parentPath","addedCounter","removedCounter","counter","watchOrUnwatchCallback","oldStat","mtime","getTime","getAllDirectoryContents","filterNothing","visitor","visit","visitHiddenTree","clearAllCaches","watch","watchingParentRoot","status","STARTING","ACTIVE","watchingChildRoot","warn","unwatch","INACTIVE","removeEntry","ROOT_NOT_WATCHED","on","event","handler","off","_FileSystem","HTTP_PROTOCOL","HTTPS_PROTOCOL","TAURI_PROTOCOL","TAURI_ASSET_PROTOCOL","setFileTreeFilter","fileTreeFilter"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*global Phoenix*/\n\n// @INCLUDE_IN_API_DOCS\n\n\n/**\n * FileSystem is a model object representing a complete file system. This object creates\n * and manages File and Directory instances, dispatches events when the file system changes,\n * and provides methods for showing 'open' and 'save' dialogs.\n *\n * FileSystem automatically initializes when loaded. It depends on a pluggable \"impl\" layer, which\n * it loads itself but must be designated in the require.config() that loads FileSystem. For details\n * see: https://github.com/adobe/brackets/wiki/File-System-Implementations\n *\n * There are three ways to get File or Directory instances:\n *    * Use FileSystem.resolve() to convert a path to a File/Directory object. This will only\n *      succeed if the file/directory already exists.\n *    * Use FileSystem.getFileForPath()/FileSystem.getDirectoryForPath() if you know the\n *      file/directory already exists, or if you want to create a new entry.\n *    * Use Directory.getContents() to return all entries for the specified Directory.\n *\n * All paths passed *to* FileSystem APIs must be in the following format:\n *    * The path separator is \"/\" regardless of platform\n *    * Paths begin with \"/\" on Mac/Linux and \"c:/\" (or some other drive letter) on Windows\n *\n * All paths returned *from* FileSystem APIs additionally meet the following guarantees:\n *    * No \"..\" segments\n *    * No consecutive \"/\"s\n *    * Paths to a directory always end with a trailing \"/\"\n * (Because FileSystem normalizes paths automatically, paths passed *to* FileSystem do not need\n * to meet these requirements)\n *\n * FileSystem dispatches the following events:\n * (NOTE: attach to these events via `FileSystem.on()` - not `$(FileSystem).on()`)\n *\n * __change__ - Sent whenever there is a change in the file system. The handler\n *   is passed up to three arguments: the changed entry and, if that changed entry\n *   is a Directory, a list of entries added to the directory and a list of entries\n *   removed from the Directory. The entry argument can be:\n *   *  a File - the contents of the file have changed, and should be reloaded.\n *   *  a Directory - an immediate child of the directory has been added, removed,\n *      or renamed/moved. Not triggered for \"grandchildren\".\n *      - If the added & removed arguments are null, we don't know what was added/removed:\n *        clients should assume the whole subtree may have changed.\n *      - If the added & removed arguments are 0-length, there's no net change in the set\n *        of files but a file may have been replaced: clients should assume the contents\n *        of any immediate child file may have changed.\n *   *  null - a 'wholesale' change happened, and you should assume everything may\n *      have changed.\n *   For changes made externally, there may be a significant delay before a \"change\" event\n *   is dispatched.\n *\n * __rename__ - Sent whenever a File or Directory is renamed. All affected File and Directory\n *   objects have been updated to reflect the new path by the time this event is dispatched.\n *   This event should be used to trigger any UI updates that may need to occur when a path\n *   has changed. Note that these events will only be sent for rename operations that happen\n *   within the filesystem. If a file is renamed externally, a change event on the parent\n *   directory will be sent instead.\n *\n * FileSystem may perform caching. But it guarantees:\n *    * File contents & metadata - reads are guaranteed to be up to date (cached data is not used\n *      without first veryifying it is up to date).\n *    * Directory structure / file listing - reads may return cached data immediately, which may not\n *      reflect external changes made recently. (However, changes made via FileSystem itself are always\n *      reflected immediately, as soon as the change operation's callback signals success).\n *\n * The FileSystem doesn't directly read or write contents--this work is done by a low-level\n * implementation object. This allows client code to use the FileSystem API without having to\n * worry about the underlying storage, which could be a local filesystem or a remote server.\n */\ndefine(function (require, exports, module) {\n\n\n    const Directory = require(\"filesystem/Directory\"),\n        File = require(\"filesystem/File\"),\n        FileIndex = require(\"filesystem/FileIndex\"),\n        FileSystemError = require(\"filesystem/FileSystemError\"),\n        RemoteFile = require(\"filesystem/RemoteFile\"),\n        WatchedRoot = require(\"filesystem/WatchedRoot\"),\n        EventDispatcher = require(\"utils/EventDispatcher\"),\n        PathUtils = require(\"thirdparty/path-utils/path-utils\"),\n        _ = require(\"thirdparty/lodash\");\n\n\n    // Collection of registered protocol adapters\n    let _fileProtocolPlugins = {};\n    const MAX_DEDUPE_NUMBER = 1000; // Eg: folder (copy 1000)\n\n    /**\n     * Typical signature of a file protocol adapter.\n     * @typedef {Object} FileProtocol~Adapter\n     * @property {Number} priority - Indicates the priority.\n     * @property {Object} fileImpl - Handle for the custom file implementation prototype.\n     * @property {function} canRead - To check if this impl can read a file for a given path.\n     */\n\n    /**\n     * FileSystem hook to register file protocol adapter\n     * @param {string} protocol ex: \"https:\"|\"http:\"|\"ftp:\"|\"file:\"\n     * @param {...FileProtocol~Adapter} adapter wrapper over file implementation\n     */\n    function registerProtocolAdapter(protocol, adapter) {\n        var adapters;\n        if (protocol) {\n            adapters = _fileProtocolPlugins[protocol] || [];\n            adapters.push(adapter);\n\n            // We will keep a sorted adapter list on 'priority'\n            // If priority is not provided a default of '0' is assumed\n            adapters.sort(function (a, b) {\n                return (b.priority || 0) - (a.priority || 0);\n            });\n\n            _fileProtocolPlugins[protocol] = adapters;\n        }\n    }\n\n    /**\n     * @private\n     * @param {string} protocol ex: \"https:\"|\"http:\"|\"ftp:\"|\"file:\"\n     * @param {string} filePath fullPath of the file\n     * @return adapter adapter wrapper over file implementation\n     */\n    function _getProtocolAdapter(protocol, filePath) {\n        var protocolAdapters = _fileProtocolPlugins[protocol] || [],\n            selectedAdapter;\n\n        // Find the fisrt compatible adapter having highest priority\n        _.forEach(protocolAdapters, function (adapter) {\n            if (adapter.canRead && adapter.canRead(filePath)) {\n                selectedAdapter = adapter;\n                // Break at first compatible adapter\n                return false;\n            }\n        });\n\n        return selectedAdapter;\n    }\n\n    /**\n     * The FileSystem is not usable until init() signals its callback.\n     * @private\n     * @constructor\n     */\n    function FileSystem() {\n        // Create a file index\n        this._index = new FileIndex();\n\n        // Initialize the set of watched roots\n        this._watchedRoots = {};\n\n        // Initialize the watch/unwatch request queue\n        this._watchRequests = [];\n\n        // Initialize the queue of pending external changes\n        this._externalChanges = [];\n    }\n    EventDispatcher.makeEventDispatcher(FileSystem.prototype);\n\n    /**\n     * The low-level file system implementation used by this object.\n     * This is set in the init() function and cannot be changed.\n     * @private\n     */\n    FileSystem.prototype._impl = null;\n\n    /**\n     * The FileIndex used by this object. This is initialized in the constructor.\n     * @private\n     */\n    FileSystem.prototype._index = null;\n\n    /**\n     * Refcount of any pending filesystem mutation operations (e.g., writes,\n     * unlinks, etc.). Used to ensure that external change events aren't processed\n     * until after index fixups, operation-specific callbacks, and internal change\n     * events are complete. (This is important for distinguishing rename from\n     * an unrelated delete-add pair).\n     * @private\n     * @type {number}\n     */\n    FileSystem.prototype._activeChangeCount = 0;\n\n    // For unit testing only\n    FileSystem.prototype._getActiveChangeCount = function () {\n        return this._activeChangeCount;\n    };\n\n    /**\n     * Queue of arguments with which to invoke _handleExternalChanges(); triggered\n     * once _activeChangeCount drops to zero.\n     * @private\n     * @type {!{path:?string, stat:FileSystemStats}}\n     */\n    FileSystem.prototype._externalChanges = null;\n\n    /**\n     * Process all queued watcher results, by calling _handleExternalChange() on each\n     * @private\n     */\n    FileSystem.prototype._triggerExternalChangesNow = function () {\n        this._externalChanges.forEach(function (info) {\n            this._handleExternalChange(info.path, info.stat);\n        }, this);\n        this._externalChanges.length = 0;\n    };\n\n    /**\n     * Receives a result from the impl's watcher callback, and either processes it\n     * immediately (if _activeChangeCount is 0) or otherwise stores it for later\n     * processing.\n     * @private\n     * @param {?string} path The fullPath of the changed entry\n     * @param {FileSystemStats=} stat An optional stat object for the changed entry\n     */\n    FileSystem.prototype._enqueueExternalChange = function (path, stat) {\n        this._externalChanges.push({ path: path, stat: stat });\n        if (!this._activeChangeCount) {\n            this._triggerExternalChangesNow();\n        }\n    };\n\n\n    /**\n     * The queue of pending watch/unwatch requests.\n     * @private\n     * @type {{fn: function(), cb: function()}} Array\n     */\n    FileSystem.prototype._watchRequests = null;\n\n    /**\n     * Dequeue and process all pending watch/unwatch requests\n     * @private\n     */\n    FileSystem.prototype._dequeueWatchRequest = function () {\n        if (this._watchRequests.length > 0) {\n            var request = this._watchRequests[0];\n\n            request.fn.call(null, function () {\n                // Apply the given callback\n                var callbackArgs = arguments;\n                try {\n                    request.cb.apply(null, callbackArgs);\n                } finally {\n                    // Process the remaining watch/unwatch requests\n                    this._watchRequests.shift();\n                    this._dequeueWatchRequest();\n                }\n            }.bind(this));\n        }\n    };\n\n    /**\n     * Enqueue a new watch/unwatch request.\n     * @private\n     * @param {function()} fn - The watch/unwatch request function.\n     * @param {callback()} cb - The callback for the provided watch/unwatch\n     *      request function.\n     */\n    FileSystem.prototype._enqueueWatchRequest = function (fn, cb) {\n        // Enqueue the given watch/unwatch request\n        this._watchRequests.push({ fn: fn, cb: cb });\n\n        // Begin processing the queue if it is not already being processed\n        if (this._watchRequests.length === 1) {\n            this._dequeueWatchRequest();\n        }\n    };\n\n    /**\n     * The set of watched roots, encoded as a mapping from full paths to WatchedRoot\n     * objects which contain a file entry, filter function, and an indication of\n     * whether the watched root is inactive, starting up or fully active.\n     * @private\n     * @type {Object.<string, WatchedRoot>}\n     */\n    FileSystem.prototype._watchedRoots = null;\n\n    /**\n    * Finds a parent watched root for a given path, or returns null if a parent\n    * watched root does not exist.\n    * @private\n    * @param {string} fullPath The child path for which a parent watched root is to be found.\n    * @return {?{entry: FileSystemEntry, filter: function(string): boolean}} The parent\n    *      watched root, if it exists, or null.\n    */\n\n    FileSystem.prototype._findWatchedRootForPath = function (fullPath) {\n        var watchedRoot = null;\n\n        Object.keys(this._watchedRoots).some(function (watchedPath) {\n            if (fullPath.indexOf(watchedPath) === 0) {\n                watchedRoot = this._watchedRoots[watchedPath];\n                return true;\n            }\n        }, this);\n\n        return watchedRoot;\n    };\n\n    /**\n     * Helper function to watch or unwatch a filesystem entry beneath a given\n     * watchedRoot.\n     *\n     * @private\n     * @param {FileSystemEntry} entry - The FileSystemEntry to watch. Must be a\n     *      non-strict descendent of watchedRoot.entry.\n     * @param {WatchedRoot} watchedRoot - See FileSystem._watchedRoots.\n     * @param {function(?string)} callback - A function that is called once the\n     *      watch is complete, possibly with a FileSystemError string.\n     * @param {boolean} shouldWatch - Whether the entry should be watched (true)\n     *      or unwatched (false).\n     */\n    FileSystem.prototype._watchOrUnwatchEntry = function (entry, watchedRoot, callback, shouldWatch) {\n        const impl = this._impl,\n            commandName = shouldWatch ? \"watchPath\" : \"unwatchPath\",\n            filterGitIgnore = watchedRoot.filterGitIgnore;\n\n        // The impl can watch the entire subtree with one call on the root (we also fall into this case for\n        // unwatch, although that never requires us to do the recursion - see similar final case below)\n        if (entry !== watchedRoot.entry) {\n            // Watch and unwatch calls to children of the watched root are\n            // no-ops if the impl supports recursiveWatch\n            callback(null);\n        } else {\n            // The impl will handle finding all subdirectories to watch.\n            this._enqueueWatchRequest(function (requestCb) {\n                impl[commandName].call(impl, entry.fullPath, filterGitIgnore, requestCb);\n            }.bind(this), callback);\n        }\n    };\n\n    /**\n     * Watch a filesystem entry beneath a given watchedRoot.\n     *\n     * @private\n     * @param {FileSystemEntry} entry - The FileSystemEntry to watch. Must be a\n     *      non-strict descendent of watchedRoot.entry.\n     * @param {WatchedRoot} watchedRoot - See FileSystem._watchedRoots.\n     * @param {function(?string)} callback - A function that is called once the\n     *      watch is complete, possibly with a FileSystemError string.\n     */\n    FileSystem.prototype._watchEntry = function (entry, watchedRoot, callback) {\n        this._watchOrUnwatchEntry(entry, watchedRoot, callback, true);\n    };\n\n    /**\n     * Unwatch a filesystem entry beneath a given watchedRoot.\n     *\n     * @private\n     * @param {FileSystemEntry} entry - The FileSystemEntry to watch. Must be a\n     *      non-strict descendent of watchedRoot.entry.\n     * @param {WatchedRoot} watchedRoot - See FileSystem._watchedRoots.\n     * @param {function(?string)} callback - A function that is called once the\n     *      watch is complete, possibly with a FileSystemError string.\n     */\n    FileSystem.prototype._unwatchEntry = function (entry, watchedRoot, callback) {\n        this._watchOrUnwatchEntry(entry, watchedRoot, function (err) {\n            // Make sure to clear cached data for all unwatched entries because\n            // entries always return cached data if it exists!\n            this._index.visitAll(function (child) {\n                if (child.fullPath.indexOf(entry.fullPath) === 0) {\n                    // 'true' so entry doesn't try to clear its immediate childrens' caches too. That would be redundant\n                    // with the visitAll() here, and could be slow if we've already cleared its parent (#7150).\n                    child._clearCachedData(true);\n                }\n            }.bind(this));\n\n            callback(err);\n        }.bind(this), false);\n    };\n\n    /**\n     * Initialize this FileSystem instance.\n     *\n     * @param {FileSystemImpl} impl The back-end implementation for this\n     *      FileSystem instance.\n     */\n    FileSystem.prototype.init = function (impl) {\n        console.assert(!this._impl, \"This FileSystem has already been initialized!\");\n\n        var changeCallback = this._enqueueExternalChange.bind(this),\n            offlineCallback = this._unwatchAll.bind(this);\n\n        this._impl = impl;\n        this._impl.initWatchers(changeCallback, offlineCallback);\n    };\n\n    /**\n     * Close a file system. Clear all caches, indexes, and file watchers.\n     */\n    FileSystem.prototype.close = function () {\n        this._impl.unwatchAll();\n        this._index.clear();\n    };\n\n    /**\n     * Will never remove the given file from index. Useful if you want to always hold cache the file.\n     */\n    FileSystem.prototype.alwaysIndex = function (filePath) {\n        this._index.doNotRemoveFromIndex(filePath);\n    };\n\n    /**\n     * Indicates that a filesystem-mutating operation has begun. As long as there\n     * are changes taking place, change events from the external watchers are\n     * blocked and queued, to be handled once changes have finished. This is done\n     * because for mutating operations that originate from within the filesystem,\n     * synthetic change events are fired that do not depend on external file\n     * watchers, and we prefer the former over the latter for the following\n     * reasons: 1) there is no delay; and 2) they may have higher fidelity ---\n     * e.g., a rename operation can be detected as such, instead of as a nearly\n     * simultaneous addition and deletion.\n     *\n     * All operations that mutate the file system MUST begin with a call to\n     * _beginChange and must end with a call to _endChange.\n     * @private\n     */\n    FileSystem.prototype._beginChange = function () {\n        this._activeChangeCount++;\n        //console.log(\"> beginChange  -> \" + this._activeChangeCount);\n    };\n\n    /**\n     * Indicates that a filesystem-mutating operation has completed. See\n     * FileSystem._beginChange above.\n     * @private\n     */\n    FileSystem.prototype._endChange = function () {\n        this._activeChangeCount--;\n        //console.log(\"< endChange    -> \" + this._activeChangeCount);\n\n        if (this._activeChangeCount < 0) {\n            console.error(\"FileSystem _activeChangeCount has fallen below zero!\");\n        }\n\n        if (!this._activeChangeCount) {\n            this._triggerExternalChangesNow();\n        }\n    };\n\n    /**\n     * Determines whether or not the supplied path is absolute, as opposed to relative.\n     *\n     * @param {!string} fullPath\n     * @return {boolean} True if the fullPath is absolute and false otherwise.\n     */\n    FileSystem.isAbsolutePath = function (fullPath) {\n        return (fullPath[0] === \"/\" || (fullPath[1] === \":\" && fullPath[2] === \"/\"));\n    };\n\n    /*\n     * Matches continguous groups of forward slashes\n     * @const\n     */\n    var _DUPLICATED_SLASH_RE = /\\/{2,}/g;\n\n    /**\n     * Returns a canonical version of the path: no duplicated \"/\"es, no \"..\"s,\n     * and directories guaranteed to end in a trailing \"/\"\n     * @private\n     * @param {!string} path  Absolute path, using \"/\" as path separator\n     * @param {boolean=} isDirectory\n     * @return {!string}\n     */\n    FileSystem.prototype._normalizePath = function (path, isDirectory) {\n\n        if (!FileSystem.isAbsolutePath(path)) {\n            throw new Error(\"Paths must be absolute: '\" + path + \"'\");  // expect only absolute paths\n        }\n\n        var isUNCPath = this._impl.normalizeUNCPaths && path.search(_DUPLICATED_SLASH_RE) === 0;\n\n        // Remove duplicated \"/\"es\n        path = path.replace(_DUPLICATED_SLASH_RE, \"/\");\n\n        // Remove \"..\" segments\n        if (path.indexOf(\"..\") !== -1) {\n            var segments = path.split(\"/\"),\n                i;\n            for (i = 1; i < segments.length; i++) {\n                if (segments[i] === \"..\") {\n                    if (i < 2) {\n                        throw new Error(\"Invalid absolute path: '\" + path + \"'\");\n                    }\n                    segments.splice(i - 1, 2);\n                    i -= 2; // compensate so we start on the right index next iteration\n                }\n            }\n            path = segments.join(\"/\");\n        }\n\n        if (isDirectory) {\n            // Make sure path DOES include trailing slash\n            path = Phoenix.VFS.ensureTrailingSlash(path);\n        }\n\n        if (isUNCPath) {\n            // Restore the leading double slash that was removed previously\n            path = \"/\" + path;\n        }\n\n        return path;\n    };\n\n    /**\n     * This method adds an entry for a file in the file Index. Files on disk are added\n     * to the file index either on load or on open. This method is primarily needed to add\n     * in memory files to the index\n     *\n     * @param {File} The fileEntry which needs to be added\n     * @param {String} The full path to the file\n     */\n    FileSystem.prototype.addEntryForPathIfRequired = function (fileEntry, path) {\n        var entry = this._index.getEntry(path);\n\n        if (!entry) {\n            this._index.addEntry(fileEntry);\n        }\n    };\n\n    /**\n     * Return a (strict subclass of a) FileSystemEntry object for the specified\n     * path using the provided constuctor. For now, the provided constructor\n     * should be either File or Directory.\n     *\n     * @private\n     * @param {function(string, FileSystem)} EntryConstructor Constructor with\n     *      which to initialize new FileSystemEntry objects.\n     * @param {string} path Absolute path of file.\n     * @return {File|Directory} The File or Directory object. This file may not\n     *      yet exist on disk.\n     */\n    FileSystem.prototype._getEntryForPath = function (EntryConstructor, path) {\n        var isDirectory = EntryConstructor === Directory;\n        path = this._normalizePath(path, isDirectory);\n        var entry = this._index.getEntry(path);\n\n        if (!entry) {\n            entry = new EntryConstructor(path, this);\n            this._index.addEntry(entry);\n        }\n\n        return entry;\n    };\n\n    /**\n     * Return a File object for the specified path.\n     *\n     * @param {string} path Absolute path of file.\n     *\n     * @return {File} The File object. This file may not yet exist on disk.\n     */\n    FileSystem.prototype.getFileForPath = function (path) {\n        let virtualServingPath = Phoenix.VFS.getPathForVirtualServingURL(path);\n        if (virtualServingPath) {\n            // this is so that extensions that load from an http path can figure out the actual file system path\n            // from just the virtual serving URL.\n            // FileSystem.getDirectoryForPath(ExtensionUtils.getModulePath(module, \"some FolderInModule/\"))\n            path = virtualServingPath;\n        }\n        var protocol = PathUtils.parseUrl(path).protocol,\n            protocolAdapter = _getProtocolAdapter(protocol);\n\n        if (protocolAdapter && protocolAdapter.fileImpl) {\n            return new protocolAdapter.fileImpl(protocol, path, this);\n        }\n        return this._getEntryForPath(File, path);\n\n    };\n\n    function _getNewPath(suggestedPath, isDir, i, pathLib) {\n        suggestedPath = pathLib.normalize(suggestedPath);\n        if (isDir) {\n            return `${suggestedPath} (copy ${i})`;\n        } else {\n            const dir = pathLib.dirname(suggestedPath),\n                extName = pathLib.extname(suggestedPath),\n                baseName = pathLib.basename(suggestedPath, extName);\n            return pathLib.join(dir, `${baseName}(copy ${i})${extName}`);\n        }\n    }\n\n    /**\n     * copies a file/folder path from src to destination recursively. follows unix copy semantics mostly.\n     * As with unix copy, the destination path may not be exactly the `dst` path provided.\n     * Eg. copy(\"/a/b\", \"/a/x\") -> will copy to `/a/x/b` if folder `/a/x` exists. If dst `/a/x` not exists,\n     * then copy will honor the given destination `/a/x`\n     *\n     * @param {string} src Absolute path of file or directory to copy\n     * @param {string} dst Absolute path of file or directory destination\n     * @param {function(err, string)} callback Callback with err or stat of copied destination.\n     */\n    FileSystem.prototype.copy = function (src, dst, callback) {\n        let self = this;\n        // Block external change events until after the write has finished\n        self._beginChange();\n        self._impl.copy(src, dst, async function (err, stat) {\n            if (err) {\n                callback(err);\n                self._endChange();\n                return;\n            }\n            let target;\n            if (stat.isFile) {\n                let parentDir = window.path.dirname(stat.realPath);\n                target = self.getDirectoryForPath(parentDir);\n            } else {\n                target = self.getDirectoryForPath(stat.realPath);\n            }\n            self._handleDirectoryChange(target, function (added, removed) {\n                try {\n                    callback(null, stat);\n                } finally {\n                    if (target._isWatched()) {\n                        self._fireChangeEvent(target, added, removed);\n                    }\n                    // Unblock external change events\n                    self._endChange();\n                }\n            });\n        });\n    };\n\n    /**\n     * Return a path that is free to use for the given suggestedPath.\n     * If suggestedPath is, Eg: `/a/b/dir` , then if `/a/b/dir` does not exist, it will be returned as is.\n     *\n     * if suggestedPath exists and is a dir, then the next available path will be returned like\n     * `/a/b/dir(copy)`, /a/b/dir(copy 1)`...\n     *\n     * if suggestedPath exists and is a file say `/a/b/test.html`, then the next available path will be returned like\n     * `/a/b/test (copy).html`, /a/b/test (copy 1).html`...\n     *\n     * @param {string} suggestedPath Absolute path of file or directory to check if free.\n     * @param {function(err, string)} callback Callback with err or Absolute path that is free to use.\n     */\n    FileSystem.prototype.getFreePath = function (suggestedPath, callback) {\n        let self = this;\n        self._impl.stat(suggestedPath, async function (err, stat) {\n            if (stat) {\n                // find a suggested path\n                let isDir = stat.isDirectory;\n                for (let i = 1; i < MAX_DEDUPE_NUMBER; i++) {\n                    let newPath = _getNewPath(suggestedPath, isDir, i, self._impl.pathLib);\n                    let exists = await self._impl.existsAsync(newPath);\n                    if (!exists) {\n                        callback(null, newPath);\n                        return;\n                    }\n                }\n                callback(FileSystemError.TOO_MANY_ENTRIES);\n                return;\n            } else if (err && err === FileSystemError.NOT_FOUND) {\n                callback(null, suggestedPath);\n                return;\n            }\n            callback(err);\n        });\n    };\n\n    /**\n     * Return a Directory object for the specified path.\n     *\n     * @param {string} path Absolute path of directory.\n     *\n     * @return {Directory} The Directory object. This directory may not yet exist on disk.\n     */\n    FileSystem.prototype.getDirectoryForPath = function (path) {\n        let virtualServingPath = Phoenix.VFS.getPathForVirtualServingURL(path);\n        if (virtualServingPath) {\n            // this is so that extensions that load from an http path can figure out the actual file system path\n            // from just the virtual serving URL.\n            // FileSystem.getDirectoryForPath(ExtensionUtils.getModulePath(module, \"some FolderInModule/\"))\n            path = virtualServingPath;\n        }\n        return this._getEntryForPath(Directory, path);\n    };\n\n    /**\n     * Resolve a path.\n     *\n     * @param {string} path The path to resolve\n     * @param {function (?string, FileSystemEntry=, FileSystemStats=)} callback Callback resolved\n     *      with a FileSystemError string or with the entry for the provided path.\n     */\n    FileSystem.prototype.resolve = function (path, callback) {\n        var normalizedPath = this._normalizePath(path, false),\n            item = this._index.getEntry(normalizedPath);\n\n        if (!item) {\n            normalizedPath = Phoenix.VFS.ensureTrailingSlash(normalizedPath);\n            item = this._index.getEntry(normalizedPath);\n        }\n\n        if (item) {\n            item.stat(function (err, stat) {\n                if (err) {\n                    callback(err);\n                    return;\n                }\n\n                callback(null, item, stat);\n            });\n        } else {\n            this._impl.stat(path, function (err, stat) {\n                if (err) {\n                    callback(err);\n                    return;\n                }\n\n                if (stat.isFile) {\n                    item = this.getFileForPath(path);\n                } else {\n                    item = this.getDirectoryForPath(path);\n                }\n\n                if (item._isWatched()) {\n                    item._stat = stat;\n                }\n\n                callback(null, item, stat);\n            }.bind(this));\n        }\n    };\n\n    /**\n     * Determine whether a file or directory exists at the given path\n     * resolved to a boolean, which is true if the file exists and false otherwise.\n     * The error will never be FileSystemError.NOT_FOUND; in that case, there will be no error and the\n     * boolean parameter will be false.\n     *\n     * @param {string} path\n     * @param {function(?string, boolean)} callback\n     */\n    FileSystem.prototype.existsAsync = function (path) {\n        return this._impl.existsAsync(path);\n    };\n\n    /**\n     * promisified version of FileSystem.resolve\n     * @param {String} path to resolve\n     * @returns {{'entry', 'stat'}}\n     */\n    FileSystem.prototype.resolveAsync = function (path) {\n        let self = this;\n        return new Promise((resolve, reject) => {\n            self.resolve(path, (err, item, stat) => {\n                if (err) {\n                    reject(err);\n                    return;\n                }\n                resolve({\n                    entry: item,\n                    stat: stat\n                });\n            });\n        });\n    };\n\n    /**\n     * Show an \"Open\" dialog and return the file(s)/directories selected by the user.\n     *\n     * @param {boolean} allowMultipleSelection Allows selecting more than one file at a time\n     * @param {boolean} chooseDirectories Allows directories to be opened\n     * @param {string} title The title of the dialog\n     * @param {string} initialPath The folder opened inside the window initially. If initialPath\n     *                          is not set, or it doesn't exist, the window would show the last\n     *                          browsed folder depending on the OS preferences\n     * @param {?Array.<string>} fileTypes (Currently *ignored* except on Mac - https://trello.com/c/430aXkpq)\n     *                          List of extensions that are allowed to be opened, without leading \".\".\n     *                          Null or empty array allows all files to be selected. Not applicable\n     *                          when chooseDirectories = true.\n     * @param {function (?string, Array.<string>=)} callback Callback resolved with a FileSystemError\n     *                          string or the selected file(s)/directories. If the user cancels the\n     *                          open dialog, the error will be falsy and the file/directory array will\n     *                          be empty.\n     */\n    FileSystem.prototype.showOpenDialog = function (allowMultipleSelection,\n        chooseDirectories,\n        title,\n        initialPath,\n        fileTypes,\n        callback) {\n\n        this._impl.showOpenDialog(allowMultipleSelection, chooseDirectories, title, initialPath, fileTypes, callback);\n    };\n\n    /**\n     * Show a \"Save\" dialog and return the path of the file to save.\n     *\n     * @param {string} title The title of the dialog.\n     * @param {string} initialPath The folder opened inside the window initially. If initialPath\n     *                          is not set, or it doesn't exist, the window would show the last\n     *                          browsed folder depending on the OS preferences.\n     * @param {string} proposedNewFilename Provide a new file name for the user. This could be based on\n     *                          on the current file name plus an additional suffix\n     * @param {function (?string, string=)} callback Callback that is resolved with a FileSystemError\n     *                          string or the name of the file to save. If the user cancels the save,\n     *                          the error will be falsy and the name will be empty.\n     */\n    FileSystem.prototype.showSaveDialog = function (title, initialPath, proposedNewFilename, callback) {\n        this._impl.showSaveDialog(title, initialPath, proposedNewFilename, callback);\n    };\n\n    /**\n     * Fire a rename event. Clients listen for these events using FileSystem.on.\n     * @private\n     * @param {string} oldPath The entry's previous fullPath\n     * @param {string} newPath The entry's current fullPath\n     */\n    FileSystem.prototype._fireRenameEvent = function (oldPath, newPath) {\n        this.trigger(\"rename\", oldPath, newPath);\n    };\n\n    /**\n     * Fire a change event. Clients listen for these events using FileSystem.on.\n     * @private\n     * @param {File|Directory} entry The entry that has changed\n     * @param {Array<File|Directory>=} added If the entry is a directory, this\n     *      is a set of new entries in the directory.\n     * @param {Array<File|Directory>=} removed If the entry is a directory, this\n     *      is a set of removed entries from the directory.\n     */\n    FileSystem.prototype._fireChangeEvent = function (entry, added, removed) {\n        this.trigger(\"change\", entry, added, removed);\n    };\n\n    /**\n     * @private\n     * Notify the system when an entry name has changed.\n     *\n     * @param {string} oldFullPath\n     * @param {string} newFullPath\n     * @param {boolean} isDirectory\n     */\n    FileSystem.prototype._handleRename = function (oldFullPath, newFullPath, isDirectory) {\n        // Update all affected entries in the index\n        this._index.entryRenamed(oldFullPath, newFullPath, isDirectory);\n    };\n\n    /**\n     * Notify the filesystem that the given directory has changed. Updates the filesystem's\n     * internal state as a result of the change, and calls back with the set of added and\n     * removed entries. Mutating FileSystemEntry operations should call this method before\n     * applying the operation's callback, and pass along the resulting change sets in the\n     * internal change event.\n     * @private\n     * @param {Directory} directory The directory that has changed.\n     * @param {function(Array<File|Directory>=, Array<File|Directory>=)} callback\n     *      The callback that will be applied to a set of added and a set of removed\n     *      FileSystemEntry objects.\n     */\n    FileSystem.prototype._handleDirectoryChange = function (directory, callback) {\n        var oldContents = directory._contents;\n\n        directory._clearCachedData();\n        directory.getContents(function (err, contents) {\n            var addedEntries = oldContents && contents.filter(function (entry) {\n                return oldContents.indexOf(entry) === -1;\n            });\n\n            var removedEntries = oldContents && oldContents.filter(function (entry) {\n                return contents.indexOf(entry) === -1;\n            });\n\n            // If directory is not watched, clear children's caches manually.\n            var watchedRoot = this._findWatchedRootForPath(directory.fullPath);\n            if (!watchedRoot || !watchedRoot.filter(directory.name, directory.parentPath)) {\n                this._index.visitAll(function (entry) {\n                    if (entry.fullPath.indexOf(directory.fullPath) === 0) {\n                        // Passing 'true' for a similar reason as in _unwatchEntry() - see #7150\n                        entry._clearCachedData(true);\n                    }\n                }.bind(this));\n\n                callback(addedEntries, removedEntries);\n                return;\n            }\n\n            var addedCounter = addedEntries ? addedEntries.length : 0,\n                removedCounter = removedEntries ? removedEntries.length : 0,\n                counter = addedCounter + removedCounter;\n\n            if (counter === 0) {\n                callback(addedEntries, removedEntries);\n                return;\n            }\n\n            var watchOrUnwatchCallback = function (err) {\n                if (err) {\n                    console.error(\"FileSystem error in _handleDirectoryChange after watch/unwatch entries: \" + err);\n                }\n\n                if (--counter === 0) {\n                    callback(addedEntries, removedEntries);\n                }\n            };\n\n            if (addedEntries) {\n                addedEntries.forEach(function (entry) {\n                    this._watchEntry(entry, watchedRoot, watchOrUnwatchCallback);\n                }, this);\n            }\n\n            if (removedEntries) {\n                removedEntries.forEach(function (entry) {\n                    this._unwatchEntry(entry, watchedRoot, watchOrUnwatchCallback);\n                }, this);\n            }\n        }.bind(this));\n    };\n\n    /**\n     * @private\n     * Processes a result from the file/directory watchers. Watch results are sent from the low-level implementation\n     * whenever a directory or file is changed.\n     *\n     * @param {string} path The path that changed. This could be a file or a directory.\n     * @param {FileSystemStats=} stat Optional stat for the item that changed. This param is not always\n     *         passed.\n     */\n    FileSystem.prototype._handleExternalChange = function (path, stat) {\n\n        if (!path) {\n            // This is a \"wholesale\" change event; clear all caches\n            this._index.visitAll(function (entry) {\n                // Passing 'true' for a similar reason as in _unwatchEntry() - see #7150\n                entry._clearCachedData(true);\n            });\n\n            this._fireChangeEvent(null);\n            return;\n        }\n\n        path = this._normalizePath(path, false);\n\n        var entry = this._index.getEntry(path);\n        if (entry) {\n            var oldStat = entry._stat;\n            if (entry.isFile) {\n                // Update stat and clear contents, but only if out of date\n                if (!(stat && oldStat && stat.mtime.getTime() <= oldStat.mtime.getTime())) {\n                    entry._clearCachedData();\n                    entry._stat = stat;\n                    this._fireChangeEvent(entry);\n                }\n            } else {\n                this._handleDirectoryChange(entry, function (added, removed) {\n                    entry._stat = stat;\n\n                    if (entry._isWatched()) {\n                        // We send a change even if added & removed are both zero-length. Something may still have changed,\n                        // e.g. a file may have been quickly removed & re-added before we got a chance to reread the directory\n                        // listing.\n                        this._fireChangeEvent(entry, added, removed);\n                    }\n                }.bind(this));\n            }\n        }\n    };\n\n    /**\n     * Recursively gets all files and directories given a root path. It filters out all files\n     * that are not shown in the file tree by default, unless the filterNothing option is specified.\n     *\n     * @param {Directory} directory The root directory to get all descendant contents from.\n     * @param {boolean} [filterNothing=false] If true, returns everything, including system locations like `.git`.\n     *     Use this option for full backups or entire disk read workflows.\n     * @return {Promise<Array<(File|Directory)>>} A promise that resolves with an array of file and directory contents.\n     */\n    FileSystem.prototype.getAllDirectoryContents = function (directory, filterNothing = false) {\n        return new Promise((resolve, reject) => {\n            let contents = [];\n            function visitor(entry) {\n                if (directory.fullPath !== entry.fullPath) {\n                    contents.push(entry);\n                }\n                return true;\n            }\n            directory.visit(visitor, { visitHiddenTree: filterNothing }, (err) => {\n                if (err) {\n                    reject(err);\n                    return;\n                }\n                resolve(contents);\n            });\n        });\n    };\n    /**\n     * Clears all cached content. Because of the performance implications of this, this should only be used if\n     * there is a suspicion that the file system has not been updated through the normal file watchers\n     * mechanism.\n     */\n    FileSystem.prototype.clearAllCaches = function () {\n        this._handleExternalChange(null);\n    };\n\n    /**\n     * Start watching a filesystem root entry.\n     *\n     * @param {FileSystemEntry} entry - The root entry to watch. If entry is a directory,\n     *      all subdirectories that aren't explicitly filtered will also be watched.\n     * @param {function(string): boolean} filter - Returns true if a particular item should\n     *      be watched, given its name (not full path). Items that are ignored are also\n     *      filtered from Directory.getContents() results within this subtree.\n     * @param {string|Array<string>} filterGitIgnore - GitIgnore file contents or as arrayof strings for\n     *      filtering out events on the node side.\n     * @param {function(?string)=} callback - A function that is called when the watch has\n     *      completed. If the watch fails, the function will have a non-null FileSystemError\n     *      string parametr.\n     */\n    FileSystem.prototype.watch = function (entry, filter, filterGitIgnore, callback) {\n        // make filterGitIgnore an optional argument to stay backwards compatible\n        if (typeof callback === \"undefined\" && typeof filterGitIgnore === \"function\") {\n            callback = filterGitIgnore;\n            filterGitIgnore = null;\n        }\n\n        var fullPath = entry.fullPath;\n\n        callback = callback || function () { };\n\n        var watchingParentRoot = this._findWatchedRootForPath(fullPath);\n        if (watchingParentRoot &&\n            (watchingParentRoot.status === WatchedRoot.STARTING ||\n                watchingParentRoot.status === WatchedRoot.ACTIVE)) {\n            callback(\"A parent of this root is already watched\");\n            return;\n        }\n\n        var watchingChildRoot = Object.keys(this._watchedRoots).some(function (path) {\n            var watchedRoot = this._watchedRoots[path],\n                watchedPath = watchedRoot.entry.fullPath;\n\n            return watchedPath.indexOf(fullPath) === 0;\n        }, this);\n\n        if (watchingChildRoot &&\n            (watchingChildRoot.status === WatchedRoot.STARTING ||\n                watchingChildRoot.status === WatchedRoot.ACTIVE)) {\n            callback(\"A child of this root is already watched\");\n            return;\n        }\n\n        const watchedRoot = new WatchedRoot(entry, filter, filterGitIgnore);\n\n        this._watchedRoots[fullPath] = watchedRoot;\n\n        // Enter the STARTING state early to indiate that watched Directory\n        // objects may cache their contents. See FileSystemEntry._isWatched.\n        watchedRoot.status = WatchedRoot.STARTING;\n\n        this._watchEntry(entry, watchedRoot, function (err) {\n            if (err) {\n                console.warn(\"Failed to watch root: \", entry.fullPath, err);\n                delete this._watchedRoots[fullPath];\n                callback(err);\n                return;\n            }\n\n            watchedRoot.status = WatchedRoot.ACTIVE;\n\n            callback(null);\n        }.bind(this));\n    };\n\n    /**\n     * Stop watching a filesystem root entry.\n     *\n     * @param {FileSystemEntry} entry - The root entry to stop watching. The unwatch will\n     *      if the entry is not currently being watched.\n     * @param {function(?string)=} callback - A function that is called when the unwatch has\n     *      completed. If the unwatch fails, the function will have a non-null FileSystemError\n     *      string parameter.\n     */\n    FileSystem.prototype.unwatch = function (entry, callback) {\n        var fullPath = entry.fullPath,\n            watchedRoot = this._watchedRoots[fullPath];\n\n        callback = callback || function () { };\n\n        if (!watchedRoot) {\n            callback(FileSystemError.ROOT_NOT_WATCHED);\n            return;\n        }\n\n        // Mark this as inactive, but don't delete the entry until the unwatch is complete.\n        // This is useful for making sure we don't try to concurrently watch overlapping roots.\n        watchedRoot.status = WatchedRoot.INACTIVE;\n\n        this._unwatchEntry(entry, watchedRoot, function (err) {\n            delete this._watchedRoots[fullPath];\n\n            this._index.visitAll(function (child) {\n                if (child.fullPath.indexOf(entry.fullPath) === 0) {\n                    this._index.removeEntry(child);\n                }\n            }.bind(this));\n\n            if (err) {\n                console.warn(\"Failed to unwatch root: \", entry.fullPath, err);\n                callback(err);\n                return;\n            }\n\n            callback(null);\n        }.bind(this));\n    };\n\n    /**\n     * Unwatch all watched roots. Calls unwatch on the underlying impl for each\n     * watched root and ignores errors.\n     * @private\n     */\n    FileSystem.prototype._unwatchAll = function () {\n        console.warn(\"File watchers went offline!\");\n\n        Object.keys(this._watchedRoots).forEach(function (path) {\n            var watchedRoot = this._watchedRoots[path];\n\n            watchedRoot.status = WatchedRoot.INACTIVE;\n            delete this._watchedRoots[path];\n            this._unwatchEntry(watchedRoot.entry, watchedRoot, function () {\n                console.warn(\"Watching disabled for\", watchedRoot.entry.fullPath);\n            });\n        }, this);\n\n        // Fire a wholesale change event, clearing all caches and request that\n        // clients manually update their state.\n        this._handleExternalChange(null);\n    };\n\n\n    // The singleton instance\n    var _instance;\n\n    function _wrap(func) {\n        return function () {\n            return func.apply(_instance, arguments);\n        };\n    }\n\n    // Export public methods as proxies to the singleton instance\n    exports.init = _wrap(FileSystem.prototype.init);\n    exports.close = _wrap(FileSystem.prototype.close);\n    exports.getFileForPath = _wrap(FileSystem.prototype.getFileForPath);\n    exports.addEntryForPathIfRequired = _wrap(FileSystem.prototype.addEntryForPathIfRequired);\n    exports.getDirectoryForPath = _wrap(FileSystem.prototype.getDirectoryForPath);\n    exports.resolve = _wrap(FileSystem.prototype.resolve);\n    exports.resolveAsync = _wrap(FileSystem.prototype.resolveAsync);\n    exports.showOpenDialog = _wrap(FileSystem.prototype.showOpenDialog);\n    exports.showSaveDialog = _wrap(FileSystem.prototype.showSaveDialog);\n    exports.watch = _wrap(FileSystem.prototype.watch);\n    exports.unwatch = _wrap(FileSystem.prototype.unwatch);\n    exports.clearAllCaches = _wrap(FileSystem.prototype.clearAllCaches);\n    exports.alwaysIndex = _wrap(FileSystem.prototype.alwaysIndex);\n    exports.getFreePath = _wrap(FileSystem.prototype.getFreePath);\n    exports.copy = _wrap(FileSystem.prototype.copy);\n    exports.existsAsync = _wrap(FileSystem.prototype.existsAsync);\n    exports.getAllDirectoryContents = _wrap(FileSystem.prototype.getAllDirectoryContents);\n\n    // Static public utility methods\n    exports.isAbsolutePath = FileSystem.isAbsolutePath;\n    exports.registerProtocolAdapter = registerProtocolAdapter;\n\n    // For testing only\n    exports._getActiveChangeCount = _wrap(FileSystem.prototype._getActiveChangeCount);\n\n    /**\n     * Add an event listener for a FileSystem event.\n     *\n     * @param {string} event The name of the event\n     * @param {function} handler The handler for the event\n     */\n    exports.on = function (event, handler) {\n        _instance.on(event, handler);\n    };\n\n    /**\n     * Remove an event listener for a FileSystem event.\n     *\n     * @param {string} event The name of the event\n     * @param {function} handler The handler for the event\n     */\n    exports.off = function (event, handler) {\n        _instance.off(event, handler);\n    };\n\n    // Export the FileSystem class as \"private\" for unit testing only.\n    exports._FileSystem = FileSystem;\n\n    // Create the singleton instance\n    _instance = new FileSystem();\n\n    // Initialize the singleton instance\n    _instance.init(require(\"fileSystemImpl\"));\n\n    // attach remote file handlers\n    var HTTP_PROTOCOL = \"http:\",\n        HTTPS_PROTOCOL = \"https:\",\n        TAURI_PROTOCOL = \"phtauri:\",\n        TAURI_ASSET_PROTOCOL = \"asset:\";\n\n    var protocolAdapter = {\n        priority: 0, // Default priority\n        fileImpl: RemoteFile,\n        canRead: function (filePath) {\n            return true; // Always claim true, we are the default adpaters\n        }\n    };\n\n    // private api\n    function setFileTreeFilter(filter) {\n        exports.fileTreeFilter = filter;\n    }\n\n    // private API\n    exports.setFileTreeFilter = setFileTreeFilter;\n\n    // Register the custom object as HTTP and HTTPS protocol adapter\n    registerProtocolAdapter(HTTP_PROTOCOL, protocolAdapter);\n    registerProtocolAdapter(HTTPS_PROTOCOL, protocolAdapter);\n    registerProtocolAdapter(TAURI_PROTOCOL, protocolAdapter);\n    registerProtocolAdapter(TAURI_ASSET_PROTOCOL, protocolAdapter);\n});\n"],"file":"FileSystem.js"}