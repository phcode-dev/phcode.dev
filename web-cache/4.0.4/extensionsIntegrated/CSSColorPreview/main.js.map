{"version":3,"sources":["extensionsIntegrated/CSSColorPreview/main.js"],"names":["define","require","exports","module","_","EditorManager","ColorUtils","AppInit","Editor","PreferencesManager","MainViewManager","Commands","CommandManager","Strings","COLOR_REGEX","GUTTER_NAME","DUMMY_GUTTER_CLASS","SINGLE_COLOR_PREVIEW_CLASS","MULTI_COLOR_PREVIEW_CLASS","COLOR_MARK_NAME","COLOR_PREVIEW_GUTTER_PRIORITY","COLOR_LANGUAGES","SVG_REGEX","CSS_REGEX","PREFERENCES_CSS_COLOR_PREVIEW","enabled","showColorMarks","editor","getActiveEditor","isGutterActive","showGutters","_getAllColorsAndLineNums","addColorMarksToAllEditors","allActiveEditors","getAllViewedEditors","forEach","activeEditor","currEditor","aColors","_colorIconClicked","lineNumber","colorValue","lineText","getLine","colorIndex","indexOf","currentPos","getCursorPos","line","ch","setCursorPos","focus","setTimeout","execute","TOGGLE_QUICK_EDIT","_results","update","operation","clearGutter","_addDummyGutterMarkerIfNotExist","colorGutters","sortBy","obj","lineHandle","$marker","colorValues","length","$","addClass","css","color","setGutterMarker","click","event","preventDefault","stopPropagation","lineNo","positions","top","left","right","bottom","index","$colorBox","background-color","append","mouseenter","_applyInlineColor","mouseleave","clearAllMarks","marker","getGutterMarker","_cursorActivity","_evt","_currentlyColorMarkedLine","registerHandlers","off","onChanged","on","newEditor","oldEditor","_colorMark","from","to","markText","colors","detectValidColorsInLine","preferenceChanged","value","get","registerGutter","unregisterGutter","definePreference","description","DESCRIPTION_CSS_COLOR_PREVIEW","STYLE_PARSE_LANGUAGES","php","jsx","tsx","_isInStyleAttr","token","type","currentToken","getPreviousToken","start","end","string","_shouldProcessToken","pos","languageID","document","getLanguage","getId","getLanguageForPosition","isAlphanumeric","char","test","_isColor","segment","colorInSegment","previousChar","charAt","endIndex","nextChar","valueRegex","validColors","lineMatches","matchAll","lineMatch","colorMatches","colorMatch","getToken","push","nLen","lineCount","i","updateColorMarks","fromLineNumber","toLineNumber","instance","changeList","changeObj","origin","toLine","text","Math","max","appReady"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2024 [cmgddd](https://github.com/cmgddd/Brackets-css-color-preview). All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n\n/* Displays a color preview in the gutter for any file containing color values */\n/* Styles on `styles/brackets.less` file */\n\ndefine(function (require, exports, module) {\n\n    // Brackets modules.\n    const _                 = require(\"thirdparty/lodash\"),\n        EditorManager       = require('editor/EditorManager'),\n        ColorUtils          = require('utils/ColorUtils'),\n        AppInit             = require(\"utils/AppInit\"),\n        Editor              = require(\"editor/Editor\").Editor,\n        PreferencesManager  = require(\"preferences/PreferencesManager\"),\n        MainViewManager     = require(\"view/MainViewManager\"),\n        Commands            = require(\"command/Commands\"),\n        CommandManager      = require(\"command/CommandManager\"),\n        Strings             = require(\"strings\");\n\n    // Extension variables.\n    const COLOR_REGEX       = ColorUtils.COLOR_REGEX,    // used to match color\n        GUTTER_NAME          = \"CodeMirror-colorGutter\",\n        DUMMY_GUTTER_CLASS   = \"CodeMirror-colorGutter-none\",\n        SINGLE_COLOR_PREVIEW_CLASS   = \"ico-cssColorPreview\",\n        MULTI_COLOR_PREVIEW_CLASS   = \"ico-multiple-cssColorPreview\",\n        COLOR_MARK_NAME = \"colorMarker\",\n        COLOR_PREVIEW_GUTTER_PRIORITY = 200,\n        COLOR_LANGUAGES= [\"css\", \"scss\", \"less\", \"sass\", \"stylus\", \"html\", \"svg\", \"jsx\", \"tsx\",\n            \"php\", \"ejs\", \"erb_html\", \"pug\"];\n\n    const SVG_REGEX = /(:[^;]*;?|(?:fill|stroke|stop-color|flood-color|lighting-color|background-color|border-color|from|to)\\s*=\\s*(['\"]?)[^'\";]*\\2)/g,\n        CSS_REGEX = /:[^;]*;?/g; // the last semi colon is optional.\n\n\n    // For preferences settings, to toggle this feature on/off\n    const PREFERENCES_CSS_COLOR_PREVIEW = \"colorPreview\";\n    let enabled = true; // by default:- on\n\n    PreferencesManager.definePreference(PREFERENCES_CSS_COLOR_PREVIEW, \"boolean\", enabled, {\n        description: Strings.DESCRIPTION_CSS_COLOR_PREVIEW\n    });\n\n\n    /**\n     * Gets all the colors that are to be displayed\n     *\n     * Makes sure that the feature is enabled and editor is active, if yes:\n     * Calls showGutter function to display the color marks on the gutter\n     */\n    function showColorMarks() {\n        if (!enabled) {\n            return;\n        }\n\n        const editor = EditorManager.getActiveEditor();\n        if (editor && editor.isGutterActive(GUTTER_NAME)) {\n            showGutters(editor, _getAllColorsAndLineNums(editor));\n        }\n    }\n\n\n    /**\n     * To add the color marks on the gutter of all the active editors\n     * This function is called when the user toggles the\n     * CssColorPreview preference and set it to true\n     */\n    function addColorMarksToAllEditors() {\n        const allActiveEditors = MainViewManager.getAllViewedEditors();\n\n        allActiveEditors.forEach((activeEditor) => {\n            const currEditor = activeEditor.editor;\n            if(currEditor) {\n                const aColors = _getAllColorsAndLineNums(currEditor);\n                showGutters(currEditor, aColors);\n            }\n        });\n    }\n\n    /**\n     * To move the cursor to the color text and display the color quick edit\n     * @param {Editor} editor the codemirror instance\n     * @param {Number} lineNumber the line number that is clicked\n     * @param {string} colorValue the color value clicked\n     */\n    function _colorIconClicked(editor, lineNumber, colorValue) {\n        const lineText = editor.getLine(lineNumber);\n        const colorIndex = lineText.indexOf(colorValue);\n        const currentPos = editor.getCursorPos(false, \"start\");\n        if(!(currentPos.line === lineNumber && currentPos.ch === colorIndex)) {\n            editor.setCursorPos(lineNumber, colorIndex);\n            editor.focus();\n        }\n\n        // Added a 50ms delay with setTimeout to make sure the quick edit menu toggles correctly.\n        // Without it, closing the menu trigger text selection, reopening the menu.\n        setTimeout(() => {\n            CommandManager.execute(Commands.TOGGLE_QUICK_EDIT);\n        }, 50);\n    }\n\n    /**\n     * To display the color marks on the gutter\n     *\n     * @param {Editor} editor\n     * @param {Array.<object>} _results An array of objects which stores\n     *   all the line numbers and the colors to be displayed on that line.\n     * @param {Boolean} update marks whether this function is called when some lines\n     *  are updated or when the whole file is re-updated. Defaults to false.\n     */\n    function showGutters(editor, _results, update = false) {\n        if (editor && enabled) {\n            editor.operation(()=>{\n                // if the file is updated we don't need to clear the gutter\n                // as it will clear all the existing markers.\n                if(!update) {\n                    editor.clearGutter(GUTTER_NAME); // clear color markers\n                }\n                _addDummyGutterMarkerIfNotExist(editor, editor.getCursorPos().line);\n\n                // Only add markers if enabled\n                if (enabled) {\n                    const colorGutters = _.sortBy(_results, \"lineNumber\");\n\n                    colorGutters.forEach(function (obj) {\n                        let lineHandle;\n                        let $marker;\n                        if (obj.colorValues.length === 1) {\n                            // Single color preview\n                            $marker = $(\"<i>\")\n                                .addClass(SINGLE_COLOR_PREVIEW_CLASS)\n                                .css('background-color', obj.colorValues[0].color);\n                            lineHandle = editor.setGutterMarker(obj.lineNumber, GUTTER_NAME, $marker[0]);\n\n                            $marker.click((event)=>{\n                                event.preventDefault();\n                                event.stopPropagation();\n                                _colorIconClicked(editor, lineHandle.lineNo(), obj.colorValues[0].color);\n                            });\n                        } else {\n                            // Multiple colors preview\n                            $marker = $(\"<div>\").addClass(MULTI_COLOR_PREVIEW_CLASS);\n                            lineHandle = editor.setGutterMarker(obj.lineNumber, GUTTER_NAME, $marker[0]);\n\n                            // Positions for up to 4 colors in grid\n                            const positions = [\n                                { top: 0, left: 0 },\n                                { top: 0, right: 0 },\n                                { bottom: 0, right: 0 },\n                                { bottom: 0, left: 0 }\n                            ];\n\n                            obj.colorValues.forEach((color, index) => {\n                                if (index < 4) {\n                                    const $colorBox = $(\"<div>\")\n                                        .addClass(\"color-box\")\n                                        .css({\n                                            'background-color': color.color,\n                                            ...positions[index]\n                                        });\n                                    $colorBox.click((event)=>{\n                                        event.preventDefault();\n                                        event.stopPropagation();\n                                        _colorIconClicked(editor, lineHandle.lineNo(), color.color);\n                                    });\n                                    $marker.append($colorBox);\n                                }\n                            });\n                        }\n                        $marker.mouseenter(event=>{\n                            event.preventDefault();\n                            event.stopPropagation();\n                            _applyInlineColor(editor, lineHandle.lineNo());\n                        });\n                        $marker.mouseleave(event=>{\n                            event.preventDefault();\n                            event.stopPropagation();\n                            editor.clearAllMarks(COLOR_MARK_NAME);\n                        });\n                    });\n                }\n            });\n        }\n    }\n\n    function _addDummyGutterMarkerIfNotExist(editor, line) {\n        let marker = editor.getGutterMarker(line, GUTTER_NAME);\n        if(!marker){\n            let $marker = $('<div>')\n                .addClass(DUMMY_GUTTER_CLASS);\n            editor.setGutterMarker(line, GUTTER_NAME, $marker[0]);\n        }\n    }\n\n    function _cursorActivity(_evt, editor){\n        // this is to prevent a gutter gap in the active line if there is no color on this line.\n        _addDummyGutterMarkerIfNotExist(editor, editor.getCursorPos().line);\n        if(editor._currentlyColorMarkedLine){\n            editor.clearAllMarks(COLOR_MARK_NAME);\n            editor._currentlyColorMarkedLine = null;\n        }\n    }\n\n    /**\n     * Register all the required handlers\n     */\n    function registerHandlers() {\n        // Remove previous listeners to avoid multiple binding issue\n        EditorManager.off(\"activeEditorChange\", onChanged);\n\n        // Add listener for all editor changes\n        EditorManager.on(\"activeEditorChange\", function (event, newEditor, oldEditor) {\n            if (newEditor && newEditor.isGutterActive(GUTTER_NAME)) {\n                newEditor.off(\"cursorActivity.colorPreview\");\n                newEditor.on(\"cursorActivity.colorPreview\", _cursorActivity);\n                // Unbind the previous editor's change event if it exists\n                if (oldEditor) {\n                    oldEditor.off(\"change\", onChanged);\n                }\n                newEditor.off(\"change\", onChanged);\n                newEditor.on(\"change\", onChanged);\n                showColorMarks();\n                _cursorActivity(null, newEditor);\n            }\n        });\n\n        // Handle the currently active editor at initialization\n        const activeEditor = EditorManager.getActiveEditor();\n        if (activeEditor) {\n            activeEditor.off(\"change\", onChanged);\n            activeEditor.on(\"change\", onChanged);\n            activeEditor.off(\"cursorActivity.colorPreview\");\n            activeEditor.on(\"cursorActivity.colorPreview\", _cursorActivity);\n            showColorMarks();\n            _cursorActivity(null, activeEditor);\n        }\n    }\n\n    function _colorMark(editor, from, to, color) {\n        editor.markText(COLOR_MARK_NAME, from, to, {\n            css: `\n      --bg-color-mark: ${color};\n      background: var(--bg-color-mark);\n      color: lch(from var(--bg-color-mark) calc((50 - l) * infinity) 0 0);\n    `\n        });\n    }\n\n    function _applyInlineColor(editor, line) {\n        editor._currentlyColorMarkedLine = line;\n        editor.clearAllMarks(COLOR_MARK_NAME);\n        const colors = detectValidColorsInLine(editor, line);\n        for(let color of colors){\n            _colorMark(editor, {line, ch: color.index}, {line, ch: color.index + color.color.length},\n                color.color);\n        }\n    }\n\n    /**\n     * Checks for preference changes, to enable/disable the feature\n     */\n    function preferenceChanged() {\n        const value = PreferencesManager.get(PREFERENCES_CSS_COLOR_PREVIEW);\n        enabled = value;\n        if (!value) {\n            Editor.unregisterGutter(GUTTER_NAME);\n        } else {\n            Editor.registerGutter(GUTTER_NAME, COLOR_PREVIEW_GUTTER_PRIORITY, COLOR_LANGUAGES);\n            // to dynamically add color to all active editors\n            addColorMarksToAllEditors();\n        }\n    }\n\n    const STYLE_PARSE_LANGUAGES = {\n        php: true,\n        jsx: true,\n        tsx: true\n    };\n    function _isInStyleAttr(editor, token) {\n        while(token.type === \"string\") {\n            const currentToken = token;\n            token = editor.getPreviousToken({line: token.line, ch: token.start}, true);\n            if(currentToken.line === token.line &&\n                currentToken.start === token.start && currentToken.end === token.end) {\n                // reached start of file\n                break;\n            }\n        }\n        return token.type === \"attribute\" && token.string === \"style\";\n    }\n\n    function _shouldProcessToken(editor, token, pos) {\n        const languageID = editor.document.getLanguage().getId();\n        if(languageID === \"html\") {\n            return editor.getLanguageForPosition(pos).getId() === \"css\";\n        } else if (STYLE_PARSE_LANGUAGES[languageID]) {\n            // unfortunately the codemirror mode doesn't support css detection in attributes in php files right now\n            return token.type !== \"comment\" && _isInStyleAttr(editor, token);\n        }\n        return token.type !== \"comment\";\n    }\n\n    function isAlphanumeric(char) {\n        return /^[a-z0-9-@$]$/i.test(char);\n    }\n    function _isColor(segment, colorInSegment, colorIndex) {\n        const previousChar = colorIndex === 0 ? \"\" :  segment.charAt(colorIndex-1);\n        const endIndex = colorIndex + colorInSegment.length;\n        const nextChar = endIndex === segment.length ? \"\" :  segment.charAt(endIndex);\n        return !isAlphanumeric(previousChar) && !isAlphanumeric(nextChar);\n    }\n\n    /**\n     * Detects valid colors in a given line of text\n     *\n     * @param {Editor} editor - The editor instance\n     * @param {number} lineNumber - The line number to check\n     * @return {Array<{color: string, index: number}>} An array of valid color values with their indices\n     */\n    function detectValidColorsInLine(editor, lineNumber) {\n        const lineText = editor.getLine(lineNumber);\n        const languageID = editor.document.getLanguage().getId();\n\n        // to make sure that code doesn't break when lineText is null.\n        if (!lineText || lineText.length > 1000) { // too long lines we cant scan, maybe minified?\n            return [];\n        }\n\n        const valueRegex = languageID === \"svg\" ? SVG_REGEX: CSS_REGEX;\n        const validColors = [];\n\n        // Find all property value sections in the line\n        const lineMatches = [...lineText.matchAll(valueRegex)];\n\n        for (const lineMatch of lineMatches) {\n            // Find colors within each property value\n            const colorMatches = [...lineMatch[0].matchAll(COLOR_REGEX)];\n\n            colorMatches.forEach(colorMatch => {\n                const colorIndex = lineMatch.index + colorMatch.index;\n                // this will also allow color name like vars eg: --red-main or @heading-green. we need to omit those\n                if(!_isColor(lineMatch[0], colorMatch[0], colorMatch.index)) {\n                    return;\n                }\n\n                // Check if the color is within a comment\n                const token = editor.getToken({ line: lineNumber, ch: colorIndex }, true);\n\n                // If the token is not a comment, add the color\n                if (_shouldProcessToken(editor, token, { line: lineNumber, ch: colorIndex })) {\n                    validColors.push({\n                        color: colorMatch[0],\n                        index: colorIndex\n                    });\n                }\n            });\n        }\n\n        // Return up to 4 colors\n        return validColors;\n    }\n\n    /**\n     * Responsible to get all the colors and their respective line numbers.\n     *\n     * @param {Editor} editor\n     * @return {Array.<Object>} an array of objects with all the line nos and,\n     *  the colors to be added on those lines\n     */\n    function _getAllColorsAndLineNums(editor) {\n        const nLen = editor.lineCount();\n        const aColors = [];\n\n        // Match colors and push into an array\n        for (let i = 0; i < nLen; i++) {\n            const colors = detectValidColorsInLine(editor, i);\n\n            // If valid colors found, add to the results\n            if (colors.length > 0) {\n                aColors.push({\n                    lineNumber: i,\n                    colorValues: colors\n                });\n            }\n        }\n\n        return aColors;\n    }\n\n\n    /**\n     * Responsible to update the color marks only on the modified lines\n     *\n     * @param {Editor} editor the editor instance\n     * @param {Number} fromLineNumber modification start from line number\n     * @param {Number} toLineNumber modification upto line number\n     * @return {Array.<Object>} an array of objects with all the line nos and,\n     *  the colors to be added on those lines\n     */\n    function updateColorMarks(editor, fromLineNumber, toLineNumber) {\n        const aColors = [];\n\n        // Match colors and push into an array for modified lines\n        for (let i = fromLineNumber; i <= toLineNumber; i++) {\n            const colors = detectValidColorsInLine(editor, i);\n\n            // If no valid colors, clear the gutter marker\n            if (colors.length === 0) {\n                editor.setGutterMarker(i, GUTTER_NAME, \"\");\n            } else {\n                aColors.push({\n                    lineNumber: i,\n                    colorValues: colors\n                });\n            }\n        }\n\n        return aColors;\n    }\n\n\n    /**\n     * Function that gets triggered when any change occurs on the editor\n     *\n     * @param _evt unused event detail\n     * @param {Editor} instance the editor instance\n     * @param {Object} changeList an object that has properties regarding the line changed and type of change\n     */\n    function onChanged(_evt, instance, changeList) {\n        // for insertion and deletion, update the changed lines\n        if(!changeList || !changeList.length) {\n            return;\n        }\n        const changeObj = changeList[0];\n        if(changeList.length === 1 && changeObj.origin === '+input' || changeObj.origin === '+delete') {\n            // we only do the diff updates on single key type input/delete and not bulk changes\n            // somehow the performance degrades if we do the diff logic on large blocks.\n            if(changeObj.from.line && changeObj.to.line && changeObj.from.line <= changeObj.to.line) {\n                let toLine = changeObj.to.line;\n                if(changeObj.text && changeObj.text.length) {\n                    toLine = changeObj.from.line + changeObj.text.length;\n                }\n                const aColors = updateColorMarks(instance, changeObj.from.line, Math.max(changeObj.to.line, toLine));\n                showGutters(instance, aColors, true);\n            } else {\n                showColorMarks();\n            }\n\n        } else { // for any complex operation like, cut, paste etc, we re-update the whole file\n            showColorMarks();\n        }\n    }\n\n    // init after appReady\n    AppInit.appReady(function () {\n        PreferencesManager.on(\"change\", PREFERENCES_CSS_COLOR_PREVIEW, preferenceChanged);\n        preferenceChanged();\n        registerHandlers();\n    });\n});\n\n"],"file":"main.js"}