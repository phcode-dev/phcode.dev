{"version":3,"sources":["widgets/PopUpManager.js"],"names":["define","require","exports","module","AppInit","EventDispatcher","WorkspaceManager","CommandManager","MainViewManager","KeyEvent","_popUps","addPopupInProgress","currentEventPopups","addPopUp","$popUp","removeHandler","autoRemove","options","closeCurrentPopups","closeAllPopups","popupManagesFocus","push","data","handleSelectionEvents","keyboardEventHandler","enableSearchFilter","_selectItem","find","removeClass","$","this","addClass","_unselectItem","length","console","error","prepend","off","_processSelectionEvent","on","focus","removePopUp","focusActivePane","handlerIndex","findIndex","item","is","splice","searchStr","index","indexOf","remove","removeCurrentPopUp","keyEvent","i","event","Event","trigger","isDefaultPrevented","stopImmediatePropagation","_filterDropdown","$popup","searchString","$stickyLi","each","li","$li","text","toLowerCase","includes","selectNextItem","direction","$selectedItem","$links","not","closest","nextIndex","selectedIndex","$newItem","eq","processed","keyHandled","keyCode","DOM_VK_UP","DOM_VK_DOWN","DOM_VK_ENTER","DOM_VK_RETURN","$dropdownItem","preventDefault","ctrlKey","metaKey","key","Phoenix","app","clipboardReadText","then","slice","_keydownCaptureListener","DOM_VK_ESCAPE","DOM_VK_ALT","brackets","platform","_beforeMenuPopup","_dontToggleWorkspacePanel","popUp","listenToContextMenu","contextMenu","htmlReady","window","document","body","addEventListener","commandId","addEscapeKeyEventHandler","makeEventDispatcher"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n// @INCLUDE_IN_API_DOCS\n\n/**\n * Utilities for managing pop-ups.\n */\ndefine(function (require, exports, module) {\n\n\n    let AppInit         = require(\"utils/AppInit\"),\n        EventDispatcher = require(\"utils/EventDispatcher\"),\n        WorkspaceManager = require(\"view/WorkspaceManager\"),\n        CommandManager  = require(\"command/CommandManager\"),\n        MainViewManager     = require(\"view/MainViewManager\"),\n        KeyEvent        = require(\"utils/KeyEvent\");\n\n    let _popUps = [], addPopupInProgress = false,\n        currentEventPopups = [];\n\n    /**\n     * Add Esc key handling for a popup DOM element.\n     *\n     * @param {!jQuery} $popUp jQuery object for the DOM element pop-up\n     * @param {function} removeHandler Pop-up specific remove (e.g. display:none or DOM removal)\n     * @param {?Boolean} autoRemove - Specify true to indicate the PopUpManager should\n     *      remove the popup from the _popUps array when the popup is closed. Specify false\n     *      when the popup is always persistant in the _popUps array.\n     * @param {object} options\n     * @param {boolean} [options.popupManagesFocus] - set to true if the popup manages focus restore on close\n     * @param {boolean} [options.closeCurrentPopups] - set to true if you want to dismiss all exiting popups before\n     *              adding this. Useful when this should be the only popup visible.\n     *\n     */\n    function addPopUp($popUp, removeHandler, autoRemove, options) {\n        autoRemove = autoRemove || false;\n        options = options || {};\n        addPopupInProgress = true;\n        if(options.closeCurrentPopups) {\n            closeAllPopups();\n        }\n        const popupManagesFocus = options.popupManagesFocus || false;\n\n        _popUps.push($popUp[0]);\n        $popUp.data(\"PopUpManager-autoRemove\", autoRemove);\n        $popUp.data(\"PopUpManager-popupManagesFocus\", popupManagesFocus);\n        $popUp.data(\"PopUpManager-removeHandler\", removeHandler);\n        addPopupInProgress = false;\n    }\n\n    function handleSelectionEvents($popUp, options = {}) {\n        const {keyboardEventHandler, enableSearchFilter} = options;\n        currentEventPopups.push({\n            $popUp,\n            keyboardEventHandler,\n            enableSearchFilter\n        });\n        if(currentEventPopups.length > 1){\n            console.error(`${currentEventPopups.length} popups are visible while handling keyboard events!`,\n                \"Possible popup event handler leak. Only 1 popup event handler is expected at this time.\");\n        }\n        if(enableSearchFilter && !$popUp.find(\".sticky-li-top\").length) {\n            $popUp.prepend(\n                `<li class=\"sticky-li-top forced-hidden\">\n                    <a class='stylesheet-link'><i class=\"fa fa-search\" aria-hidden=\"true\"></i>&nbsp;&nbsp;\n                    <span class=\"searchTextSpan\"></span></a>\n                </li>`);\n        }\n        $popUp.off(\"keydown\", _processSelectionEvent);\n        $popUp.on(\"keydown\", _processSelectionEvent);\n        $popUp.focus();\n        function _selectItem() {\n            $popUp.find(\".selected\").removeClass(\"selected\");\n            $(this).addClass(\"selected\");\n        }\n        function _unselectItem() {\n            $(this).removeClass(\"selected\");\n        }\n        $popUp\n            .off(\"mouseenter\", \"a\", _selectItem)\n            .off(\"mouseleave\", \"a\", _unselectItem);\n        $popUp\n            .on(\"mouseenter\", \"a\", _selectItem)\n            .on(\"mouseleave\", \"a\", _unselectItem);\n    }\n\n    /**\n     * Remove Esc key handling for a pop-up. Removes the pop-up from the DOM\n     * if the pop-up is currently visible and was not originally attached.\n     *\n     * @param {!jQuery} $popUp\n     */\n    function removePopUp($popUp) {\n        // check visible first to help protect against recursive calls\n        // via removeHandler\n        if ($popUp.find(\":visible\").length > 0) {\n            let removeHandler = $popUp.data(\"PopUpManager-removeHandler\");\n            if (removeHandler) {\n                removeHandler();\n            }\n        }\n        let popupManagesFocus = $popUp.data(\"PopUpManager-popupManagesFocus\");\n        if(!popupManagesFocus && !addPopupInProgress){\n            // We need to have a focus manager to correctly manage focus\n            // between editors and other UI elements.\n            // For now we set focus here if the popup doesnt manage the focus itself\n            MainViewManager.focusActivePane();\n        }\n\n        let handlerIndex = currentEventPopups.findIndex(item => item.$popUp.is($popUp));\n        if(handlerIndex >= 0){\n            currentEventPopups.splice(handlerIndex, 1);\n            searchStr = \"\";\n            $popUp.off(\"keydown\", _processSelectionEvent);\n        }\n        // check index after removeHandler is done processing to protect\n        // against recursive calls\n        let index = _popUps.indexOf($popUp[0]);\n        if (index >= 0) {\n            let autoRemove = $popUp.data(\"PopUpManager-autoRemove\");\n            if (autoRemove) {\n                $popUp.remove();\n                _popUps.splice(index, 1);\n            }\n        }\n    }\n\n    /**\n     * Remove Esc key handling for a pop-up. Removes the pop-up from the DOM\n     * if the pop-up is currently visible and was not originally attached.\n     * @private\n     * @param {KeyboardEvent=} keyEvent (optional)\n     */\n    function removeCurrentPopUp(keyEvent) {\n        // allow the popUp to prevent closing\n        let $popUp,\n            i,\n            event = new $.Event(\"popUpClose\");\n\n        for (i = _popUps.length - 1; i >= 0; i--) {\n            $popUp = $(_popUps[i]);\n\n            if ($popUp.find(\":visible\").length > 0) {\n                $popUp.trigger(event);\n\n                if (!event.isDefaultPrevented()) {\n                    // Stop the DOM event from propagating\n                    if (keyEvent) {\n                        keyEvent.stopImmediatePropagation();\n                    }\n\n                    removePopUp($popUp);\n                    return true;\n                }\n\n                break;\n            }\n        }\n    }\n\n    let searchStr =\"\";\n    /**\n     * hides all elements in popup that doesn't match the given search string, also shows the search bar in popup\n     * @param $popup\n     * @param searchString\n     */\n    function _filterDropdown($popup, searchString) {\n        searchStr = searchString;\n        const $stickyLi = $popup.find('li.sticky-li-top');\n        if(!$stickyLi.length){\n            console.error(\"Search filter element not found! Please call\" +\n                \" PopUpManager.handleSelectionEvents with enableSearchFilter option.\");\n            return;\n        }\n        if(searchString){\n            $stickyLi.removeClass(\"forced-hidden\");\n        } else {\n            $stickyLi.addClass(\"forced-hidden\");\n        }\n\n        $popup.find('li').each(function(index, li) {\n            if(index === 0){\n                // this is the top search box itself\n                return;\n            }\n            const $li = $(li);\n            if(!$li.text().toLowerCase().includes(searchString.toLowerCase())){\n                $li.addClass(\"forced-hidden\");\n            } else {\n                $li.removeClass(\"forced-hidden\");\n            }\n        });\n\n        if(searchString) {\n            $stickyLi.removeClass('forced-hidden');\n            $stickyLi.find('.searchTextSpan').text(searchString);\n        } else {\n            $stickyLi.addClass('forced-hidden');\n        }\n    }\n\n\n    /**\n     * Selects the next or previous item in the popup.\n     * @param {number} direction  +1 for next, -1 for prev\n     * @param $popUp\n     */\n    function selectNextItem(direction, $popUp) {\n        const $selectedItem = $popUp.find(\".selected\");\n        let $links   = $popUp.find(\"a:visible\").not(function() {\n                return $(this).closest('.sticky-li-top').length > 0;\n            }),\n            nextIndex    = 0;\n        const selectedIndex = $links.index($selectedItem);\n        if(selectedIndex >= 0){\n            // the selected item is visible, move from this index\n            nextIndex = (selectedIndex + direction) % $links.length;\n        } else if(direction === -1) {\n            // nothing is selected and reverse direction, select the last element\n            nextIndex = $links.length - 1;\n        } else {\n            // nothing is selected, select the first element\n            nextIndex = 0;\n        }\n        if(searchStr && $links.length === 0){\n            // no search result, only the top search field visible\n            return;\n        }\n\n        const $newItem = $links.eq(nextIndex);\n        if ($selectedItem) {\n            $selectedItem.removeClass(\"selected\");\n        }\n        $newItem.addClass(\"selected\");\n    }\n\n    function _processSelectionEvent(event) {\n        const {$popUp, keyboardEventHandler} = currentEventPopups[currentEventPopups.length - 1];\n        if(!$popUp || !$popUp.is(\":visible\")){\n            return false;\n        }\n        if(keyboardEventHandler) {\n            const processed = keyboardEventHandler(event, $popUp);\n            if(processed){\n                return true;\n            }\n        }\n        var keyHandled = false;\n\n        switch (event.keyCode) {\n        case KeyEvent.DOM_VK_UP:\n            selectNextItem(-1, $popUp);\n            keyHandled = true;\n            break;\n        case KeyEvent.DOM_VK_DOWN:\n            selectNextItem(+1, $popUp);\n            keyHandled = true;\n            break;\n        case KeyEvent.DOM_VK_ENTER:\n        case KeyEvent.DOM_VK_RETURN:\n            const $dropdownItem = $popUp.find(\".selected\");\n            if ($dropdownItem) {\n                $dropdownItem.trigger(\"click\");\n            }\n            keyHandled = true;\n            break;\n        }\n\n        if(keyHandled){\n            event.stopImmediatePropagation();\n            event.preventDefault();\n            return keyHandled;\n        } else if((event.ctrlKey || event.metaKey) && event.key === 'v') {\n            Phoenix.app.clipboardReadText().then(text=>{\n                searchStr += text;\n                _filterDropdown($popUp, searchStr);\n            });\n            keyHandled = true;\n        } else if (event.key.length === 1) {\n            searchStr += event.key;\n            keyHandled = true;\n        } else if (event.key === 'Backspace') {\n            // Remove the last character when Backspace is pressed\n            searchStr  = searchStr.slice(0, -1);\n            keyHandled = true;\n        } else {\n            // bubble up, not for us to handle\n            return false;\n        }\n        _filterDropdown($popUp, searchStr);\n\n        if (keyHandled) {\n            event.stopImmediatePropagation();\n            event.preventDefault();\n        }\n        return keyHandled;\n    }\n\n    function _keydownCaptureListener(keyEvent) {\n        // Escape key or Alt key (Windows-only)\n        if (keyEvent.keyCode !== KeyEvent.DOM_VK_ESCAPE &&\n            !(keyEvent.keyCode === KeyEvent.DOM_VK_ALT && brackets.platform === \"win\")) {\n            return;\n        }\n\n        // Don't dismiss the popup if both Ctrl and Alt keys are pressed.\n        if (keyEvent.keyCode === KeyEvent.DOM_VK_ALT && keyEvent.ctrlKey) {\n            return;\n        }\n\n        return removeCurrentPopUp(keyEvent);\n    }\n\n    /**\n     * A menu is being popped up, so remove any menu that is currently popped up\n     * @private\n     */\n    function _beforeMenuPopup() {\n        removeCurrentPopUp();\n    }\n\n    function _dontToggleWorkspacePanel() {\n        for(let popUp of _popUps){\n            let $popUp = $(popUp);\n            if ($popUp.find(\":visible\").length > 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Context menus are also created in AppInit.htmlReady(), so they may not\n     * yet have been created when we get our AppInit.htmlReady() callback, so\n     * we provide this method to tell us when to start listening for their events\n     *\n     * @param {ContextMenu} contextMenu\n     */\n    function listenToContextMenu(contextMenu) {\n        contextMenu.on(\"beforeContextMenuOpen\", _beforeMenuPopup);\n    }\n\n    AppInit.htmlReady(function () {\n        // Register for events\n        window.document.body.addEventListener(\"keydown\", _keydownCaptureListener, true);\n        exports.on(\"beforeMenuPopup\", _beforeMenuPopup);\n\n        // Close all popups when a command is executed\n        CommandManager.on(\"beforeExecuteCommand\", function (event, commandId) {\n            removeCurrentPopUp();\n        });\n\n        WorkspaceManager.addEscapeKeyEventHandler(\"PopUpManager\", _dontToggleWorkspacePanel);\n    });\n\n    function closeAllPopups() {\n        removeCurrentPopUp();\n    }\n\n    EventDispatcher.makeEventDispatcher(exports);\n\n    exports.addPopUp            = addPopUp;\n    exports.handleSelectionEvents = handleSelectionEvents;\n    exports.selectNextItem = selectNextItem;\n    exports.removePopUp         = removePopUp;\n    exports.closeAllPopups      = closeAllPopups;\n    exports.listenToContextMenu = listenToContextMenu;\n});\n"],"file":"PopUpManager.js"}