{"version":3,"sources":["filesystem/impls/appshell/AppshellFileSystem.js"],"names":["define","require","exports","module","FileUtils","FileSystemStats","FileSystemError","FILE_WATCHER_BATCH_TIMEOUT","_changeCallback","_offlineCallback","_changeTimeout","_pendingChanges","_enqueueChange","changedPath","stats","window","setTimeout","Object","keys","forEach","path","_registerChangeEventListeners","pathToWatch","eventEmitter","reloadParentDirContents","pathToReload","_normalise_path","appshell","dirname","on","fs","WATCH_EVENTS","ADD_FILE","ADD_DIR","UNLINK_DIR","UNLINK_FILE","CHANGE","stat","err","newStat","initWatchers","changeCallback","offlineCallback","_watchEventListeners","watchPath","ignored","callback","console","log","watchAsync","then","catch","_mapError","unwatchPath","pathBeingWatched","unwatchAsync","unwatchAll","allUnwatchPromises","push","Promise","all","FS_ERROR_CODES","Phoenix","app","ERR_CODES","code","EINVAL","INVALID_PARAMS","ENOENT","NOT_FOUND","EIO","NOT_READABLE","EROFS","NOT_WRITABLE","ECHARSET","UNSUPPORTED_ENCODING","ENOSPC","OUT_OF_SPACE","EEXIST","ALREADY_EXISTS","ENCODE_FILE_FAILED","DECODE_FILE_FAILED","UNSUPPORTED_UTF16_ENCODING","error","UNKNOWN","VFS","normalize","_wrap","cb","args","Array","prototype","slice","call","arguments","apply","showOpenDialog","allowMultipleSelection","chooseDirectories","title","initialPath","fileTypes","wrappedCallback","isNativeApp","openTauriFilePickerAsync","multiple","directory","defaultPath","getTauriPlatformPath","filters","name","extensions","undefined","mountNativeFolder","showSaveDialog","proposedNewFilename","_createStatObject","realPath","hash","mtime","getTime","options","isFile","size","fsStats","exists","existsAsync","resolve","reject","existStatus","readdir","withFileTypes","count","length","contents","statsObject","entryStat","entryPath","mkdir","mode","mkdirs","copy","src","dst","copiedPath","rename","oldPath","newPath","readFile","encoding","doReadFile","EXCEEDS_MAX_FILE_SIZE","_err","_data","preserveBOM","_stat","writeFile","data","_finishWrite","created","hasOwnProperty","expectedHash","_hash","expectedContents","CONTENTS_MODIFIED","unlink","moveToTrash","pathLib","normalizeUNCPaths","brackets","platform"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*global appshell, Phoenix*/\n/*eslint-env es6*/\n// jshint ignore: start\n\ndefine(function (require, exports, module) {\n\n\n    var FileUtils           = require(\"file/FileUtils\"),\n        FileSystemStats     = require(\"filesystem/FileSystemStats\"),\n        FileSystemError     = require(\"filesystem/FileSystemError\");\n\n    /**\n     * @const\n     */\n    var FILE_WATCHER_BATCH_TIMEOUT = 200;   // 200ms - granularity of file watcher changes\n\n    /**\n     * Callback to notify FileSystem of watcher changes\n     * @type {?function(string, FileSystemStats=)}\n     */\n    var _changeCallback;\n\n    /**\n     * Callback to notify FileSystem if watchers stop working entirely\n     * @type {?function()}\n     */\n    var _offlineCallback;\n\n    /** Timeout used to batch up file watcher changes (setTimeout() return value) */\n    var _changeTimeout;\n\n    /**\n     * Pending file watcher changes - map from fullPath to flag indicating whether we need to pass stats\n     * to _changeCallback() for this path.\n     * @type {!Object.<string, boolean>}\n     */\n    var _pendingChanges = {};\n\n    /**\n     * Enqueue a file change event for eventual reporting back to the FileSystem.\n     *\n     * @param {string} changedPath The path that was changed\n     * @param {object} stats Stats coming from the underlying watcher, if available\n     * @private\n     */\n    function _enqueueChange(changedPath, stats) {\n        _pendingChanges[changedPath] = stats;\n        if (!_changeTimeout) {\n            _changeTimeout = window.setTimeout(function () {\n                if (_changeCallback) {\n                    Object.keys(_pendingChanges).forEach(function (path) {\n                        _changeCallback(path, _pendingChanges[path]);\n                    });\n                }\n\n                _changeTimeout = null;\n                _pendingChanges = {};\n            }, FILE_WATCHER_BATCH_TIMEOUT);\n        }\n    }\n\n    /**\n     * Register Event handler for file system change event\n     *\n     * @param {string} pathToWatch the path that is being watched\n     * @param {string} eventEmitter\n     * * @param {string=} fullPath The full path that has changed\n     * @private\n     */\n    function _registerChangeEventListeners(pathToWatch, eventEmitter) {\n        function reloadParentDirContents({path}) {\n            const changedPath = path;\n            let pathToReload = _normalise_path(changedPath);\n            if(pathToReload !== pathToWatch) {\n                // if the changed path is the path being watched itself, we don't issue reload on its parent.\n                // else file/directory was created/deleted; fire change on parent to reload contents\n                pathToReload = appshell.path.dirname(changedPath);\n            }\n            _enqueueChange(`${pathToReload}/`, null);\n        }\n        eventEmitter.on(appshell.fs.WATCH_EVENTS.ADD_FILE, reloadParentDirContents);\n        eventEmitter.on(appshell.fs.WATCH_EVENTS.ADD_DIR, reloadParentDirContents);\n        eventEmitter.on(appshell.fs.WATCH_EVENTS.UNLINK_DIR, reloadParentDirContents);\n        eventEmitter.on(appshell.fs.WATCH_EVENTS.UNLINK_FILE, reloadParentDirContents);\n        eventEmitter.on(appshell.fs.WATCH_EVENTS.CHANGE, ({path})=>{\n            const changedPath = path;\n            stat(changedPath, (err, newStat) => {\n                // fire change event irrespective of error. if err, stat will be null.\n                _enqueueChange(changedPath, newStat);\n            });\n        });\n    }\n\n    /**\n     * Initialize file watching for this filesystem, using the supplied\n     * changeCallback to provide change notifications. The first parameter of\n     * changeCallback specifies the changed path (either a file or a directory);\n     * if this parameter is null, it indicates that the implementation cannot\n     * specify a particular changed path, and so the callers should consider all\n     * paths to have changed and to update their state accordingly. The second\n     * parameter to changeCallback is an optional FileSystemStats object that\n     * may be provided in case the changed path already exists and stats are\n     * readily available. The offlineCallback will be called in case watchers\n     * are no longer expected to function properly. All watched paths are\n     * cleared when the offlineCallback is called.\n     *\n     * @param {function(?string, FileSystemStats=)} changeCallback\n     * @param {function()=} offlineCallback\n     */\n    function initWatchers(changeCallback, offlineCallback) {\n        _changeCallback = changeCallback;\n        _offlineCallback = offlineCallback;\n\n        if (_offlineCallback) {\n            _offlineCallback();\n        }\n    }\n\n    const _watchEventListeners = {};\n\n    /**\n     * Start providing change notifications for the file or directory at the\n     * given path, calling back asynchronously with a possibly null FileSystemError\n     * string when the initialization is complete. Notifications are provided\n     * using the changeCallback function provided by the initWatchers method.\n     * Note that change notifications are only provided recursively for directories\n     * when the recursiveWatch property of this module is true.\n     *\n     * @param {string} pathToWatch\n     * @param {Array<string>|string} ignored\n     * @param {function(?string)=} callback\n     */\n    function watchPath(pathToWatch, ignored, callback) {\n        console.log('Watch path: ', pathToWatch, ignored);\n        pathToWatch = _normalise_path(pathToWatch);\n        appshell.fs.watchAsync(pathToWatch, ignored)\n            .then(eventEmitter=>{\n                _watchEventListeners[pathToWatch] = eventEmitter;\n                _registerChangeEventListeners(pathToWatch, eventEmitter);\n                callback(null);\n            })\n            .catch(err=>{\n                callback(_mapError(err));\n            });\n    }\n    /**\n     * Stop providing change notifications for the file or directory at the\n     * given path, calling back asynchronously with a possibly null FileSystemError\n     * string when the operation is complete.\n     * This function needs to mirror the signature of watchPath\n     * because of FileSystem.prototype._watchOrUnwatchEntry implementation.\n     *\n     * @param {string} pathBeingWatched\n     * @param {Array<string>} ignored\n     * @param {function(?string)=} callback\n     */\n    function unwatchPath(pathBeingWatched, ignored, callback) {\n        console.log('unwatch path: ', pathBeingWatched);\n        pathBeingWatched = _normalise_path(pathBeingWatched);\n        const eventEmitter = _watchEventListeners[pathBeingWatched];\n        delete _watchEventListeners[pathBeingWatched];\n        appshell.fs.unwatchAsync(eventEmitter)\n            .then(()=>{\n                callback(null);\n            }).catch(err=>{\n                callback(_mapError(err));\n            });\n    }\n\n    /**\n     * Stop providing change notifications for all previously watched files and\n     * directories, optionally calling back asynchronously with a possibly null\n     * FileSystemError string when the operation is complete.\n     *\n     * @param {function(?string)=} callback\n     */\n    function unwatchAll(callback) {\n        const allUnwatchPromises = [];\n        for(let pathBeingWatched of Object.keys(_watchEventListeners)) {\n            const eventEmitter = _watchEventListeners[pathBeingWatched];\n            delete _watchEventListeners[pathBeingWatched];\n            allUnwatchPromises.push(appshell.fs.unwatchAsync(eventEmitter));\n        }\n        Promise.all(allUnwatchPromises).then(()=>{\n            callback(null);\n        }).catch(err=>{\n            callback(_mapError(err));\n        });\n    }\n\n\n    /**\n     * Convert appshell error codes to FileSystemError values.\n     *\n     * @param {?number} err An appshell error code\n     * @return {?string} A FileSystemError string, or null if there was no error code.\n     * @private\n     */\n    function _mapError(err) {\n        if (!err) {\n            return null;\n        }\n\n        const FS_ERROR_CODES = window.Phoenix.app.ERR_CODES.FS_ERROR_CODES;\n        console.log('appshell fs error: ', err);\n\n        switch (err.code) {\n        case FS_ERROR_CODES.EINVAL:\n            return FileSystemError.INVALID_PARAMS;\n        case FS_ERROR_CODES.ENOENT:\n            return FileSystemError.NOT_FOUND;\n        case FS_ERROR_CODES.EIO:\n            return FileSystemError.NOT_READABLE;\n        case FS_ERROR_CODES.EROFS:\n            return FileSystemError.NOT_WRITABLE;\n        case FS_ERROR_CODES.ECHARSET:\n            return FileSystemError.UNSUPPORTED_ENCODING;\n        case FS_ERROR_CODES.ENOSPC:\n            return FileSystemError.OUT_OF_SPACE;\n        case FS_ERROR_CODES.EEXIST:\n            return FileSystemError.ALREADY_EXISTS;\n        case FS_ERROR_CODES.ECHARSET:\n            return FileSystemError.ENCODE_FILE_FAILED;\n        case FS_ERROR_CODES.ECHARSET:\n            return FileSystemError.DECODE_FILE_FAILED;\n        case FS_ERROR_CODES.ECHARSET:\n            return FileSystemError.UNSUPPORTED_UTF16_ENCODING;\n        }\n\n        console.error('unknown error: ', err);\n        return FileSystemError.UNKNOWN;\n    }\n\n    /**\n     * Normalises path.\n     *\n     * @param {string} path The path to normalise\n     * @return {string} Normalised path.\n     * @private\n     */\n    function _normalise_path(path) {\n        return window.Phoenix.VFS.path.normalize(path);\n    }\n\n    /**\n     * Convert a callback to one that transforms its first parameter from an\n     * appshell error code to a FileSystemError string.\n     *\n     * @param {function(?number)} cb A callback that expects an appshell error code\n     * @return {function(?string)} A callback that expects a FileSystemError string\n     * @private\n     */\n    function _wrap(cb) {\n        return function (err) {\n            var args = Array.prototype.slice.call(arguments);\n            args[0] = _mapError(args[0]);\n            cb.apply(null, args);\n        };\n    }\n\n    /**\n     * Display an open-files dialog to the user and call back asynchronously with\n     * either a FileSystmError string or an array of path strings, which indicate\n     * the entry or entries selected.\n     *\n     * @param {boolean} allowMultipleSelection\n     * @param {boolean} chooseDirectories\n     * @param {string} title\n     * @param {string} initialPath\n     * @param {Array.<string>=} fileTypes\n     * @param {function(?string, Array.<string>=)} callback\n     */\n    function showOpenDialog(allowMultipleSelection, chooseDirectories, title, initialPath, fileTypes, callback) {\n        const wrappedCallback = _wrap(callback);\n        if(Phoenix.isNativeApp){\n            appshell.fs.openTauriFilePickerAsync({\n                multiple: allowMultipleSelection,\n                directory: chooseDirectories,\n                title,\n                defaultPath: Phoenix.fs.getTauriPlatformPath(initialPath),\n                filters: fileTypes ? [{\n                    name: \"openDialog\",\n                    extensions: fileTypes || []\n                }] : undefined\n            }).then(directory => {\n                if(!directory) {\n                    wrappedCallback(FileSystemError.NOT_READABLE);\n                    return;\n                }\n                if(typeof directory === 'string') {\n                    wrappedCallback(null, [directory]);\n                    return;\n                }\n                wrappedCallback(null, directory); // is an array of paths\n            }).catch(wrappedCallback);\n            return;\n        }\n        appshell.fs.mountNativeFolder(wrappedCallback);\n    }\n\n    /**\n     * Display a save-file dialog and call back asynchronously with either a\n     * FileSystemError string or the path to which the user has chosen to save\n     * the file. If the dialog is cancelled, the path string will be empty.\n     *\n     * @param {string} title\n     * @param {string} initialPath\n     * @param {string} proposedNewFilename\n     * @param {function(?string, string=)} callback\n     */\n    function showSaveDialog(title, initialPath, proposedNewFilename, callback) {\n        appshell.fs.showSaveDialog(title, initialPath, proposedNewFilename, _wrap(callback));\n    }\n\n    function _createStatObject(stats, realPath) {\n        const hash = stats.mtime? stats.mtime.getTime() : null;\n        var options = {\n            isFile: stats.isFile(),\n            mtime: stats.mtime,\n            size: stats.size,\n            realPath: stats.realPath || realPath,\n            hash: hash\n        };\n        return  new FileSystemStats(options);\n    }\n\n    /**\n     * Stat the file or directory at the given path, calling back\n     * asynchronously with either a FileSystemError string or the entry's\n     * associated FileSystemStats object.\n     *\n     * @param {string} path\n     * @param {function(?string, FileSystemStats=)} callback\n     */\n    function stat(path, callback) {\n        console.log('stat: ', path);\n        path = _normalise_path(path);\n        appshell.fs.stat(path, function (err, stats) {\n            if (err) {\n                callback(_mapError(err));\n            } else {\n                var fsStats = _createStatObject(stats, path);\n                callback(null, fsStats);\n            }\n        });\n    }\n\n    /**\n     * Determine whether a file or directory exists at the given path by calling\n     * back asynchronously with either a FileSystemError string or a boolean,\n     * which is true if the file exists and false otherwise. The error will never\n     * be FileSystemError.NOT_FOUND; in that case, there will be no error and the\n     * boolean parameter will be false.\n     *\n     * @param {string} path\n     * @param {function(?string, boolean)} callback\n     */\n    function exists(path, callback) {\n        console.log('exists: ', path);\n        path = _normalise_path(path);\n        stat(path, function (err) {\n            if (err) {\n                if (err === FileSystemError.NOT_FOUND) {\n                    callback(null, false);\n                } else {\n                    callback(err);\n                }\n                return;\n            }\n\n            callback(null, true);\n        });\n    }\n\n    /**\n     * Determine whether a file or directory exists at the given path by calling\n     * back asynchronously with either a FileSystemError string or a boolean,\n     * which is true if the file exists and false otherwise. The error will never\n     * be FileSystemError.NOT_FOUND; in that case, there will be no error and the\n     * boolean parameter will be false.\n     *\n     * @param {string} path\n     * @param {function(?string, boolean)} callback\n     */\n    function existsAsync(path) {\n        console.log('exists: ', path);\n        return new Promise(function (resolve, reject) {\n            exists(path, function (err, existStatus) {\n                if (err) {\n                    reject(err);\n                    return;\n                }\n                resolve(existStatus);\n            });\n        });\n    }\n\n    /**\n     * Read the contents of the directory at the given path, calling back\n     * asynchronously either with a FileSystemError string or an array of\n     * FileSystemEntry objects along with another consistent array, each index\n     * of which either contains a FileSystemStats object for the corresponding\n     * FileSystemEntry object in the second parameter or a FileSystemError\n     * string describing a stat error.\n     *\n     * @param {string} path\n     * @param {function(?string, Array.<FileSystemEntry>=, Array.<string|FileSystemStats>=)} callback\n     */\n    function readdir(path, callback) {\n        console.log('readdir: ', path);\n        path = _normalise_path(path);\n        appshell.fs.readdir(path, {withFileTypes: true}, function (err, stats) {\n            if (err) {\n                callback(_mapError(err));\n                return;\n            }\n\n            var count = stats.length;\n            if (!count) {\n                callback(null, [], []);\n                return;\n            }\n\n            let contents = [],\n                statsObject =[];\n\n            stats.forEach(function (entryStat) {\n                contents.push(entryStat.name);\n                let entryPath = `${path}/${entryStat.name}`;\n                statsObject.push(_createStatObject(entryStat, entryPath));\n            });\n            callback(null, contents, statsObject);\n        });\n    }\n\n    /**\n     * Create a directory at the given path, and call back asynchronously with\n     * either a FileSystemError string or a stats object for the newly created\n     * directory. The octal mode parameter is optional; if unspecified, the mode\n     * of the created directory is implementation dependent.\n     *\n     * @param {string} path\n     * @param {number=} mode The base-eight mode of the newly created directory.\n     * @param {function(?string, FileSystemStats=)=} callback\n     */\n    function mkdir(path, mode, callback) {\n        console.log('mkdir: ', path);\n        path = _normalise_path(path);\n        if (typeof mode === \"function\") {\n            callback = mode;\n            mode = 0o755;\n        }\n        appshell.fs.mkdirs(path, mode, true, function (err) {\n            if (err) {\n                callback(_mapError(err));\n            } else {\n                stat(path, function (err, stat) {\n                    callback(err, stat);\n                });\n            }\n        });\n    }\n\n    /**\n     * copies a file/folder path from src to destination recursively. follows unix copy semantics mostly.\n     * As with unix copy, the destination path may not be exactly the `dst` path provided.\n     * Eg. copy(\"/a/b\", \"/a/x\") -> will copy to `/a/x/b` if folder `/a/x` exists. If dst `/a/x` not exists,\n     * then copy will honor the given destination `/a/x`\n     *\n     * @param {string} src Absolute path of file or directory to copy\n     * @param {string} dst Absolute path of file or directory destination\n     * @param {function(err, string)} callback Callback with err or stat of copied destination.\n     */\n    function copy(src, dst, callback) {\n        console.log('copy: ', src);\n        src = _normalise_path(src);\n        dst = _normalise_path(dst);\n        appshell.fs.copy(src, dst, function (err, copiedPath) {\n            if (err) {\n                callback(_mapError(err));\n            } else {\n                stat(copiedPath, function (err, stat) {\n                    callback(err, stat);\n                });\n            }\n        });\n    }\n\n    /**\n     * Rename the file or directory at oldPath to newPath, and call back\n     * asynchronously with a possibly null FileSystemError string.\n     *\n     * @param {string} oldPath\n     * @param {string} newPath\n     * @param {function(?string)=} callback\n     */\n    function rename(oldPath, newPath, callback) {\n        console.log('rename: ', oldPath, ' to ', newPath);\n        oldPath = _normalise_path(oldPath);\n        newPath = _normalise_path(newPath);\n        appshell.fs.rename(oldPath, newPath, _wrap(callback));\n    }\n\n    /**\n     * Read the contents of the file at the given path, calling back\n     * asynchronously with either a FileSystemError string, or with the data and\n     * the FileSystemStats object associated with the read file. The options\n     * parameter can be used to specify an encoding (default \"utf8\"), and also\n     * a cached stats object that the implementation is free to use in order\n     * to avoid an additional stat call.\n     *\n     * Note: if either the read or the stat call fails then neither the read data\n     * nor stat will be passed back, and the call should be considered to have failed.\n     * If both calls fail, the error from the read call is passed back.\n     *\n     * @param {string} path\n     * @param {{encoding: string=, stat: FileSystemStats=}} options\n     * @param {function(?string, string=, FileSystemStats=)} callback\n     */\n    function readFile(path, options, callback) {\n        console.log('Reading file: ', path);\n        path = _normalise_path(path);\n        const encoding = options.encoding || \"utf8\";\n\n        // callback to be executed when the call to stat completes\n        //  or immediately if a stat object was passed as an argument\n        function doReadFile(stat) {\n            if (stat.size > (FileUtils.MAX_FILE_SIZE)) {\n                callback(FileSystemError.EXCEEDS_MAX_FILE_SIZE);\n            } else {\n                appshell.fs.readFile(path, encoding, function (_err, _data, encoding, preserveBOM) {\n                    if (_err) {\n                        callback(_mapError(_err));\n                    } else {\n                        callback(null, _data, encoding, preserveBOM, stat);\n                    }\n                });\n            }\n        }\n\n        if (options.stat) {\n            doReadFile(options.stat);\n        } else {\n            exports.stat(path, function (_err, _stat) {\n                if (_err) {\n                    callback(_err);\n                } else {\n                    doReadFile(_stat);\n                }\n            });\n        }\n    }\n    /**\n     * Write data to the file at the given path, calling back asynchronously with\n     * either a FileSystemError string or the FileSystemStats object associated\n     * with the written file and a boolean that indicates whether the file was\n     * created by the write (true) or not (false). If no file exists at the\n     * given path, a new file will be created. The options parameter can be used\n     * to specify an encoding (default \"utf8\"), an octal mode (default\n     * unspecified and implementation dependent), and a consistency hash, which\n     * is used to the current state of the file before overwriting it. If a\n     * consistency hash is provided but does not match the hash of the file on\n     * disk, a FileSystemError.CONTENTS_MODIFIED error is passed to the callback.\n     *\n     * @param {string} path\n     * @param {string} data\n     * @param {{encoding : string=, mode : number=, expectedHash : object=, expectedContents : string=}} options\n     * @param {function(?string, FileSystemStats=, boolean)} callback\n     */\n    function writeFile(path, data, options, callback) {\n        console.log('Write file: ', path);\n        path = _normalise_path(path);\n        var encoding = options.encoding || \"utf8\",\n            preserveBOM = options.preserveBOM;\n\n        function _finishWrite(created) {\n            appshell.fs.writeFile(path, data, encoding, preserveBOM, function (err) {\n                if (err) {\n                    callback(_mapError(err));\n                } else {\n                    stat(path, function (err, stat) {\n                        callback(err, stat, created);\n                    });\n                }\n            });\n        }\n\n        stat(path, function (err, stats) {\n            if (err) {\n                switch (err) {\n                case FileSystemError.NOT_FOUND:\n                    _finishWrite(true);\n                    break;\n                default:\n                    callback(err);\n                }\n                return;\n            }\n\n            if (options.hasOwnProperty(\"expectedHash\") && options.expectedHash !== stats._hash) {\n                console.error(\"Blind write attempted: \", path, stats._hash, options.expectedHash);\n\n                if (options.hasOwnProperty(\"expectedContents\")) {\n                    appshell.fs.readFile(path, encoding, function (_err, _data) {\n                        if (_err || _data !== options.expectedContents) {\n                            callback(FileSystemError.CONTENTS_MODIFIED);\n                            return;\n                        }\n\n                        _finishWrite(false);\n                    });\n                    return;\n                }\n                callback(FileSystemError.CONTENTS_MODIFIED);\n                return;\n\n            }\n\n            _finishWrite(false);\n        });\n    }\n\n    /**\n     * Unlink (i.e., permanently delete) the file or directory at the given path,\n     * calling back asynchronously with a possibly null FileSystemError string.\n     * Directories will be unlinked even when non-empty.\n     *\n     * @param {string} path\n     * @param {function(string)=} callback\n     */\n    function unlink(path, callback) {\n        console.log('delete file: ', path);\n        path = _normalise_path(path);\n        appshell.fs.unlink(path, function (err) {\n            callback(_mapError(err));\n        });\n    }\n\n    /**\n     * Move the file or directory at the given path to a system dependent trash\n     * location, calling back asynchronously with a possibly null FileSystemError\n     * string. Directories will be moved even when non-empty.\n     *\n     * @param {string} path\n     * @param {function(string)=} callback\n     */\n    function moveToTrash(path, callback) {\n        console.log('Trash file: ', path);\n        path = _normalise_path(path);\n        appshell.fs.moveToTrash(path, function (err) {\n            callback(_mapError(err));\n        });\n    }\n\n    // Export public API\n    exports.showOpenDialog  = showOpenDialog;\n    exports.showSaveDialog  = showSaveDialog;\n    exports.exists          = exists;\n    exports.existsAsync     = existsAsync;\n    exports.readdir         = readdir;\n    exports.mkdir           = mkdir;\n    exports.rename          = rename;\n    exports.copy            = copy;\n    exports.stat            = stat;\n    exports.readFile        = readFile;\n    exports.writeFile       = writeFile;\n    exports.unlink          = unlink;\n    exports.moveToTrash     = moveToTrash;\n    exports.initWatchers    = initWatchers;\n    exports.watchPath       = watchPath;\n    exports.unwatchPath     = unwatchPath;\n    exports.unwatchAll      = unwatchAll;\n    exports.pathLib         = window.Phoenix.VFS.path;\n\n    /**\n     * Indicates whether or not the filesystem should expect and normalize UNC\n     * paths. If set, then //server/directory/ is a normalized path; otherwise the\n     * filesystem will normalize it to /server/directory. Currently, UNC path\n     * normalization only occurs on Windows.\n     *\n     * @type {boolean}\n     */\n    exports.normalizeUNCPaths = brackets.platform === \"win\";\n});\n"],"file":"AppshellFileSystem.js"}